{"pageProps":{"item":{"id":"compiler-lost-in-translation","title":"Lost in Translation (Exploring the Compiler's Front End)","author":"Björn Gustavsson","excerpt":"\nIn this blog post, we will explore the compiler passes that make up\nthe compiler's front end.\n\n[erl_scan:string/1]: http://erlang.org/doc/man/erl_scan.html#string-1,\n[The Abstract Format]: http://erlang.org/doc/apps/erts/absform.html,\n[parse tree]: ../images/compiler-2018-04-26.svg,\n[erl_pp]: http://erlang.org/doc/man/erl_pp.html,\n[epp]: http://erlang.org/doc/man/epp.html,\n[QLC]: http://erlang.org/doc/man/qlc.html,\n[ms_transform]: http://erlang.org/doc/man/ms_transform.html,\n[erl_lint]: http://erlang.org/doc/man/erl_lint.html,\n[erl_expand_records]: http://erlang.org/doc/man/erl_expand_records.html","article_date":1524700800000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Lost in Translation (Exploring the Compiler's Front End)","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nIn this blog post, we will explore the compiler passes that make up\nthe compiler's front end.\n\nIn the [previous blog post](http://blog.erlang.org/compiler-time-option/)\nwe showed how the `time` option shows information about the compiler passes\nbeing executed:\n\n\n```\n$ erlc +time trivial.erl\nCompiling \"trivial\"\n remove_file                   :      0.000 s       3.7 kB\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.002 s       5.5 kB\n expand_records                :      0.000 s       5.3 kB\n     .\n     .\n     .\n```\n\nWe explained what the `remove_file` pass does in the previous\nblog post. In today's blog post, we will discuss the other passes\nlisted in the output above.\n\nThose passes makes up the compiler's front end. The implementation\nmodules for those passes are not in the **compiler** application, but\nin **STDLIB**. The reason is that the Erlang shell also uses those\nmodules. That means that the shell will work in an embedded system\nthat does not include the **compiler** application.\n\nThe front end passes operate on the **abstract format**. The abstract\nformat is fairly close to the original Erlang source code. In fact, by\npretty-printing the abstract format, we can reconstruct the original\nsource code, albeit not perfectly.\n\n## Lost in translation ##\n\nTo see how much we will lose in translation, we will compile and\npretty-print this module:\n\n```\n-module(trivial).\n-export([example/4]).\n-record(rec, {mod,func,result}).\n\n%% Example to help explore the compiler front end.\nexample(A, B, C, D) ->\n    #rec{mod=?MODULE,func=?FUNCTION_NAME,result=A + (B*C*(D+42))}.\n```\n\nWe use `-P` option to run the `parse_module` pass and produce\na listing of the result:\n\n```\n$ erlc -P +time trivial.erl\nCompiling \"trivial\"\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.003 s       5.5 kB\n listing                       :      0.001 s       5.5 kB\n```\n\nFor the moment, ignore the `transform_module` and `erl_lint` passes.\nThey don't change the abstract code for this module. The `listing`\npass pretty prints the abstract format, converting it back to Erlang\nsource code and creating the file `trivial.P`.\n\n\n```\n$ cat trivial.P\n-file(\"trivial.erl\", 1).\n\n-module(trivial).\n\n-export([example/4]).\n\n-record(rec,{mod,func,result}).\n\nexample(A, B, C, D) ->\n    #rec{mod = trivial,func = example,result = A + B * C * (D + 42)}.\n```\n\nComparing the `trivial.P` file to the original, we can see what was\nlost in translation:\n\n* The `?MODULE` and `?FUNCTION_NAME` macro invocations have been\nreplaced with `trival` and `example`, respectively. That was done by\nthe preprocessor.\n\n* The comment has disappeared. There are also several differences in the\namount of whitespace surrounding variables and operators. The abstract format\ndoes not include whitepace or comments in its representation.\n\n* Also note that a redundant pair of parentheses has been omitted in the\nexpression `A + (B*C*(D+42))`. The parentheses around `D+42` are still there\nbecause otherwise the value of the expression would change. The abstract\nformat has no direct representation of parenheses.\n\n## Looking closer at the parse_module pass ##\n\nNow that we have seen what is lost in translation, we will take a\ncloser look at the abstract format.\n\nWe will use the expression `A+(B*C*(D+42))` as an example and\ntranslate it to the abstract format using the same modules that the\n`parse_module` pass uses to do its work.\n\n### Tokenizing using erl_scan ###\n\nThe first step in the translation from Erlang source code is to group\nthe characters into logical groups called **tokens**. This process is\ncalled **tokenization** or **scanning**, and is done by the `erl_scan`\nmodule.\n\nWe will use `erl_scan:string/1` to tokenize our example. (The\ncompiler will use other functions in `erl_scan`, but the principle\nis the same.)\n\n```\n1> {ok,Tokens,_} = erl_scan:string(\"A + (B*C*(D+42)).\"), Tokens.\n[{var,1,'A'},\n {'+',1},\n {'(',1},\n {var,1,'B'},\n {'*',1},\n {var,1,'C'},\n {'*',1},\n {'(',1},\n {var,1,'D'},\n {'+',1},\n {integer,1,42},\n {')',1},\n {')',1},\n {dot,1}]\n```\n\nThe output is a list of tokens. The second element in each tuple\nis the line number. The first element is the category of the token.\nIf there is a third element, it is the symbol within that category.\n\nWe can see that whitespace has already been lost. Had there been\na comment, it would have been lost too.\n\nTo read more details about tokens, see [erl_scan:string/1].\n\n[erl_scan:string/1]: http://erlang.org/doc/man/erl_scan.html#string-1\n\n### Preprocessing the tokens ###\n\nIn the compiler, the next step would be to run the preprocessor\non the tokens. In this example, there are no macro invocations\nand thus nothing to preprocess, so we will skip to the next step.\n\n### Parsing using erl_parse ###\n\nThe next step is to **parse** the tokens to produce the abstract\nformat:\n\n```\n2> {ok,Abstract} = erl_parse:parse_exprs(Tokens), Abstract.\n[{op,1,'+',\n     {var,1,'A'},\n     {op,1,'*',\n         {op,1,'*',{var,1,'B'},{var,1,'C'}},\n         {op,1,'+',{var,1,'D'},{integer,1,42}}}}]\n```\n\nThe result is a list with one expression. The expression is not a\nlist, but a **parse tree**. It can be visualized like this:\n\n![Abstract format visualized](../images/compiler-2018-04-26.svg)\n\nThe parentheses have been lost, because the structure of the tree\nmakes the evaluation order unambiguous.\n\nSee [The Abstract Format] for more details about the abstract format.\n\n[The Abstract Format]: http://erlang.org/doc/apps/erts/absform.html\n[parse tree]: ../images/compiler-2018-04-26.svg\n\n### Pretty-printing using erl_pp ###\n\nThe `listing` pass uses the [erl_pp] module to pretty print the\nabstract format to produce a listing file.\n\nWe can pretty print the abstract format of the example:\n\n```\n3> lists:flatten(erl_pp:exprs(Abstract)).\n\"A + B * C * (D + 42)\"\n```\n\nHere the pretty printer has inserted one pair of parentheses, but the\nredundant pair of parentheses in the original expression has been lost.\nThe whitespace is also different from the original.\n\n[erl_pp]: http://erlang.org/doc/man/erl_pp.html\n\n### A quick look at the preprocessor ###\n\nA mentioned in passing, the preprocessor (the [epp] module) is run\nafter tokenization and before parsing.\n\nThe preprocessor goes through the tokens, looking for a question\nmark followed by a variable or atom. For example, `?MODULE` in\na source file would be tokenized like this by `erl_scan`:\n\n    [{'?',1},{var,1,'MODULE'}]\n\nAssuming that the module name is `trivial`, the preprocessor will\nreplace those tokens with the token:\n\n    [{atom,1,trivial}]\n\n[epp]: http://erlang.org/doc/man/epp.html\n\n\n## The other passes operating on the abstract format ##\n\nNow that `parse_module` has been explained, let's take quick look at the\nother passes in the front end.\n\n### The transform_module pass ###\n\nThe `transform_module` pass runs parse transforms, for example\nfor [QLC] or [ms_transform].\n\n[QLC]: http://erlang.org/doc/man/qlc.html\n[ms_transform]: http://erlang.org/doc/man/ms_transform.html\n\n### The lint_module pass ###\n\nThe `lint_module` pass verifies that the code is semantically\ncorrect. That is, variables must be bound before they are used,\nall clauses for a function must have the same number of arguments,\nand so on.\n\nWhen we compile a module with problems, [erl_lint] will print\nerror messages and terminate the compilation:\n\n```\n$ cat bug.erl\n-module(bug).\n-export([main/0]).\n\nmain() ->\n    A+B.\n$ erlc +time bug.erl\nCompiling \"bug\"\n remove_file                   :      0.000 s       2.1 kB\n parse_module                  :      0.000 s       2.7 kB\n transform_module              :      0.000 s       2.7 kB\n lint_module                   :      0.004 s       2.4 kB\nbug.erl:5: variable 'A' is unbound\nbug.erl:5: variable 'B' is unbound\n$\n```\n\n[erl_lint]: http://erlang.org/doc/man/erl_lint.html\n\n### Translating records ###\n\nThe `expand_records` pass uses [erl_expand_records] to translate\nrecords:\n\n```\n$ erlc -E +time trivial.erl\nCompiling \"trivial\"\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.002 s       5.5 kB\n expand_records                :      0.000 s       5.3 kB\n listing                       :      0.001 s       5.3 kB\n$ cat trivial.E\n-file(\"trivial.erl\", 1).\n\n-module(trivial).\n\n-export([example/4]).\n\n-record(rec,{mod,func,result}).\n\nexample(A, B, C, D) ->\n    {rec,trivial,example,A + B * C * (D + 42)}.\n```\n\nThe `-E` option produces a listing of the abstract format\nproduced by the `expand_records` pass.\n\nThe `-record()` declaration is still there, but the construction of\nthe record has been replaced with construction of a tuple. Similarly,\nmatching of records will be translated to matching of tuples.\n\n[erl_expand_records]: http://erlang.org/doc/man/erl_expand_records.html\n\n## Tip: Producing a single source file using -P ##\n\nThe `-P` option can be used to package a source file that includes\nmultiple include files into a single self-contained source file.\n\nHaving a self-contained source file is useful if you want to report\na compiler bug, but don't have the time to minimize the source code\nto a minimum example.\n\nHere is an example. The `compile.erl` file includes two header files.\nCompiling it directly like this will not work:\n\n```\n$ cd lib/compiler/src\n$ erlc compile.erl\ncompile.erl:36: can't find include file \"erl_compile.hrl\"\n   .\n   .\n   .\n$\n```\n\nWe must give the path to the `include` directories of both\nKernel and STDLIB:\n\n```\n$ erlc -I ../../kernel/include -I ../../stdlib/include compile.erl\n$\n```\n\nTo package the source from `compile.erl` as well as the contents\nof the header files, use the `-P` option to generate `compile.P`:\n\n\n```\n$ erlc -P -I ../../kernel/include -I ../../stdlib/include compile.erl\n```\n\n`compile.P` can be renamed to `compile.erl` and successfully\ncompiled without any additional options:\n\n```\n$ mv compile.P $HOME/compile.erl\n$ cd $HOME\n$ erlc compile.erl\n$\n```\n\n## Points to Ponder ##\n\nThe preprocessor is run after tokenization, before running the\nparser.\n\nSo how are the `?FUNCTION_NAME` and `?FUNCTION_ARITY` macros implemented?\n\nHere is an example of how tokens for a simple function looks like:\n\n```\n1> {ok,T,_} = erl_scan:string(\"foo({tag,X,Y}) -> ?FUNCTION_ARITY.\"), T.\n[{atom,1,foo},\n {'(',1},\n {'{',1},\n {atom,1,tag},\n {',',1},\n {var,1,'X'},\n {',',1},\n {var,1,'Y'},\n {'}',1},\n {')',1},\n {'->',1},\n {'?',1},\n {var,1,'FUNCTION_ARITY'},\n {dot,1}]\n```\n"}},"__N_SSG":true}