{"pageProps":{"item":{"id":"digging-deeper-in-ssa","title":"Digging deeper in SSA","author":"Björn Gustavsson","excerpt":"\nThis blog post continues the exploration of the [new SSA-based\nintermediate representation][pr1935] through multiple examples. Make\nsure to read the [Introduction to SSA][prev] if you missed it.","article_date":1537401600000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Digging deeper in SSA","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post continues the exploration of the [new SSA-based\nintermediate representation][pr1935] through multiple examples. Make\nsure to read the [Introduction to SSA][prev] if you missed it.\n\n## Calling a BIF that may fail\n\nThe first example calls a guard BIF that may fail with\nan exception:\n\n```erlang\nelement_body(T) ->\n    element(2, T).\n```\n\nThe (optimized) SSA code looks like this:\n\n```\nfunction blog:element_body(_0) {\n0:\n  %% blog.erl:5\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n  br @ssa_bool, label 3, label 1\n\n3:\n  ret _1\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\nLet's go through the code a few lines at a time:\n\n```\n  %% blog.erl:5\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n```\n\nThe `bif:element` instruction calls the guard BIF `element/2`, assigning\nthe value to the variable `_1` if the call is successful.\n\nWhat if the call is not successful?\n\nThe `succeeded _1` instruction tests whether the previous instruction\nassigning to `_1` was successful. `true` will be assigned to `@ssa_bool`\nif the second element of the tuple was successfully fetched from the tuple,\nand `false` will be assigned otherwise.\n\n```\n  br @ssa_bool, label 3, label 1\n```\n\nThe `br` instruction tests whether `@ssa_bool` is `true`. If `true`, execution\ncontinues at block 3, which returns the value of the second element from the\ntuple. If `false`, execution continues at block 1.\n\nIt was mentioned in the [previous blog post][prev] that block 1 is a\nspecial block that the SSA code generator always emits. In the\nprevious examples, it was never referenced and therefore removed by\none of the optimization passes.\n\nIn this example, it is used as the target when the call to `element/2` fails.\n\nThe BEAM code generator treats references to block 1 specially. Here follows the\nBEAM code for the function. As usual, I have omitted the function header.\n\n      %% Block 0.\n      {line,[{location,\"blog.erl\",5}]}.\n      {bif,element,{f,0},[{integer,2},{x,0}],{x,0}}.\n      return.\n\nNote that no code has been generated for block 1.\n\nThe `line` instructions gives the file name and line number of the source file.\nIt will be used in the stack backtrace if the following instruction fails.\n\nThe `bif` instruction calls the given guard BIF, `element/2` in this case.\nThe `{f,0}` operand gives the action to take if the `element/2` fails. The number\n`0` is a special case, meaning that a `badarg` exception should be raised if the\ncall of `element/2` fails.\n\n## A failing BIF call in a guard\n\nIn the next example, `element/2` is called in a guard:\n\n```erlang\nelement_guard(T) when element(2, T) =:= true ->\n    ok;\nelement_guard(_) ->\n    error.\n```\n\nThe SSA code looks like this:\n\n```\nfunction blog:element_guard(_0) {\n0:\n  %% blog.erl:7\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n  br @ssa_bool, label 4, label 3\n\n4:\n  @ssa_bool:5 = bif:'=:=' _1, literal true\n  br @ssa_bool:5, label 6, label 3\n\n6:\n  ret literal ok\n\n3:\n  ret literal error\n}\n```\n\nThe first two instructions in block 0 are the same as in the previous\nexample.  The `br` instruction has different labels, though. The\nfailure label refers to block 3, which returns the value `error`. The\nsuccess label continues execution at block 4.\n\n```\n4:\n  @ssa_bool:5 = bif:'=:=' _1, literal true\n  br @ssa_bool:5, label 6, label 3\n```\n\nBlock 4 is the translation of `=:= true` part of the Erlang code.\nIf the second element in the tuple is equal to `true`, execution\ncontinues at block 6, which returns the value `ok`. Otherwise\nexecution continues at block 3, which returns the value `error`.\n\nHere is the BEAM code:\n\n      {bif,element,{f,5},[{integer,2},{x,0}],{x,0}}.\n      {test,is_eq_exact,{f,5},[{x,0},{atom,true}]}.\n      {move,{atom,ok},{x,0}}.\n      return.\n    {label,5}.\n      {move,{atom,error},{x,0}}.\n      return.\n\nIn the `bif` instruction, `{f,5}` means that execution should\ncontinue at label 5 if the `element/2` call fails. Otherwise\nexecution will continue at the next instruction.\n\n## Our first case\n\nHere is the next example:\n\n```erlang\ncase1(X) ->\n    case X of\n        1 -> a;\n        2 -> b;\n        _ -> c\n    end.\n```\n\nTranslated to SSA code:\n\n```\nfunction blog:case1(_0) {\n0:\n  switch _0, label 3, [ { literal 2, label 5 }, { literal 1, label 4 } ]\n\n4:\n  ret literal a\n\n5:\n  ret literal b\n\n3:\n  ret literal c\n}\n```\n\nThe `switch` instruction is a multi-way branch to one of any number of\nother blocks, based on the value of a variable. In this example, it\nbranches based on the value of the variable `_0`. If `_0` is equal\nto 2, execution continues at block 5. If `_0` is equal to 1,\nexecution continues at block 4. If the value is not equal to any\nof the values in the switch list, execution continues at the block\nreferred to by the failure label, in this example block 3.\n\nThe BEAM code looks like this:\n\n      {select_val,{x,0},{f,10},{list,[{integer,2},{f,9},{integer,1},{f,8}]}}.\n    {label,8}.\n      {move,{atom,a},{x,0}}.\n      return.\n    {label,9}.\n      {move,{atom,b},{x,0}}.\n      return.\n    {label,10}.\n      {move,{atom,c},{x,0}}.\n      return.\n\n## Terminators\n\nAs mentioned in the [previous blog post][prev], the last instruction in a block is\ncalled a *terminator*. A terminator either returns from the function or transfers\ncontrol to another block. With the introduction of `switch`, the terminator story\nis complete. To summarize, a block can end in one of the following terminators:\n\n* `ret` to return a value from the function.\n\n* `br` to either branch to another block (one-way branch), or branch to one\nof two possible other blocks based on a variable (two-way branch).\n\n* `switch` to branch to one of any number of other blocks.\n\n## Another case\n\nHere is a slightly different example:\n\n```erlang\ncase2(X) ->\n    case X of\n        1 -> a;\n        2 -> b;\n        3 -> c\n    end.\n```\n\nIn this case, `X` must be one of the integers 1, 2, or 3. Otherwise, there will\nbe a `{case_clause,X}` exception. Here is the SSA code:\n\n```\nfunction blog:case2(_0) {\n0:\n  switch _0, label 3, [ { literal 3, label 6 }, { literal 2, label 5 }, { literal 1, label 4 } ]\n\n4:\n  ret literal a\n\n5:\n  ret literal b\n\n6:\n  ret literal c\n\n3:\n  _2 = put_tuple literal case_clause, _0\n\n  %% blog.erl:20\n  @ssa_ret:7 = call remote (literal erlang):(literal error)/1, _2\n  ret @ssa_ret:7\n}\n```\n\nThe failure label for the `switch` is 3. Block 3 builds the `{case_clause,X}`\ntuple and calls `erlang:error/1`.\n\nHere is the BEAM code:\n\n      {select_val,{x,0},\n                  {f,16},\n                  {list,[{integer,3},\n                         {f,15},\n                         {integer,2},\n                         {f,14},\n                         {integer,1},\n                         {f,13}]}}.\n    {label,13}.\n      {move,{atom,a},{x,0}}.\n      return.\n    {label,14}.\n      {move,{atom,b},{x,0}}.\n      return.\n    {label,15}.\n      {move,{atom,c},{x,0}}.\n      return.\n    {label,16}.\n      {line,[{location,\"blog.erl\",20}]}.\n      {case_end,{x,0}}.\n\nThe `case_end` instruction is an optimization to save space. It is shorter than\nthe equivalent:\n\n      {test_heap,3,1}.\n      {put_tuple2,{x,0},{list,[{atom,case_clause},{x,0}]}}.\n      {line,[{location,\"blog.erl\",20}]}.\n      {call_ext_only,1,{extfunc,erlang,error,1}}.\n\n(The `put_tuple2` instruction was introduced in\n[#1947: Introduce a put_tuple2 instruction][pr1947], which was recently merged\nto `master`.)\n\n## Our final case\n\nIt's time to address the kind of `case` similar to what was teased at the\nend of the previous blog post.\n\nIn this example, the variable `Y` will be assigned different values in\neach clause of the `case`:\n\n```erlang\ncase3a(X) ->\n    case X of\n        zero ->\n            Y = 0;\n        something ->\n            Y = X;\n        _ ->\n            Y = no_idea\n    end,\n    {ok,Y}.\n```\n\nPerhaps a more common way to write this `case` would be:\n\n```erlang\ncase3b(X) ->\n    Y = case X of\n            zero -> 0;\n            something -> X;\n            _ -> no_idea\n        end,\n    {ok,Y}.\n```\n\nIn either case, the problem remains. Static Single Assignment means that each\nvariable can only be given a value once. So how can this example be translated\nto SSA code?\n\nHere follows the SSA code for `case3a/1`. The SSA code for `case3b/1` is almost\nidentical except for variable naming.\n\n```\nfunction blog:case3a(_0) {\n0:\n  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]\n\n5:\n  br label 3\n\n6:\n  br label 3\n\n4:\n  br label 3\n\n3:\n  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }\n  _7 = put_tuple literal ok, Y\n  ret _7\n}\n```\n\nLet's jump right to the interesting (and confusing) part of the code:\n\n```\n3:\n  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }\n```\n\nClearly, `Y` is only given a value once, so the SSA property is\npreserved.\n\nThat's good, but exactly what is the value that is being assigned?\n\nThe name of the instruction is `phi`, which is the name of the\nGreek letter [&phi;][phi]. Having an unusual name, the instruction\ndeserves to have unusual operands, too. Each operand is a pair, the\nfirst element in the pair being a value and the second element a block\nnumber of a predecessor block. The value of the `phi` node will be one\nof the values from one the pairs. But from which pair? That depends on\nthe number of the previous block that branched to the `phi` instruction.\n\nTo make that somewhat clearer, let's look at all operands:\n\n* `{ literal no_idea, 4 }`: If the number of block that executed `br label 3`\nwas 4, the value of the `phi` instruction will be the value in this pair,\nthat is, the atom `no_idea`. The failure label for the `switch` instruction\nis 4, so this pair will be chosen when `_0` does not match any of the values\nin the switch list.\n\n* `{ literal 0, 5 }`: If the number of block that executed `br label 3`\nwas 5, the value of the `phi` instruction will be the integer 0. The\n`switch` instruction will transfer control to block 5 if the value of\n`_0` is the atom `zero`.\n\n* `{ _0, 6 }`: Finally, if `_0` is the atom `something`, the `switch`\nwill transfer control to block 6, which will transfer control to\nblock 3. The value of the `phi` instruction will be the value of the\nvariable `_0`.\n\nThe concept of `phi` instructions probably feels a bit strange at\nfirst sight (and at second sight), and one might also think they\nmust be terribly inefficient.\n\nLeaving the strangeness aside, let's talk about the efficiency. `phi`\ninstructions is a fiction convenient for representing and optimizing\nthe code. When translating to BEAM code, the `phi` instructions are\neliminated.\n\nHere follows an example that is **not** SSA code, because it assigns\nthe variable `Y` three times, but gives an idea how the `phi`\ninstruction is eliminated:\n\n```\n%% Not SSA code!\nfunction blog:case3a(_0) {\n0:\n  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]\n\n5:\n  Y := literal 0\n  br label 3\n\n6:\n  Y := _0\n  br label 3\n\n4:\n  Y := no_idea\n  br label 3\n\n3:\n  _7 = put_tuple literal ok, Y\n  ret _7\n}\n```\n\nThe BEAM code generator (`beam_ssa_codegen`) does a similar rewrite\nduring code generation.\n\nHere is the unoptimized BEAM code, slightly edited for clarity:\n\n    %% Block 0.\n    {select_val,{x,0},\n                {f,53},\n                {list,[{atom,something},{f,55},{atom,zero},{f,57}]}}.\n\n    %% Block 5.\n    {label,57}.\n      {move,{integer,0},{x,0}}.\n      {jump,{f,59}}.\n\n    %% Block 6.\n    {label,55}.\n      %% The result is already in {x,0}.\n      {jump,{f,59}}.\n\n    %% Block 4.\n    {label,53}.\n      {move,{atom,no_idea},{x,0}}.\n      {jump,{f,59}}.\n\n    %% Block 3.\n    {label,59}.\n       {test_heap,3,1}.\n       {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n       return.\n\nHere is the final BEAM code after some more optimizations:\n\n    {label,18}.\n      {select_val,{x,0},\n                  {f,20},\n                  {list,[{atom,something},{f,21},{atom,zero},{f,19}]}}.\n    {label,19}.\n      {move,{integer,0},{x,0}}.\n      {jump,{f,21}}.\n    {label,20}.\n      {move,{atom,no_idea},{x,0}}.\n    {label,21}.\n      {test_heap,3,1}.\n      {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n      return.\n\n## The cold case\n\nHere is the example from the end of the previous blog post:\n\n```erlang\nbar(X) ->\n    case X of\n        none ->\n            Y = 0;\n        _ ->\n            Y = X\n    end,\n    Y + 1.\n```\n\nAnd here is the SSA code:\n\n```\nfunction blog:bar(_0) {\n0:\n  @ssa_bool = bif:'=:=' _0, literal none\n  br @ssa_bool, label 5, label 4\n\n5:\n  br label 3\n\n4:\n  br label 3\n\n3:\n  Y = phi { _0, 4 }, { literal 0, 5 }\n\n  %% blog.erl:52\n  _6 = bif:'+' Y, literal 1\n  @ssa_bool:6 = succeeded _6\n  br @ssa_bool:6, label 7, label 1\n\n7:\n  ret _6\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\nIt is left as an exercise to the reader to read and understand the code.\n\nHere is the BEAM code:\n\n    {label,28}.\n      {test,is_eq_exact,{f,29},[{x,0},{atom,none}]}.\n      {move,{integer,0},{x,0}}.\n    {label,29}.\n      {line,[{location,\"blog.erl\",52}]}.\n      {gc_bif,'+',{f,0},1,[{x,0},{integer,1}],{x,0}}.\n      return.\n\nThe `gc_bif` instruction calls a guard BIF that might need to do a\ngarbage collection. Since integers can be of essentially unlimited\nsize in Erlang, the result of `+` might not fit in a word. The\n`1` following `{f,0}` is the number of registers that must be\npreserved; in this case, only `{x,0}`.\n\n[prev]: http://blog.erlang.org/introducing-ssa/\n[pr1935]: https://github.com/erlang/otp/pull/1935\n[pr1947]: https://github.com/erlang/otp/pull/1947\n[phi]: https://en.wikipedia.org/wiki/Phi\n"}},"__N_SSG":true}