{"pageProps":{"item":{"id":"core-erlang-optimizations","title":"Core Erlang Optimizations","author":"Björn Gustavsson","excerpt":"\nThis blog post continues the exploration of Core Erlang by\nlooking at some optimizations done by the `sys_core_fold`\ncompiler pass. The Core Erlang language was introduced in\nthe [previous blog post](http://blog.erlang.org/core-erlang-by-example/).","article_date":1526601600000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Core Erlang Optimizations","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post continues the exploration of Core Erlang by\nlooking at some optimizations done by the `sys_core_fold`\ncompiler pass. The Core Erlang language was introduced in\nthe [previous blog post](http://blog.erlang.org/core-erlang-by-example/).\n\nTo prepare the examples in this blog post I used two\ncommands.\n\n```\n$ erlc +time +dcore core_fold_example.erl\nCompiling \"core_fold_example\"\n parse_module                  :      0.000 s       9.4 kB\n transform_module              :      0.000 s       9.4 kB\n lint_module                   :      0.005 s       9.4 kB\n expand_records                :      0.000 s       9.4 kB\n core                          :      0.000 s      59.3 kB\n listing                       :      0.003 s      59.3 kB\n```\n\nThe `dcore` option produces the file `core_fold_example.core`\ncontaining a listing of the Core Erlang code produced by the `core`\nparse (implemented by the module `v3_core`).\n\n```\n$ erlc +time +dcopt core_fold_example.erl\nCompiling \"core_fold_example\"\n parse_module                  :      0.000 s       9.4 kB\n transform_module              :      0.000 s       9.4 kB\n lint_module                   :      0.002 s       9.4 kB\n expand_records                :      0.000 s       9.4 kB\n core                          :      0.000 s      59.3 kB\n sys_core_fold                 :      0.000 s      25.3 kB\n core_transforms               :      0.000 s      25.3 kB\n listing                       :      0.002 s      25.3 kB\n```\n\nThe `dcopt` option produces the file `core_fold_example.copt`\ncontaining a listing of the Core Erlang code as it looks\nafter optimization by the `sys_core_fold` pass.\n\nAs was mentioned in my first blog post about the compiler,\n`compile:options()` will print most of the hidden options for\nthe compiler.\n\n## The most basic optimization\n\nThe most basic optimization done by `sys_core_fold` is constant propagation.\n\nConsider this Erlang function:\n\n```erlang\na() ->\n    A = 42,\n    {ok,A}.\n```\n\nIt can be translated to Core Erlang like this:\n\n```\n'a'/0 =\n    fun () ->\n       let <A> = 42\n       in {'ok',A}\n```\n\nThe variable `A` is bound to a constant (as opposed to an expression such\nas function call). We can replace all occurrences of the variable `A` with\nthe constant value `42` and eliminate the `let`:\n\n```\n'a'/0 =\n    fun () ->\n\t{'ok',42}\n```\n\n## Optimizing `case` expressions\n\nActually, the first version of `a/0` that I showed was already\nslightly optimized by me.\n\nHere is the actual Core Erlang code (only slightly edited to\nremove annotations and unnecessary line breaks):\n\n```\n'a'/0 =\n    fun () ->\n        case <> of\n\t  <> when 'true' ->\n\t      let <A> = 42\n\t      in {'ok',A}\n\t  <> when 'true' ->\n\t\tprimop 'match_fail'({'function_clause'})\n\tend\n```\n\nThe `let` has been wrapped in a useless outer `case`. The\n`case` would serve some purpose if there had been some function\narguments, but why complicate the code generator if `sys_core_fold` is\nperfectly capable of simplifying this code?\n\n`sys_core_fold` will simplify the code in several steps.\n\nFirst it will look at each clause. If a clause can't possibly\nbe executed (for example, it its guard is `false`) it will be\ndropped. If a clause will always match, all clauses following\nthe clause will be dropped.\n\nIn this case, the first clause will always match, because the\npattern is a list of no variables that can't fail to match, and\nthe guard is `true`. Thus the second clause is unreachable and\nis dropped:\n\n\n```\n'a'/0 =\n    fun () ->\n        case <> of\n\t  <> when 'true' ->\n\t      let <A> = 42\n\t      in {'ok',A}\n\tend\n```\n\nThe next step is to see if there is only one clause remaining.\nIf it is, the body of the clause can be kept and the `case`\neliminated:\n\n\n```\n'a'/0 =\n    fun () ->\n       let <A> = 42\n       in {'ok',A}\n```\n\n## Another case example\n\nLet's see how a more complicated function can be optimized\nfollowing the steps just described. Consider this Erlang\nfunction:\n\n```erlang\naa() ->\n    case {a,tuple} of\n\t[List] -> List;\n\t{A,B} ->  {tuple,A,B};\n\t_ ->      something_else\n    end.\n```\n\nTranslated to Core Erlang code (with the outer `case` and\nannotations removed) it will look this:\n\n```\n'aa'/0 =\n    fun () ->\n      case {'a','tuple'} of\n\t<[List|[]]> when 'true' ->\n\t    List\n\t<{A,B}> when 'true' ->\n\t    {'tuple',A,B}\n\t<_@c1> when 'true' ->\n\t    'something_else'\n\t<_@c0> when 'true' ->\n\t    primop 'match_fail'({'case_clause',_@c0})\n      end\n```\n\nLet's go through the clauses one by one:\n\n* The first clause will only match a list with exactly one element.\nThe `case` expression is a tuple, so the first clause can't\npossibly match. It will be dropped.\n\n* The second clause will match a tuple with (any) two elements.\nThe case expression is a tuple with two elements, so this clause\nwill always match.\n\n* There is no need to look at the remaining clauses, since the\nsecond clause will always match. The remaining clauses are dropped.\n\nWe now have:\n\n```\n'aa'/0 =\n    fun () ->\n      case {'a','tuple'} of\n\t<{A,B}> when 'true' ->\n\t    {'tuple',A,B}\n      end\n```\n\nThis is a `case` with just one clause, so we can keep\nthe body of the clause and remove the `case`. But there is\na problem if we do that naively:\n\n```\n'aa'/0 =\n    fun () ->\n       {'tuple',A,B}\n```\n\nThe variables `A` and `B` are used, but they don't have\nany values bound to them. We must use a `let` to bind\nthe variables before they can be used:\n\n```\n'aa'/0 =\n    fun () ->\n      let <A,B> = <'a','tuple'>\n      in {'tuple',A,B}\n```\n\nPropagating constants, the final code is:\n\n```\n'aa'/0 =\n    fun () ->\n\t{'tuple','a','tuple'}\n```\n\n## Avoiding tuple building\n\nHere is an example of a common pattern of matching\nseveral expressions in parallel:\n\n```erlang\nb(A, B) ->\n    case {A,B} of\n\t{true,false} -> ok;\n\t{false,true} -> not_ok;\n\t{_,_} -> error\n    end.\n```\n\nThe unoptimized Core Erlang code looks like this:\n\n```\n'b'/2 =\n    fun (_@c1,_@c0) ->\n\tcase <_@c1,_@c0> of\n\t  <A,B> when 'true' ->\n\t      case {A,B} of\n\t\t<{'true','false'}> when 'true' ->\n\t\t    'ok'\n\t\t<{'false','true'}> when 'true' ->\n\t\t    'not_ok'\n\t\t<{_@c5,_@c6}> when 'true' ->\n\t\t    'error'\n\t\t<_@c2> when 'true' ->\n\t\t      primop 'match_fail'({'case_clause',_@c2})\n\t      end\n\tend\n```\n\nThe `case` expression is `{A,B}`. When executing the `case`\na tuple will built, and then almost immediately discarded.\nThat is wasteful. Therefore `sys_core_fold` rewrites the\ncode to eliminate the tuple building:\n\n```\n'b'/2 =\n    fun (_@c1,_@c0) ->\n\tcase <_@c1,_@c0> of\n\t  <'true','false'> when 'true' ->\n\t      'ok'\n\t  <'false','true'> when 'true' ->\n\t      'not_ok'\n\t  <_@c5,_@c6> when 'true' ->\n\t      'error'\n\tend\n```\n\nHere a value list is used instead of a tuple. (See\n[previous blog post](http://blog.erlang.org/core-erlang-by-example/)\nfor several examples of value lists.)\n\nAnother common pattern where tuples are built and immediately\ndiscarded is shown in this example:\n\n```erlang\nc(X) ->\n    {A,B} = case X of\n\t\ta1 -> {10,1};\n\t\tb2 -> {20,2};\n\t\t_ ->  {100,42}\n\t    end,\n    A+B.\n```\n\nThe unoptimized Core Erlang code looks like this:\n\n```\n'c'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <X> when 'true' ->\n\t      let <_@c2> =\n\t\t  case X of\n\t\t    <'a1'> when 'true' ->\n\t\t\t{10,1}\n\t\t    <'b2'> when 'true' ->\n\t\t\t{20,2}\n\t\t    <_@c5> when 'true' ->\n\t\t\t{100,42}\n\t\t    <_@c1> when 'true' ->\n\t\t\t  primop 'match_fail'({'case_clause',_@c1})\n\t\t  end\n\t      in\n\t\t  case _@c2 of\n\t\t    <{A,B}> when 'true' ->\n\t\t\tcall 'erlang':'+'(A, B)\n\t\t    <_@c3> when 'true' ->\n\t\t\t  primop 'match_fail'({'badmatch',_@c3})\n\t\t  end\n\t  <_@c4> when 'true' ->\n\t\t  primop 'match_fail'({'function_clause',_@c4})\n\tend\n```\n\nHere a tuple is built and assigned to `_@c2`. It is then matched\nin a `case`.\n\nFirst the code is optimized like this to eliminate the tuple building\nin each clause of the first `case`:\n\n```\n'c'/1 =\n    fun (_@c0) ->\n\tlet <_@f4,_@f5> =\n\t    case _@c0 of\n\t      <'a1'> when 'true' ->\n\t\t  <10,1>\n\t      <'b2'> when 'true' ->\n\t\t  <20,2>\n\t      <_@c5> when 'true' ->\n\t\t  <100,42>\n\t    end\n\tin\n            let <_@c2> = {_@f4,_@f5}\n            in\n\t          case _@c2 of\n\t\t    <{A,B}> when 'true' ->\n\t\t\tcall 'erlang':'+'(A, B)\n\t\t    <_@c3> when 'true' ->\n\t\t\t  primop 'match_fail'({'badmatch',_@c3})\n\t\t  end\n\tend\n```\n\nApplying all of the optimizations previously described,\nthe remaining tuple building and matching can be eliminated:\n\n```\n'c'/1 =\n    fun (_@c0) ->\n\tlet <_@f4,_@f5> =\n\t    case _@c0 of\n\t      <'a1'> when 'true' ->\n\t\t  <10,1>\n\t      <'b2'> when 'true' ->\n\t\t  <20,2>\n\t      <_@c5> when 'true' ->\n\t\t  <100,42>\n\t    end\n\tin\n\t    call 'erlang':'+'(_@f4, _@f5)\n```\n\n## Conclusion\n\nThat was a quick look at some of the optimizations done by\n`sys_core_fold`.\n\nSome of the optimizations are very simple. The power of the\n`sys_core_fold` pass comes from the combination of optimizations.  One\noptimization gives opportunities for other optimizations, as could be\nseen in the examples.\n\n## Points to Ponder\n\nWhy is the optimization pass called `sys_core_fold`?\n\nA hint can be found in the title of this Wikipedia article:\n[Constant folding](https://en.wikipedia.org/wiki/Constant_folding).\n\n"}},"__N_SSG":true}