<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Björn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
Status: Accepted/R13A Proposal is to be implemented in OTP release R13A
Type: Standards Track
Erlang-Version: R12B-5
Created: 28-Jan-2009
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 26: <a href="eep-0026.md" title="EEP Source"> Make andalso and orelse tail-recursive</a></h2>

<h1>Abstract</h1>

<p>Erlang 5.1 added the ability to use 'andalso', 'orelse',
'and', and 'or' in guards.  However, the semantics for
'andalso' and 'orelse' differs from that in other related
languages, causing confusion and inefficiency.</p>

<p>I propose making 'andalso' and 'orelse' tail-recursive.</p>

<p>This EEP is partly based on Richard O'Keefe's <a href="/eeps/eep-0017" title="Richard O'Keefe: EEP 17 - Fix andalso and orelse">EEP 17</a>,
but has a narrower scope.</p>

<h1>Specification</h1>

<p>Currently, <code>(E1 andalso E2)</code> as an expression acts like</p>

<pre><code>case E1 of
   false -&gt; false;
   true  -&gt; case E2 of
       false -&gt; false;
       true  -&gt; true
   end
end
</code></pre>

<p>except that the former raises <code>{badarg,NonBool}</code> exceptions and the
latter raises <code>{case_clause,NonBool}</code> ones.</p>

<p>This should be changed to</p>

<pre><code>case E1 of
   false -&gt; false;
   true  -&gt; E2
end.
</code></pre>

<p>Currently, <code>(E1 orelse E2)</code> as an expression acts like</p>

<pre><code>case E1 of
    true -&gt; true
    false -&gt; case E2 of
        true  -&gt; true
        false -&gt; false
    end
end
</code></pre>

<p>except that the former raises <code>{badarg,NonBool}</code> exceptions and the
latter raises <code>{case_clause,NonBool}</code> ones.</p>

<p>This should be changed to</p>

<pre><code>case E1 of
    true  -&gt; true;
    false -&gt; E2
end
</code></pre>

<h1>Motivation</h1>

<p>To unlock the full potential of 'andalso'/'orelse' in Erlang.</p>

<p>Given the current implementation, you either have to make
rewrite code that is naturally written using AND and OR
operators using 'case', or only use 'andalso'/'orelse' when
you know that your lists are relatively short.</p>

<p>For instance, the function <code>all/2</code> that returns 'true' if
all elements of a list satisfies a predicate and 'false'
otherwise, can be written like this:</p>

<p>all(Pred, [Hd|Tail]) ->
       Pred(Hd) and all(Pred, Tail);
   all(_, []) ->
       true.</p>

<p>In each recursion, we test that the current element Hd
satisfies the predicate AND that the rest of the list also
matches the predicate. The code reads almost like English.</p>

<p>Of course, 'and' evaluates both of its operand, so the entire
list will be traversed even if the first element of the list
fails to satisfy the predicate. Furthermore, 'and' is not
tail-recursive, so the function will use stack space
proportional to the length of the list.</p>

<p>To avoid the traversing the rest of the list if one element
fails to satisfy the predicate, we can use 'andalso':</p>

<p>all(Pred, [Hd|Tail]) ->
       Pred(Hd) andalso all(Pred, Tail);
   all(_, []) ->
      true.</p>

<p>As soon as <code>Pred(Hd)</code> returns false, the recursion will
stop and the rest of the list need not be traversed.
Since 'andalso' is not tail-recursive, however, the
function will need stack space proportional to the number
of list elements that are traversed.</p>

<p>To see more clearly that 'andalso' is not tail-recursive,
here is <code>all/1</code> with 'andalso' expanded out to a nested
'case' expression (as it would be in R12B-5):</p>

<pre><code>all(Pred, [Hd|Tail]) -&gt;
    case Pred(Hd) of
        false -&gt; false;
        true  -&gt; case all(Pred, Tail) of
        false -&gt; false;
        true  -&gt; true
        end
    end;
all(_, []) -&gt;
    true.
</code></pre>

<p>To make <code>all/1</code> tail-recursive in R12B-5, you would have
to write a 'case' expression yourself:</p>

<pre><code>all(Pred, [Hd|Tail]) -&gt;
    case Pred(Hd) of
        false -&gt; false;
        true  -&gt; all(Pred, Tail)
    end;
all(_, []) -&gt;
    true.
</code></pre>

<p>If this EEP is accepted, in R13B we could write like
this</p>

<pre><code>all(Pred, [Hd|Tail]) -&gt;
    Pred(Hd) andalso all(Pred, Tail);
all(_, []) -&gt;
    true.
</code></pre>

<p>and the <code>all/1</code> function would be tail-recursive.</p>

<p>In my opinion, the latter is easier to read and write.
The 'case' expression is mostly boiler-plate code
where 'true' and 'false' must be correctly spelled
several times. (Misspellings like 'ture' and 'flase'
are quite common, but are in most cases found the
first time the program is tested.)</p>

<p>It could be argued that because Erlang has clearly defined truth
values (unlike some other languages where 0 is false and
everything else true), all operators that operate on booleans
should make sure that their arguments are booleans.</p>

<p>Testing both arguments of 'and' and 'or' makes
sense, because the code executed for those operators always GETS
the values of both operands.  But 'andalso' and 'orelse' only test
their second operand SOME of the time.</p>

<pre><code>X = 1, X &gt;= 0 andalso X    % checked error
X = 1, X &lt; 0 andalso X     % unchecked error
</code></pre>

<p>There doesn't seem to be much point in checking SOME of the time,
especially when it does something as dramatic as blocking tail
recursion.</p>

<p>Richard O'Keefe's motivation in <a href="/eeps/eep-0017" title="Richard O'Keefe: EEP 17 - Fix andalso and orelse">EEP 17</a> is "Cultural consistency"
with other languages. See <a href="/eeps/eep-0017" title="Richard O'Keefe: EEP 17 - Fix andalso and orelse">EEP 17</a>.</p>

<h1>Rationale</h1>

<p>Surprisingly (for me), the subject of this EEP turned out to
be controversial.</p>

<p>I will start this rationale by listing some of the more serious
arguments against this proposal and my counter-arguments, and
finish with the arguments for this proposal.</p>

<p>One argument against is to be that the new construct
will be confusing for users. 'andalso'/'orelse' can no longer
be described as a "boolean operator", but is now a "control
structure".</p>

<p>Yes, 'andalso'/'orelse' is no longer a boolean operator in the
sense that it no longer GUARANTEES that it returns a boolean.
However, using 'andalso'/'orelse' as a 'case' expression</p>

<pre><code>case E1 orelse E2 of
    true -&gt; ....;
    false -&gt; ...
end
</code></pre>

<p>works in the same way as before. Most users certainly will not
notice any difference.  And if an operator is not allowed to not
evaluate both of its arguments, it certainly wasn't an operator
before either.</p>

<p>Another argument against is that 'andalso'/'orelse' can be
used in one-liners to write "ugly code", such as</p>

<pre><code>Debug andalso io:format("...", [...])
</code></pre>

<p>instead of</p>

<pre><code>if
    Debug -&gt; io:format("...", [...]);
    true -&gt; ok
end
</code></pre>

<p>The code might be "ugly" (according to someone's taste or
some definition of "ugly"), but the one-liner is not hard
to understand and I don't see how it could turn into a
code-maintenance problem.</p>

<p>The main argument for making 'andalso'/'orelse' tail-recursive:
The current implementation is dangerous. You could very easily
write non-tail-recursive code, for instance</p>

<pre><code>all(Pred, [Hd|Tail]) -&gt;
    Pred(Hd) andalso all(Pred, Tail);
all(_, []) -&gt;
    true.
</code></pre>

<p>without realizing it and introduce serious performance
problems. (Which has happened in <a href="http://www.erlang.org/pipermail/erlang-questions/2008-November/039935.html" title="Mikael Pettersson: e-mail to erlang-questions">practice</a>).</p>

<p>If you cannot use 'andalso'/'orelse' in this way, these
operators become pretty useless. (Some would say
<a href="http://www.erlang.org/pipermail/erlang-questions/2008-November/039935.html" title="Mikael Pettersson: e-mail to erlang-questions">"utterly useless"</a>.) You have to rewrite
beautiful code (in my opinion) to uglier code (in
comparison, in my opinion) and more error-prone
code (misspelling of 'true'/'false' in the boiler-plate
code):</p>

<pre><code>all(Pred, [Hd|Tail]) -&gt;
    case Pred(Hd) of
        false -&gt; false;
        true  -&gt; all(Pred, Tail)
    end;
all(_, []) -&gt;
   true.
</code></pre>

<h1>Backwards Compatibility</h1>

<p>Any code that ran without raising exceptions will continue
to produce the same results, except for running faster.</p>

<p>Code that did raise exceptions may raise different exceptions
elsewhere later, or may quietly complete in unexpected ways.
I believe it to be unlikely that anyone deliberately relied
on <code>(E1 andalso 0)</code> raising an exception.</p>

<p>Code that was previously broken because these operators have
such surprising behavior will now work in more cases.</p>

<h1>Reference Implementation</h1>

<p>The proposed change has been implemented and run in our
daily builds without finding any code in Erlang/OTP that
needed to be updated. One test case in the compiler test
suite that that test 'andalso'/'orelse' needed to be updated.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0026","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Björn Gustavsson \u0026lt;bjorn(at)erlang(dot)org\u0026gt;\nStatus: Accepted/R13A Proposal is to be implemented in OTP release R13A\nType: Standards Track\nErlang-Version: R12B-5\nCreated: 28-Jan-2009\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 26: \u003ca href=\"eep-0026.md\" title=\"EEP Source\"\u003e Make andalso and orelse tail-recursive\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eErlang 5.1 added the ability to use 'andalso', 'orelse',\n'and', and 'or' in guards.  However, the semantics for\n'andalso' and 'orelse' differs from that in other related\nlanguages, causing confusion and inefficiency.\u003c/p\u003e\n\n\u003cp\u003eI propose making 'andalso' and 'orelse' tail-recursive.\u003c/p\u003e\n\n\u003cp\u003eThis EEP is partly based on Richard O'Keefe's \u003ca href=\"/eeps/eep-0017\" title=\"Richard O'Keefe: EEP 17 - Fix andalso and orelse\"\u003eEEP 17\u003c/a\u003e,\nbut has a narrower scope.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eCurrently, \u003ccode\u003e(E1 andalso E2)\u003c/code\u003e as an expression acts like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1 of\n   false -\u0026gt; false;\n   true  -\u0026gt; case E2 of\n       false -\u0026gt; false;\n       true  -\u0026gt; true\n   end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eexcept that the former raises \u003ccode\u003e{badarg,NonBool}\u003c/code\u003e exceptions and the\nlatter raises \u003ccode\u003e{case_clause,NonBool}\u003c/code\u003e ones.\u003c/p\u003e\n\n\u003cp\u003eThis should be changed to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1 of\n   false -\u0026gt; false;\n   true  -\u0026gt; E2\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCurrently, \u003ccode\u003e(E1 orelse E2)\u003c/code\u003e as an expression acts like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1 of\n    true -\u0026gt; true\n    false -\u0026gt; case E2 of\n        true  -\u0026gt; true\n        false -\u0026gt; false\n    end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eexcept that the former raises \u003ccode\u003e{badarg,NonBool}\u003c/code\u003e exceptions and the\nlatter raises \u003ccode\u003e{case_clause,NonBool}\u003c/code\u003e ones.\u003c/p\u003e\n\n\u003cp\u003eThis should be changed to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1 of\n    true  -\u0026gt; true;\n    false -\u0026gt; E2\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eTo unlock the full potential of 'andalso'/'orelse' in Erlang.\u003c/p\u003e\n\n\u003cp\u003eGiven the current implementation, you either have to make\nrewrite code that is naturally written using AND and OR\noperators using 'case', or only use 'andalso'/'orelse' when\nyou know that your lists are relatively short.\u003c/p\u003e\n\n\u003cp\u003eFor instance, the function \u003ccode\u003eall/2\u003c/code\u003e that returns 'true' if\nall elements of a list satisfies a predicate and 'false'\notherwise, can be written like this:\u003c/p\u003e\n\n\u003cp\u003eall(Pred, [Hd|Tail]) -\u003e\n       Pred(Hd) and all(Pred, Tail);\n   all(_, []) -\u003e\n       true.\u003c/p\u003e\n\n\u003cp\u003eIn each recursion, we test that the current element Hd\nsatisfies the predicate AND that the rest of the list also\nmatches the predicate. The code reads almost like English.\u003c/p\u003e\n\n\u003cp\u003eOf course, 'and' evaluates both of its operand, so the entire\nlist will be traversed even if the first element of the list\nfails to satisfy the predicate. Furthermore, 'and' is not\ntail-recursive, so the function will use stack space\nproportional to the length of the list.\u003c/p\u003e\n\n\u003cp\u003eTo avoid the traversing the rest of the list if one element\nfails to satisfy the predicate, we can use 'andalso':\u003c/p\u003e\n\n\u003cp\u003eall(Pred, [Hd|Tail]) -\u003e\n       Pred(Hd) andalso all(Pred, Tail);\n   all(_, []) -\u003e\n      true.\u003c/p\u003e\n\n\u003cp\u003eAs soon as \u003ccode\u003ePred(Hd)\u003c/code\u003e returns false, the recursion will\nstop and the rest of the list need not be traversed.\nSince 'andalso' is not tail-recursive, however, the\nfunction will need stack space proportional to the number\nof list elements that are traversed.\u003c/p\u003e\n\n\u003cp\u003eTo see more clearly that 'andalso' is not tail-recursive,\nhere is \u003ccode\u003eall/1\u003c/code\u003e with 'andalso' expanded out to a nested\n'case' expression (as it would be in R12B-5):\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eall(Pred, [Hd|Tail]) -\u0026gt;\n    case Pred(Hd) of\n        false -\u0026gt; false;\n        true  -\u0026gt; case all(Pred, Tail) of\n        false -\u0026gt; false;\n        true  -\u0026gt; true\n        end\n    end;\nall(_, []) -\u0026gt;\n    true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTo make \u003ccode\u003eall/1\u003c/code\u003e tail-recursive in R12B-5, you would have\nto write a 'case' expression yourself:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eall(Pred, [Hd|Tail]) -\u0026gt;\n    case Pred(Hd) of\n        false -\u0026gt; false;\n        true  -\u0026gt; all(Pred, Tail)\n    end;\nall(_, []) -\u0026gt;\n    true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf this EEP is accepted, in R13B we could write like\nthis\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eall(Pred, [Hd|Tail]) -\u0026gt;\n    Pred(Hd) andalso all(Pred, Tail);\nall(_, []) -\u0026gt;\n    true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand the \u003ccode\u003eall/1\u003c/code\u003e function would be tail-recursive.\u003c/p\u003e\n\n\u003cp\u003eIn my opinion, the latter is easier to read and write.\nThe 'case' expression is mostly boiler-plate code\nwhere 'true' and 'false' must be correctly spelled\nseveral times. (Misspellings like 'ture' and 'flase'\nare quite common, but are in most cases found the\nfirst time the program is tested.)\u003c/p\u003e\n\n\u003cp\u003eIt could be argued that because Erlang has clearly defined truth\nvalues (unlike some other languages where 0 is false and\neverything else true), all operators that operate on booleans\nshould make sure that their arguments are booleans.\u003c/p\u003e\n\n\u003cp\u003eTesting both arguments of 'and' and 'or' makes\nsense, because the code executed for those operators always GETS\nthe values of both operands.  But 'andalso' and 'orelse' only test\ntheir second operand SOME of the time.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eX = 1, X \u0026gt;= 0 andalso X    % checked error\nX = 1, X \u0026lt; 0 andalso X     % unchecked error\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere doesn't seem to be much point in checking SOME of the time,\nespecially when it does something as dramatic as blocking tail\nrecursion.\u003c/p\u003e\n\n\u003cp\u003eRichard O'Keefe's motivation in \u003ca href=\"/eeps/eep-0017\" title=\"Richard O'Keefe: EEP 17 - Fix andalso and orelse\"\u003eEEP 17\u003c/a\u003e is \"Cultural consistency\"\nwith other languages. See \u003ca href=\"/eeps/eep-0017\" title=\"Richard O'Keefe: EEP 17 - Fix andalso and orelse\"\u003eEEP 17\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eSurprisingly (for me), the subject of this EEP turned out to\nbe controversial.\u003c/p\u003e\n\n\u003cp\u003eI will start this rationale by listing some of the more serious\narguments against this proposal and my counter-arguments, and\nfinish with the arguments for this proposal.\u003c/p\u003e\n\n\u003cp\u003eOne argument against is to be that the new construct\nwill be confusing for users. 'andalso'/'orelse' can no longer\nbe described as a \"boolean operator\", but is now a \"control\nstructure\".\u003c/p\u003e\n\n\u003cp\u003eYes, 'andalso'/'orelse' is no longer a boolean operator in the\nsense that it no longer GUARANTEES that it returns a boolean.\nHowever, using 'andalso'/'orelse' as a 'case' expression\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1 orelse E2 of\n    true -\u0026gt; ....;\n    false -\u0026gt; ...\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eworks in the same way as before. Most users certainly will not\nnotice any difference.  And if an operator is not allowed to not\nevaluate both of its arguments, it certainly wasn't an operator\nbefore either.\u003c/p\u003e\n\n\u003cp\u003eAnother argument against is that 'andalso'/'orelse' can be\nused in one-liners to write \"ugly code\", such as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eDebug andalso io:format(\"...\", [...])\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003einstead of\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eif\n    Debug -\u0026gt; io:format(\"...\", [...]);\n    true -\u0026gt; ok\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe code might be \"ugly\" (according to someone's taste or\nsome definition of \"ugly\"), but the one-liner is not hard\nto understand and I don't see how it could turn into a\ncode-maintenance problem.\u003c/p\u003e\n\n\u003cp\u003eThe main argument for making 'andalso'/'orelse' tail-recursive:\nThe current implementation is dangerous. You could very easily\nwrite non-tail-recursive code, for instance\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eall(Pred, [Hd|Tail]) -\u0026gt;\n    Pred(Hd) andalso all(Pred, Tail);\nall(_, []) -\u0026gt;\n    true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewithout realizing it and introduce serious performance\nproblems. (Which has happened in \u003ca href=\"http://www.erlang.org/pipermail/erlang-questions/2008-November/039935.html\" title=\"Mikael Pettersson: e-mail to erlang-questions\"\u003epractice\u003c/a\u003e).\u003c/p\u003e\n\n\u003cp\u003eIf you cannot use 'andalso'/'orelse' in this way, these\noperators become pretty useless. (Some would say\n\u003ca href=\"http://www.erlang.org/pipermail/erlang-questions/2008-November/039935.html\" title=\"Mikael Pettersson: e-mail to erlang-questions\"\u003e\"utterly useless\"\u003c/a\u003e.) You have to rewrite\nbeautiful code (in my opinion) to uglier code (in\ncomparison, in my opinion) and more error-prone\ncode (misspelling of 'true'/'false' in the boiler-plate\ncode):\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eall(Pred, [Hd|Tail]) -\u0026gt;\n    case Pred(Hd) of\n        false -\u0026gt; false;\n        true  -\u0026gt; all(Pred, Tail)\n    end;\nall(_, []) -\u0026gt;\n   true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eAny code that ran without raising exceptions will continue\nto produce the same results, except for running faster.\u003c/p\u003e\n\n\u003cp\u003eCode that did raise exceptions may raise different exceptions\nelsewhere later, or may quietly complete in unexpected ways.\nI believe it to be unlikely that anyone deliberately relied\non \u003ccode\u003e(E1 andalso 0)\u003c/code\u003e raising an exception.\u003c/p\u003e\n\n\u003cp\u003eCode that was previously broken because these operators have\nsuch surprising behavior will now work in more cases.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eThe proposed change has been implemented and run in our\ndaily builds without finding any code in Erlang/OTP that\nneeded to be updated. One test case in the compiler test\nsuite that that test 'andalso'/'orelse' needed to be updated.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0026"},"buildId":"92Ploa_JRk4A9mAiRpquq","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_buildManifest.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_ssgManifest.js" async=""></script></body></html>