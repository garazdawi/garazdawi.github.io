{"pageProps":{"item":{"id":"OTP-22-Highlights","title":"OTP 22 Highlights","author":"Lukas Larsson","excerpt":"\nOTP 22 has just been released. It has been a long process with three release\ncandidates before the final release. We decided this year to try to get one month\nmore testing of the major release and I think that the extra time has paid off.\nWe've received many bug reports from the community about large and small bugs\nthat our internal tests did not find.","article_date":1557705600000,"tags":["otp","22","release"],"frontmatter":{"layout":"post","title":"OTP 22 Highlights","tags":"otp 22 release","author":"Lukas Larsson"},"content":"\nOTP 22 has just been released. It has been a long process with three release\ncandidates before the final release. We decided this year to try to get one month\nmore testing of the major release and I think that the extra time has paid off.\nWe've received many bug reports from the community about large and small bugs\nthat our internal tests did not find.\n\nThis blog post will describe some highlights of what is released in OTP 22\nand in OTP 21 maintenance patches.\n\nYou can download the readme describing the changes here:\n[OTP 22 Readme](http://erlang.org/download/otp_src_22.0.readme).\nOr, as always, look at the release notes of the application you are interested in.\nFor instance here: [OTP 22 Erts Release Notes](http://erlang.org/doc/apps/erts/notes.html).\n\n# Compiler\n\nIn OTP 22 we have completely re-implemented the lower levels of the Erlang compiler.\nBefore this change the Erlang compiler consisted of a number of\nIRs (intermediate representations):\n\n    Erlang AST -> Core Erlang -> Kernel Erlang -> Beam Asm\n\nWhen compiling an Erlang module, the code is optimized and transformed between\nthese different IRs. In OTP 22 we have almost removed the `Kernel Erlang` IR and\nadded a new IR called `Beam SSA`. There are a series of blog posts describing this\nchange in greater details for those that are interested.\n\n  * [Introduction to SSA](http://blog.erlang.org/introducing-ssa/)\n  * [Digging deeper in SSA](http://blog.erlang.org/digging-deeper-in-ssa//)\n  * [SSA History](http://blog.erlang.org/ssa-history/)\n\nWith this change the compile pipeline now looks like this:\n\n    Erlang AST -> Core Erlang -> Kernel Erlang -> Beam SSA -> Beam Asm\n\nTogether with the SSA rewrite a number of new optimizations have been introduced. One such\nis [strengthening](https://github.com/erlang/otp/pull/1958) of the\n[bit syntax](http://erlang.org/doc/reference_manual/expressions.html#bit-syntax-expressions).\nBefore the change, you had to be very careful with how you wrote your binary matching in\norder for the binary match context optimization to work properly. There were also scenarios\nwhere it was impossible to get the optimization to trigger at all. One place in Erlang/OTP\nwhere this had a great effect was the internal [string:bin\\_search\\_inv\\_1](https://github.com/erlang/otp/blob/master/lib/stdlib/src/string.erl#L1638-L1671) function used by `string:lexemes/1`\nand other string functions. We can see the change in the benchmark graph below (where higher\nis better and <span style=\"color:#0c839c\">the turquoise line</span> in the OTP 22 branch):\n\n![String Lexemes OTP 22 benchmark](../images/bsm_opt_lexemes.png)\n\nYou can read more about this optimization in [PR1958](https://github.com/erlang/otp/pull/1958)\nand [Retiring old performance pitfalls](http://blog.erlang.org/retired-pitfalls-22/).\n\nAnother great optimization is [PR2100](https://github.com/erlang/otp/pull/2100) which\nmakes the compiler's type optimization pass work across functions within the same module.\nFor instance in the code below:\n\n```\n-record(myrecord, {value}).\n\nh(#myrecord{value=Val}) ->\n    #myrecord{value=Val+1}.\n\ni(A) ->\n    #myrecord{value=V} = h(#myrecord{value=A}),\n    V.\n```\n\nThe new compiler is able to detect the type of the term passed as an argument to\n`h/1` and also the return value of `h/1` so it can eliminate the record checks\ncompletely. Looking at the BEAM code (produced by `erlc -S`) of the `h/1` function we get:\n\nOTP 21:\n```\n    {test,is_tagged_tuple,{f,9},[{x,0},2,{atom,myrecord}]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {gc_bif,'+',{f,0},3,[{x,2},{integer,1}],{x,0}}.\n    {test_heap,3,1}.\n```\n\nOTP 22:\n```\n    {get_tuple_element,{x,0},1,{x,0}}.\n    {gc_bif,'+',{f,0},1,[{x,0},{integer,1}],{x,0}}.\n    {test_heap,3,1}.\n```\n\nThe `is_tagged_tuple` instruction has been completely eliminated and as an added bonus\none `get_tuple_element` was also removed.\n\nHowever, this is only the start and we are already looking into making even\nbetter optimizations for OTP 23, building on top of the SSA rewrite.\n\n# Socket\n\nOTP 22 comes with a new experimental [socket](http://erlang.org/doc/man/socket.html) API.\nThe idea behind this API is to have a stable intermediary API that users can use\nto create features that are not part of the higher-level gen APIs. We will also be using\nthis API to re-implement the higher-level gen APIs in OTP 23.\n\nAnother aspect of the new socket API is that it can be used to greatly reduce the\noverhead that is inherent with using ports. I wrote this\n[microbenchmark](https://gist.github.com/garazdawi/cd8ea31acb3284bfc526ae4b1bcb67af)\ncalled gen\\_tcp2 to see what the difference could be.\n\n```\nErlang/OTP 22 [erts-10.4] [source] [64-bit]\n\nEshell V10.4  (abort with ^G)\n1> gen_tcp2:run().\n              client             server\n gen_tcp:       12.4 ns/byte       12.4 ns/byte\ngen_tcp2:        7.3 ns/byte        7.3 ns/byte\n   ratio:       58.9 %             58.9%\nok\n```\n\nThe results seem promising. The socket implementation of gen\\_tcp uses roughly 40%\nless CPU to send the same amount of packets. Of course, gen\\_tcp does a lot more\nthan gen\\_tcp2 (dealing with lots of buffers, error cases and IPv6 to name a new),\nso it is not by any means a fair comparison. Though if an application can live\nwithout all the guarantees that come with gen_tcp, then using socket could be\nvery good for performance.\n\n# Write concurrency in `ordered_sets`\n\n[PR1952](https://github.com/erlang/otp/pull/1952) contributed by Kjell\nWinblad from Uppsala University makes it possible to do updates in\nparallel on `ets` tables of the type `ordered_set`. This together with\nother improvements by Kjell Winblad and Sverker Eriksson\n([PR1997](https://github.com/erlang/otp/pull/1997) and\n[PR2190](https://github.com/erlang/otp/pull/2190)) has greatly\nincreased the scalability of such ets tables that are the base for\nmany applications, for instance,\n[pg2](http://erlang.org/doc/man/pg2.html) and the default [ssl session\ncache](http://erlang.org/doc/man/ssl_session_cache_api.html).\n\n![Ordered Set Write Concurrency OTP 22 benchmark](../images/ordered_set_write_conc.png)\n\nIn the benchmark above we can see that on an `ordered_set` table the\noperations per seconds possible on a 64 core machine has increased\ndramatically between OTP 21 and OTP 22. You can see a description of\nthe benchmark and the results of many more benchmarks\n[here](/bench/ets_ord_set_21_vs_22/21_vs_22.html).\n\nThe data structure used to enable `write_concurrency` in the\n`ordered_set` is called contention adaptive search tree. In a\nnutshell, the data structure keeps a shadow tree that represents the\nlocks needed to read or write a term in the tree. When conflicts\nbetween multiple writers happen, the shadow tree is updated to have\nmore fine-grained locks for specific branches of the tree. You can\nread more about the details of the algorithm in [A Contention Adapting\nApproach to Concurrent Ordered\nSets](https://www.sciencedirect.com/science/article/pii/S0743731517303052)\n([PDF](http://www.it.uu.se/research/group/languages/software/ca_tree/catree_proofs.pdf)).\n\n# TLS Improvements\n\nIn OTP 21.3 the culmination of many optimizations in the ssl application was released.\nFor certain use-cases, the overhead of a using TLS has been significantly reduced. For\ninstance in this TLS distribution benchmark:\n\n![TLS Dist OTP 22 benchmark](../images/tls_dist_until_opt.png)\n\nThe bytes per second that the Erlang distribution over TLS is able to send has been\nincreased from 17K to about 80K, so more than 4 times as much data as before. The\nthroughput gain above is mostly due to better batching of distribution messages\nwhich makes it so that ssl does not have to add a lot of padding to each message\nsent. So it does not translate over to using ssl directly but is still a very nice\nperformance improvement.\n\nIn OTP 22 the [logging facility for ssl](http://blog.erlang.org/ssl-logging-in-otp-22/)\nhas been greatly improved and there is now basic server support for `TLSv1.3`. In order to\nwork with `TLSv1.3` you need to install an [OpenSSL](https://github.com/openssl/openssl)\nversion that supports `TLSv1.3` (for instance 1.1.1b), compile Erlang/OTP using\nthat OpenSSL version and generate the correct certificates. Then we can start a `TLSv1.3`\nserver like this:\n\n```\nLOpts = [{certfile, \"tls_server_cert.pem\"},\n\t     {keyfile, \"tls_server_key.pem\"},\n\t     {versions, ['tlsv1.3']},\n\t     {log_level, debug}\n\t    ],\n{ok, LSock} = ssl:listen(8443, LOpts),\n{ok, CSock} = ssl:transport_accept(LSock),\n{ok, S} = ssl:handshake(CSock).\n```\n\nAnd use the `OpenSSL` client to connect:\n\n    openssl s_client -debug -connect localhost:8443 \\\n      -CAfile tls_client_cacerts.pem \\\n      -tls1_3 -groups P-256:X25519\n\nThis will produce a huge amount of logs, but somewhere in there we can see this in Erlang:\n\n    <<< TLS 1.3 Handshake, ClientHello\n\nand this in `OpenSSL`:\n\n    New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384\n\nwhich means that we have successfully created a new `TLSv1.3` connection. If you want to\nduplicate what I've done you can follow \n[these instructions](https://gist.github.com/garazdawi/062627973b2887e50e9c9bbc86740b63).\n\nNot all features of `TLSv1.3` have been implemented, you can see which parts of the RFCs\nthat are missing in the `ssl` application's [Standard Complience documentation](http://erlang.org/doc/apps/ssl/standards_compliance.html#tls-1.3).\n\n# Fragmented distribution messages\n\nIn order to deal with the [head of line blocking](https://en.wikipedia.org/wiki/Head-of-line_blocking)\ncaused by sending very large messages over Erlang Distribution, we have added\n[fragmentation of distribution messages](https://github.com/erlang/otp/pull/2133) in OTP 22.\nThis means that large messages will now be split up into smaller fragments\nallowing smaller messages to be sent without being blocked for a long time.\n\nIf we run the code below that does small rpc calls every 100ms millisecond and\nconcurrently sends many 1/2 GB terms.\n\n```\n1> spawn(fun() ->\n           (fun F(Max) ->\n             {T, _} = timer:tc(fun() ->\n                 rpc:call(RemoteNode, erlang, length, [[]])\n               end),\n             NewMax = lists:max([Max, T]),\n             [io:format(\"Max: ~p~n\",[NewMax]) || NewMax > Max],\n             timer:sleep(100),\n             F(NewMax)\n           end)(0)\n         end).\n2> D = lists:duplicate(100000000,100000000),\n   [{kjell, RemoteNode} ! D || _ <- lists:seq(1,100)],\n   ok.\n```\n\nUsing two of our test machines I get a max latency of about 0.4 seconds on OTP 22,\nwhereas on OTP 21 the max latency is around 50 seconds. So with the network at our\ntest site the max latency is decreased by roughly 99%, which is a nice improvement.\n\n# Counter/Atomics and persistent_terms\n\nThree new modules,\n[`counters`](http://erlang.org/doc/man/counters.html),\n[`atomics`](http://erlang.org/doc/man/atomics.html), and\n[`persistent_term`](http://erlang.org/doc/man/persistent_term.html),\nwere added in OTP 21.2.\nThese modules make it possible for the user to access low-level primitives of the\nruntime to make some spectacular performance improvements.\n\nFor instance, the `cover` tool was recently re-written to use `counters` and `persistent_term`.\nPreviously it used a bunch of `ets` tables to keep the counters for when the code was executed,\nbut now it uses `counters` and the overhead of running `cover` has decreased by up to 80%.\n\n`persistent_term` is adding run-time support for\n[mochiglobal](https://github.com/mochi/mochiweb/blob/master/src/mochiglobal.erl)\nand [similar](https://github.com/discordapp/fastglobal) tools. It makes it possible to\nvery efficiently access data globally but at the cost of making updates very expensive.\nIn Erlang/OTP we so far use it to optimize [logger backends](https://github.com/erlang/otp/blob/9c8075413728e3be373d7dff2a7168b3983e0be3/lib/kernel/src/logger_proxy.erl#L45)\nbut the use cases are numerous.\n\nA fun (and possibly useful) use case for `atomics` is to create a\n[shared mutable bit-vector](https://gist.github.com/garazdawi/48f1284c0d533ab5a39eeac6f8ff99a0).\nSo, now we can spawn 100 processes and play flip that bit with each other:\n\n```\nBV = bit_vector:new(80),\n[spawn(fun F() ->\n            bit_vector:flip(BV, rand:uniform(80)-1),\n            F()\n          end) || _ <- lists:seq(1,100)],\ntimer:sleep(1000),\nbit_vector:print(BV).\n```\n\n# Documentation Changes\n\nIn OTP 21.3, the version when all functions and modules were\n[introduced](https://github.com/erlang/otp/pull/2044) was added to the documentation.\n\n![Documentation Version OTP 21.3](../images/otp_22_docs.png)\n\nSverker used some git magic to figure out when functions and modules were added\nand automatically updated all the reference manuals. So now it should be a lot easier\nto see when some functionality was introduced. Knowing when an option to functions was\nadded is still problematic, but we are trying to be better there as well.\n\nIn OTP 22 a new documentation top section called `Internal Documentation` has been added to\nthe [erts](http://erlang.org/doc/apps/erts/internal_docs.html) and\n[compiler](http://erlang.org/doc/apps/compiler/internal_docs.html) applications.\nThe sections contain the internal documentation that previously only has been\navailable on github so that it easier to access.\n\n# More Memory optimizations\n\nEach major OTP release wouldn't be complete without a set of memory allocator improvements\nand OTP 22 is no exception. The ones with the most potential to impact your\napplications are [PR2046](https://github.com/erlang/otp/pull/2046) and\n[PR1854](https://github.com/erlang/otp/pull/1854). Both of these optimizations\nshould allow systems to better utilize memory carriers in high memory\nsituations allowing your systems to handle more load.\n"}},"__N_SSG":true}