<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 05-Aug-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 20: <a href="eep-0020.md" title="EEP Source"> Split the atoms!</a></h2>

<h1>Abstract</h1>

<p>An idea from the Logix implementation of Flat Concurrent Prolog
can be adapted to Erlang:  invisibly to users there can be two
implementations of 'atoms', fixing a major system integrity
issue and removing the need to warp one's data structure design
to code around it.</p>

<h1>Specification</h1>

<p>There are no user-visible changes to the Erlang language or
libraries.  Interfaces between Erlang and other languages such
as C may need to be changed.</p>

<p>We split atoms into two classes:  "global" atoms are those atoms
which either appear in the post-preprocessing text of some loaded
module or are the registered name of any process; "local" atoms
are all others which a process creates.</p>

<p>A local atom is represented by a data structure SUCH AS</p>

<pre><code>+----------+
| size+tag |    boxed object header; see below
+----------+
| hashcode |    a 32-bit hash code
+----------+
| equivrep |    points to Union/Find representative
+----------+
| bytes of |
| name ... |
+----------+
</code></pre>

<p>As usual, the size+tag contains a 2 bit tag to say it is an
IMMED2 object, a 4-bit subtag to say what kind (I propose
1011), and a 26-bit arity.  However, the arity field is
split into two subfields:</p>

<pre><code>+--------------+------------+----+--+
|  byte count  | char count |LATM|BX|
+--------------+------------+----+--+
             14           12    4   2   size in bits
</code></pre>

<p>The char count says how many Unicode characters there are in
the name.  The byte count says how many bytes those characters
are stored in.  For compactness and backwards compatibility,
an atom whose name consists only of Latin-1 characters has
byte count = char count and name represented as Latin-1; atoms
with names outside that range are held in some other form
<em>such as</em> UTF-8, SCSU, BOCU, or what have you.  This proposal
is not specifically about encoding schemes; all I have to say
here is that it should be the same for all atoms and it should
be at least as good as UTF-8.</p>

<p>The hash code field is a 32-bit hash code.  Again, I have
nothing to say about atom hashes as such except to say that
the method should be the same for all atoms in all processes
on a node and that it should be a good one.  Advice about
good hashing functions is hard to find.  <code>hashpjw()</code> can be
improved on.  I heartily recommend <a href="http://www.lulu.com/content/1455536" title="Hashing in Smalltalk: Theory and Practice, AndrÃ©s Valloud">Valloud's book</a>.</p>

<p>The equivrep field is a pointer.  It always points to an atom,
which may be a global atom or a local atom.  Initially, it points
to the local atom itself.  When a local atom is compared with
another local atom,</p>

<ul>
<li>first,   check the header fields to see if they match</li>
<li>second,  check the hash codes to see if they match</li>
<li>finally, check the bytes of the names.</li>
</ul>

<p>But this is also combined with Union/Find, very much like
binding variables in Prolog.  So we "dereference" (chase the
equivrep fields) after the second step, and if we end up at
the same place, the two local atoms are equal.  And if two
physically distinct local atoms do turn out equal, we make
the younger one (the one most recently created) point to the
older one.</p>

<p>Global atoms should have a similar representation; I suggest that
the representation of a local atom should be embedded in the
representation of a global atom, so that local atoms can be
compared with global atoms as if they were both local.</p>

<p>Atoms returned by <code>list_to_existing_atom/1</code> are always global atoms.
Atoms returned by <code>list_to_atom/1</code> or <code>binary_to_term/1</code> are global
atoms if and only if they are already existing global atoms,
otherwise they are local atoms.</p>

<p>Interfaces provided to other languages, such as C or Java, should
leave existing atom-creation operations returning global atoms,
and should add operations for creating local atoms.</p>

<p>When a process is garbage collected, a pointer to a local atom is
replaced by that local atom's equivrep, so that processes that
have ever noticed they have duplicate local atoms don't keep them
forever.</p>

<h1>Motivation</h1>

<p>There are a number of problems that limit the usefulness
of Erlang atoms.</p>

<p>The first is that atom size is limited to 255 bytes,
which makes Erlang atoms of very little use for file names,
as C's <code>FILENAME_MAX</code> is typically 1024 these days.</p>

<p>The second is that atoms are limited to Latin-1 characters.
We really do want full Unicode support for them, not so
much for programmers to write atoms in strange scripts in
their source code as to allow information to flow <em>through</em>
an Erlang system as atoms.</p>

<p>Those two are minor problems.</p>

<p>The major problem is the atom table.</p>

<p>It is a global resource, which means that on an SMP system
there has to be a lot of locking and unlocking.  This proposal
doesn't include a new "always return a local atom" operation,
but it creates the possibilities for new operations like that
which require no locking.</p>

<p>The atom table is limited, in atom.c, to <code>ATOM_LIMIT=1024*1024</code>
entries.  Even on a 32-bit system, this is smaller than a
machine could support; it is an arbitrary limit, and such limits
are always a problem.</p>

<p>The atom table is not garbage collected.  Once an atom has been
created, it says created.  Historic Prolog systems, like Quintus
Prolog, did the same thing.  Back in 1984 this was recognised as
a problem, especially for programs that wanted to access large
volumes of stored data.  Modern Prolog systems, like SWI Prolog,
do collect atoms; SWI Prolog would not be nearly so useful for
manipulating large collections of RDF data if it were otherwise.
This proposal does not add garbage collection for the atom table;
what it does is to stop most of the atoms that would have been
collected ever entering that table in the first place.</p>

<p>Filling up the atom table crashes or hangs the entire node.</p>

<p>This means that it is far too easy to crash or hash Erlang
software by feeding it too many atoms.</p>

<p>And <em>that</em> means that Erlang programmers who would like to use
atoms in data structures (as keys in dictionaries, say) use
binaries instead: binaries are not limited in size or number,
can hold UTF-8 if you want them to, are garbage collected, and
are generally safer to use.</p>

<p>While this proposal makes atoms more <em>convenient</em> to use (they
may be longer, more numerous, and may contain Unicode), the
real point is to make atoms <em>safer</em> to use.  If you can
stream data from source through an Erlang process, mapping
external "strings" to binaries, you will be able to do the
same thing just as safely mapping them to atoms.</p>

<h1>Rationale</h1>

<p>Erlang is not the first language to face these problems.
It isn't even the first concurrent language to face them.
Flat Concurrent Prolog was there first, and while I have
not seen the Logix source code, the idea was explained in
Logix documentation many years ago.  I know this <em>can</em>
work because it <em>did</em> work.</p>

<p>Logix used this approach for all atoms; eventually, I
believe Erlang will need to as well in order to handle
thousands of processors without lots of locks.  Right now,
it makes sense to keep on using the old representation for
fairly "static" atoms.  In particular, we would like module
and function names (and frame keys when we have them) to be
just the way they are now.  If an application is loaded after a
local atom has been created, we may find that it is a module
name or function name after all; this is one of the reasons
for the equivrep field.  Once it's noticed, the duplication
won't survive another garbage collection.</p>

<p>The current 'global atom' representation has a hack to make
term comparison faster.  For simplicity I have not described
it above, because that's orthogonal to the issues this EEP is
concerned with.  I note (a) that for the ord0 field to
continue in its present form, the encoding would best be
UTF-8 or BOCU, and (b) to keep the compactness of the Latin-1
atoms, the ord0 field should be the first 31 bits that <em>would</em>
have been stored had the atom been stored in whichever of
UTF-8 or BOCU is chosen.  I also note (c) that if you don't
allow "native" byte ordering to dictate the order in which the
bytes of an atom's name are stored, you don't <em>need</em> a special
ord0 field.</p>

<p>I should confess that this proposal doesn't <em>entirely</em> avoid the
crashes and hangs problem.  If an Erlang system can be persuaded
to load modules from an untrustworthy source, it can still be
made to try to create enough atoms to get into trouble.  This is
one of the reasons that I think Erlang will eventually have to
abandon the global atom table.  However, anyone who loads modules</p>

<p>from untrustworthy sources should KNOW they are doing that; it is
an obviously dangerous thing to do.  <code>list_to_atom/1</code> is NOT an
obviously dangerous function, and it should not be any more
dangerous than <code>list_to_binary/1</code>.</p>

<h1>Backwards Compatibility</h1>

<p>No existing code (outside the Erlang implementation)
should be affected in the slightest.</p>

<h1>Reference Implementation</h1>

<p>None.  The change is simple in concept, but affects several
atoms in the core of the system.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0020","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 05-Aug-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 20: \u003ca href=\"eep-0020.md\" title=\"EEP Source\"\u003e Split the atoms!\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eAn idea from the Logix implementation of Flat Concurrent Prolog\ncan be adapted to Erlang:  invisibly to users there can be two\nimplementations of 'atoms', fixing a major system integrity\nissue and removing the need to warp one's data structure design\nto code around it.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eThere are no user-visible changes to the Erlang language or\nlibraries.  Interfaces between Erlang and other languages such\nas C may need to be changed.\u003c/p\u003e\n\n\u003cp\u003eWe split atoms into two classes:  \"global\" atoms are those atoms\nwhich either appear in the post-preprocessing text of some loaded\nmodule or are the registered name of any process; \"local\" atoms\nare all others which a process creates.\u003c/p\u003e\n\n\u003cp\u003eA local atom is represented by a data structure SUCH AS\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e+----------+\n| size+tag |    boxed object header; see below\n+----------+\n| hashcode |    a 32-bit hash code\n+----------+\n| equivrep |    points to Union/Find representative\n+----------+\n| bytes of |\n| name ... |\n+----------+\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs usual, the size+tag contains a 2 bit tag to say it is an\nIMMED2 object, a 4-bit subtag to say what kind (I propose\n1011), and a 26-bit arity.  However, the arity field is\nsplit into two subfields:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e+--------------+------------+----+--+\n|  byte count  | char count |LATM|BX|\n+--------------+------------+----+--+\n             14           12    4   2   size in bits\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe char count says how many Unicode characters there are in\nthe name.  The byte count says how many bytes those characters\nare stored in.  For compactness and backwards compatibility,\nan atom whose name consists only of Latin-1 characters has\nbyte count = char count and name represented as Latin-1; atoms\nwith names outside that range are held in some other form\n\u003cem\u003esuch as\u003c/em\u003e UTF-8, SCSU, BOCU, or what have you.  This proposal\nis not specifically about encoding schemes; all I have to say\nhere is that it should be the same for all atoms and it should\nbe at least as good as UTF-8.\u003c/p\u003e\n\n\u003cp\u003eThe hash code field is a 32-bit hash code.  Again, I have\nnothing to say about atom hashes as such except to say that\nthe method should be the same for all atoms in all processes\non a node and that it should be a good one.  Advice about\ngood hashing functions is hard to find.  \u003ccode\u003ehashpjw()\u003c/code\u003e can be\nimproved on.  I heartily recommend \u003ca href=\"http://www.lulu.com/content/1455536\" title=\"Hashing in Smalltalk: Theory and Practice, AndrÃ©s Valloud\"\u003eValloud's book\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe equivrep field is a pointer.  It always points to an atom,\nwhich may be a global atom or a local atom.  Initially, it points\nto the local atom itself.  When a local atom is compared with\nanother local atom,\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003efirst,   check the header fields to see if they match\u003c/li\u003e\n\u003cli\u003esecond,  check the hash codes to see if they match\u003c/li\u003e\n\u003cli\u003efinally, check the bytes of the names.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBut this is also combined with Union/Find, very much like\nbinding variables in Prolog.  So we \"dereference\" (chase the\nequivrep fields) after the second step, and if we end up at\nthe same place, the two local atoms are equal.  And if two\nphysically distinct local atoms do turn out equal, we make\nthe younger one (the one most recently created) point to the\nolder one.\u003c/p\u003e\n\n\u003cp\u003eGlobal atoms should have a similar representation; I suggest that\nthe representation of a local atom should be embedded in the\nrepresentation of a global atom, so that local atoms can be\ncompared with global atoms as if they were both local.\u003c/p\u003e\n\n\u003cp\u003eAtoms returned by \u003ccode\u003elist_to_existing_atom/1\u003c/code\u003e are always global atoms.\nAtoms returned by \u003ccode\u003elist_to_atom/1\u003c/code\u003e or \u003ccode\u003ebinary_to_term/1\u003c/code\u003e are global\natoms if and only if they are already existing global atoms,\notherwise they are local atoms.\u003c/p\u003e\n\n\u003cp\u003eInterfaces provided to other languages, such as C or Java, should\nleave existing atom-creation operations returning global atoms,\nand should add operations for creating local atoms.\u003c/p\u003e\n\n\u003cp\u003eWhen a process is garbage collected, a pointer to a local atom is\nreplaced by that local atom's equivrep, so that processes that\nhave ever noticed they have duplicate local atoms don't keep them\nforever.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThere are a number of problems that limit the usefulness\nof Erlang atoms.\u003c/p\u003e\n\n\u003cp\u003eThe first is that atom size is limited to 255 bytes,\nwhich makes Erlang atoms of very little use for file names,\nas C's \u003ccode\u003eFILENAME_MAX\u003c/code\u003e is typically 1024 these days.\u003c/p\u003e\n\n\u003cp\u003eThe second is that atoms are limited to Latin-1 characters.\nWe really do want full Unicode support for them, not so\nmuch for programmers to write atoms in strange scripts in\ntheir source code as to allow information to flow \u003cem\u003ethrough\u003c/em\u003e\nan Erlang system as atoms.\u003c/p\u003e\n\n\u003cp\u003eThose two are minor problems.\u003c/p\u003e\n\n\u003cp\u003eThe major problem is the atom table.\u003c/p\u003e\n\n\u003cp\u003eIt is a global resource, which means that on an SMP system\nthere has to be a lot of locking and unlocking.  This proposal\ndoesn't include a new \"always return a local atom\" operation,\nbut it creates the possibilities for new operations like that\nwhich require no locking.\u003c/p\u003e\n\n\u003cp\u003eThe atom table is limited, in atom.c, to \u003ccode\u003eATOM_LIMIT=1024*1024\u003c/code\u003e\nentries.  Even on a 32-bit system, this is smaller than a\nmachine could support; it is an arbitrary limit, and such limits\nare always a problem.\u003c/p\u003e\n\n\u003cp\u003eThe atom table is not garbage collected.  Once an atom has been\ncreated, it says created.  Historic Prolog systems, like Quintus\nProlog, did the same thing.  Back in 1984 this was recognised as\na problem, especially for programs that wanted to access large\nvolumes of stored data.  Modern Prolog systems, like SWI Prolog,\ndo collect atoms; SWI Prolog would not be nearly so useful for\nmanipulating large collections of RDF data if it were otherwise.\nThis proposal does not add garbage collection for the atom table;\nwhat it does is to stop most of the atoms that would have been\ncollected ever entering that table in the first place.\u003c/p\u003e\n\n\u003cp\u003eFilling up the atom table crashes or hangs the entire node.\u003c/p\u003e\n\n\u003cp\u003eThis means that it is far too easy to crash or hash Erlang\nsoftware by feeding it too many atoms.\u003c/p\u003e\n\n\u003cp\u003eAnd \u003cem\u003ethat\u003c/em\u003e means that Erlang programmers who would like to use\natoms in data structures (as keys in dictionaries, say) use\nbinaries instead: binaries are not limited in size or number,\ncan hold UTF-8 if you want them to, are garbage collected, and\nare generally safer to use.\u003c/p\u003e\n\n\u003cp\u003eWhile this proposal makes atoms more \u003cem\u003econvenient\u003c/em\u003e to use (they\nmay be longer, more numerous, and may contain Unicode), the\nreal point is to make atoms \u003cem\u003esafer\u003c/em\u003e to use.  If you can\nstream data from source through an Erlang process, mapping\nexternal \"strings\" to binaries, you will be able to do the\nsame thing just as safely mapping them to atoms.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eErlang is not the first language to face these problems.\nIt isn't even the first concurrent language to face them.\nFlat Concurrent Prolog was there first, and while I have\nnot seen the Logix source code, the idea was explained in\nLogix documentation many years ago.  I know this \u003cem\u003ecan\u003c/em\u003e\nwork because it \u003cem\u003edid\u003c/em\u003e work.\u003c/p\u003e\n\n\u003cp\u003eLogix used this approach for all atoms; eventually, I\nbelieve Erlang will need to as well in order to handle\nthousands of processors without lots of locks.  Right now,\nit makes sense to keep on using the old representation for\nfairly \"static\" atoms.  In particular, we would like module\nand function names (and frame keys when we have them) to be\njust the way they are now.  If an application is loaded after a\nlocal atom has been created, we may find that it is a module\nname or function name after all; this is one of the reasons\nfor the equivrep field.  Once it's noticed, the duplication\nwon't survive another garbage collection.\u003c/p\u003e\n\n\u003cp\u003eThe current 'global atom' representation has a hack to make\nterm comparison faster.  For simplicity I have not described\nit above, because that's orthogonal to the issues this EEP is\nconcerned with.  I note (a) that for the ord0 field to\ncontinue in its present form, the encoding would best be\nUTF-8 or BOCU, and (b) to keep the compactness of the Latin-1\natoms, the ord0 field should be the first 31 bits that \u003cem\u003ewould\u003c/em\u003e\nhave been stored had the atom been stored in whichever of\nUTF-8 or BOCU is chosen.  I also note (c) that if you don't\nallow \"native\" byte ordering to dictate the order in which the\nbytes of an atom's name are stored, you don't \u003cem\u003eneed\u003c/em\u003e a special\nord0 field.\u003c/p\u003e\n\n\u003cp\u003eI should confess that this proposal doesn't \u003cem\u003eentirely\u003c/em\u003e avoid the\ncrashes and hangs problem.  If an Erlang system can be persuaded\nto load modules from an untrustworthy source, it can still be\nmade to try to create enough atoms to get into trouble.  This is\none of the reasons that I think Erlang will eventually have to\nabandon the global atom table.  However, anyone who loads modules\u003c/p\u003e\n\n\u003cp\u003efrom untrustworthy sources should KNOW they are doing that; it is\nan obviously dangerous thing to do.  \u003ccode\u003elist_to_atom/1\u003c/code\u003e is NOT an\nobviously dangerous function, and it should not be any more\ndangerous than \u003ccode\u003elist_to_binary/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eNo existing code (outside the Erlang implementation)\nshould be affected in the slightest.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone.  The change is simple in concept, but affects several\natoms in the core of the system.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0020"},"buildId":"BGhkIUi1bNl03TKudis6o","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/BGhkIUi1bNl03TKudis6o/_buildManifest.js" async=""></script><script src="/_next/static/BGhkIUi1bNl03TKudis6o/_ssgManifest.js" async=""></script></body></html>