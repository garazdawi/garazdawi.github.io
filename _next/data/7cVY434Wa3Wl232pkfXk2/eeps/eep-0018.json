{"pageProps":{"index":{"id":"0018","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 28-Jul-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 18: <a href=\"eep-0018.md\" title=\"EEP Source\"> JSON bifs</a></h2>\n\n<h1>Abstract</h1>\n\n<p>According to the <a href=\"http://www.json.org/\" title=\"The JSON web site\">JSON web site</a>,\n\"JSON (JavaScript Object Notation) is a lightweight\ndata-interchange format. It is easy for humans to read and write.\nIt is easy for machines to parse and generate.\"</p>\n\n<p>JSON is specified by <a href=\"http://www.ietf.org/rfc/rfc4627.txt\" title=\"The JSON RFC\">RFC 4627</a>, which defines a Media Type\napplication/json.</p>\n\n<p>There are JSON libraries for a wide range of languages, so it is a\nuseful format.  <a href=\"http://incubator.apache.org/couchdb/\" title=\"CouchDB\">CouchDB</a> <a href=\"http://wiki.apache.org/couchdb/\" title=\"CouchDB\">uses</a> JSON as its storage format and in\nits RESTful interface; it offers an alternative to Mnesia for some\nprojects, and is accessible from many more languages.  There are\nalready JSON bindings for Erlang, such as the <a href=\"www.lshift.net/blog/2007/02/17/json-and-json-rpc-for-erlang\" title=\"rfc4627 module for Erlang from LShift\">rfc4627</a> module\nfrom LShift, but on the 24th of July 2008, Joe Armstrong suggested\nthat it would be worth having built in functions to convert Erlang\nterms to and from the JSON format.</p>\n\n<pre><code>term_to_json        -- convert a term to JSON form\njson_to_term        -- convert a JSON form to Erlang\n</code></pre>\n\n<h1>Specification</h1>\n\n<p>Three new types are added to the vocabulary of well known\ntypes to be used in edoc.</p>\n\n<pre><code>@type json_label() = atom() + binary().\n@type json(L, N) = null + false + true\n                 + N                % some kind of number\n                 + [{}]             % empty \"object\"\n                 + [{L, json(L,N)}] % non-empty \"object\"\n                 + [json(L, N)].    % \"array\"\n                 | [json(L, N)] | tuple({L, json(L, N)}).\n@type json() = json(json_label(), number()).\n</code></pre>\n\n<h3>New functions</h3>\n\n<p>Four new functions are added to the erlang: module.</p>\n\n<pre><code>erlang:json_to_term(IO_Data) -&gt; json()\nerlang:json_to_term(IO_Data, Option_List) -&gt; json()\n</code></pre>\n\n<p>Types:</p>\n\n<pre><code>IO_Data = iodata()\nOption_List = [Option]\nOption = {encoding,atom()}\n       | {float,bool()}\n       | {label,binary|existing_atom|atom}\n</code></pre>\n\n<p><code>json_to_term(X)</code> is equivalent to <code>json_to_term(X, [])</code>.</p>\n\n<p>The <code>IO_Data</code> implies a sequence of bytes.</p>\n\n<p>The encoding option says what character encoding to use for\nconverting those bytes to characters.  The default encoding\nis UTF-8.  All encodings supported elsewhere in Erlang should\nbe supported here.  The JSON specification mentions\nauto-detection of the encoding as a possibility; the ones\nthat can be detected include UTF-32-BE, UTF-32-LE,\nUTF-16-BE, UTF-16-LE, UTF-8, and UTF-EBDIC.  The encoding\n'auto' requests auto-detection.</p>\n\n<p>The <code>{float,true}</code> option says to convert all JSON numbers to\nErlang floats, even if they look like integers.\nWith this option, the result has type <code>json(L, float())</code>.</p>\n\n<p>The <code>{float,false}</code> option says to convert integers to integers;\nit is the default. With this option, the result has type\n<code>json(L, number())</code>.</p>\n\n<p>The <code>{label,binary}</code> option says to convert all JSON strings\nto Erlang binaries, even if they are keys in key:value pairs.\nWith this option, the result has type <code>json(binary(), N)</code>.\nThis is the default.</p>\n\n<p>The <code>{label,atom}</code> option says to convert keys to atoms if\npossible, leaving other strings as binaries.\nWith this option, the result has type <code>json(json_label(), N)</code>.</p>\n\n<p>The <code>{label,existing_atom}</code> option says to convert keys to\natoms if the atoms already exist, leaving other keys as\nbinaries.  All other strings remain binaries too.\nWith this option, the result has type <code>json(json_label(), N)</code>.</p>\n\n<p>Other options may be added in the future.</p>\n\n<p>The mapping from JSON to Erlang is described below in this\nsection.  An argument that is not a well formed IO_Data,\nor that cannot be decoded, or that when decoded does not\nfollow the rules of JSON syntax, results in a badarg\nexception.  [It would be nice if there were Erlang-wide\nconventions for distinguishing these cases.]</p>\n\n<pre><code>erlang:term_to_json(JSON) -&gt; binary()\nerlang:term_to_json(JSON, Option_List) -&gt; Binary()\n</code></pre>\n\n<p>Types:</p>\n\n<pre><code>JSON = json()\nOption_List = [Option]\nOption = {encoding,atom()}\n       | {space,int()}\n       | space\n       | {indent,int()}\n       | indent\n</code></pre>\n\n<p>This is a function for producing portable JSON.\nIt is not intended as a means for encoding arbitrary Erlang\nterms.  Terms that do not fit into the mapping scheme\ndescribed below in this section result in a badarg exception.\nThe JSON RFC says that \"The names within an object SHOULD be\nunique.\"  JSON terms that violate this should also result in\na badarg exception.</p>\n\n<p><code>term_to_json(X)</code> is equivalent to <code>term_to_json(X, [])</code>.</p>\n\n<p>Converting Erlang terms to JSON results in a (logical)\ncharacter sequence, which is encoded as a sequence of\nbytes, which is returned as a binary.  The default encoding\nis UTF-8; this may be overridden by the encoding option.\nAny encoding supported elsewhere in Erlang should be\nsupported here.</p>\n\n<p>There are two options for controlling white space.\nBy default, none is generated.</p>\n\n<p><code>{space,N}</code>, where N is a non-negative integer, says to\nadd N spaces after each colon and comma.\n'space' is equivalent to <code>{space,1}</code>.\nNo other space is ever inserted.</p>\n\n<p><code>{indent,N}</code>, where N is a non-negative integer, says\nto add a line break and some indentation after each\ncomma.  The indentation is N spaces for each enclosing\n[] or {}.  Note that this still does not result in any\nother spaces being added; in particular ] and } will\nnot appear at the beginning of lines.\n'indent' is equivalent to <code>{indent,1}</code>.</p>\n\n<p>Other options may be added in the future.</p>\n\n<h3>Converting JSON to Erlang</h3>\n\n<p>The keywords 'null', 'false', and 'true' are converted to the\ncorresponding Erlang atoms. No other complete JSON forms\nare converted to atoms.</p>\n\n<p>A number is converted to an Erlang float if</p>\n\n<ul>\n<li>it contains a decimal point, or</li>\n<li>it contains an exponent, or</li>\n<li>it is a negative zero, or</li>\n<li>the option {float,true} was passed.</li>\n</ul>\n\n<p>A JSON number that looks like an integer other than -0\nwill be converted to an Erlang integer unless <code>{float,true}</code>\nwas provided.</p>\n\n<p>When occurring as a label in an \"object\", a string may on\nexplicit request be converted to an Erlang atom, if possible.\nOtherwise, a string is converted to a UTF-8-encoded binary,\nwhatever the encoding used by the data source.\nAn empty string is converted to an empty binary.</p>\n\n<p>A sequence is converted to an Erlang list.  The elements have\nthe same order in the list as in the original sequence.</p>\n\n<p>A non-empty \"object\" is converted to a list of {Key,Value}\npairs suitable for processing with the 'proplists' module.\nNote that proplists: does not require that keys be atoms.\nAn \"object\" with no key:value pairs is converted to\nthe list <code>[{}]</code>, preserving the invariant that an object\nis always represented by a non-empty list of tuples.\nThe proplists: module will correctly view <code>[{}]</code> as holding\nno keys.</p>\n\n<p>Keys in the JSON form are always strings.  A Key is converted\nto an Erlang atom if and only if</p>\n\n<ul>\n<li><code>{label,atom}</code> was specified or\n<code>{label,existing_atom}</code> was specified and a suitable atom\nalready existed; and</li>\n<li>every character in the JSON string can be held in an atom.</li>\n</ul>\n\n<p>Currently, only names made of Latin-1 characters can be turned\ninto atoms.  Empty keys, \"\", are converted to empty atoms ''.\nKeys are otherwise converted to binaries, using the UTF-8\nencoding, whatever the original encoding was.</p>\n\n<p>This means that if you read and convert a JSON term now,\nand save the binary somewhere, then read and convert it in\na later fully-Unicode Erlang, you will find the\nrepresentations different.  However, the order of the pairs\nin a JSON \"object\" has no significance, and an implementation\nof this specification is free to report them in any order it\nlikes (as given, reversed, sorted, sorted by some hash, you\nname it).  Within any particular Erlang version, this\nconversion is a pure function, but different Erlang releases\nmay change the order of pairs, so you cannot expect exactly\nthe same term from release to release anyway.</p>\n\n<p>See the rationale for reasons why we do not convert to\na canonical form, for example by sorting.</p>\n\n<p>In the spirit of \"be generous in what you accept, strict in\nwhat you produce\", it might be a good idea to accept unquoted\nlabels in the input.  You can't accept just any old junk,\nbut allowing <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf\" title=\"ECMA standard 262, ECMAScript\">Javascript</a> IdentifierNames would make sense.</p>\n\n<pre><code>IdentifierName  = IdentifierStart IdentifierPart*.\nIdentifierStart = UnicodeLetter | '$' | '_' |\n                  '\\u' HexDigit*4\nIdentifierPart  = IdentifierStart | UnicodeCombiningMark |\n                  UnicodeDigit | UnicodeConnectorPunctuation\n</code></pre>\n\n<p>There are apparently JSON generators out there that do this,\nso it would add value, but it is not <em>required</em>.</p>\n\n<h3>Converting Erlang to JSON</h3>\n\n<p>The atoms 'null', 'false', and 'true' are converted to the\ncorresponding JSON keywords.  No other Erlang atoms are\nallowed.</p>\n\n<p>An Erlang integer is converted to a JSON integer.\nAn Erlang float is converted to a JSON float, as precisely\nas practical.  An Erlang float which has an integral value\nis written in such a way that it will read back as a float;\nsuitable methods include suffixing \".0\" or \"e0\".</p>\n\n<p>An Erlang binary that is the UTF-8 representation of some\nUnicode string is converted to a string.  No other binaries\nare allowed.</p>\n\n<p>An Erlang list all of whose elements are tuples is converted\nto a JSON \"object\".  If the list is <code>[{}]</code> it is converted to\n\"{}\", otherwise all the tuples must have two elements and\nthe first must be an atom or binary; other tuples are not\nallowed.  For each <code>{Key,Value}</code> pair, the key must be an atom\nor a binary that is the  UTF-8 representation of some Unicode\nstring; the key is converted to a JSON string.  The value must\nbe a JSON term.  The order of the key:value pairs in the\noutput is the same as the order of the <code>{Key,Value}</code> pairs \nin the list.  A list with two equivalent keys is not allowed.\nTwo binaries, or two atoms, are equivalent iff they are equal.\nAn atom and a binary are equivalent if they would convert to\nthe same JSON string.</p>\n\n<p>Erlang tuples are not allowed except as elements of lists\nthat will be converted to JSON \"objects\".\nNo other tuples are allowed.</p>\n\n<p>An Erlang proper list whose elements are not tuples is\nconverted to a JSON sequence by converting its elements in\nnatural order.</p>\n\n<p>An improper list is not allowed.</p>\n\n<p>Other Erlang terms are not allowed.  If you want to \"tunnel\"\nother Erlang terms through JSON, fine, but it is entirely up\nto you to do whatever conversion you want.</p>\n\n<h1>Motivation</h1>\n\n<p>As Joe Armstrong put it in his message,\n\"JSON seems to be ubiquitous\".\nIt should not only be supported, it should be supported\nsimply, efficiently, and reliably.</p>\n\n<p>As noted above, http://www.ietf.org/rfc/rfc4627.txt\ndefines an application/json Media Type that Erlang\nshould be able to handle \"out of the box\".</p>\n\n<h1>Rationale</h1>\n\n<p>The very first question is whether the interface should be a\n\"value\" interface (where a chunk of data is converted to an\nErlang term in one go) or an \"event stream\" interface, like\nthe classical ESIS interface offered by SGML parsers, for\nsome arcane reason known as SAX these days.</p>\n\n<p>There is room in the world for both kinds of interface.\nThis one is a \"value\" interface, which is best suited to\nmodest quantities of JSON data, less than a few megabytes say,\nwhere the latency of waiting for the whole form before\nprocessing any of it is not a problem.  Someone else might\nwant to write an \"event stream\" EEP.</p>\n\n<p>Related to this issue, a JSON text must be an array or an object,\nnot, for example, a bare number.  Or so says the JSON RFC.  I do\nnot know whether all JSON libraries enforce this.  Since a JSON\ntext must be [something] or {something}, JSON texts are self-\ndelimiting, and it makes sense to consume them one at a time from\na stream.  Should that be part of this interface?  Maybe, maybe\nnot.  I note that you can separate parsing</p>\n\n<ul>\n<li>skip leading white space</li>\n<li>check for '[' or '{'</li>\n<li>keep on accumulating characters until you find a\nmatching ']' or '}', ignoring characters inside \"\".</li>\n</ul>\n\n<p>from conversion.  So I have separated them.  This proposal only\naddresses conversion.  An extension should address parsing.  It\nmight work better to have that as part of an event stream EEP.</p>\n\n<p>Let's consider conversion then.  Round trip conversion fidelity\n(X -> Y -> X should be an identity function) is always nice.  Can\nwe have it?</p>\n\n<p>JSON has</p>\n\n<ul>\n<li>null</li>\n<li>false</li>\n<li>true</li>\n<li>number (integers, floats, and ratios are not distinguished)</li>\n<li>string</li>\n<li>sequence (called array)</li>\n<li>record (called object)</li>\n</ul>\n\n<p>Erlang has</p>\n\n<ul>\n<li>atom</li>\n<li>number (integers and floats are distinguished)</li>\n<li>binary</li>\n<li>list</li>\n<li>tuple</li>\n<li>pid</li>\n<li>port</li>\n<li>reference</li>\n<li>fun</li>\n</ul>\n\n<p>More precisely, JSON syntax DOES make integers distinguishable\nfrom floats; it is Javascript (when JSON is used with Javascript)\nthat fails to distinguish them.  Since we would like to use JSON\nto exchange data between Erlang, Common Lisp, Scheme, Smalltalk,\nand above all Python, all of which have such a distinction, it is\nfortunate that JSON syntax and the RFC allow the distinction.</p>\n\n<p>Clearly, Erlang->JSON->Erlang is going to be tricky.  To take\njust one minor point, neither www.json.org nor RFC 4627 makes\nan promises whatever about the range of numbers that can be\npassed through JSON.  There isn't even any minimum range.  It\nseems as though a JSON implementation could reject all numbers\nother than 0 as too large and still conform!  This is stupid.\nWe can PROBABLY rely on IEEE doubles; we almost certainly cannot\nexpect to get large integers through JSON.</p>\n\n<p>Converting pids, ports, and references to textual form using\n<code>pid_to_list/1</code>, <code>erlang:port_to_list/1</code>, and <code>erlang:ref_to_list/1</code>\nis possible.  A built in function can certainly convert back\nfrom textual form if we want it to.  The problem is telling these\nstrings from other strings:  when is \"&lt;0.43.0>\" a pid and when is\nit a string?  As for funs, let's not go there.</p>\n\n<p>Basically, converting Erlang terms to JSON so that they can be\nreconstructed as the same (or very similar) Erlang terms would\ninvolve something like this:</p>\n\n<pre><code>atom   -&gt; string\nnumber -&gt; number\nbinary -&gt; {\"type\":\"binary\", \"data\":[&lt;bytes&gt;]}\nlist   -&gt; &lt;list&gt;, if it's a proper list\nlist   -&gt; {\"type\":\"dotted\", \"data\":&lt;list&gt;, \"end\":&lt;last cdr&gt;}\ntuple  -&gt; {\"type\":\"tuple\",  \"data\":&lt;tuple as list&gt;}\npid    -&gt; {\"type\":\"pid\",    \"data\":&lt;pid as string&gt;}\nport   -&gt; {\"type\":\"port\",   \"data\":&lt;port as string&gt;}\nref    -&gt; {\"type\":\"ref\",    \"data\":&lt;ref as string&gt;}\nfun    -&gt; {\"module\":&lt;m&gt;, \"name\":&lt;n&gt;, \"arity\":&lt;a&gt;}\nfun    -&gt; we're pushing things a bit for anything else.\n</code></pre>\n\n<p>This is not part of the specification because I am not proposing\nJSON as a representation for arbitrary Erlang data.  I am making\nthe point that we COULD represent (most) Erlang data in JSON if\nwe really wanted to, but it is not an easy or natural fit.  For\nthat we have Erlang binary format and we have UBF.  To repeat,\nwe have no reason to believe that a JSON->JSON copier that works\nby decoding JSON to an internal form and recoding it for output\nwill preserve Erlang terms, even encoded like this.</p>\n\n<p>No, the point of JSON support in Erlang is to let Erlang programs\ndeal with the JSON data that other people are sending around the\nnet, and to send JSON data to other programs (like scripts in Web\nbrowsers) that are expecting plain old JSON.  The round trip\nconversion we need to care about is JSON -> Erlang -> JSON.</p>\n\n<p>Here too we run into problems.  The obvious way to represent\n{\"a\":A, \"b\":B} in Erlang is <code>[{'a',A},{'b',B}]</code>, and the obvious\nway to represent a string is as a list of characters.  But in\nJSON, an empty list, an empty \"object\", and an empty string are\nall clearly distinct, so must be translated to different Erlang\nterms.  Bearing this in mind, here's a first cut at mapping\nJSON to Erlang:</p>\n\n<pre><code>- null     =&gt; the atom 'null'\n- false    =&gt; the atom 'false'\n- true     =&gt; the atom 'true'\n- number   =&gt; a float if there is a decimal point or exponent,\n           =&gt; the float -0.0 if it is a minus sign followed by\n              one or more zeros, with or without a decimal point\n              or exponent\n           =&gt; an integer otherwise\n- string   =&gt; a UTF-8-encoded binary\n- sequence =&gt; a list\n- object   =&gt; a list of {Key,Value} pairs\n           =&gt; the empty tuple {} for an empty {} object\n</code></pre>\n\n<p>Since Erlang does not currently allow the full range of\nUnicode characters in an atom, a Key should be an atom if\neach character of a label fits in Latin 1, or a binary if\nit does not.</p>\n\n<p>Let's examine \"objects\" a little more closely.  Erlang\nprogrammers are used to working with lists of {Key,Value}\npairs.  The standard library even include orddict, which\nworks with just such lists (although they must be sorted).\nHowever, there is something distasteful about having empty\nobjects convert to empty tuples, but non-empty objects to\nempty lists, and there is also something distasteful about\nlists converting to sequence or objects depending on what\nis inside them.  What is distasteful here has something to\ndo with TYPES.  Erlang doesn't have static types, but that\ndoes not mean that types are not useful as a design tool,\nor that something resembling type consistency is not useful\nto people.  The fact that Erlang tuples happen to use curly\nbraces is just icing on the cake.  The first draft of this\nEEP used lists; that was entirely R.A.O'K's own work.  It\nwas then brought to his attention that Joe Armstrong thought\nconverting \"objects\" to tuples was the right thing to do.\nSo the next draft did that.  Then other alternatives were\nbrought up.  I'm currently aware of</p>\n\n<ul>\n<li><p>Objects are tuples</p>\n\n<ul>\n<li>A. <code>{{K1,V1}, ..., {Kn,Vn}}</code>.\nThis is the result of <code>list_to_tuple/1</code> applied to a <br />\nproplist.  There are no library functions to deal\nwith such things, but they are unambiguous and\nrelatively space-efficient.</li>\n<li>B. <code>{object,[{K1,V1}, ..., {Kn,Vn}]}</code>\nThis is a proplist wrapped in a tuple purely to\ndistinguish it from other lists.  This offers\nsimple type testing (objects are tuples) and simple\nfield processing (they contain proplists).\nThere seems to be no consensus for what the tag\nshould be, 'obj' (gratuitous abbreviation), 'json'\n(but even the numbers binaries and lists are JSON),\n'object' seems to be least objectionable.</li>\n<li>C. <code>{[{K1,V1},...,{Kn,Vn}]}</code>\nLike B, but there isn't any need for a tag.</li>\n</ul>\n\n<p>A and B are due to Joe Armstrong; I cannot recall who\nthought of C.  It has recently had supporters.</p></li>\n<li><p>Objects are lists</p>\n\n<ul>\n<li>D. Empty objects are <code>{}</code>.\nThis was my original proposal.  Simple but non-uniform\nand clumsy.</li>\n<li>E. Empty objects are <code>[{}]</code>.\nThis came from the Erlang mailing list; I have forgotten\nwho proposed it.  It's brilliant: objects are always\nlists of tuples.</li>\n<li>F. Empty objects are 'empty'.\nLike A but a tiny fraction more space-efficient.</li>\n</ul></li>\n</ul>\n\n<p>We can demonstrate handling \"objects\" in each of these forms:</p>\n\n<pre><code>json:is_object(X) -&gt; is_tuple(X).          % A\n\njson:is_object({object,X}) -&gt; is_list(X).  % B\n\njson:is_object({X}) -&gt; is_list(X).         % C\n\njson:is_object({}) -&gt; true;                % D\njson:is_object([{_,_}|_]) -&gt; true;\njson:is_object(_) -&gt; false.   \n\njson:is_object([X|_]) -&gt; is_tuple(X).      % E\n\njson:is_object(empty) -&gt; true;             % F\njson:is_object([{_,_}|_]) -&gt; true;\njson:is_object(_) -&gt; false.\n</code></pre>\n\n<p>Of these, A, B, C, and E can easily be used in clause heads,\nand E is the only one that is easy to use with proplist.\nAfter much scratching of the head and floundering around,\nE does it.</p>\n\n<p>We might consider adding an 'object' option:</p>\n\n<pre><code>{object,tuple}    representation A\n{object,pair}     representation B.\n{object,wrap}     representation C.\n{object,list}     representation E.\n</code></pre>\n\n<p>For conversion from Erlang to JSON,</p>\n\n<pre><code>{T1,...,Tn}       0 or more tuples\n{object,L}        size 2, 1st element atom, 2nd list\n{L}               size 1, only element a list\n</code></pre>\n\n<p>are all recognisable, so <code>term_to_json/[1,2]</code> could accept\nall of them without requiring an option.</p>\n\n<p>There is a long term reason why we want some such option.\nBoth lists and tuples are just WRONG.  The right data structure to\nrepresent JSON \"objects\" is the one that I call \"frames\" and Joe\nArmstrong calls \"proper structs\".  At some point in the future we\nwill definitely want to have <code>{object,frame}</code> as a possibility.</p>\n\n<p>Suppose you are receiving JSON data from a source that does\nnot distinguish between integers and floating point numbers?\nPerl, for example, or even more obviously, Javascript itself.\nIn that case some floating point numbers may have been written\nin integer style more or less accidentally.  In such a case, you\nmay want all the numbers in a JSON form converted to Erlang\nfloats.  <code>{float,true}</code> was provided for that purpose.</p>\n\n<p>The corresponding mapping from Erlang to JSON is</p>\n\n<pre><code>- atom   =&gt; itself if it is null, false, or true\n         =&gt; error otherwise\n- number =&gt; itself; use full precision for floats,\n            and always include a decimal point or exponent\n            in a float\n- binary =&gt; if the binary is a well formed UTF-8 encoding\n            of some string, that string\n         =&gt; error otherwise\n- tuple  =&gt; if all elements are {Key,Value} pairs with\n            non-equivalent keys, then a JSON \"object\",\n         =&gt; error otherwise\n- list   =&gt; if it is proper, itself as a sequence\n         =&gt; error otherwise\n- otherwise, an error\n</code></pre>\n\n<p>There is an issue here with keys.  The RFC says that \"The names\nwithin an object SHOULD be unique.\"  In the spirit of \"be\ngenerous in what you accept, strict in what you generate\", we\nreally ought to check that.  The only time <code>term_to_json/[1,2]</code>\nterminate successfully should be when the output is absolutely\nperfect JSON.  I did toy with the idea of an option to allow\nduplicate labels, but if I want to send such non-standard data,\nwho can I send it to?  Another Erlang program?  Then I would be\nbetter to use external binary format.  So the only options now\nallowed are ones to affect white space.  One might add an\noption later to specify the order of key:value pairs somehow,\nbut options that do not affect the semantics are appropriate.</p>\n\n<p>On second thoughts, look at the <a href=\"http://json-rpc.org/wd/JSON-RPC-1-1-WD-20060807.html\" title=\"The JSON RPC 1.1 draft specification\">JSON-RPC 1.1 draft</a>.\nIt says, in section 6.2.4 \"Member Sequence\":</p>\n\n<blockquote>\n  <p>Client implementations SHOULD strive to order the members of\nthe Procedure Call object such that the server is able to\nemploy a streaming strategy to process the contents.  At the\nvery least, a client SHOULD ensure that the version member\nappears first and the params member last.\nThis means that for conformity with JSON-RPC,</p>\n</blockquote>\n\n<pre><code>term_to_json([{version,&lt;&lt;\"1.1\"&gt;&gt;},\n              {method, &lt;&lt;\"sum\"&gt;&gt;},\n              {params, [17,25]}])\n</code></pre>\n\n<p>should not re-order the pairs.  Hence the current specification\nsays the order is preserved and does not provide any means for\nre-ordering.  If you want a standard order, program it outside.</p>\n\n<p>How should the \"duplicate label\" error be reported?  There are two\nways to report such errors in Erlang:  raise 'badarg' exceptions,\nor return either <code>{ok,Result}</code> or <code>{error,Reason}</code> answers.  I'm\nreally not at all sure what to do here.  I ended up with 'raise\nbadarg' because that's what things like <code>binary_to_term/1</code> do.</p>\n\n<p>At the moment, I specify that the Erlang terms use UTF-8 and only\nUTF-8.  This is by far the simplest possibility.  However, we\ncould certainly add</p>\n\n<pre><code>{internal,Encoding}\n</code></pre>\n\n<p>options to say what Encoding to use or assume for binaries.  The\ntime to add that, I think, is when there is a demonstrated need.</p>\n\n<p>There are five \"round trip\" issues left:</p>\n\n<ul>\n<li><p>all information about white space is lost.\nThis is not a problem, because it has no significance.</p></li>\n<li><p>decimal->binary->decimal conversion of floating point numbers\nmay introduce error unless techniques like those described in <br />\nthe Scheme report are used to do these conversions with high\naccuracy.  This is a general problem for Erlang, and a general\nproblem for JSON.</p></li>\n<li><p>there is another JSON library for Erlang that always converts\nintegers outside the 32-bit range to floating point.  This seems\nlike a bad idea.  There are languages (Scheme, Common Lisp,\nSWI Prolog, Smalltalk) with JSON libraries that have bignums.\nWhy put an arbitrary restriction on our ability to communication\nwith them?  Any JSON implementation that is unable to cope with\nlarge integers as integers is (or should be) perfectly able to\nconvert such numbers to floating-point for itself.  It seems\nspecially silly to do this when you consider that the program on\nthe other end might itself be in Erlang.  So we expect that if T\nis of type <code>json(binary(),integer())</code> then</p>\n\n<pre><code>json_to_term(term_to_json(T), [{label,binary}])\n</code></pre>\n\n<p>should be identical to T, up to re-ordering of attribute pairs.</p></li>\n<li><p>conversion of a string to a binary and then a binary to a\nstring will not always yield the same representation, but\nwhat you get will represent the same string.  Example,\n\"\\0041\" will read as <code>&lt;&lt;65&gt;&gt;</code> which will display as \"A\".</p></li>\n<li><p>Technically speaking the Unicode \"surrogates\" are not\ncharacters.  The RFC allows characters outside the Basic\nMultilingual Plane to be written as UTF-8 sequences, or\nto be written as 12-character \\uHIGH\\uLOWW surrogate pair\nescapes.  Something with a bare \\uHIGH or \\uLOWW surrogate\ncode point is not, technically speaking, a legal Unicode\nstring, so a UTF-8 sequence for such a code point should\nnot appear.  A \\uHIGH or \\uLOWW escape sequence on its own\nshould not appear either; it would be just as much of a\nsyntax error as a byte with value 255 in a UTF-8 sequence.\nWe actually have two problems:</p>\n\n<ul>\n<li><p>(a) Some languages may be sloppy and may allow singleton\nsurrogates inside strings.  Should Erlang be equally\nsloppy?  Should this just be allowed?</p></li>\n<li><p>(b) Some languages (and yes, I do mean Java) don't really\ndo UTF-8, but instead first break a sequence of Unicode\ncharacters into 16-bit chunks (UTF-16) and then encode\nthe chunks as UTF-8, producing what is quite definitely\nillegal UTF-8.  Since there is a lot of Java code in the\nworld, how do we deal with this?</p>\n\n<p>Be generous in what you accept:  the 'utf8' decoder\nshould quietly accept \"UTF-Java\", converting\nseparately encoded surrogates to a single numeric\ncode, and converting singleton surrogates <em>as if</em> they\nwere characters.</p>\n\n<p>Be strict in what you generate:  never generate\nUTF-Java when the requested encoding is 'utf8';\nhave a separate 'java' encoding that can be requested\ninstead.</p></li>\n</ul></li>\n</ul>\n\n<p>Hynek Vychodil is vehement that the only acceptable way to handle\nJSON labels is as binaries.  His argument against <code>{label,atom}</code> is\nsound:  as noted above, that option is only usable within a trust\nboundary.  His argument against <code>{label,existing_atom}</code> is that if\nyou convert a JSON form at one time in one node, and then store\nthe Erlang term in a file or send it across a wire or in any\nother way make it available at another node or another time,\nthen it won't match the same JSON form converted at that time in\nthat node.  This is true, but there are plenty of other round\ntrip issues as well.  Data converted using <code>{float,true}</code> will not\nmatch data converted using <code>{float,false}</code>.  The handling of\nduplicate labels may vary.  The order of {key,value} pairs is\nparticularly likely to vary.  For all programming languages and\nlibraries, if you want to move JSON data around in time or\nspace, the <em>only</em> reliable way to do that is to move it <em>as</em>\n(possibly compressed) JSON data, not as something else.  You\ncan expect a JSON form read at one time/place to be equivalent\nto the same form read at another time/place; you cannot expect\nit to be identical.  Any code that does is essentially buggy,\nwhether <code>{label,existing_atom}</code> is used or not.  Here is an\nexample that shows that the problem is ineradicable.</p>\n\n<p>Suppose we have the JSON form\n\"[0.123456789123456789123456789123456]\".\nTwo Erlang nodes on different machines read this and\nconvert it to an Erlang term.  One of them sends its term to\nthe other, which compares them.  To its astonishment, they\nare not identical!  Why?  Well, it could be that they use\ndifferent floating-point precisions.  On one of Erlang's main\nplatforms, 128-bit floats are supported.  (The example needs\n128 bits.)  On its other main platform, 80-bit floats are\nsupported.  (In neither case am I saying that Erlang does,\nonly that the hardware does.)  Indeed, modern versions of the\nsecond platform usually work with 64-bit floats.  Let us\nsuppose that they both stick with 64-bit floats instead.\nWhat if one of the systems is an IBM/370 with its non-IEEE\ndoubles?  So suppose they are both using IEEE 64-bit floats.\nThey will use different C libraries to do the initial\ndecimal-to-binary conversion, so the number may be rounded\ndifferently.  And if one is Windows and another is Linux or\nSolaris, they WILL use different libraries.  Should Erlang\nuse its own code (which might not be a bad idea), we would\nstill have trouble talking to machines with non-IEEE doubles,\nwhich are still in use.  Even Java, which originally wanted\nto have bit-identical results everywhere, eventually retreated.</p>\n\n<p>There is one important issue for JSON generation, and that is\nwhat white space should be generated.  Since JSON is supposed to\nbe \"human readable\", it would be nice if it could be indented,\nand if it could be kept to a reasonable line width.  However,\nappearances to the contrary, JSON has to be regard as a binary\nformat.  There is no way to insert line breaks inside strings.\nJavascript doesn't have any analogue of C's <backslash><newline>\ncontinuation; it can always join the pieces with '+'.  JSON has\ninherited the lack (no line continuation) but not the remedy\n(you may not use '+' in JSON).  So a JSON form containing a\n1000-character string cannot be fitted into 80-column lines;\nit just cannot be done.</p>\n\n<p>The main thing I have not accounted for is the <code>{label,_}</code>.\noption of <code>json_to_term/2</code>.  For normal Erlang purposes, it is\nmuch nicer (and somewhat more efficient) to deal with</p>\n\n<pre><code>[{name,&lt;&lt;\"fred\"&gt;&gt;},{female,false},{age,65}]\n</code></pre>\n\n<p>than with</p>\n\n<pre><code>[{&lt;&lt;\"name\"&gt;&gt;,&lt;&lt;\"fred\"&gt;&gt;},{&lt;&lt;\"female\"&gt;&gt;,false},{&lt;&lt;\"age\"&gt;&gt;,65}]\n</code></pre>\n\n<p>If you are communicating with a trusted source that deals with\na known small number of labels, fine.  There are limits on the\nnumber of atoms Erlang can deal with.  A small test program\nthat looped creating atoms and putting them into a list ticked\nover happily until shortly after its millionth atom, and then\nhung there burning cycles apparently getting nowhere.  Also,\nthe atom table is shared by all processes on an Erlang node,\nso garbage collecting it is not as cheap as it might be.  As\na system integrity measure, therefore, it is useful to have a\nmode of operation in which json<em>to</em>term never creates atoms.\nBut Erlang offers a third possibility:  there is a built-in\n<code>list_to_existing_atom/1</code> function that returns an atom only if\nthat atom already exists.  Otherwise it raises an exception.\nSo there are three cases:</p>\n\n<ul>\n<li><p><code>{label,binary}</code></p>\n\n<p>Always convert labels to binaries.\nThis is always safe and always clumsy.\nSince &lt;&lt;\"xxx\">> syntax exists in Erlang,\nit isn't <em>that</em> clumsy.  It is uniform,\nand stable, in that it does not depend\non whether Erlang atoms support Unicode or\nnot, or what other modules have been loaded.</p></li>\n<li><p><code>{label,atom}</code></p>\n\n<p>Always convert labels to atoms if all their\ncharacters are allowed in atoms, leave them\nas binaries otherwise.</p>\n\n<p>This is more convenient for Erlang programming.\nHowever, it is only really usable with a partner\nthat you trust.  Since much communication takes\nplace within trust boundaries, it definitely has\na place.  If this were not so, term<em>to</em>binary/1\nwould be of no use!</p></li>\n<li><p><code>{label,existing_atom}</code></p>\n\n<p>Convert labels that match the names of existing\natoms to those atoms, leave all others as binaries.\nIf a module mentions an atom, and goes looking for\nthat atom as a key, it will find it.  This is safe\n<em>and</em> convenient.  The only real issue with it is\nthat the same JSON term converted at different times\n(in the same Erlang node) may be converted differently.\nThis usually won't matter.</p></li>\n</ul>\n\n<p>In previous drafts I selected <code>existing_atom</code> as the default,\nbecause that's the option I like best.  It's the one that would\nmost simplify the code that I would like to write.  However, one\nmust also consider conversion issues.  Some well considered\nexisting JSON libraries for Erlang always use binaries.</p>\n\n<p>There is no <code>{string,XXX}</code> option.  That's because I see the\nstrings in JSON as \"payload\", as unpredictable data that are\nbeing transmitted, that one does not <em>expect</em> to match against.\nThis is in marked contrast with labels, which are \"structure\"\nrather than data, and which one expects to match against a lot.\nI did briefly consider a <code>{string,list|binary}</code> option, but these\ndays Erlang is so good at matching binaries that there didn't\nseem to be much point.</p>\n\n<p>This raises a general issue about binaries.  One of the reasons\nfor liking atoms as labels is that atoms are stored uniquely,\nand binaries are not.  This extends to <code>term_to_binary()</code>, which\ncompresses repeated references to identical atoms, but not\nrepeated references to equal binaries.  There is no reason that\na C implementation of <code>json_to_term/[1,2]</code> could not keep track\nof which labels have been seen and share references to repeated\nones.  For example,</p>\n\n<pre><code>[{\"name\":\"root\",\"command\":\"java\",\"cpu\":75.7},\n {\"name\":\"ok\",\"command\":\"iropt\",\"cpu\":1.5}\n]\n</code></pre>\n\n<p>-- extracted from a run of the 'top' command showing that my\nC compilation was getting a tiny fraction of the machine,\nwhile some Java program run by root was getting the lion's share --\nwould convert to Erlang as the equivalent of</p>\n\n<pre><code>N = &lt;&lt;\"name\"&gt;&gt;,\nM = &lt;&lt;\"command\"&gt;&gt;,\nP = &lt;&lt;\"cpu\"&gt;&gt;,\n[[{N,&lt;&lt;\"root\"&gt;&gt;},{M,&lt;&lt;\"java\"&gt;&gt;}, {P,75.7}],\n [{N,&lt;&lt;\"ok\"&gt;&gt;},  {M,&lt;&lt;\"iropt\"&gt;&gt;},{P, 1.5}]\n]\n</code></pre>\n\n<p>getting much of the space saving that atoms would use.  There is\nof course no way for a pure Erlang program to detect whether such\nsharing is happening or not.  It would be nice if</p>\n\n<pre><code>term_to_binary(json_to_term(JSON))\n</code></pre>\n\n<p>preserved such sharing.</p>\n\n<p>Another issue that has been raised concerns encoding.  Some people\nhave said that they would like (a) to allow input encodings other\nthan UTF-8, (b) to have strings reported in their original\nencoding, rather than UTF-8, so that (c) strings can be slices of\nthe original binary.  What does the JSON specification actually\nsay?  Section 3, Encoding:</p>\n\n<blockquote>\n  <p>JSON text SHALL be encoded in Unicode.\nThe default encoding is UTF-8.</p>\n</blockquote>\n\n<p>This is not quite as clear as it might be.  There is explicit\nmention of UTF-32 and UTF-16 (both of them in big- and little-\nendian forms).  But is SCSU \"Unicode\"?  Is BOCU?  How about\n<a href=\"http://unicode.org/reports/tr16/\" title=\"Uniode technical report #16, UTF-EBCDIC\">UTF-EBCDIC</a>?  That's right, there is a legal way to encode\nsomething in \"Unicode\" in which the JSON special characters\n[]{},:\\\" do not have their ASCII values.  There does not seem\nto be any reason to suppose that this is forbidden, and on an\nIBM mainframe I would expect it to be useful.  Until the day\nsomeone ports Erlang to a z/Series machine, this is mainly of\nacademic interest, but we don't want to paint ourselves into\nany corners.</p>\n\n<p>Suppose we did represent strings in their native encoding.\nWhat then?  First, a string that contained an escape sequence\nof any kind could not be held as a slice of the source anyway.\nNor could a string that spanned two or more chunks of the\nIO_Data input.  The really big problem is that there would be\nno indication of what the encoding actually was, so that we\nwould end up regarding logically equal strings from different\nsources as unequal and logically unequal strings as equal.</p>\n\n<p>I do not want to forbid strings in the result being slices of\nan original binary.  In the common case when the input is\nUTF-8 and the string does not contain any escapes, so that it\n<em>can</em> be done, an implementation should definitely be free to\nexploit that.  As this EEP currently stands, it is.  What we\ncannot do is to <em>require</em> such sharing, because it generally\nwon't work.</p>\n\n<p>It has been suggested to me that it might be better for the\nresult of <code>term_to_json/[1,2]</code> to be <code>iodata()</code> rather than a\n<code>binary()</code>.  Anything that would have accepted <code>iodata()</code> will be\nhappy with a <code>binary()</code>, so the question is whether it is better\nfor the implementation, whether perhaps there are chunks of stuff\nthat have to be copied using a <code>binary()</code> but can be shared using\n<code>iodata()</code>.  Thanks to the encoding issue, I don't really think so.\nThis might be a good time to point out why the encoding is done\nhere rather than somewhere else.  If you know that you are\ngenerating stuff that will be encoded into character set X, then\nyou can avoid generating characters that are not in that\ncharacter set.  You can generate \\u sequences instead.  Of course\nJSON itself requires UTF-8, but what if you are going to send it\nthrough some other transport?  With <code>{encoding,ascii}</code> you are out\nof trouble all the way.  So for now I am sticking with <code>binary()</code>.</p>\n\n<p>The final issue is whether these functions should go in the\nerlang: module or in some other module (perhaps called json:).</p>\n\n<ul>\n<li><p>If another module, then there is no barrier to adding other\nfunctions.  For example, we might offer functions to test\nwhether a term is a JSON term, or an IO_Data represents a JSON\nterm, or alternative functions that present results in some\ncanonical form.</p></li>\n<li><p>If another module, then someone looking for a JSON module might\nfind one.</p></li>\n<li><p>If another module, then this interface can easily be prototyped\nwithout any modification to the core Erlang system.</p></li>\n<li><p>If another module, then someone who doesn't need this feature\nneed not load it.</p></li>\n</ul>\n\n<p>Conversely,</p>\n\n<ul>\n<li><p>If another module, then it is too easy to bloat the interface.\nWe don't <em>need</em> such testing functions, as we can always catch\nthe badarg exception from the existing ones.  We don't <em>need</em>\nextra canonicalising functions, because we can add options to\nthe existing ones.  Something that subtly encourages us to\nkeep the number of functions down is a Good Thing.</p></li>\n<li><p>Every Erlang programmer ought to be familiar with the erlang:\nmodule, and when looking for any feature, ought to start by\nlooking there.</p></li>\n<li><p>There are JSON implementations in Erlang already; we know what\nit is like to use such a thing, and we only need to settle the\nfine details of the implementation.  We know that it can be\nimplemented.  Now we want something that is always there and\nalways the same and is as efficient as practical.</p></li>\n<li><p>In particular, we know that the feature is useful, and we know\nthat in applications where it is used, it will be used often,\nso we want it to go about as fast as term<em>to</em>binary/1 and\n<code>binary_to_term/1</code>.  So we'd really like it to be implemented in\nC, ideally inside the emulator.  Erlang does not make dynamic\nloading of foreign code modules easy.</p></li>\n</ul>\n\n<p>It's a delicate balance.  On the whole, I still think that putting\nthese functions in erlang: is a good idea, but more reasons on\nboth sides would be useful.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>There are no <code>term_to_json/N</code> or <code>json_to_term/N</code> functions in\nthe erlang: module now, so adding them should not break\nanything.  These functions will NOT be automatically imported;\nit will be necessary to use an explicit erlang: prefix.  So\nany existing code that uses these function names won't notice\nany change.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}