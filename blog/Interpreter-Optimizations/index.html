<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/Interpreter-Optimizations/">Interpreter optimization</a></h3><p><em>Monday, 11 June 2018<!-- --> - <!-- -->Lukas Larsson</em></p><p>The BEAM <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> in erts has been completely re-written in OTP 21.
Most of the instructions have remained the same, but the perl scripts used
to generate the C code have a new implementation. This blog post will look at
some of the optimizations that were possible because of those changes.</p><p>First however, let&#x27;s start with some basics about how the interpreter is
built. The BEAM interpreter is built using generated C code. Dispatching
is done using <a href="https://en.wikipedia.org/wiki/Threaded_code#Direct_threading">direct threading</a> which leverages the GCC extension <a href="https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html">labels as values</a>.
It is the job of the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops">beam_makeops</a> perl script to take the input files
and create the C files.</p><p>There is also a set of transformation rules generated that is used by the
<a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/beam_load.c#L5213">transform_engine</a> in the beam code loader to do several peephole optimization.
The optimization include, but are not limited to, instruction combining,
instruction specialization and dead code elimination.</p><p>There are three separate types of input files used.</p><ul><li><a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/lib/compiler/src/genop.tab">genop.tab</a> contains a listing of the instructions that the compiler emits.</li><li><a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/ops.tab">ops.tab</a> contains load time transformations done to the code.</li><li><a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab">instrs.tab</a> contain the implementation of each instruction.</li></ul><p>There is a description of the syntax and semantics of the different files
in the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md">internal beam_makeops documentation</a>. The largest difference
between the new and old way of doing the code generation is that
in OTP 21 <em>all</em> the instructions are now generated, instead of about 75%.
This allowed us to do architecture specific optimizations for all instructions
when generating the code for the instructions.</p><h2>Packing the dispatch target address</h2><p>On 64-bit machines all pointers are 8 byte large, this is also the case for
the pointer that you get when taking the address of a label. So for a small
instruction such as move_cx (move a constant to an x register), 3 words of
memory is needed.</p><pre><code>     +--------------------+--------------------+
I -&gt; |                            &amp;&amp;lb_move_cx |
     +--------------------+--------------------+
     |                        Tagged atom &#x27;id&#x27; |
     +--------------------+--------------------+
     |                                      40 |
     +--------------------+--------------------+</code></pre><p>One word for the instruction, one word for the literal and then the target x
register actually only needs 2 bytes, but since all code is word aligned it
gets its own word.</p><p>However, on most machines, the linker uses what is called a small or medium code model.
This means that it will place all code in the lower 2 GB of the address space
so that more efficient machine instructions can be used. It also works in the
favor of the beam interpreter as we now know that the upper 4 bytes of the
instruction word will always be 0.</p><pre><code>     +--------------------+--------------------+
I -&gt; |                 40 |       &amp;&amp;lb_move_cx |
     +--------------------+--------------------+
     |                        Tagged atom &#x27;id&#x27; |
     +--------------------+--------------------+</code></pre><p>So instead of placing the x register to use in its own word we pack it into the
instruction word, thus saving one word of memory for this instruction.</p><p>The optimization is only possible to do on 64-bit platforms that place all code in the
lower 4 GB of the address space, so that makes 32-bit and <a href="https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables">position-independent executable</a>
platforms not use it.
To figure out which 64-bit platforms we can do it on we first started by writing
a configure script that looked at CFLAGS and LDFLAGS, asked the compiler what it would do
by default etc etc. After tinkering for a while we came up with a simpler and so
far stable solution:</p><pre><code>#include &lt;stdlib.h&gt;
int main() {
  if ((unsigned long long)&amp;main &lt; (1ull &lt;&lt; 32)) {
    exit(0);
  }
  exit(1);
}</code></pre><p>It would seem that <a href="https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables">position-independent executable</a> always places code in
segments &gt; 4GB so we can just check where it put main in a small test program.</p><p>Packing arguments into the instruction word is possible for a significant amount
of instructions which reduced loaded code size and in turn increased performance.</p><h2>Smarter packing</h2><p>The packing engine in [beam_makeops] uses several different heuristics to figure
out which instruction argument(s) it should put in the instruction word. Because
of alignment requirements and other things, only some types of argument are allowed
together. When choosing how to pack arguments the packer first builds all different
variant possible and then chooses the instruction that takes the least amount of
memory. The logic for this can be found in the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops#L1801">do_pack_one</a> function in
<a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops">beam_makeops</a>. Before OTP-21 this had to be done manually for all instructions,
which meant that the implementer had to be extra careful when deciding which
order the arguments should be placed in <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/ops.tab">ops.tab</a>. In addition the packing logic
before OTP-21 did not pack argument of varying size into the same machine word.</p><p>The packer is not perfect however, so in some cases we needed to make it
possible to override its decisions. That is why the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md#the--type-modifier">? type modifier</a> was introduced.
The <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md#the--type-modifier">? type modifier</a> is used to determine whether an argument is likely to be used
or not by the instruction.</p><p>How do you determine if an argument is likely to be used or not? For some instructions
it is obvious, eg. the allocate instruction has an argument that is only used
if a garbage collection is triggered, so it is very unlikely to be used. In other cases
it is not so obvious, eg. the failure label of test instructions, is it likely to be
used or not? For most test instructions it will be unlikely that it will be used,
or at least more unlikely than the other arguments of the instruction as they are used
in the actual test.</p><p>Why is packing less used instructions into the instruction word better? It seems like
GCC will generate a little better code for most instructions if the arguments that
are always used are in the same word, we&#x27;ve seen this by both looking at the assembly
that GCC produced and the total code size of the interpreter becomes smaller. We haven&#x27;t
been able to measure any differences in performance due to how the unlikely instructions
are packed, but smaller code is always a good thing.</p><h2>Relative jump labels</h2><p>Many instruction have branches in them that will be taken depending on various conditions.
One of the simplest ones is the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab#L789">is_eq_exact_immed</a> instruction. It will continue on
to the next instruction if the value is equal to the immediate literal in the argument,
or jump to the fail label if they are not equal. Before OTP-21 the instruction
is_eq_exact_immed_frc would have this layout:</p><pre><code>     +--------------------+--------------------+
I -&gt; |              &amp;&amp;lb_is_eq_exact_immed_frc |
     +--------------------+--------------------+
     |                 Pointer To failure code |
     +--------------------+--------------------+
     |                       Tagged immed &#x27;id&#x27; |
     +--------------------+--------------------+</code></pre><p>The C code for the instruction would look something like this (I&#x27;ve removed all macros
that beam_makeops uses):</p><pre><code>if (reg[0] != I[2]) {
  I = I[1];
  goto *(void**)I;
}
I+=3;
goto *(void**)I;</code></pre><p>In this example it does not help to use part of the instruction word as both arguments
are 8 bytes large. We also cannot use the same trick as the instruction word to make
the fail label smaller as Erlang code can be allocated anywhere in the 64-bit address
space. One thing that we can rely on though is that the code for a single Erlang module
will be located in a contiguous memory area. So instead of using pointers to the code
that we want to jump to we can use relative addresses for jumps within the same module.</p><p>The problem with using relative local jumps is that we put a limit on how large a module
can be. For instance, the largest module in Erlang/OTP is the &#x27;OTP-PUB-KEY&#x27; module,
it is 61585 words large when loaded and the longest local jump is 5814 words. For this
particular module we could have used a 13-bit jump label, or 16-bits if we wanted to be
sure that all functions could call each other. 16-bits would have been a perfect size as
it can be packed with another register in the instruction word. So it would have been
possible to fit a instruction address + jump label + register in 8 bytes. However, it is
way too close for comfort, and there are sure to be larger modules than ours in other
systems, so we decided to use 32-bits for the jump labels. So in OTP-21 the max size of
a loaded module has gone from 2^32 GB to 32 GB, which should be enough for most use cases.</p><p>Using this new layout the is_eq_exact_immed_frc instruction can be re-written to use
the following layout instead:</p><pre><code>     +--------------------+--------------------+
I -&gt; | Offset to failure..| &amp;&amp;lb_is_eq_exac... |
     +--------------------+--------------------+
     |                       Tagged immed &#x27;id&#x27; |
     +--------------------+--------------------+</code></pre><p>And generate this code:</p><pre><code>if (reg[0] != I[1]) {
  I += I[0] &gt;&gt; 32;
  goto *(void**)(Uint64)(Uint32)I;
}
I+=2;
goto *(void**)(Uint64)(Uint32)I;</code></pre><p>The code ends up being a little bit more complicated, but the C compiler manages to optimize
it into very efficient code. Basically for each jump label there is an extra add operation
when compared to before. When profiling this extra code is not noticeable as it drowns in
the load of the value from (hopefully) the l1-cache.</p><p>A lot of instructions benefit from this optimization as a lot of them control the control
flow. This is especially noticeable on large <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/select_instrs.tab#L32-L76">select_val_bins</a>, as they have their memory
usage reduced by 25%. Also as you may have noticed, it plays very well with the packing
of the instruction word and the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md#the--type-modifier">? type modifier</a> in <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops">beam_makeops</a>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"Interpreter-Optimizations","title":"Interpreter optimization","author":"Lukas Larsson","excerpt":"\nThe BEAM [interpreter] in erts has been completely re-written in OTP 21.\nMost of the instructions have remained the same, but the perl scripts used\nto generate the C code have a new implementation. This blog post will look at\nsome of the optimizations that were possible because of those changes.\n\n[interpreter]: https://en.wikipedia.org/wiki/Interpreter_(computing),\n[direct threading]: https://en.wikipedia.org/wiki/Threaded_code#Direct_threading,\n[labels as values]: https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html,\n[beam_makeops]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops,\n[genop.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/lib/compiler/src/genop.tab,\n[ops.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/ops.tab,\n[instrs.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab,\n[internal beam_makeops documentation]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md,\n[transform_engine]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/beam_load.c#L5213,\n[? type modifier]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md#the--type-modifier,\n[position-independent executable]: https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables,\n[do_pack_one]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops#L1801,\n[is_eq_exact_immed]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab#L789,\n[select_val_bins]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/select_instrs.tab#L32-L76","article_date":1528675200000,"tags":["interpreter","BEAM"],"frontmatter":{"layout":"post","title":"Interpreter optimization","tags":"interpreter BEAM","author":"Lukas Larsson"},"content":"\nThe BEAM [interpreter] in erts has been completely re-written in OTP 21.\nMost of the instructions have remained the same, but the perl scripts used\nto generate the C code have a new implementation. This blog post will look at\nsome of the optimizations that were possible because of those changes.\n\nFirst however, let's start with some basics about how the interpreter is\nbuilt. The BEAM interpreter is built using generated C code. Dispatching\nis done using [direct threading] which leverages the GCC extension [labels as values].\nIt is the job of the [beam_makeops] perl script to take the input files\nand create the C files.\n\nThere is also a set of transformation rules generated that is used by the\n[transform_engine] in the beam code loader to do several peephole optimization.\nThe optimization include, but are not limited to, instruction combining,\ninstruction specialization and dead code elimination.\n\nThere are three separate types of input files used.\n\n* [genop.tab] contains a listing of the instructions that the compiler emits.\n* [ops.tab] contains load time transformations done to the code.\n* [instrs.tab] contain the implementation of each instruction.\n\nThere is a description of the syntax and semantics of the different files\nin the [internal beam_makeops documentation]. The largest difference\nbetween the new and old way of doing the code generation is that\nin OTP 21 _all_ the instructions are now generated, instead of about 75%.\nThis allowed us to do architecture specific optimizations for all instructions\nwhen generating the code for the instructions.\n\n[interpreter]: https://en.wikipedia.org/wiki/Interpreter_(computing)\n[direct threading]: https://en.wikipedia.org/wiki/Threaded_code#Direct_threading\n[labels as values]: https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html\n[beam_makeops]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops\n[genop.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/lib/compiler/src/genop.tab\n[ops.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/ops.tab\n[instrs.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab\n[internal beam_makeops documentation]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md\n[transform_engine]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/beam_load.c#L5213\n\n## Packing the dispatch target address ##\n\nOn 64-bit machines all pointers are 8 byte large, this is also the case for\nthe pointer that you get when taking the address of a label. So for a small\ninstruction such as move_cx (move a constant to an x register), 3 words of\nmemory is needed.\n\n         +--------------------+--------------------+\n    I -\u003e |                            \u0026\u0026lb_move_cx |\n         +--------------------+--------------------+\n         |                        Tagged atom 'id' |\n         +--------------------+--------------------+\n         |                                      40 |\n         +--------------------+--------------------+\n\nOne word for the instruction, one word for the literal and then the target x\nregister actually only needs 2 bytes, but since all code is word aligned it\ngets its own word.\n\nHowever, on most machines, the linker uses what is called a small or medium code model.\nThis means that it will place all code in the lower 2 GB of the address space\nso that more efficient machine instructions can be used. It also works in the\nfavor of the beam interpreter as we now know that the upper 4 bytes of the\ninstruction word will always be 0.\n\n         +--------------------+--------------------+\n    I -\u003e |                 40 |       \u0026\u0026lb_move_cx |\n         +--------------------+--------------------+\n         |                        Tagged atom 'id' |\n         +--------------------+--------------------+\n\nSo instead of placing the x register to use in its own word we pack it into the\ninstruction word, thus saving one word of memory for this instruction.\n\nThe optimization is only possible to do on 64-bit platforms that place all code in the\nlower 4 GB of the address space, so that makes 32-bit and [position-independent executable]\nplatforms not use it.\nTo figure out which 64-bit platforms we can do it on we first started by writing\na configure script that looked at CFLAGS and LDFLAGS, asked the compiler what it would do\nby default etc etc. After tinkering for a while we came up with a simpler and so\nfar stable solution:\n\n    #include \u003cstdlib.h\u003e\n    int main() {\n      if ((unsigned long long)\u0026main \u003c (1ull \u003c\u003c 32)) {\n        exit(0);\n      }\n      exit(1);\n    }\n\nIt would seem that [position-independent executable] always places code in\nsegments \u003e 4GB so we can just check where it put main in a small test program.\n\nPacking arguments into the instruction word is possible for a significant amount\nof instructions which reduced loaded code size and in turn increased performance.\n\n## Smarter packing ##\n\nThe packing engine in [beam\\_makeops] uses several different heuristics to figure\nout which instruction argument(s) it should put in the instruction word. Because\nof alignment requirements and other things, only some types of argument are allowed\ntogether. When choosing how to pack arguments the packer first builds all different\nvariant possible and then chooses the instruction that takes the least amount of\nmemory. The logic for this can be found in the [do_pack_one] function in\n[beam_makeops]. Before OTP-21 this had to be done manually for all instructions,\nwhich meant that the implementer had to be extra careful when deciding which\norder the arguments should be placed in [ops.tab]. In addition the packing logic\nbefore OTP-21 did not pack argument of varying size into the same machine word.\n\nThe packer is not perfect however, so in some cases we needed to make it\npossible to override its decisions. That is why the [? type modifier] was introduced.\nThe [? type modifier] is used to determine whether an argument is likely to be used\nor not by the instruction.\n\nHow do you determine if an argument is likely to be used or not? For some instructions\nit is obvious, eg. the allocate instruction has an argument that is only used\nif a garbage collection is triggered, so it is very unlikely to be used. In other cases\nit is not so obvious, eg. the failure label of test instructions, is it likely to be\nused or not? For most test instructions it will be unlikely that it will be used,\nor at least more unlikely than the other arguments of the instruction as they are used\nin the actual test.\n\nWhy is packing less used instructions into the instruction word better? It seems like\nGCC will generate a little better code for most instructions if the arguments that\nare always used are in the same word, we've seen this by both looking at the assembly\nthat GCC produced and the total code size of the interpreter becomes smaller. We haven't\nbeen able to measure any differences in performance due to how the unlikely instructions\nare packed, but smaller code is always a good thing.\n\n[? type modifier]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md#the--type-modifier\n[position-independent executable]: https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables\n[do_pack_one]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops#L1801\n\n## Relative jump labels ##\n\nMany instruction have branches in them that will be taken depending on various conditions.\nOne of the simplest ones is the [is_eq_exact_immed] instruction. It will continue on\nto the next instruction if the value is equal to the immediate literal in the argument,\nor jump to the fail label if they are not equal. Before OTP-21 the instruction\nis\\_eq\\_exact\\_immed\\_frc would have this layout:\n\n         +--------------------+--------------------+\n    I -\u003e |              \u0026\u0026lb_is_eq_exact_immed_frc |\n         +--------------------+--------------------+\n         |                 Pointer To failure code |\n         +--------------------+--------------------+\n         |                       Tagged immed 'id' |\n         +--------------------+--------------------+\n\nThe C code for the instruction would look something like this (I've removed all macros\nthat beam\\_makeops uses):\n\n    if (reg[0] != I[2]) {\n      I = I[1];\n      goto *(void**)I;\n    }\n    I+=3;\n    goto *(void**)I;\n\nIn this example it does not help to use part of the instruction word as both arguments\nare 8 bytes large. We also cannot use the same trick as the instruction word to make\nthe fail label smaller as Erlang code can be allocated anywhere in the 64-bit address\nspace. One thing that we can rely on though is that the code for a single Erlang module\nwill be located in a contiguous memory area. So instead of using pointers to the code\nthat we want to jump to we can use relative addresses for jumps within the same module.\n\nThe problem with using relative local jumps is that we put a limit on how large a module\ncan be. For instance, the largest module in Erlang/OTP is the 'OTP-PUB-KEY' module,\nit is 61585 words large when loaded and the longest local jump is 5814 words. For this\nparticular module we could have used a 13-bit jump label, or 16-bits if we wanted to be\nsure that all functions could call each other. 16-bits would have been a perfect size as\nit can be packed with another register in the instruction word. So it would have been\npossible to fit a instruction address + jump label + register in 8 bytes. However, it is\nway too close for comfort, and there are sure to be larger modules than ours in other\nsystems, so we decided to use 32-bits for the jump labels. So in OTP-21 the max size of\na loaded module has gone from 2^32 GB to 32 GB, which should be enough for most use cases.\n\nUsing this new layout the is\\_eq\\_exact\\_immed\\_frc instruction can be re-written to use\nthe following layout instead:\n\n         +--------------------+--------------------+\n    I -\u003e | Offset to failure..| \u0026\u0026lb_is_eq_exac... |\n         +--------------------+--------------------+\n         |                       Tagged immed 'id' |\n         +--------------------+--------------------+\n\nAnd generate this code:\n\n    if (reg[0] != I[1]) {\n      I += I[0] \u003e\u003e 32;\n      goto *(void**)(Uint64)(Uint32)I;\n    }\n    I+=2;\n    goto *(void**)(Uint64)(Uint32)I;\n\nThe code ends up being a little bit more complicated, but the C compiler manages to optimize\nit into very efficient code. Basically for each jump label there is an extra add operation\nwhen compared to before. When profiling this extra code is not noticeable as it drowns in\nthe load of the value from (hopefully) the l1-cache.\n\nA lot of instructions benefit from this optimization as a lot of them control the control\nflow. This is especially noticeable on large [select_val_bins], as they have their memory\nusage reduced by 25%. Also as you may have noticed, it plays very well with the packing\nof the instruction word and the [? type modifier] in [beam_makeops].\n\n[is_eq_exact_immed]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab#L789\n[select_val_bins]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/select_instrs.tab#L32-L76\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"Interpreter-Optimizations"},"buildId":"ob9V3f7Iet6syJeg0QYgd","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_buildManifest.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_ssgManifest.js" async=""></script></body></html>