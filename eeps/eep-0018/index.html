<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 28-Jul-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 18: <a href="eep-0018.md" title="EEP Source"> JSON bifs</a></h2>

<h1>Abstract</h1>

<p>According to the <a href="http://www.json.org/" title="The JSON web site">JSON web site</a>,
"JSON (JavaScript Object Notation) is a lightweight
data-interchange format. It is easy for humans to read and write.
It is easy for machines to parse and generate."</p>

<p>JSON is specified by <a href="http://www.ietf.org/rfc/rfc4627.txt" title="The JSON RFC">RFC 4627</a>, which defines a Media Type
application/json.</p>

<p>There are JSON libraries for a wide range of languages, so it is a
useful format.  <a href="http://incubator.apache.org/couchdb/" title="CouchDB">CouchDB</a> <a href="http://wiki.apache.org/couchdb/" title="CouchDB">uses</a> JSON as its storage format and in
its RESTful interface; it offers an alternative to Mnesia for some
projects, and is accessible from many more languages.  There are
already JSON bindings for Erlang, such as the <a href="www.lshift.net/blog/2007/02/17/json-and-json-rpc-for-erlang" title="rfc4627 module for Erlang from LShift">rfc4627</a> module
from LShift, but on the 24th of July 2008, Joe Armstrong suggested
that it would be worth having built in functions to convert Erlang
terms to and from the JSON format.</p>

<pre><code>term_to_json        -- convert a term to JSON form
json_to_term        -- convert a JSON form to Erlang
</code></pre>

<h1>Specification</h1>

<p>Three new types are added to the vocabulary of well known
types to be used in edoc.</p>

<pre><code>@type json_label() = atom() + binary().
@type json(L, N) = null + false + true
                 + N                % some kind of number
                 + [{}]             % empty "object"
                 + [{L, json(L,N)}] % non-empty "object"
                 + [json(L, N)].    % "array"
                 | [json(L, N)] | tuple({L, json(L, N)}).
@type json() = json(json_label(), number()).
</code></pre>

<h3>New functions</h3>

<p>Four new functions are added to the erlang: module.</p>

<pre><code>erlang:json_to_term(IO_Data) -&gt; json()
erlang:json_to_term(IO_Data, Option_List) -&gt; json()
</code></pre>

<p>Types:</p>

<pre><code>IO_Data = iodata()
Option_List = [Option]
Option = {encoding,atom()}
       | {float,bool()}
       | {label,binary|existing_atom|atom}
</code></pre>

<p><code>json_to_term(X)</code> is equivalent to <code>json_to_term(X, [])</code>.</p>

<p>The <code>IO_Data</code> implies a sequence of bytes.</p>

<p>The encoding option says what character encoding to use for
converting those bytes to characters.  The default encoding
is UTF-8.  All encodings supported elsewhere in Erlang should
be supported here.  The JSON specification mentions
auto-detection of the encoding as a possibility; the ones
that can be detected include UTF-32-BE, UTF-32-LE,
UTF-16-BE, UTF-16-LE, UTF-8, and UTF-EBDIC.  The encoding
'auto' requests auto-detection.</p>

<p>The <code>{float,true}</code> option says to convert all JSON numbers to
Erlang floats, even if they look like integers.
With this option, the result has type <code>json(L, float())</code>.</p>

<p>The <code>{float,false}</code> option says to convert integers to integers;
it is the default. With this option, the result has type
<code>json(L, number())</code>.</p>

<p>The <code>{label,binary}</code> option says to convert all JSON strings
to Erlang binaries, even if they are keys in key:value pairs.
With this option, the result has type <code>json(binary(), N)</code>.
This is the default.</p>

<p>The <code>{label,atom}</code> option says to convert keys to atoms if
possible, leaving other strings as binaries.
With this option, the result has type <code>json(json_label(), N)</code>.</p>

<p>The <code>{label,existing_atom}</code> option says to convert keys to
atoms if the atoms already exist, leaving other keys as
binaries.  All other strings remain binaries too.
With this option, the result has type <code>json(json_label(), N)</code>.</p>

<p>Other options may be added in the future.</p>

<p>The mapping from JSON to Erlang is described below in this
section.  An argument that is not a well formed IO_Data,
or that cannot be decoded, or that when decoded does not
follow the rules of JSON syntax, results in a badarg
exception.  [It would be nice if there were Erlang-wide
conventions for distinguishing these cases.]</p>

<pre><code>erlang:term_to_json(JSON) -&gt; binary()
erlang:term_to_json(JSON, Option_List) -&gt; Binary()
</code></pre>

<p>Types:</p>

<pre><code>JSON = json()
Option_List = [Option]
Option = {encoding,atom()}
       | {space,int()}
       | space
       | {indent,int()}
       | indent
</code></pre>

<p>This is a function for producing portable JSON.
It is not intended as a means for encoding arbitrary Erlang
terms.  Terms that do not fit into the mapping scheme
described below in this section result in a badarg exception.
The JSON RFC says that "The names within an object SHOULD be
unique."  JSON terms that violate this should also result in
a badarg exception.</p>

<p><code>term_to_json(X)</code> is equivalent to <code>term_to_json(X, [])</code>.</p>

<p>Converting Erlang terms to JSON results in a (logical)
character sequence, which is encoded as a sequence of
bytes, which is returned as a binary.  The default encoding
is UTF-8; this may be overridden by the encoding option.
Any encoding supported elsewhere in Erlang should be
supported here.</p>

<p>There are two options for controlling white space.
By default, none is generated.</p>

<p><code>{space,N}</code>, where N is a non-negative integer, says to
add N spaces after each colon and comma.
'space' is equivalent to <code>{space,1}</code>.
No other space is ever inserted.</p>

<p><code>{indent,N}</code>, where N is a non-negative integer, says
to add a line break and some indentation after each
comma.  The indentation is N spaces for each enclosing
[] or {}.  Note that this still does not result in any
other spaces being added; in particular ] and } will
not appear at the beginning of lines.
'indent' is equivalent to <code>{indent,1}</code>.</p>

<p>Other options may be added in the future.</p>

<h3>Converting JSON to Erlang</h3>

<p>The keywords 'null', 'false', and 'true' are converted to the
corresponding Erlang atoms. No other complete JSON forms
are converted to atoms.</p>

<p>A number is converted to an Erlang float if</p>

<ul>
<li>it contains a decimal point, or</li>
<li>it contains an exponent, or</li>
<li>it is a negative zero, or</li>
<li>the option {float,true} was passed.</li>
</ul>

<p>A JSON number that looks like an integer other than -0
will be converted to an Erlang integer unless <code>{float,true}</code>
was provided.</p>

<p>When occurring as a label in an "object", a string may on
explicit request be converted to an Erlang atom, if possible.
Otherwise, a string is converted to a UTF-8-encoded binary,
whatever the encoding used by the data source.
An empty string is converted to an empty binary.</p>

<p>A sequence is converted to an Erlang list.  The elements have
the same order in the list as in the original sequence.</p>

<p>A non-empty "object" is converted to a list of {Key,Value}
pairs suitable for processing with the 'proplists' module.
Note that proplists: does not require that keys be atoms.
An "object" with no key:value pairs is converted to
the list <code>[{}]</code>, preserving the invariant that an object
is always represented by a non-empty list of tuples.
The proplists: module will correctly view <code>[{}]</code> as holding
no keys.</p>

<p>Keys in the JSON form are always strings.  A Key is converted
to an Erlang atom if and only if</p>

<ul>
<li><code>{label,atom}</code> was specified or
<code>{label,existing_atom}</code> was specified and a suitable atom
already existed; and</li>
<li>every character in the JSON string can be held in an atom.</li>
</ul>

<p>Currently, only names made of Latin-1 characters can be turned
into atoms.  Empty keys, "", are converted to empty atoms ''.
Keys are otherwise converted to binaries, using the UTF-8
encoding, whatever the original encoding was.</p>

<p>This means that if you read and convert a JSON term now,
and save the binary somewhere, then read and convert it in
a later fully-Unicode Erlang, you will find the
representations different.  However, the order of the pairs
in a JSON "object" has no significance, and an implementation
of this specification is free to report them in any order it
likes (as given, reversed, sorted, sorted by some hash, you
name it).  Within any particular Erlang version, this
conversion is a pure function, but different Erlang releases
may change the order of pairs, so you cannot expect exactly
the same term from release to release anyway.</p>

<p>See the rationale for reasons why we do not convert to
a canonical form, for example by sorting.</p>

<p>In the spirit of "be generous in what you accept, strict in
what you produce", it might be a good idea to accept unquoted
labels in the input.  You can't accept just any old junk,
but allowing <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf" title="ECMA standard 262, ECMAScript">Javascript</a> IdentifierNames would make sense.</p>

<pre><code>IdentifierName  = IdentifierStart IdentifierPart*.
IdentifierStart = UnicodeLetter | '$' | '_' |
                  '\u' HexDigit*4
IdentifierPart  = IdentifierStart | UnicodeCombiningMark |
                  UnicodeDigit | UnicodeConnectorPunctuation
</code></pre>

<p>There are apparently JSON generators out there that do this,
so it would add value, but it is not <em>required</em>.</p>

<h3>Converting Erlang to JSON</h3>

<p>The atoms 'null', 'false', and 'true' are converted to the
corresponding JSON keywords.  No other Erlang atoms are
allowed.</p>

<p>An Erlang integer is converted to a JSON integer.
An Erlang float is converted to a JSON float, as precisely
as practical.  An Erlang float which has an integral value
is written in such a way that it will read back as a float;
suitable methods include suffixing ".0" or "e0".</p>

<p>An Erlang binary that is the UTF-8 representation of some
Unicode string is converted to a string.  No other binaries
are allowed.</p>

<p>An Erlang list all of whose elements are tuples is converted
to a JSON "object".  If the list is <code>[{}]</code> it is converted to
"{}", otherwise all the tuples must have two elements and
the first must be an atom or binary; other tuples are not
allowed.  For each <code>{Key,Value}</code> pair, the key must be an atom
or a binary that is the  UTF-8 representation of some Unicode
string; the key is converted to a JSON string.  The value must
be a JSON term.  The order of the key:value pairs in the
output is the same as the order of the <code>{Key,Value}</code> pairs 
in the list.  A list with two equivalent keys is not allowed.
Two binaries, or two atoms, are equivalent iff they are equal.
An atom and a binary are equivalent if they would convert to
the same JSON string.</p>

<p>Erlang tuples are not allowed except as elements of lists
that will be converted to JSON "objects".
No other tuples are allowed.</p>

<p>An Erlang proper list whose elements are not tuples is
converted to a JSON sequence by converting its elements in
natural order.</p>

<p>An improper list is not allowed.</p>

<p>Other Erlang terms are not allowed.  If you want to "tunnel"
other Erlang terms through JSON, fine, but it is entirely up
to you to do whatever conversion you want.</p>

<h1>Motivation</h1>

<p>As Joe Armstrong put it in his message,
"JSON seems to be ubiquitous".
It should not only be supported, it should be supported
simply, efficiently, and reliably.</p>

<p>As noted above, http://www.ietf.org/rfc/rfc4627.txt
defines an application/json Media Type that Erlang
should be able to handle "out of the box".</p>

<h1>Rationale</h1>

<p>The very first question is whether the interface should be a
"value" interface (where a chunk of data is converted to an
Erlang term in one go) or an "event stream" interface, like
the classical ESIS interface offered by SGML parsers, for
some arcane reason known as SAX these days.</p>

<p>There is room in the world for both kinds of interface.
This one is a "value" interface, which is best suited to
modest quantities of JSON data, less than a few megabytes say,
where the latency of waiting for the whole form before
processing any of it is not a problem.  Someone else might
want to write an "event stream" EEP.</p>

<p>Related to this issue, a JSON text must be an array or an object,
not, for example, a bare number.  Or so says the JSON RFC.  I do
not know whether all JSON libraries enforce this.  Since a JSON
text must be [something] or {something}, JSON texts are self-
delimiting, and it makes sense to consume them one at a time from
a stream.  Should that be part of this interface?  Maybe, maybe
not.  I note that you can separate parsing</p>

<ul>
<li>skip leading white space</li>
<li>check for '[' or '{'</li>
<li>keep on accumulating characters until you find a
matching ']' or '}', ignoring characters inside "".</li>
</ul>

<p>from conversion.  So I have separated them.  This proposal only
addresses conversion.  An extension should address parsing.  It
might work better to have that as part of an event stream EEP.</p>

<p>Let's consider conversion then.  Round trip conversion fidelity
(X -> Y -> X should be an identity function) is always nice.  Can
we have it?</p>

<p>JSON has</p>

<ul>
<li>null</li>
<li>false</li>
<li>true</li>
<li>number (integers, floats, and ratios are not distinguished)</li>
<li>string</li>
<li>sequence (called array)</li>
<li>record (called object)</li>
</ul>

<p>Erlang has</p>

<ul>
<li>atom</li>
<li>number (integers and floats are distinguished)</li>
<li>binary</li>
<li>list</li>
<li>tuple</li>
<li>pid</li>
<li>port</li>
<li>reference</li>
<li>fun</li>
</ul>

<p>More precisely, JSON syntax DOES make integers distinguishable
from floats; it is Javascript (when JSON is used with Javascript)
that fails to distinguish them.  Since we would like to use JSON
to exchange data between Erlang, Common Lisp, Scheme, Smalltalk,
and above all Python, all of which have such a distinction, it is
fortunate that JSON syntax and the RFC allow the distinction.</p>

<p>Clearly, Erlang->JSON->Erlang is going to be tricky.  To take
just one minor point, neither www.json.org nor RFC 4627 makes
an promises whatever about the range of numbers that can be
passed through JSON.  There isn't even any minimum range.  It
seems as though a JSON implementation could reject all numbers
other than 0 as too large and still conform!  This is stupid.
We can PROBABLY rely on IEEE doubles; we almost certainly cannot
expect to get large integers through JSON.</p>

<p>Converting pids, ports, and references to textual form using
<code>pid_to_list/1</code>, <code>erlang:port_to_list/1</code>, and <code>erlang:ref_to_list/1</code>
is possible.  A built in function can certainly convert back
from textual form if we want it to.  The problem is telling these
strings from other strings:  when is "&lt;0.43.0>" a pid and when is
it a string?  As for funs, let's not go there.</p>

<p>Basically, converting Erlang terms to JSON so that they can be
reconstructed as the same (or very similar) Erlang terms would
involve something like this:</p>

<pre><code>atom   -&gt; string
number -&gt; number
binary -&gt; {"type":"binary", "data":[&lt;bytes&gt;]}
list   -&gt; &lt;list&gt;, if it's a proper list
list   -&gt; {"type":"dotted", "data":&lt;list&gt;, "end":&lt;last cdr&gt;}
tuple  -&gt; {"type":"tuple",  "data":&lt;tuple as list&gt;}
pid    -&gt; {"type":"pid",    "data":&lt;pid as string&gt;}
port   -&gt; {"type":"port",   "data":&lt;port as string&gt;}
ref    -&gt; {"type":"ref",    "data":&lt;ref as string&gt;}
fun    -&gt; {"module":&lt;m&gt;, "name":&lt;n&gt;, "arity":&lt;a&gt;}
fun    -&gt; we're pushing things a bit for anything else.
</code></pre>

<p>This is not part of the specification because I am not proposing
JSON as a representation for arbitrary Erlang data.  I am making
the point that we COULD represent (most) Erlang data in JSON if
we really wanted to, but it is not an easy or natural fit.  For
that we have Erlang binary format and we have UBF.  To repeat,
we have no reason to believe that a JSON->JSON copier that works
by decoding JSON to an internal form and recoding it for output
will preserve Erlang terms, even encoded like this.</p>

<p>No, the point of JSON support in Erlang is to let Erlang programs
deal with the JSON data that other people are sending around the
net, and to send JSON data to other programs (like scripts in Web
browsers) that are expecting plain old JSON.  The round trip
conversion we need to care about is JSON -> Erlang -> JSON.</p>

<p>Here too we run into problems.  The obvious way to represent
{"a":A, "b":B} in Erlang is <code>[{'a',A},{'b',B}]</code>, and the obvious
way to represent a string is as a list of characters.  But in
JSON, an empty list, an empty "object", and an empty string are
all clearly distinct, so must be translated to different Erlang
terms.  Bearing this in mind, here's a first cut at mapping
JSON to Erlang:</p>

<pre><code>- null     =&gt; the atom 'null'
- false    =&gt; the atom 'false'
- true     =&gt; the atom 'true'
- number   =&gt; a float if there is a decimal point or exponent,
           =&gt; the float -0.0 if it is a minus sign followed by
              one or more zeros, with or without a decimal point
              or exponent
           =&gt; an integer otherwise
- string   =&gt; a UTF-8-encoded binary
- sequence =&gt; a list
- object   =&gt; a list of {Key,Value} pairs
           =&gt; the empty tuple {} for an empty {} object
</code></pre>

<p>Since Erlang does not currently allow the full range of
Unicode characters in an atom, a Key should be an atom if
each character of a label fits in Latin 1, or a binary if
it does not.</p>

<p>Let's examine "objects" a little more closely.  Erlang
programmers are used to working with lists of {Key,Value}
pairs.  The standard library even include orddict, which
works with just such lists (although they must be sorted).
However, there is something distasteful about having empty
objects convert to empty tuples, but non-empty objects to
empty lists, and there is also something distasteful about
lists converting to sequence or objects depending on what
is inside them.  What is distasteful here has something to
do with TYPES.  Erlang doesn't have static types, but that
does not mean that types are not useful as a design tool,
or that something resembling type consistency is not useful
to people.  The fact that Erlang tuples happen to use curly
braces is just icing on the cake.  The first draft of this
EEP used lists; that was entirely R.A.O'K's own work.  It
was then brought to his attention that Joe Armstrong thought
converting "objects" to tuples was the right thing to do.
So the next draft did that.  Then other alternatives were
brought up.  I'm currently aware of</p>

<ul>
<li><p>Objects are tuples</p>

<ul>
<li>A. <code>{{K1,V1}, ..., {Kn,Vn}}</code>.
This is the result of <code>list_to_tuple/1</code> applied to a <br />
proplist.  There are no library functions to deal
with such things, but they are unambiguous and
relatively space-efficient.</li>
<li>B. <code>{object,[{K1,V1}, ..., {Kn,Vn}]}</code>
This is a proplist wrapped in a tuple purely to
distinguish it from other lists.  This offers
simple type testing (objects are tuples) and simple
field processing (they contain proplists).
There seems to be no consensus for what the tag
should be, 'obj' (gratuitous abbreviation), 'json'
(but even the numbers binaries and lists are JSON),
'object' seems to be least objectionable.</li>
<li>C. <code>{[{K1,V1},...,{Kn,Vn}]}</code>
Like B, but there isn't any need for a tag.</li>
</ul>

<p>A and B are due to Joe Armstrong; I cannot recall who
thought of C.  It has recently had supporters.</p></li>
<li><p>Objects are lists</p>

<ul>
<li>D. Empty objects are <code>{}</code>.
This was my original proposal.  Simple but non-uniform
and clumsy.</li>
<li>E. Empty objects are <code>[{}]</code>.
This came from the Erlang mailing list; I have forgotten
who proposed it.  It's brilliant: objects are always
lists of tuples.</li>
<li>F. Empty objects are 'empty'.
Like A but a tiny fraction more space-efficient.</li>
</ul></li>
</ul>

<p>We can demonstrate handling "objects" in each of these forms:</p>

<pre><code>json:is_object(X) -&gt; is_tuple(X).          % A

json:is_object({object,X}) -&gt; is_list(X).  % B

json:is_object({X}) -&gt; is_list(X).         % C

json:is_object({}) -&gt; true;                % D
json:is_object([{_,_}|_]) -&gt; true;
json:is_object(_) -&gt; false.   

json:is_object([X|_]) -&gt; is_tuple(X).      % E

json:is_object(empty) -&gt; true;             % F
json:is_object([{_,_}|_]) -&gt; true;
json:is_object(_) -&gt; false.
</code></pre>

<p>Of these, A, B, C, and E can easily be used in clause heads,
and E is the only one that is easy to use with proplist.
After much scratching of the head and floundering around,
E does it.</p>

<p>We might consider adding an 'object' option:</p>

<pre><code>{object,tuple}    representation A
{object,pair}     representation B.
{object,wrap}     representation C.
{object,list}     representation E.
</code></pre>

<p>For conversion from Erlang to JSON,</p>

<pre><code>{T1,...,Tn}       0 or more tuples
{object,L}        size 2, 1st element atom, 2nd list
{L}               size 1, only element a list
</code></pre>

<p>are all recognisable, so <code>term_to_json/[1,2]</code> could accept
all of them without requiring an option.</p>

<p>There is a long term reason why we want some such option.
Both lists and tuples are just WRONG.  The right data structure to
represent JSON "objects" is the one that I call "frames" and Joe
Armstrong calls "proper structs".  At some point in the future we
will definitely want to have <code>{object,frame}</code> as a possibility.</p>

<p>Suppose you are receiving JSON data from a source that does
not distinguish between integers and floating point numbers?
Perl, for example, or even more obviously, Javascript itself.
In that case some floating point numbers may have been written
in integer style more or less accidentally.  In such a case, you
may want all the numbers in a JSON form converted to Erlang
floats.  <code>{float,true}</code> was provided for that purpose.</p>

<p>The corresponding mapping from Erlang to JSON is</p>

<pre><code>- atom   =&gt; itself if it is null, false, or true
         =&gt; error otherwise
- number =&gt; itself; use full precision for floats,
            and always include a decimal point or exponent
            in a float
- binary =&gt; if the binary is a well formed UTF-8 encoding
            of some string, that string
         =&gt; error otherwise
- tuple  =&gt; if all elements are {Key,Value} pairs with
            non-equivalent keys, then a JSON "object",
         =&gt; error otherwise
- list   =&gt; if it is proper, itself as a sequence
         =&gt; error otherwise
- otherwise, an error
</code></pre>

<p>There is an issue here with keys.  The RFC says that "The names
within an object SHOULD be unique."  In the spirit of "be
generous in what you accept, strict in what you generate", we
really ought to check that.  The only time <code>term_to_json/[1,2]</code>
terminate successfully should be when the output is absolutely
perfect JSON.  I did toy with the idea of an option to allow
duplicate labels, but if I want to send such non-standard data,
who can I send it to?  Another Erlang program?  Then I would be
better to use external binary format.  So the only options now
allowed are ones to affect white space.  One might add an
option later to specify the order of key:value pairs somehow,
but options that do not affect the semantics are appropriate.</p>

<p>On second thoughts, look at the <a href="http://json-rpc.org/wd/JSON-RPC-1-1-WD-20060807.html" title="The JSON RPC 1.1 draft specification">JSON-RPC 1.1 draft</a>.
It says, in section 6.2.4 "Member Sequence":</p>

<blockquote>
  <p>Client implementations SHOULD strive to order the members of
the Procedure Call object such that the server is able to
employ a streaming strategy to process the contents.  At the
very least, a client SHOULD ensure that the version member
appears first and the params member last.
This means that for conformity with JSON-RPC,</p>
</blockquote>

<pre><code>term_to_json([{version,&lt;&lt;"1.1"&gt;&gt;},
              {method, &lt;&lt;"sum"&gt;&gt;},
              {params, [17,25]}])
</code></pre>

<p>should not re-order the pairs.  Hence the current specification
says the order is preserved and does not provide any means for
re-ordering.  If you want a standard order, program it outside.</p>

<p>How should the "duplicate label" error be reported?  There are two
ways to report such errors in Erlang:  raise 'badarg' exceptions,
or return either <code>{ok,Result}</code> or <code>{error,Reason}</code> answers.  I'm
really not at all sure what to do here.  I ended up with 'raise
badarg' because that's what things like <code>binary_to_term/1</code> do.</p>

<p>At the moment, I specify that the Erlang terms use UTF-8 and only
UTF-8.  This is by far the simplest possibility.  However, we
could certainly add</p>

<pre><code>{internal,Encoding}
</code></pre>

<p>options to say what Encoding to use or assume for binaries.  The
time to add that, I think, is when there is a demonstrated need.</p>

<p>There are five "round trip" issues left:</p>

<ul>
<li><p>all information about white space is lost.
This is not a problem, because it has no significance.</p></li>
<li><p>decimal->binary->decimal conversion of floating point numbers
may introduce error unless techniques like those described in <br />
the Scheme report are used to do these conversions with high
accuracy.  This is a general problem for Erlang, and a general
problem for JSON.</p></li>
<li><p>there is another JSON library for Erlang that always converts
integers outside the 32-bit range to floating point.  This seems
like a bad idea.  There are languages (Scheme, Common Lisp,
SWI Prolog, Smalltalk) with JSON libraries that have bignums.
Why put an arbitrary restriction on our ability to communication
with them?  Any JSON implementation that is unable to cope with
large integers as integers is (or should be) perfectly able to
convert such numbers to floating-point for itself.  It seems
specially silly to do this when you consider that the program on
the other end might itself be in Erlang.  So we expect that if T
is of type <code>json(binary(),integer())</code> then</p>

<pre><code>json_to_term(term_to_json(T), [{label,binary}])
</code></pre>

<p>should be identical to T, up to re-ordering of attribute pairs.</p></li>
<li><p>conversion of a string to a binary and then a binary to a
string will not always yield the same representation, but
what you get will represent the same string.  Example,
"\0041" will read as <code>&lt;&lt;65&gt;&gt;</code> which will display as "A".</p></li>
<li><p>Technically speaking the Unicode "surrogates" are not
characters.  The RFC allows characters outside the Basic
Multilingual Plane to be written as UTF-8 sequences, or
to be written as 12-character \uHIGH\uLOWW surrogate pair
escapes.  Something with a bare \uHIGH or \uLOWW surrogate
code point is not, technically speaking, a legal Unicode
string, so a UTF-8 sequence for such a code point should
not appear.  A \uHIGH or \uLOWW escape sequence on its own
should not appear either; it would be just as much of a
syntax error as a byte with value 255 in a UTF-8 sequence.
We actually have two problems:</p>

<ul>
<li><p>(a) Some languages may be sloppy and may allow singleton
surrogates inside strings.  Should Erlang be equally
sloppy?  Should this just be allowed?</p></li>
<li><p>(b) Some languages (and yes, I do mean Java) don't really
do UTF-8, but instead first break a sequence of Unicode
characters into 16-bit chunks (UTF-16) and then encode
the chunks as UTF-8, producing what is quite definitely
illegal UTF-8.  Since there is a lot of Java code in the
world, how do we deal with this?</p>

<p>Be generous in what you accept:  the 'utf8' decoder
should quietly accept "UTF-Java", converting
separately encoded surrogates to a single numeric
code, and converting singleton surrogates <em>as if</em> they
were characters.</p>

<p>Be strict in what you generate:  never generate
UTF-Java when the requested encoding is 'utf8';
have a separate 'java' encoding that can be requested
instead.</p></li>
</ul></li>
</ul>

<p>Hynek Vychodil is vehement that the only acceptable way to handle
JSON labels is as binaries.  His argument against <code>{label,atom}</code> is
sound:  as noted above, that option is only usable within a trust
boundary.  His argument against <code>{label,existing_atom}</code> is that if
you convert a JSON form at one time in one node, and then store
the Erlang term in a file or send it across a wire or in any
other way make it available at another node or another time,
then it won't match the same JSON form converted at that time in
that node.  This is true, but there are plenty of other round
trip issues as well.  Data converted using <code>{float,true}</code> will not
match data converted using <code>{float,false}</code>.  The handling of
duplicate labels may vary.  The order of {key,value} pairs is
particularly likely to vary.  For all programming languages and
libraries, if you want to move JSON data around in time or
space, the <em>only</em> reliable way to do that is to move it <em>as</em>
(possibly compressed) JSON data, not as something else.  You
can expect a JSON form read at one time/place to be equivalent
to the same form read at another time/place; you cannot expect
it to be identical.  Any code that does is essentially buggy,
whether <code>{label,existing_atom}</code> is used or not.  Here is an
example that shows that the problem is ineradicable.</p>

<p>Suppose we have the JSON form
"[0.123456789123456789123456789123456]".
Two Erlang nodes on different machines read this and
convert it to an Erlang term.  One of them sends its term to
the other, which compares them.  To its astonishment, they
are not identical!  Why?  Well, it could be that they use
different floating-point precisions.  On one of Erlang's main
platforms, 128-bit floats are supported.  (The example needs
128 bits.)  On its other main platform, 80-bit floats are
supported.  (In neither case am I saying that Erlang does,
only that the hardware does.)  Indeed, modern versions of the
second platform usually work with 64-bit floats.  Let us
suppose that they both stick with 64-bit floats instead.
What if one of the systems is an IBM/370 with its non-IEEE
doubles?  So suppose they are both using IEEE 64-bit floats.
They will use different C libraries to do the initial
decimal-to-binary conversion, so the number may be rounded
differently.  And if one is Windows and another is Linux or
Solaris, they WILL use different libraries.  Should Erlang
use its own code (which might not be a bad idea), we would
still have trouble talking to machines with non-IEEE doubles,
which are still in use.  Even Java, which originally wanted
to have bit-identical results everywhere, eventually retreated.</p>

<p>There is one important issue for JSON generation, and that is
what white space should be generated.  Since JSON is supposed to
be "human readable", it would be nice if it could be indented,
and if it could be kept to a reasonable line width.  However,
appearances to the contrary, JSON has to be regard as a binary
format.  There is no way to insert line breaks inside strings.
Javascript doesn't have any analogue of C's <backslash><newline>
continuation; it can always join the pieces with '+'.  JSON has
inherited the lack (no line continuation) but not the remedy
(you may not use '+' in JSON).  So a JSON form containing a
1000-character string cannot be fitted into 80-column lines;
it just cannot be done.</p>

<p>The main thing I have not accounted for is the <code>{label,_}</code>.
option of <code>json_to_term/2</code>.  For normal Erlang purposes, it is
much nicer (and somewhat more efficient) to deal with</p>

<pre><code>[{name,&lt;&lt;"fred"&gt;&gt;},{female,false},{age,65}]
</code></pre>

<p>than with</p>

<pre><code>[{&lt;&lt;"name"&gt;&gt;,&lt;&lt;"fred"&gt;&gt;},{&lt;&lt;"female"&gt;&gt;,false},{&lt;&lt;"age"&gt;&gt;,65}]
</code></pre>

<p>If you are communicating with a trusted source that deals with
a known small number of labels, fine.  There are limits on the
number of atoms Erlang can deal with.  A small test program
that looped creating atoms and putting them into a list ticked
over happily until shortly after its millionth atom, and then
hung there burning cycles apparently getting nowhere.  Also,
the atom table is shared by all processes on an Erlang node,
so garbage collecting it is not as cheap as it might be.  As
a system integrity measure, therefore, it is useful to have a
mode of operation in which json<em>to</em>term never creates atoms.
But Erlang offers a third possibility:  there is a built-in
<code>list_to_existing_atom/1</code> function that returns an atom only if
that atom already exists.  Otherwise it raises an exception.
So there are three cases:</p>

<ul>
<li><p><code>{label,binary}</code></p>

<p>Always convert labels to binaries.
This is always safe and always clumsy.
Since &lt;&lt;"xxx">> syntax exists in Erlang,
it isn't <em>that</em> clumsy.  It is uniform,
and stable, in that it does not depend
on whether Erlang atoms support Unicode or
not, or what other modules have been loaded.</p></li>
<li><p><code>{label,atom}</code></p>

<p>Always convert labels to atoms if all their
characters are allowed in atoms, leave them
as binaries otherwise.</p>

<p>This is more convenient for Erlang programming.
However, it is only really usable with a partner
that you trust.  Since much communication takes
place within trust boundaries, it definitely has
a place.  If this were not so, term<em>to</em>binary/1
would be of no use!</p></li>
<li><p><code>{label,existing_atom}</code></p>

<p>Convert labels that match the names of existing
atoms to those atoms, leave all others as binaries.
If a module mentions an atom, and goes looking for
that atom as a key, it will find it.  This is safe
<em>and</em> convenient.  The only real issue with it is
that the same JSON term converted at different times
(in the same Erlang node) may be converted differently.
This usually won't matter.</p></li>
</ul>

<p>In previous drafts I selected <code>existing_atom</code> as the default,
because that's the option I like best.  It's the one that would
most simplify the code that I would like to write.  However, one
must also consider conversion issues.  Some well considered
existing JSON libraries for Erlang always use binaries.</p>

<p>There is no <code>{string,XXX}</code> option.  That's because I see the
strings in JSON as "payload", as unpredictable data that are
being transmitted, that one does not <em>expect</em> to match against.
This is in marked contrast with labels, which are "structure"
rather than data, and which one expects to match against a lot.
I did briefly consider a <code>{string,list|binary}</code> option, but these
days Erlang is so good at matching binaries that there didn't
seem to be much point.</p>

<p>This raises a general issue about binaries.  One of the reasons
for liking atoms as labels is that atoms are stored uniquely,
and binaries are not.  This extends to <code>term_to_binary()</code>, which
compresses repeated references to identical atoms, but not
repeated references to equal binaries.  There is no reason that
a C implementation of <code>json_to_term/[1,2]</code> could not keep track
of which labels have been seen and share references to repeated
ones.  For example,</p>

<pre><code>[{"name":"root","command":"java","cpu":75.7},
 {"name":"ok","command":"iropt","cpu":1.5}
]
</code></pre>

<p>-- extracted from a run of the 'top' command showing that my
C compilation was getting a tiny fraction of the machine,
while some Java program run by root was getting the lion's share --
would convert to Erlang as the equivalent of</p>

<pre><code>N = &lt;&lt;"name"&gt;&gt;,
M = &lt;&lt;"command"&gt;&gt;,
P = &lt;&lt;"cpu"&gt;&gt;,
[[{N,&lt;&lt;"root"&gt;&gt;},{M,&lt;&lt;"java"&gt;&gt;}, {P,75.7}],
 [{N,&lt;&lt;"ok"&gt;&gt;},  {M,&lt;&lt;"iropt"&gt;&gt;},{P, 1.5}]
]
</code></pre>

<p>getting much of the space saving that atoms would use.  There is
of course no way for a pure Erlang program to detect whether such
sharing is happening or not.  It would be nice if</p>

<pre><code>term_to_binary(json_to_term(JSON))
</code></pre>

<p>preserved such sharing.</p>

<p>Another issue that has been raised concerns encoding.  Some people
have said that they would like (a) to allow input encodings other
than UTF-8, (b) to have strings reported in their original
encoding, rather than UTF-8, so that (c) strings can be slices of
the original binary.  What does the JSON specification actually
say?  Section 3, Encoding:</p>

<blockquote>
  <p>JSON text SHALL be encoded in Unicode.
The default encoding is UTF-8.</p>
</blockquote>

<p>This is not quite as clear as it might be.  There is explicit
mention of UTF-32 and UTF-16 (both of them in big- and little-
endian forms).  But is SCSU "Unicode"?  Is BOCU?  How about
<a href="http://unicode.org/reports/tr16/" title="Uniode technical report #16, UTF-EBCDIC">UTF-EBCDIC</a>?  That's right, there is a legal way to encode
something in "Unicode" in which the JSON special characters
[]{},:\" do not have their ASCII values.  There does not seem
to be any reason to suppose that this is forbidden, and on an
IBM mainframe I would expect it to be useful.  Until the day
someone ports Erlang to a z/Series machine, this is mainly of
academic interest, but we don't want to paint ourselves into
any corners.</p>

<p>Suppose we did represent strings in their native encoding.
What then?  First, a string that contained an escape sequence
of any kind could not be held as a slice of the source anyway.
Nor could a string that spanned two or more chunks of the
IO_Data input.  The really big problem is that there would be
no indication of what the encoding actually was, so that we
would end up regarding logically equal strings from different
sources as unequal and logically unequal strings as equal.</p>

<p>I do not want to forbid strings in the result being slices of
an original binary.  In the common case when the input is
UTF-8 and the string does not contain any escapes, so that it
<em>can</em> be done, an implementation should definitely be free to
exploit that.  As this EEP currently stands, it is.  What we
cannot do is to <em>require</em> such sharing, because it generally
won't work.</p>

<p>It has been suggested to me that it might be better for the
result of <code>term_to_json/[1,2]</code> to be <code>iodata()</code> rather than a
<code>binary()</code>.  Anything that would have accepted <code>iodata()</code> will be
happy with a <code>binary()</code>, so the question is whether it is better
for the implementation, whether perhaps there are chunks of stuff
that have to be copied using a <code>binary()</code> but can be shared using
<code>iodata()</code>.  Thanks to the encoding issue, I don't really think so.
This might be a good time to point out why the encoding is done
here rather than somewhere else.  If you know that you are
generating stuff that will be encoded into character set X, then
you can avoid generating characters that are not in that
character set.  You can generate \u sequences instead.  Of course
JSON itself requires UTF-8, but what if you are going to send it
through some other transport?  With <code>{encoding,ascii}</code> you are out
of trouble all the way.  So for now I am sticking with <code>binary()</code>.</p>

<p>The final issue is whether these functions should go in the
erlang: module or in some other module (perhaps called json:).</p>

<ul>
<li><p>If another module, then there is no barrier to adding other
functions.  For example, we might offer functions to test
whether a term is a JSON term, or an IO_Data represents a JSON
term, or alternative functions that present results in some
canonical form.</p></li>
<li><p>If another module, then someone looking for a JSON module might
find one.</p></li>
<li><p>If another module, then this interface can easily be prototyped
without any modification to the core Erlang system.</p></li>
<li><p>If another module, then someone who doesn't need this feature
need not load it.</p></li>
</ul>

<p>Conversely,</p>

<ul>
<li><p>If another module, then it is too easy to bloat the interface.
We don't <em>need</em> such testing functions, as we can always catch
the badarg exception from the existing ones.  We don't <em>need</em>
extra canonicalising functions, because we can add options to
the existing ones.  Something that subtly encourages us to
keep the number of functions down is a Good Thing.</p></li>
<li><p>Every Erlang programmer ought to be familiar with the erlang:
module, and when looking for any feature, ought to start by
looking there.</p></li>
<li><p>There are JSON implementations in Erlang already; we know what
it is like to use such a thing, and we only need to settle the
fine details of the implementation.  We know that it can be
implemented.  Now we want something that is always there and
always the same and is as efficient as practical.</p></li>
<li><p>In particular, we know that the feature is useful, and we know
that in applications where it is used, it will be used often,
so we want it to go about as fast as term<em>to</em>binary/1 and
<code>binary_to_term/1</code>.  So we'd really like it to be implemented in
C, ideally inside the emulator.  Erlang does not make dynamic
loading of foreign code modules easy.</p></li>
</ul>

<p>It's a delicate balance.  On the whole, I still think that putting
these functions in erlang: is a good idea, but more reasons on
both sides would be useful.</p>

<h1>Backwards Compatibility</h1>

<p>There are no <code>term_to_json/N</code> or <code>json_to_term/N</code> functions in
the erlang: module now, so adding them should not break
anything.  These functions will NOT be automatically imported;
it will be necessary to use an explicit erlang: prefix.  So
any existing code that uses these function names won't notice
any change.</p>

<h1>Reference Implementation</h1>

<p>None.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0018","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 28-Jul-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 18: \u003ca href=\"eep-0018.md\" title=\"EEP Source\"\u003e JSON bifs\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eAccording to the \u003ca href=\"http://www.json.org/\" title=\"The JSON web site\"\u003eJSON web site\u003c/a\u003e,\n\"JSON (JavaScript Object Notation) is a lightweight\ndata-interchange format. It is easy for humans to read and write.\nIt is easy for machines to parse and generate.\"\u003c/p\u003e\n\n\u003cp\u003eJSON is specified by \u003ca href=\"http://www.ietf.org/rfc/rfc4627.txt\" title=\"The JSON RFC\"\u003eRFC 4627\u003c/a\u003e, which defines a Media Type\napplication/json.\u003c/p\u003e\n\n\u003cp\u003eThere are JSON libraries for a wide range of languages, so it is a\nuseful format.  \u003ca href=\"http://incubator.apache.org/couchdb/\" title=\"CouchDB\"\u003eCouchDB\u003c/a\u003e \u003ca href=\"http://wiki.apache.org/couchdb/\" title=\"CouchDB\"\u003euses\u003c/a\u003e JSON as its storage format and in\nits RESTful interface; it offers an alternative to Mnesia for some\nprojects, and is accessible from many more languages.  There are\nalready JSON bindings for Erlang, such as the \u003ca href=\"www.lshift.net/blog/2007/02/17/json-and-json-rpc-for-erlang\" title=\"rfc4627 module for Erlang from LShift\"\u003erfc4627\u003c/a\u003e module\nfrom LShift, but on the 24th of July 2008, Joe Armstrong suggested\nthat it would be worth having built in functions to convert Erlang\nterms to and from the JSON format.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eterm_to_json        -- convert a term to JSON form\njson_to_term        -- convert a JSON form to Erlang\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eThree new types are added to the vocabulary of well known\ntypes to be used in edoc.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e@type json_label() = atom() + binary().\n@type json(L, N) = null + false + true\n                 + N                % some kind of number\n                 + [{}]             % empty \"object\"\n                 + [{L, json(L,N)}] % non-empty \"object\"\n                 + [json(L, N)].    % \"array\"\n                 | [json(L, N)] | tuple({L, json(L, N)}).\n@type json() = json(json_label(), number()).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eNew functions\u003c/h3\u003e\n\n\u003cp\u003eFour new functions are added to the erlang: module.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:json_to_term(IO_Data) -\u0026gt; json()\nerlang:json_to_term(IO_Data, Option_List) -\u0026gt; json()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eIO_Data = iodata()\nOption_List = [Option]\nOption = {encoding,atom()}\n       | {float,bool()}\n       | {label,binary|existing_atom|atom}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003ejson_to_term(X)\u003c/code\u003e is equivalent to \u003ccode\u003ejson_to_term(X, [])\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eIO_Data\u003c/code\u003e implies a sequence of bytes.\u003c/p\u003e\n\n\u003cp\u003eThe encoding option says what character encoding to use for\nconverting those bytes to characters.  The default encoding\nis UTF-8.  All encodings supported elsewhere in Erlang should\nbe supported here.  The JSON specification mentions\nauto-detection of the encoding as a possibility; the ones\nthat can be detected include UTF-32-BE, UTF-32-LE,\nUTF-16-BE, UTF-16-LE, UTF-8, and UTF-EBDIC.  The encoding\n'auto' requests auto-detection.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e{float,true}\u003c/code\u003e option says to convert all JSON numbers to\nErlang floats, even if they look like integers.\nWith this option, the result has type \u003ccode\u003ejson(L, float())\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e{float,false}\u003c/code\u003e option says to convert integers to integers;\nit is the default. With this option, the result has type\n\u003ccode\u003ejson(L, number())\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e{label,binary}\u003c/code\u003e option says to convert all JSON strings\nto Erlang binaries, even if they are keys in key:value pairs.\nWith this option, the result has type \u003ccode\u003ejson(binary(), N)\u003c/code\u003e.\nThis is the default.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e{label,atom}\u003c/code\u003e option says to convert keys to atoms if\npossible, leaving other strings as binaries.\nWith this option, the result has type \u003ccode\u003ejson(json_label(), N)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e{label,existing_atom}\u003c/code\u003e option says to convert keys to\natoms if the atoms already exist, leaving other keys as\nbinaries.  All other strings remain binaries too.\nWith this option, the result has type \u003ccode\u003ejson(json_label(), N)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eOther options may be added in the future.\u003c/p\u003e\n\n\u003cp\u003eThe mapping from JSON to Erlang is described below in this\nsection.  An argument that is not a well formed IO_Data,\nor that cannot be decoded, or that when decoded does not\nfollow the rules of JSON syntax, results in a badarg\nexception.  [It would be nice if there were Erlang-wide\nconventions for distinguishing these cases.]\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:term_to_json(JSON) -\u0026gt; binary()\nerlang:term_to_json(JSON, Option_List) -\u0026gt; Binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eJSON = json()\nOption_List = [Option]\nOption = {encoding,atom()}\n       | {space,int()}\n       | space\n       | {indent,int()}\n       | indent\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is a function for producing portable JSON.\nIt is not intended as a means for encoding arbitrary Erlang\nterms.  Terms that do not fit into the mapping scheme\ndescribed below in this section result in a badarg exception.\nThe JSON RFC says that \"The names within an object SHOULD be\nunique.\"  JSON terms that violate this should also result in\na badarg exception.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eterm_to_json(X)\u003c/code\u003e is equivalent to \u003ccode\u003eterm_to_json(X, [])\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eConverting Erlang terms to JSON results in a (logical)\ncharacter sequence, which is encoded as a sequence of\nbytes, which is returned as a binary.  The default encoding\nis UTF-8; this may be overridden by the encoding option.\nAny encoding supported elsewhere in Erlang should be\nsupported here.\u003c/p\u003e\n\n\u003cp\u003eThere are two options for controlling white space.\nBy default, none is generated.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e{space,N}\u003c/code\u003e, where N is a non-negative integer, says to\nadd N spaces after each colon and comma.\n'space' is equivalent to \u003ccode\u003e{space,1}\u003c/code\u003e.\nNo other space is ever inserted.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e{indent,N}\u003c/code\u003e, where N is a non-negative integer, says\nto add a line break and some indentation after each\ncomma.  The indentation is N spaces for each enclosing\n[] or {}.  Note that this still does not result in any\nother spaces being added; in particular ] and } will\nnot appear at the beginning of lines.\n'indent' is equivalent to \u003ccode\u003e{indent,1}\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eOther options may be added in the future.\u003c/p\u003e\n\n\u003ch3\u003eConverting JSON to Erlang\u003c/h3\u003e\n\n\u003cp\u003eThe keywords 'null', 'false', and 'true' are converted to the\ncorresponding Erlang atoms. No other complete JSON forms\nare converted to atoms.\u003c/p\u003e\n\n\u003cp\u003eA number is converted to an Erlang float if\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eit contains a decimal point, or\u003c/li\u003e\n\u003cli\u003eit contains an exponent, or\u003c/li\u003e\n\u003cli\u003eit is a negative zero, or\u003c/li\u003e\n\u003cli\u003ethe option {float,true} was passed.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA JSON number that looks like an integer other than -0\nwill be converted to an Erlang integer unless \u003ccode\u003e{float,true}\u003c/code\u003e\nwas provided.\u003c/p\u003e\n\n\u003cp\u003eWhen occurring as a label in an \"object\", a string may on\nexplicit request be converted to an Erlang atom, if possible.\nOtherwise, a string is converted to a UTF-8-encoded binary,\nwhatever the encoding used by the data source.\nAn empty string is converted to an empty binary.\u003c/p\u003e\n\n\u003cp\u003eA sequence is converted to an Erlang list.  The elements have\nthe same order in the list as in the original sequence.\u003c/p\u003e\n\n\u003cp\u003eA non-empty \"object\" is converted to a list of {Key,Value}\npairs suitable for processing with the 'proplists' module.\nNote that proplists: does not require that keys be atoms.\nAn \"object\" with no key:value pairs is converted to\nthe list \u003ccode\u003e[{}]\u003c/code\u003e, preserving the invariant that an object\nis always represented by a non-empty list of tuples.\nThe proplists: module will correctly view \u003ccode\u003e[{}]\u003c/code\u003e as holding\nno keys.\u003c/p\u003e\n\n\u003cp\u003eKeys in the JSON form are always strings.  A Key is converted\nto an Erlang atom if and only if\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e{label,atom}\u003c/code\u003e was specified or\n\u003ccode\u003e{label,existing_atom}\u003c/code\u003e was specified and a suitable atom\nalready existed; and\u003c/li\u003e\n\u003cli\u003eevery character in the JSON string can be held in an atom.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCurrently, only names made of Latin-1 characters can be turned\ninto atoms.  Empty keys, \"\", are converted to empty atoms ''.\nKeys are otherwise converted to binaries, using the UTF-8\nencoding, whatever the original encoding was.\u003c/p\u003e\n\n\u003cp\u003eThis means that if you read and convert a JSON term now,\nand save the binary somewhere, then read and convert it in\na later fully-Unicode Erlang, you will find the\nrepresentations different.  However, the order of the pairs\nin a JSON \"object\" has no significance, and an implementation\nof this specification is free to report them in any order it\nlikes (as given, reversed, sorted, sorted by some hash, you\nname it).  Within any particular Erlang version, this\nconversion is a pure function, but different Erlang releases\nmay change the order of pairs, so you cannot expect exactly\nthe same term from release to release anyway.\u003c/p\u003e\n\n\u003cp\u003eSee the rationale for reasons why we do not convert to\na canonical form, for example by sorting.\u003c/p\u003e\n\n\u003cp\u003eIn the spirit of \"be generous in what you accept, strict in\nwhat you produce\", it might be a good idea to accept unquoted\nlabels in the input.  You can't accept just any old junk,\nbut allowing \u003ca href=\"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf\" title=\"ECMA standard 262, ECMAScript\"\u003eJavascript\u003c/a\u003e IdentifierNames would make sense.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eIdentifierName  = IdentifierStart IdentifierPart*.\nIdentifierStart = UnicodeLetter | '$' | '_' |\n                  '\\u' HexDigit*4\nIdentifierPart  = IdentifierStart | UnicodeCombiningMark |\n                  UnicodeDigit | UnicodeConnectorPunctuation\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere are apparently JSON generators out there that do this,\nso it would add value, but it is not \u003cem\u003erequired\u003c/em\u003e.\u003c/p\u003e\n\n\u003ch3\u003eConverting Erlang to JSON\u003c/h3\u003e\n\n\u003cp\u003eThe atoms 'null', 'false', and 'true' are converted to the\ncorresponding JSON keywords.  No other Erlang atoms are\nallowed.\u003c/p\u003e\n\n\u003cp\u003eAn Erlang integer is converted to a JSON integer.\nAn Erlang float is converted to a JSON float, as precisely\nas practical.  An Erlang float which has an integral value\nis written in such a way that it will read back as a float;\nsuitable methods include suffixing \".0\" or \"e0\".\u003c/p\u003e\n\n\u003cp\u003eAn Erlang binary that is the UTF-8 representation of some\nUnicode string is converted to a string.  No other binaries\nare allowed.\u003c/p\u003e\n\n\u003cp\u003eAn Erlang list all of whose elements are tuples is converted\nto a JSON \"object\".  If the list is \u003ccode\u003e[{}]\u003c/code\u003e it is converted to\n\"{}\", otherwise all the tuples must have two elements and\nthe first must be an atom or binary; other tuples are not\nallowed.  For each \u003ccode\u003e{Key,Value}\u003c/code\u003e pair, the key must be an atom\nor a binary that is the  UTF-8 representation of some Unicode\nstring; the key is converted to a JSON string.  The value must\nbe a JSON term.  The order of the key:value pairs in the\noutput is the same as the order of the \u003ccode\u003e{Key,Value}\u003c/code\u003e pairs \nin the list.  A list with two equivalent keys is not allowed.\nTwo binaries, or two atoms, are equivalent iff they are equal.\nAn atom and a binary are equivalent if they would convert to\nthe same JSON string.\u003c/p\u003e\n\n\u003cp\u003eErlang tuples are not allowed except as elements of lists\nthat will be converted to JSON \"objects\".\nNo other tuples are allowed.\u003c/p\u003e\n\n\u003cp\u003eAn Erlang proper list whose elements are not tuples is\nconverted to a JSON sequence by converting its elements in\nnatural order.\u003c/p\u003e\n\n\u003cp\u003eAn improper list is not allowed.\u003c/p\u003e\n\n\u003cp\u003eOther Erlang terms are not allowed.  If you want to \"tunnel\"\nother Erlang terms through JSON, fine, but it is entirely up\nto you to do whatever conversion you want.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eAs Joe Armstrong put it in his message,\n\"JSON seems to be ubiquitous\".\nIt should not only be supported, it should be supported\nsimply, efficiently, and reliably.\u003c/p\u003e\n\n\u003cp\u003eAs noted above, http://www.ietf.org/rfc/rfc4627.txt\ndefines an application/json Media Type that Erlang\nshould be able to handle \"out of the box\".\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe very first question is whether the interface should be a\n\"value\" interface (where a chunk of data is converted to an\nErlang term in one go) or an \"event stream\" interface, like\nthe classical ESIS interface offered by SGML parsers, for\nsome arcane reason known as SAX these days.\u003c/p\u003e\n\n\u003cp\u003eThere is room in the world for both kinds of interface.\nThis one is a \"value\" interface, which is best suited to\nmodest quantities of JSON data, less than a few megabytes say,\nwhere the latency of waiting for the whole form before\nprocessing any of it is not a problem.  Someone else might\nwant to write an \"event stream\" EEP.\u003c/p\u003e\n\n\u003cp\u003eRelated to this issue, a JSON text must be an array or an object,\nnot, for example, a bare number.  Or so says the JSON RFC.  I do\nnot know whether all JSON libraries enforce this.  Since a JSON\ntext must be [something] or {something}, JSON texts are self-\ndelimiting, and it makes sense to consume them one at a time from\na stream.  Should that be part of this interface?  Maybe, maybe\nnot.  I note that you can separate parsing\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eskip leading white space\u003c/li\u003e\n\u003cli\u003echeck for '[' or '{'\u003c/li\u003e\n\u003cli\u003ekeep on accumulating characters until you find a\nmatching ']' or '}', ignoring characters inside \"\".\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003efrom conversion.  So I have separated them.  This proposal only\naddresses conversion.  An extension should address parsing.  It\nmight work better to have that as part of an event stream EEP.\u003c/p\u003e\n\n\u003cp\u003eLet's consider conversion then.  Round trip conversion fidelity\n(X -\u003e Y -\u003e X should be an identity function) is always nice.  Can\nwe have it?\u003c/p\u003e\n\n\u003cp\u003eJSON has\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003enull\u003c/li\u003e\n\u003cli\u003efalse\u003c/li\u003e\n\u003cli\u003etrue\u003c/li\u003e\n\u003cli\u003enumber (integers, floats, and ratios are not distinguished)\u003c/li\u003e\n\u003cli\u003estring\u003c/li\u003e\n\u003cli\u003esequence (called array)\u003c/li\u003e\n\u003cli\u003erecord (called object)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eErlang has\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eatom\u003c/li\u003e\n\u003cli\u003enumber (integers and floats are distinguished)\u003c/li\u003e\n\u003cli\u003ebinary\u003c/li\u003e\n\u003cli\u003elist\u003c/li\u003e\n\u003cli\u003etuple\u003c/li\u003e\n\u003cli\u003epid\u003c/li\u003e\n\u003cli\u003eport\u003c/li\u003e\n\u003cli\u003ereference\u003c/li\u003e\n\u003cli\u003efun\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMore precisely, JSON syntax DOES make integers distinguishable\nfrom floats; it is Javascript (when JSON is used with Javascript)\nthat fails to distinguish them.  Since we would like to use JSON\nto exchange data between Erlang, Common Lisp, Scheme, Smalltalk,\nand above all Python, all of which have such a distinction, it is\nfortunate that JSON syntax and the RFC allow the distinction.\u003c/p\u003e\n\n\u003cp\u003eClearly, Erlang-\u003eJSON-\u003eErlang is going to be tricky.  To take\njust one minor point, neither www.json.org nor RFC 4627 makes\nan promises whatever about the range of numbers that can be\npassed through JSON.  There isn't even any minimum range.  It\nseems as though a JSON implementation could reject all numbers\nother than 0 as too large and still conform!  This is stupid.\nWe can PROBABLY rely on IEEE doubles; we almost certainly cannot\nexpect to get large integers through JSON.\u003c/p\u003e\n\n\u003cp\u003eConverting pids, ports, and references to textual form using\n\u003ccode\u003epid_to_list/1\u003c/code\u003e, \u003ccode\u003eerlang:port_to_list/1\u003c/code\u003e, and \u003ccode\u003eerlang:ref_to_list/1\u003c/code\u003e\nis possible.  A built in function can certainly convert back\nfrom textual form if we want it to.  The problem is telling these\nstrings from other strings:  when is \"\u0026lt;0.43.0\u003e\" a pid and when is\nit a string?  As for funs, let's not go there.\u003c/p\u003e\n\n\u003cp\u003eBasically, converting Erlang terms to JSON so that they can be\nreconstructed as the same (or very similar) Erlang terms would\ninvolve something like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eatom   -\u0026gt; string\nnumber -\u0026gt; number\nbinary -\u0026gt; {\"type\":\"binary\", \"data\":[\u0026lt;bytes\u0026gt;]}\nlist   -\u0026gt; \u0026lt;list\u0026gt;, if it's a proper list\nlist   -\u0026gt; {\"type\":\"dotted\", \"data\":\u0026lt;list\u0026gt;, \"end\":\u0026lt;last cdr\u0026gt;}\ntuple  -\u0026gt; {\"type\":\"tuple\",  \"data\":\u0026lt;tuple as list\u0026gt;}\npid    -\u0026gt; {\"type\":\"pid\",    \"data\":\u0026lt;pid as string\u0026gt;}\nport   -\u0026gt; {\"type\":\"port\",   \"data\":\u0026lt;port as string\u0026gt;}\nref    -\u0026gt; {\"type\":\"ref\",    \"data\":\u0026lt;ref as string\u0026gt;}\nfun    -\u0026gt; {\"module\":\u0026lt;m\u0026gt;, \"name\":\u0026lt;n\u0026gt;, \"arity\":\u0026lt;a\u0026gt;}\nfun    -\u0026gt; we're pushing things a bit for anything else.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is not part of the specification because I am not proposing\nJSON as a representation for arbitrary Erlang data.  I am making\nthe point that we COULD represent (most) Erlang data in JSON if\nwe really wanted to, but it is not an easy or natural fit.  For\nthat we have Erlang binary format and we have UBF.  To repeat,\nwe have no reason to believe that a JSON-\u003eJSON copier that works\nby decoding JSON to an internal form and recoding it for output\nwill preserve Erlang terms, even encoded like this.\u003c/p\u003e\n\n\u003cp\u003eNo, the point of JSON support in Erlang is to let Erlang programs\ndeal with the JSON data that other people are sending around the\nnet, and to send JSON data to other programs (like scripts in Web\nbrowsers) that are expecting plain old JSON.  The round trip\nconversion we need to care about is JSON -\u003e Erlang -\u003e JSON.\u003c/p\u003e\n\n\u003cp\u003eHere too we run into problems.  The obvious way to represent\n{\"a\":A, \"b\":B} in Erlang is \u003ccode\u003e[{'a',A},{'b',B}]\u003c/code\u003e, and the obvious\nway to represent a string is as a list of characters.  But in\nJSON, an empty list, an empty \"object\", and an empty string are\nall clearly distinct, so must be translated to different Erlang\nterms.  Bearing this in mind, here's a first cut at mapping\nJSON to Erlang:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e- null     =\u0026gt; the atom 'null'\n- false    =\u0026gt; the atom 'false'\n- true     =\u0026gt; the atom 'true'\n- number   =\u0026gt; a float if there is a decimal point or exponent,\n           =\u0026gt; the float -0.0 if it is a minus sign followed by\n              one or more zeros, with or without a decimal point\n              or exponent\n           =\u0026gt; an integer otherwise\n- string   =\u0026gt; a UTF-8-encoded binary\n- sequence =\u0026gt; a list\n- object   =\u0026gt; a list of {Key,Value} pairs\n           =\u0026gt; the empty tuple {} for an empty {} object\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSince Erlang does not currently allow the full range of\nUnicode characters in an atom, a Key should be an atom if\neach character of a label fits in Latin 1, or a binary if\nit does not.\u003c/p\u003e\n\n\u003cp\u003eLet's examine \"objects\" a little more closely.  Erlang\nprogrammers are used to working with lists of {Key,Value}\npairs.  The standard library even include orddict, which\nworks with just such lists (although they must be sorted).\nHowever, there is something distasteful about having empty\nobjects convert to empty tuples, but non-empty objects to\nempty lists, and there is also something distasteful about\nlists converting to sequence or objects depending on what\nis inside them.  What is distasteful here has something to\ndo with TYPES.  Erlang doesn't have static types, but that\ndoes not mean that types are not useful as a design tool,\nor that something resembling type consistency is not useful\nto people.  The fact that Erlang tuples happen to use curly\nbraces is just icing on the cake.  The first draft of this\nEEP used lists; that was entirely R.A.O'K's own work.  It\nwas then brought to his attention that Joe Armstrong thought\nconverting \"objects\" to tuples was the right thing to do.\nSo the next draft did that.  Then other alternatives were\nbrought up.  I'm currently aware of\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eObjects are tuples\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eA. \u003ccode\u003e{{K1,V1}, ..., {Kn,Vn}}\u003c/code\u003e.\nThis is the result of \u003ccode\u003elist_to_tuple/1\u003c/code\u003e applied to a \u003cbr /\u003e\nproplist.  There are no library functions to deal\nwith such things, but they are unambiguous and\nrelatively space-efficient.\u003c/li\u003e\n\u003cli\u003eB. \u003ccode\u003e{object,[{K1,V1}, ..., {Kn,Vn}]}\u003c/code\u003e\nThis is a proplist wrapped in a tuple purely to\ndistinguish it from other lists.  This offers\nsimple type testing (objects are tuples) and simple\nfield processing (they contain proplists).\nThere seems to be no consensus for what the tag\nshould be, 'obj' (gratuitous abbreviation), 'json'\n(but even the numbers binaries and lists are JSON),\n'object' seems to be least objectionable.\u003c/li\u003e\n\u003cli\u003eC. \u003ccode\u003e{[{K1,V1},...,{Kn,Vn}]}\u003c/code\u003e\nLike B, but there isn't any need for a tag.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA and B are due to Joe Armstrong; I cannot recall who\nthought of C.  It has recently had supporters.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eObjects are lists\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eD. Empty objects are \u003ccode\u003e{}\u003c/code\u003e.\nThis was my original proposal.  Simple but non-uniform\nand clumsy.\u003c/li\u003e\n\u003cli\u003eE. Empty objects are \u003ccode\u003e[{}]\u003c/code\u003e.\nThis came from the Erlang mailing list; I have forgotten\nwho proposed it.  It's brilliant: objects are always\nlists of tuples.\u003c/li\u003e\n\u003cli\u003eF. Empty objects are 'empty'.\nLike A but a tiny fraction more space-efficient.\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWe can demonstrate handling \"objects\" in each of these forms:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ejson:is_object(X) -\u0026gt; is_tuple(X).          % A\n\njson:is_object({object,X}) -\u0026gt; is_list(X).  % B\n\njson:is_object({X}) -\u0026gt; is_list(X).         % C\n\njson:is_object({}) -\u0026gt; true;                % D\njson:is_object([{_,_}|_]) -\u0026gt; true;\njson:is_object(_) -\u0026gt; false.   \n\njson:is_object([X|_]) -\u0026gt; is_tuple(X).      % E\n\njson:is_object(empty) -\u0026gt; true;             % F\njson:is_object([{_,_}|_]) -\u0026gt; true;\njson:is_object(_) -\u0026gt; false.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOf these, A, B, C, and E can easily be used in clause heads,\nand E is the only one that is easy to use with proplist.\nAfter much scratching of the head and floundering around,\nE does it.\u003c/p\u003e\n\n\u003cp\u003eWe might consider adding an 'object' option:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{object,tuple}    representation A\n{object,pair}     representation B.\n{object,wrap}     representation C.\n{object,list}     representation E.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor conversion from Erlang to JSON,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{T1,...,Tn}       0 or more tuples\n{object,L}        size 2, 1st element atom, 2nd list\n{L}               size 1, only element a list\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eare all recognisable, so \u003ccode\u003eterm_to_json/[1,2]\u003c/code\u003e could accept\nall of them without requiring an option.\u003c/p\u003e\n\n\u003cp\u003eThere is a long term reason why we want some such option.\nBoth lists and tuples are just WRONG.  The right data structure to\nrepresent JSON \"objects\" is the one that I call \"frames\" and Joe\nArmstrong calls \"proper structs\".  At some point in the future we\nwill definitely want to have \u003ccode\u003e{object,frame}\u003c/code\u003e as a possibility.\u003c/p\u003e\n\n\u003cp\u003eSuppose you are receiving JSON data from a source that does\nnot distinguish between integers and floating point numbers?\nPerl, for example, or even more obviously, Javascript itself.\nIn that case some floating point numbers may have been written\nin integer style more or less accidentally.  In such a case, you\nmay want all the numbers in a JSON form converted to Erlang\nfloats.  \u003ccode\u003e{float,true}\u003c/code\u003e was provided for that purpose.\u003c/p\u003e\n\n\u003cp\u003eThe corresponding mapping from Erlang to JSON is\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e- atom   =\u0026gt; itself if it is null, false, or true\n         =\u0026gt; error otherwise\n- number =\u0026gt; itself; use full precision for floats,\n            and always include a decimal point or exponent\n            in a float\n- binary =\u0026gt; if the binary is a well formed UTF-8 encoding\n            of some string, that string\n         =\u0026gt; error otherwise\n- tuple  =\u0026gt; if all elements are {Key,Value} pairs with\n            non-equivalent keys, then a JSON \"object\",\n         =\u0026gt; error otherwise\n- list   =\u0026gt; if it is proper, itself as a sequence\n         =\u0026gt; error otherwise\n- otherwise, an error\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere is an issue here with keys.  The RFC says that \"The names\nwithin an object SHOULD be unique.\"  In the spirit of \"be\ngenerous in what you accept, strict in what you generate\", we\nreally ought to check that.  The only time \u003ccode\u003eterm_to_json/[1,2]\u003c/code\u003e\nterminate successfully should be when the output is absolutely\nperfect JSON.  I did toy with the idea of an option to allow\nduplicate labels, but if I want to send such non-standard data,\nwho can I send it to?  Another Erlang program?  Then I would be\nbetter to use external binary format.  So the only options now\nallowed are ones to affect white space.  One might add an\noption later to specify the order of key:value pairs somehow,\nbut options that do not affect the semantics are appropriate.\u003c/p\u003e\n\n\u003cp\u003eOn second thoughts, look at the \u003ca href=\"http://json-rpc.org/wd/JSON-RPC-1-1-WD-20060807.html\" title=\"The JSON RPC 1.1 draft specification\"\u003eJSON-RPC 1.1 draft\u003c/a\u003e.\nIt says, in section 6.2.4 \"Member Sequence\":\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eClient implementations SHOULD strive to order the members of\nthe Procedure Call object such that the server is able to\nemploy a streaming strategy to process the contents.  At the\nvery least, a client SHOULD ensure that the version member\nappears first and the params member last.\nThis means that for conformity with JSON-RPC,\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cpre\u003e\u003ccode\u003eterm_to_json([{version,\u0026lt;\u0026lt;\"1.1\"\u0026gt;\u0026gt;},\n              {method, \u0026lt;\u0026lt;\"sum\"\u0026gt;\u0026gt;},\n              {params, [17,25]}])\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eshould not re-order the pairs.  Hence the current specification\nsays the order is preserved and does not provide any means for\nre-ordering.  If you want a standard order, program it outside.\u003c/p\u003e\n\n\u003cp\u003eHow should the \"duplicate label\" error be reported?  There are two\nways to report such errors in Erlang:  raise 'badarg' exceptions,\nor return either \u003ccode\u003e{ok,Result}\u003c/code\u003e or \u003ccode\u003e{error,Reason}\u003c/code\u003e answers.  I'm\nreally not at all sure what to do here.  I ended up with 'raise\nbadarg' because that's what things like \u003ccode\u003ebinary_to_term/1\u003c/code\u003e do.\u003c/p\u003e\n\n\u003cp\u003eAt the moment, I specify that the Erlang terms use UTF-8 and only\nUTF-8.  This is by far the simplest possibility.  However, we\ncould certainly add\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{internal,Encoding}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eoptions to say what Encoding to use or assume for binaries.  The\ntime to add that, I think, is when there is a demonstrated need.\u003c/p\u003e\n\n\u003cp\u003eThere are five \"round trip\" issues left:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eall information about white space is lost.\nThis is not a problem, because it has no significance.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003edecimal-\u003ebinary-\u003edecimal conversion of floating point numbers\nmay introduce error unless techniques like those described in \u003cbr /\u003e\nthe Scheme report are used to do these conversions with high\naccuracy.  This is a general problem for Erlang, and a general\nproblem for JSON.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ethere is another JSON library for Erlang that always converts\nintegers outside the 32-bit range to floating point.  This seems\nlike a bad idea.  There are languages (Scheme, Common Lisp,\nSWI Prolog, Smalltalk) with JSON libraries that have bignums.\nWhy put an arbitrary restriction on our ability to communication\nwith them?  Any JSON implementation that is unable to cope with\nlarge integers as integers is (or should be) perfectly able to\nconvert such numbers to floating-point for itself.  It seems\nspecially silly to do this when you consider that the program on\nthe other end might itself be in Erlang.  So we expect that if T\nis of type \u003ccode\u003ejson(binary(),integer())\u003c/code\u003e then\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ejson_to_term(term_to_json(T), [{label,binary}])\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eshould be identical to T, up to re-ordering of attribute pairs.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003econversion of a string to a binary and then a binary to a\nstring will not always yield the same representation, but\nwhat you get will represent the same string.  Example,\n\"\\0041\" will read as \u003ccode\u003e\u0026lt;\u0026lt;65\u0026gt;\u0026gt;\u003c/code\u003e which will display as \"A\".\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eTechnically speaking the Unicode \"surrogates\" are not\ncharacters.  The RFC allows characters outside the Basic\nMultilingual Plane to be written as UTF-8 sequences, or\nto be written as 12-character \\uHIGH\\uLOWW surrogate pair\nescapes.  Something with a bare \\uHIGH or \\uLOWW surrogate\ncode point is not, technically speaking, a legal Unicode\nstring, so a UTF-8 sequence for such a code point should\nnot appear.  A \\uHIGH or \\uLOWW escape sequence on its own\nshould not appear either; it would be just as much of a\nsyntax error as a byte with value 255 in a UTF-8 sequence.\nWe actually have two problems:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e(a) Some languages may be sloppy and may allow singleton\nsurrogates inside strings.  Should Erlang be equally\nsloppy?  Should this just be allowed?\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e(b) Some languages (and yes, I do mean Java) don't really\ndo UTF-8, but instead first break a sequence of Unicode\ncharacters into 16-bit chunks (UTF-16) and then encode\nthe chunks as UTF-8, producing what is quite definitely\nillegal UTF-8.  Since there is a lot of Java code in the\nworld, how do we deal with this?\u003c/p\u003e\n\n\u003cp\u003eBe generous in what you accept:  the 'utf8' decoder\nshould quietly accept \"UTF-Java\", converting\nseparately encoded surrogates to a single numeric\ncode, and converting singleton surrogates \u003cem\u003eas if\u003c/em\u003e they\nwere characters.\u003c/p\u003e\n\n\u003cp\u003eBe strict in what you generate:  never generate\nUTF-Java when the requested encoding is 'utf8';\nhave a separate 'java' encoding that can be requested\ninstead.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eHynek Vychodil is vehement that the only acceptable way to handle\nJSON labels is as binaries.  His argument against \u003ccode\u003e{label,atom}\u003c/code\u003e is\nsound:  as noted above, that option is only usable within a trust\nboundary.  His argument against \u003ccode\u003e{label,existing_atom}\u003c/code\u003e is that if\nyou convert a JSON form at one time in one node, and then store\nthe Erlang term in a file or send it across a wire or in any\nother way make it available at another node or another time,\nthen it won't match the same JSON form converted at that time in\nthat node.  This is true, but there are plenty of other round\ntrip issues as well.  Data converted using \u003ccode\u003e{float,true}\u003c/code\u003e will not\nmatch data converted using \u003ccode\u003e{float,false}\u003c/code\u003e.  The handling of\nduplicate labels may vary.  The order of {key,value} pairs is\nparticularly likely to vary.  For all programming languages and\nlibraries, if you want to move JSON data around in time or\nspace, the \u003cem\u003eonly\u003c/em\u003e reliable way to do that is to move it \u003cem\u003eas\u003c/em\u003e\n(possibly compressed) JSON data, not as something else.  You\ncan expect a JSON form read at one time/place to be equivalent\nto the same form read at another time/place; you cannot expect\nit to be identical.  Any code that does is essentially buggy,\nwhether \u003ccode\u003e{label,existing_atom}\u003c/code\u003e is used or not.  Here is an\nexample that shows that the problem is ineradicable.\u003c/p\u003e\n\n\u003cp\u003eSuppose we have the JSON form\n\"[0.123456789123456789123456789123456]\".\nTwo Erlang nodes on different machines read this and\nconvert it to an Erlang term.  One of them sends its term to\nthe other, which compares them.  To its astonishment, they\nare not identical!  Why?  Well, it could be that they use\ndifferent floating-point precisions.  On one of Erlang's main\nplatforms, 128-bit floats are supported.  (The example needs\n128 bits.)  On its other main platform, 80-bit floats are\nsupported.  (In neither case am I saying that Erlang does,\nonly that the hardware does.)  Indeed, modern versions of the\nsecond platform usually work with 64-bit floats.  Let us\nsuppose that they both stick with 64-bit floats instead.\nWhat if one of the systems is an IBM/370 with its non-IEEE\ndoubles?  So suppose they are both using IEEE 64-bit floats.\nThey will use different C libraries to do the initial\ndecimal-to-binary conversion, so the number may be rounded\ndifferently.  And if one is Windows and another is Linux or\nSolaris, they WILL use different libraries.  Should Erlang\nuse its own code (which might not be a bad idea), we would\nstill have trouble talking to machines with non-IEEE doubles,\nwhich are still in use.  Even Java, which originally wanted\nto have bit-identical results everywhere, eventually retreated.\u003c/p\u003e\n\n\u003cp\u003eThere is one important issue for JSON generation, and that is\nwhat white space should be generated.  Since JSON is supposed to\nbe \"human readable\", it would be nice if it could be indented,\nand if it could be kept to a reasonable line width.  However,\nappearances to the contrary, JSON has to be regard as a binary\nformat.  There is no way to insert line breaks inside strings.\nJavascript doesn't have any analogue of C's \u003cbackslash\u003e\u003cnewline\u003e\ncontinuation; it can always join the pieces with '+'.  JSON has\ninherited the lack (no line continuation) but not the remedy\n(you may not use '+' in JSON).  So a JSON form containing a\n1000-character string cannot be fitted into 80-column lines;\nit just cannot be done.\u003c/p\u003e\n\n\u003cp\u003eThe main thing I have not accounted for is the \u003ccode\u003e{label,_}\u003c/code\u003e.\noption of \u003ccode\u003ejson_to_term/2\u003c/code\u003e.  For normal Erlang purposes, it is\nmuch nicer (and somewhat more efficient) to deal with\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[{name,\u0026lt;\u0026lt;\"fred\"\u0026gt;\u0026gt;},{female,false},{age,65}]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ethan with\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[{\u0026lt;\u0026lt;\"name\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"fred\"\u0026gt;\u0026gt;},{\u0026lt;\u0026lt;\"female\"\u0026gt;\u0026gt;,false},{\u0026lt;\u0026lt;\"age\"\u0026gt;\u0026gt;,65}]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf you are communicating with a trusted source that deals with\na known small number of labels, fine.  There are limits on the\nnumber of atoms Erlang can deal with.  A small test program\nthat looped creating atoms and putting them into a list ticked\nover happily until shortly after its millionth atom, and then\nhung there burning cycles apparently getting nowhere.  Also,\nthe atom table is shared by all processes on an Erlang node,\nso garbage collecting it is not as cheap as it might be.  As\na system integrity measure, therefore, it is useful to have a\nmode of operation in which json\u003cem\u003eto\u003c/em\u003eterm never creates atoms.\nBut Erlang offers a third possibility:  there is a built-in\n\u003ccode\u003elist_to_existing_atom/1\u003c/code\u003e function that returns an atom only if\nthat atom already exists.  Otherwise it raises an exception.\nSo there are three cases:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{label,binary}\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eAlways convert labels to binaries.\nThis is always safe and always clumsy.\nSince \u0026lt;\u0026lt;\"xxx\"\u003e\u003e syntax exists in Erlang,\nit isn't \u003cem\u003ethat\u003c/em\u003e clumsy.  It is uniform,\nand stable, in that it does not depend\non whether Erlang atoms support Unicode or\nnot, or what other modules have been loaded.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{label,atom}\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eAlways convert labels to atoms if all their\ncharacters are allowed in atoms, leave them\nas binaries otherwise.\u003c/p\u003e\n\n\u003cp\u003eThis is more convenient for Erlang programming.\nHowever, it is only really usable with a partner\nthat you trust.  Since much communication takes\nplace within trust boundaries, it definitely has\na place.  If this were not so, term\u003cem\u003eto\u003c/em\u003ebinary/1\nwould be of no use!\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{label,existing_atom}\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eConvert labels that match the names of existing\natoms to those atoms, leave all others as binaries.\nIf a module mentions an atom, and goes looking for\nthat atom as a key, it will find it.  This is safe\n\u003cem\u003eand\u003c/em\u003e convenient.  The only real issue with it is\nthat the same JSON term converted at different times\n(in the same Erlang node) may be converted differently.\nThis usually won't matter.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIn previous drafts I selected \u003ccode\u003eexisting_atom\u003c/code\u003e as the default,\nbecause that's the option I like best.  It's the one that would\nmost simplify the code that I would like to write.  However, one\nmust also consider conversion issues.  Some well considered\nexisting JSON libraries for Erlang always use binaries.\u003c/p\u003e\n\n\u003cp\u003eThere is no \u003ccode\u003e{string,XXX}\u003c/code\u003e option.  That's because I see the\nstrings in JSON as \"payload\", as unpredictable data that are\nbeing transmitted, that one does not \u003cem\u003eexpect\u003c/em\u003e to match against.\nThis is in marked contrast with labels, which are \"structure\"\nrather than data, and which one expects to match against a lot.\nI did briefly consider a \u003ccode\u003e{string,list|binary}\u003c/code\u003e option, but these\ndays Erlang is so good at matching binaries that there didn't\nseem to be much point.\u003c/p\u003e\n\n\u003cp\u003eThis raises a general issue about binaries.  One of the reasons\nfor liking atoms as labels is that atoms are stored uniquely,\nand binaries are not.  This extends to \u003ccode\u003eterm_to_binary()\u003c/code\u003e, which\ncompresses repeated references to identical atoms, but not\nrepeated references to equal binaries.  There is no reason that\na C implementation of \u003ccode\u003ejson_to_term/[1,2]\u003c/code\u003e could not keep track\nof which labels have been seen and share references to repeated\nones.  For example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[{\"name\":\"root\",\"command\":\"java\",\"cpu\":75.7},\n {\"name\":\"ok\",\"command\":\"iropt\",\"cpu\":1.5}\n]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e-- extracted from a run of the 'top' command showing that my\nC compilation was getting a tiny fraction of the machine,\nwhile some Java program run by root was getting the lion's share --\nwould convert to Erlang as the equivalent of\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eN = \u0026lt;\u0026lt;\"name\"\u0026gt;\u0026gt;,\nM = \u0026lt;\u0026lt;\"command\"\u0026gt;\u0026gt;,\nP = \u0026lt;\u0026lt;\"cpu\"\u0026gt;\u0026gt;,\n[[{N,\u0026lt;\u0026lt;\"root\"\u0026gt;\u0026gt;},{M,\u0026lt;\u0026lt;\"java\"\u0026gt;\u0026gt;}, {P,75.7}],\n [{N,\u0026lt;\u0026lt;\"ok\"\u0026gt;\u0026gt;},  {M,\u0026lt;\u0026lt;\"iropt\"\u0026gt;\u0026gt;},{P, 1.5}]\n]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003egetting much of the space saving that atoms would use.  There is\nof course no way for a pure Erlang program to detect whether such\nsharing is happening or not.  It would be nice if\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eterm_to_binary(json_to_term(JSON))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003epreserved such sharing.\u003c/p\u003e\n\n\u003cp\u003eAnother issue that has been raised concerns encoding.  Some people\nhave said that they would like (a) to allow input encodings other\nthan UTF-8, (b) to have strings reported in their original\nencoding, rather than UTF-8, so that (c) strings can be slices of\nthe original binary.  What does the JSON specification actually\nsay?  Section 3, Encoding:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eJSON text SHALL be encoded in Unicode.\nThe default encoding is UTF-8.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThis is not quite as clear as it might be.  There is explicit\nmention of UTF-32 and UTF-16 (both of them in big- and little-\nendian forms).  But is SCSU \"Unicode\"?  Is BOCU?  How about\n\u003ca href=\"http://unicode.org/reports/tr16/\" title=\"Uniode technical report #16, UTF-EBCDIC\"\u003eUTF-EBCDIC\u003c/a\u003e?  That's right, there is a legal way to encode\nsomething in \"Unicode\" in which the JSON special characters\n[]{},:\\\" do not have their ASCII values.  There does not seem\nto be any reason to suppose that this is forbidden, and on an\nIBM mainframe I would expect it to be useful.  Until the day\nsomeone ports Erlang to a z/Series machine, this is mainly of\nacademic interest, but we don't want to paint ourselves into\nany corners.\u003c/p\u003e\n\n\u003cp\u003eSuppose we did represent strings in their native encoding.\nWhat then?  First, a string that contained an escape sequence\nof any kind could not be held as a slice of the source anyway.\nNor could a string that spanned two or more chunks of the\nIO_Data input.  The really big problem is that there would be\nno indication of what the encoding actually was, so that we\nwould end up regarding logically equal strings from different\nsources as unequal and logically unequal strings as equal.\u003c/p\u003e\n\n\u003cp\u003eI do not want to forbid strings in the result being slices of\nan original binary.  In the common case when the input is\nUTF-8 and the string does not contain any escapes, so that it\n\u003cem\u003ecan\u003c/em\u003e be done, an implementation should definitely be free to\nexploit that.  As this EEP currently stands, it is.  What we\ncannot do is to \u003cem\u003erequire\u003c/em\u003e such sharing, because it generally\nwon't work.\u003c/p\u003e\n\n\u003cp\u003eIt has been suggested to me that it might be better for the\nresult of \u003ccode\u003eterm_to_json/[1,2]\u003c/code\u003e to be \u003ccode\u003eiodata()\u003c/code\u003e rather than a\n\u003ccode\u003ebinary()\u003c/code\u003e.  Anything that would have accepted \u003ccode\u003eiodata()\u003c/code\u003e will be\nhappy with a \u003ccode\u003ebinary()\u003c/code\u003e, so the question is whether it is better\nfor the implementation, whether perhaps there are chunks of stuff\nthat have to be copied using a \u003ccode\u003ebinary()\u003c/code\u003e but can be shared using\n\u003ccode\u003eiodata()\u003c/code\u003e.  Thanks to the encoding issue, I don't really think so.\nThis might be a good time to point out why the encoding is done\nhere rather than somewhere else.  If you know that you are\ngenerating stuff that will be encoded into character set X, then\nyou can avoid generating characters that are not in that\ncharacter set.  You can generate \\u sequences instead.  Of course\nJSON itself requires UTF-8, but what if you are going to send it\nthrough some other transport?  With \u003ccode\u003e{encoding,ascii}\u003c/code\u003e you are out\nof trouble all the way.  So for now I am sticking with \u003ccode\u003ebinary()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe final issue is whether these functions should go in the\nerlang: module or in some other module (perhaps called json:).\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIf another module, then there is no barrier to adding other\nfunctions.  For example, we might offer functions to test\nwhether a term is a JSON term, or an IO_Data represents a JSON\nterm, or alternative functions that present results in some\ncanonical form.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf another module, then someone looking for a JSON module might\nfind one.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf another module, then this interface can easily be prototyped\nwithout any modification to the core Erlang system.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf another module, then someone who doesn't need this feature\nneed not load it.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eConversely,\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIf another module, then it is too easy to bloat the interface.\nWe don't \u003cem\u003eneed\u003c/em\u003e such testing functions, as we can always catch\nthe badarg exception from the existing ones.  We don't \u003cem\u003eneed\u003c/em\u003e\nextra canonicalising functions, because we can add options to\nthe existing ones.  Something that subtly encourages us to\nkeep the number of functions down is a Good Thing.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eEvery Erlang programmer ought to be familiar with the erlang:\nmodule, and when looking for any feature, ought to start by\nlooking there.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThere are JSON implementations in Erlang already; we know what\nit is like to use such a thing, and we only need to settle the\nfine details of the implementation.  We know that it can be\nimplemented.  Now we want something that is always there and\nalways the same and is as efficient as practical.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIn particular, we know that the feature is useful, and we know\nthat in applications where it is used, it will be used often,\nso we want it to go about as fast as term\u003cem\u003eto\u003c/em\u003ebinary/1 and\n\u003ccode\u003ebinary_to_term/1\u003c/code\u003e.  So we'd really like it to be implemented in\nC, ideally inside the emulator.  Erlang does not make dynamic\nloading of foreign code modules easy.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIt's a delicate balance.  On the whole, I still think that putting\nthese functions in erlang: is a good idea, but more reasons on\nboth sides would be useful.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThere are no \u003ccode\u003eterm_to_json/N\u003c/code\u003e or \u003ccode\u003ejson_to_term/N\u003c/code\u003e functions in\nthe erlang: module now, so adding them should not break\nanything.  These functions will NOT be automatically imported;\nit will be necessary to use an explicit erlang: prefix.  So\nany existing code that uses these function names won't notice\nany change.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0018"},"buildId":"L68tPJnB-kPxrFxsY9AoN","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_buildManifest.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_ssgManifest.js" async=""></script></body></html>