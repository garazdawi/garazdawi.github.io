{"pageProps":{"index":{"id":"0027","content":"<pre><code>Author: James Hague &lt;james(dot)hague(at)gmail(dot)com&gt;\nStatus: Draft\nType: Standards Track\nCreated: 18-Feb-2009\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 27: <a href=\"eep-0027.md\" title=\"EEP Source\"> Multi-Parameter Typechecking BIFs</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Typechecking guards (e.g., <code>is_float/1</code>) are useful for a number of\nreasons, but they're verbose.  I propose allowing multiple\nparameters to the <code>is_</code> famility of functions, which\nsignificantly reduces source code bulk in common cases.</p>\n\n<h1>Specification</h1>\n\n<p>Where <code>is_type</code> represents any of the <code>is_</code> family of functions,\nsuch as <code>is_float</code>:</p>\n\n<p><code>is_type(A, B, C, ...)</code> is equivalent to <code>(is_type(A) andalso\nis_type(B) andalso is_type(C)...)</code>.</p>\n\n<p>The is_type functions can now take from 1 to N parameters, where\nN is the implementation defined limit on function arity.</p>\n\n<p>The old-style guards (e.g., <code>float/1</code>) would not change, as some of\nthose serve double duty as typecasts.</p>\n\n<p>Direct references to these functions in the erlang module are for\nthe single parameter versions only (such as <code>fun\nerlang:is_float/1</code>).</p>\n\n<h1>Motivation</h1>\n\n<p>I find myself adding typechecking guards not only for safety, but\nto improve code generation quality, especially when using floats.\nWriting three or four element vector math functions in Erlang,\nwith <code>is_float</code> guards, is verbose.  The <code>is_float</code> checks dwarf what\nwould otherwise be a single-line function by adding multiple lines\nof guards.</p>\n\n<h1>Rationale</h1>\n\n<p>Here's an example from the Wings3D project:</p>\n\n<pre><code>cross({V10,V11,V12}, {V20,V21,V22})\n  when is_float(V10), is_float(V11), is_float(V12),\n       is_float(V20), is_float(V21), is_float(V22) -&gt;\n    {V11*V22-V12*V21,V12*V20-V10*V22,V10*V21-V11*V20}.\n</code></pre>\n\n<p>The <code>is_float</code> checks significantly improve the quality of the\ngenerated code, allowing floats to be kept in virtual machine\nregisters instead of allocated on the heap.  If multiple\nparameters to <code>is_float</code> were allowed, this code could be\nrewritten as:</p>\n\n<pre><code>cross({V10,V11,V12}, {V20,V21,V22})\n  when is_float(V10,V11,V12,V20,V21,V22) -&gt;\n    {V11*V22-V12*V21,V12*V20-V10*V22,V10*V21-V11*V20}.\n</code></pre>\n\n<p>In the second version, the intent is clearer at a glance, and\nthe source-level weight of adding typechecking doesn't overwhelm\nthe function.</p>\n\n<p>Over the years the the Erlang system has become more reliant on\ntypechecking.  There are the dialyzer and typer tools.  The\ncompiler can statically infer types and generate better code as\na result. Making typechecking guards be lighter-weight at the\nsource code level encourages their use and is more in-line with\nthe overall syntactic density of the language.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All uses of the <code>is_type/1</code> functions will still work if this\nproposal were implemented.  Direct references to\n<code>erlang:is_float</code>, <code>erlang:is_atom</code>, etc., as funs will still work\nas originally intended.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}