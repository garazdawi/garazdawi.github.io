{"pageProps":{"item":{"id":"compiler-time-option","title":"Exploring the Compiler Using the 'time' Option","author":"Björn Gustavsson","excerpt":"\nThis is the first of a series of blog posts about the compiler.  There\nwill be blog posts about how the compiler works now, how it might work\nin the future, and some historical notes to explain why some things\nare what they are. In this blog post I will talk about one of the most\nuseful options for exploring the compiler, namely the `time` option.","article_date":1524096000000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Exploring the Compiler Using the 'time' Option","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis is the first of a series of blog posts about the compiler.  There\nwill be blog posts about how the compiler works now, how it might work\nin the future, and some historical notes to explain why some things\nare what they are. In this blog post I will talk about one of the most\nuseful options for exploring the compiler, namely the `time` option.\n\nFirst let see `time` in action on a huge file with many functions\nand many variables so that the numbers get interesting:\n\n```\n$ erlc +time NBAP-PDU-Contents.erl\nCompiling \"NBAP-PDU-Contents\"\n remove_file                   :      0.000 s       6.5 kB\n parse_module                  :      0.709 s   25146.1 kB\n transform_module              :      0.000 s   25146.1 kB\n lint_module                   :      0.426 s   25146.1 kB\n expand_records                :      0.086 s   25993.7 kB\n core                          :      0.675 s  282518.3 kB\n sys_core_fold                 :      1.566 s  237885.4 kB\n core_transforms               :      0.000 s  237885.4 kB\n sys_core_bsm                  :      0.205 s  238982.3 kB\n sys_core_dsetel               :      0.108 s  238982.3 kB\n v3_kernel                     :      0.950 s  305320.5 kB\n v3_life                       :      0.453 s  221354.8 kB\n v3_codegen                    :      0.896 s   75801.0 kB\n beam_a                        :      0.080 s   75561.2 kB\n beam_reorder                  :      0.049 s   75561.2 kB\n beam_block                    :      0.361 s   87171.9 kB\n beam_except                   :      0.041 s   81557.7 kB\n beam_bs                       :      0.097 s   79929.2 kB\n beam_type                     :      0.502 s   77270.5 kB\n beam_split                    :      0.042 s   75004.5 kB\n beam_dead                     :      0.356 s   77566.7 kB\n beam_jump                     :      0.232 s   73347.9 kB\n beam_peep                     :      0.164 s   73346.0 kB\n beam_clean                    :      0.150 s   73081.0 kB\n beam_bsm                      :      0.092 s   75473.2 kB\n beam_receive                  :      0.020 s   75473.2 kB\n beam_record                   :      0.023 s   75471.4 kB\n beam_trim                     :      0.042 s   75471.4 kB\n beam_flatten                  :      0.071 s   66745.5 kB\n beam_z                        :      0.019 s   66442.2 kB\n beam_validator                :      0.401 s   66442.2 kB\n beam_asm                      :      0.236 s       6.5 kB\n save_binary                   :      0.000 s       6.5 kB\n```\n\nWhen the `time` option is given, the compiler will print a line after\nexecuting each compiler pass.  First on each line is the name of the\ncompiler pass. Often, but not always, the name is the name of the\nErlang module that implements the compiler pass.\n\nThe name is followed by the time (in seconds) that the compiler\nspent running that compiler pass. For smaller files, the time\nis usually zero or nearly zero. For this huge file, most of the\ntimes are non-zero. For example, the `sys_core_fold` pass needs\nabout one and a half second to do its work.\n\nThe time is followed by the amount of memory used by that compiler\npass.\n\nIn this blog post, I will just talk about a few of the compiler\npasses. There will be more about what the compiler passes do in later\nblog posts.\n\nThe `remove_file` pass is the very first pass run. It removes any\nexisting BEAM file so that there will not be an outdated BEAM file\nin case the compilation fails. The last pass is the `save_binary`\npass. It saves the binary with the BEAM code to the BEAM file.\n\nNow let's see how the output changes if we give the `-S` option:\n\n```\n$ erlc -S +time NBAP-PDU-Contents.erl\nCompiling \"NBAP-PDU-Contents\"\n parse_module                  :      0.718 s   25146.1 kB\n transform_module              :      0.000 s   25146.1 kB\n lint_module                   :      0.420 s   25146.1 kB\n expand_records                :      0.088 s   25993.8 kB\n core                          :      0.671 s  282518.3 kB\n sys_core_fold                 :      1.564 s  237885.4 kB\n core_transforms               :      0.000 s  237885.4 kB\n sys_core_bsm                  :      0.203 s  238982.3 kB\n sys_core_dsetel               :      0.104 s  238982.3 kB\n v3_kernel                     :      0.964 s  305320.5 kB\n v3_life                       :      0.375 s  221354.8 kB\n v3_codegen                    :      1.044 s   75801.0 kB\n beam_a                        :      0.091 s   75561.3 kB\n beam_reorder                  :      0.044 s   75561.3 kB\n beam_block                    :      0.276 s   87171.9 kB\n beam_except                   :      0.028 s   81557.8 kB\n beam_bs                       :      0.103 s   79929.3 kB\n beam_type                     :      0.518 s   77270.5 kB\n beam_split                    :      0.049 s   75004.6 kB\n beam_dead                     :      0.379 s   77566.8 kB\n beam_jump                     :      0.195 s   73347.9 kB\n beam_peep                     :      0.156 s   73346.0 kB\n beam_clean                    :      0.168 s   73081.0 kB\n beam_bsm                      :      0.070 s   75473.2 kB\n beam_receive                  :      0.044 s   75473.2 kB\n beam_record                   :      0.021 s   75471.5 kB\n beam_trim                     :      0.041 s   75471.5 kB\n beam_flatten                  :      0.045 s   66745.5 kB\n beam_z                        :      0.016 s   66442.2 kB\n listing                       :      1.503 s   66442.2 kB\n```\n\nWe can see how the list of passes has changed. The last pass run is\nnow `listing`, which produces a listing of the BEAM assembly code in a\n`.S` file. The `remove_file` pass in the beginning is not run because\nno BEAM file is being produced and any existing BEAM file should be\npreserved.\n\nLet's try one of the many undocumented debugging options:\n\n```\n$ erlc +no_postopt +time NBAP-PDU-Contents.erl\nCompiling \"NBAP-PDU-Contents\"\n remove_file                   :      0.000 s       6.5 kB\n parse_module                  :      0.706 s   25146.1 kB\n transform_module              :      0.000 s   25146.1 kB\n lint_module                   :      0.421 s   25146.1 kB\n expand_records                :      0.090 s   25993.8 kB\n core                          :      0.684 s  282518.3 kB\n sys_core_fold                 :      1.614 s  237885.4 kB\n core_transforms               :      0.000 s  237885.4 kB\n sys_core_bsm                  :      0.210 s  238982.3 kB\n sys_core_dsetel               :      0.105 s  238982.3 kB\n v3_kernel                     :      0.967 s  305320.5 kB\n v3_life                       :      0.353 s  221354.8 kB\n v3_codegen                    :      1.028 s   75801.0 kB\n beam_a                        :      0.091 s   75561.3 kB\n beam_clean                    :      0.201 s   73513.2 kB\n beam_z                        :      0.023 s   72897.9 kB\n beam_validator                :      0.467 s   72897.9 kB\n beam_asm                      :      0.396 s       6.6 kB\n save_binary                   :      0.001 s       6.5 kB\n```\n\nWe can see that far fewer passes were run. The `no_postopt` option\nturns off all optimizations run on the BEAM code (i.e. all optimizations\nafter `v3_codegen`).\n\n## So why is this `time` option useful?\n\n* When compilation of a module is very slow, `time` can show if any particular\npasses are bottlenecks (much slower than the other passes). In fact, a long time\nago the compiler needed several minutes to compile the `NBAP-PDU-Contents` module\nthat I have used an example in this blog post. The `time` option immediately pointed\nout the bottlenecks that I needed to fix.\n\n* If the compiler doesn't terminate when compiling a certain module, `time` will\nshow the last successfully run pass (the one before the culprit).\n\n* The compiler ignores options it doesn't recognize, so if you\nmisremember or misspell an option, the compiler will not do what you\nexpect. Adding the `time` option can help you verify that the expected\ncompiler passes are run.\n\n## Where are all those undocumented options documented?\n\nThere are many options meant for debugging that allow you skip certain optimization\npasses or to produce a listing of the code after a certain pass.\n\nMost of these options can be shown by running `compile:options/0` from the Erlang shell:\n\n```\n$ erl\nErlang/OTP 20 [erts-9.2] [source] [64-bit] [smp:8:8] [ds:8:8:10] [async-threads:10] [hipe] [kernel-poll:false]\n\nEshell V9.2  (abort with ^G)\n1> compile:options().\ndpp - Generate .pp file\n'P' - Generate .P source listing file\ndabstr - Generate .abstr file\ndebug_info - Run save_abstract_code\ndexp - Generate .expand file\n'E' - Generate .E source listing file\ndcore - Generate .core file\nclint0 - Run core_lint_module\ndoldinline - Generate .oldinline file\ndcorefold - Generate .corefold file\ndinline - Generate .inline file\ndcopt - Generate .copt file\n.\n.\n.\n```\n\n## Points to Ponder\n\nWhy does the name of some compiler passes begin with `v3`? Follow this blog, and there might\nbe an answer in a future blog post.\n"}},"__N_SSG":true}