{"pageProps":{"item":{"id":"Interpreter-Optimizations","title":"Interpreter optimization","author":"Lukas Larsson","excerpt":"\nThe BEAM [interpreter] in erts has been completely re-written in OTP 21.\nMost of the instructions have remained the same, but the perl scripts used\nto generate the C code have a new implementation. This blog post will look at\nsome of the optimizations that were possible because of those changes.","article_date":1528675200000,"tags":["interpreter BEAM"],"frontmatter":{"layout":"post","title":"Interpreter optimization","tags":"interpreter BEAM","author":"Lukas Larsson"},"content":"\nThe BEAM [interpreter] in erts has been completely re-written in OTP 21.\nMost of the instructions have remained the same, but the perl scripts used\nto generate the C code have a new implementation. This blog post will look at\nsome of the optimizations that were possible because of those changes.\n\nFirst however, let's start with some basics about how the interpreter is\nbuilt. The BEAM interpreter is built using generated C code. Dispatching\nis done using [direct threading] which leverages the GCC extension [labels as values].\nIt is the job of the [beam_makeops] perl script to take the input files\nand create the C files.\n\nThere is also a set of transformation rules generated that is used by the\n[transform_engine] in the beam code loader to do several peephole optimization.\nThe optimization include, but are not limited to, instruction combining,\ninstruction specialization and dead code elimination.\n\nThere are three separate types of input files used.\n\n* [genop.tab] contains a listing of the instructions that the compiler emits.\n* [ops.tab] contains load time transformations done to the code.\n* [instrs.tab] contain the implementation of each instruction.\n\nThere is a description of the syntax and semantics of the different files\nin the [internal beam_makeops documentation]. The largest difference\nbetween the new and old way of doing the code generation is that\nin OTP 21 _all_ the instructions are now generated, instead of about 75%.\nThis allowed us to do architecture specific optimizations for all instructions\nwhen generating the code for the instructions.\n\n[interpreter]: https://en.wikipedia.org/wiki/Interpreter_(computing)\n[direct threading]: https://en.wikipedia.org/wiki/Threaded_code#Direct_threading\n[labels as values]: https://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html\n[beam_makeops]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops\n[genop.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/lib/compiler/src/genop.tab\n[ops.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/ops.tab\n[instrs.tab]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab\n[internal beam_makeops documentation]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md\n[transform_engine]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/beam_load.c#L5213\n\n## Packing the dispatch target address ##\n\nOn 64-bit machines all pointers are 8 byte large, this is also the case for\nthe pointer that you get when taking the address of a label. So for a small\ninstruction such as move_cx (move a constant to an x register), 3 words of\nmemory is needed.\n\n         +--------------------+--------------------+\n    I -> |                            &&lb_move_cx |\n         +--------------------+--------------------+\n         |                        Tagged atom 'id' |\n         +--------------------+--------------------+\n         |                                      40 |\n         +--------------------+--------------------+\n\nOne word for the instruction, one word for the literal and then the target x\nregister actually only needs 2 bytes, but since all code is word aligned it\ngets its own word.\n\nHowever, on most machines, the linker uses what is called a small or medium code model.\nThis means that it will place all code in the lower 2 GB of the address space\nso that more efficient machine instructions can be used. It also works in the\nfavor of the beam interpreter as we now know that the upper 4 bytes of the\ninstruction word will always be 0.\n\n         +--------------------+--------------------+\n    I -> |                 40 |       &&lb_move_cx |\n         +--------------------+--------------------+\n         |                        Tagged atom 'id' |\n         +--------------------+--------------------+\n\nSo instead of placing the x register to use in its own word we pack it into the\ninstruction word, thus saving one word of memory for this instruction.\n\nThe optimization is only possible to do on 64-bit platforms that place all code in the\nlower 4 GB of the address space, so that makes 32-bit and [position-independent executable]\nplatforms not use it.\nTo figure out which 64-bit platforms we can do it on we first started by writing\na configure script that looked at CFLAGS and LDFLAGS, asked the compiler what it would do\nby default etc etc. After tinkering for a while we came up with a simpler and so\nfar stable solution:\n\n    #include <stdlib.h>\n    int main() {\n      if ((unsigned long long)&main < (1ull << 32)) {\n        exit(0);\n      }\n      exit(1);\n    }\n\nIt would seem that [position-independent executable] always places code in\nsegments > 4GB so we can just check where it put main in a small test program.\n\nPacking arguments into the instruction word is possible for a significant amount\nof instructions which reduced loaded code size and in turn increased performance.\n\n## Smarter packing ##\n\nThe packing engine in [beam\\_makeops] uses several different heuristics to figure\nout which instruction argument(s) it should put in the instruction word. Because\nof alignment requirements and other things, only some types of argument are allowed\ntogether. When choosing how to pack arguments the packer first builds all different\nvariant possible and then chooses the instruction that takes the least amount of\nmemory. The logic for this can be found in the [do_pack_one] function in\n[beam_makeops]. Before OTP-21 this had to be done manually for all instructions,\nwhich meant that the implementer had to be extra careful when deciding which\norder the arguments should be placed in [ops.tab]. In addition the packing logic\nbefore OTP-21 did not pack argument of varying size into the same machine word.\n\nThe packer is not perfect however, so in some cases we needed to make it\npossible to override its decisions. That is why the [? type modifier] was introduced.\nThe [? type modifier] is used to determine whether an argument is likely to be used\nor not by the instruction.\n\nHow do you determine if an argument is likely to be used or not? For some instructions\nit is obvious, eg. the allocate instruction has an argument that is only used\nif a garbage collection is triggered, so it is very unlikely to be used. In other cases\nit is not so obvious, eg. the failure label of test instructions, is it likely to be\nused or not? For most test instructions it will be unlikely that it will be used,\nor at least more unlikely than the other arguments of the instruction as they are used\nin the actual test.\n\nWhy is packing less used instructions into the instruction word better? It seems like\nGCC will generate a little better code for most instructions if the arguments that\nare always used are in the same word, we've seen this by both looking at the assembly\nthat GCC produced and the total code size of the interpreter becomes smaller. We haven't\nbeen able to measure any differences in performance due to how the unlikely instructions\nare packed, but smaller code is always a good thing.\n\n[? type modifier]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md#the--type-modifier\n[position-independent executable]: https://en.wikipedia.org/wiki/Position-independent_code#Position-independent_executables\n[do_pack_one]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/utils/beam_makeops#L1801\n\n## Relative jump labels ##\n\nMany instruction have branches in them that will be taken depending on various conditions.\nOne of the simplest ones is the [is_eq_exact_immed] instruction. It will continue on\nto the next instruction if the value is equal to the immediate literal in the argument,\nor jump to the fail label if they are not equal. Before OTP-21 the instruction\nis\\_eq\\_exact\\_immed\\_frc would have this layout:\n\n         +--------------------+--------------------+\n    I -> |              &&lb_is_eq_exact_immed_frc |\n         +--------------------+--------------------+\n         |                 Pointer To failure code |\n         +--------------------+--------------------+\n         |                       Tagged immed 'id' |\n         +--------------------+--------------------+\n\nThe C code for the instruction would look something like this (I've removed all macros\nthat beam\\_makeops uses):\n\n    if (reg[0] != I[2]) {\n      I = I[1];\n      goto *(void**)I;\n    }\n    I+=3;\n    goto *(void**)I;\n\nIn this example it does not help to use part of the instruction word as both arguments\nare 8 bytes large. We also cannot use the same trick as the instruction word to make\nthe fail label smaller as Erlang code can be allocated anywhere in the 64-bit address\nspace. One thing that we can rely on though is that the code for a single Erlang module\nwill be located in a contiguous memory area. So instead of using pointers to the code\nthat we want to jump to we can use relative addresses for jumps within the same module.\n\nThe problem with using relative local jumps is that we put a limit on how large a module\ncan be. For instance, the largest module in Erlang/OTP is the 'OTP-PUB-KEY' module,\nit is 61585 words large when loaded and the longest local jump is 5814 words. For this\nparticular module we could have used a 13-bit jump label, or 16-bits if we wanted to be\nsure that all functions could call each other. 16-bits would have been a perfect size as\nit can be packed with another register in the instruction word. So it would have been\npossible to fit a instruction address + jump label + register in 8 bytes. However, it is\nway too close for comfort, and there are sure to be larger modules than ours in other\nsystems, so we decided to use 32-bits for the jump labels. So in OTP-21 the max size of\na loaded module has gone from 2^32 GB to 32 GB, which should be enough for most use cases.\n\nUsing this new layout the is\\_eq\\_exact\\_immed\\_frc instruction can be re-written to use\nthe following layout instead:\n\n         +--------------------+--------------------+\n    I -> | Offset to failure..| &&lb_is_eq_exac... |\n         +--------------------+--------------------+\n         |                       Tagged immed 'id' |\n         +--------------------+--------------------+\n\nAnd generate this code:\n\n    if (reg[0] != I[1]) {\n      I += I[0] >> 32;\n      goto *(void**)(Uint64)(Uint32)I;\n    }\n    I+=2;\n    goto *(void**)(Uint64)(Uint32)I;\n\nThe code ends up being a little bit more complicated, but the C compiler manages to optimize\nit into very efficient code. Basically for each jump label there is an extra add operation\nwhen compared to before. When profiling this extra code is not noticeable as it drowns in\nthe load of the value from (hopefully) the l1-cache.\n\nA lot of instructions benefit from this optimization as a lot of them control the control\nflow. This is especially noticeable on large [select_val_bins], as they have their memory\nusage reduced by 25%. Also as you may have noticed, it plays very well with the packing\nof the instruction word and the [? type modifier] in [beam_makeops].\n\n[is_eq_exact_immed]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/instrs.tab#L789\n[select_val_bins]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/beam/select_instrs.tab#L32-L76\n"}},"__N_SSG":true}