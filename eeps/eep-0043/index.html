<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author:         Bj√∂rn-Egil Dahlberg &lt;egil(at)Erlang.org&gt;
Status:         Draft
Type:           Standards Track
Created:        04-Apr-2013
Erlang-Version: R17A
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 43: <a href="eep-0043.md" title="EEP Source"> Maps</a></h2>

<h1>Abstract</h1>

<p>The journey of Maps and this EEP has been long and by no means a
straight-forward and continuous one. I had a crystal clear picture of what I
wanted Maps to be when we first started discussing it within OTP about
two-three years ago. This EEP resembles that vision but it has had a lot of
contributions of other ideas from both within and outside of OTP.</p>

<p>The idea was a data-type, a syntax aware mapping of key-value associations
with pattern matching. A syntax similar to records but without the hazzle of
compile-time dependency and with arbitrary terms as keys. Order was not
important and it could be implemented with a Hash-Array-Mapped-Trie with good
performance and memory trade-offs. This was a different approach than to replace
records. It was meant to replace records where suitable and in other regards
not be a replacement but its own <em>thing</em>.</p>

<blockquote>
  <p>From the community there has been many wishes of a Map like data-type and a
few suggestions.  The one suggestion that stands out is of course the Frames
proposal from Richard O'Keefe. It is the most complete proposal I've seen and
is very well thought out. Its goal is to be a record replacement and the
proposal satisfies this goal very well.</p>
</blockquote>

<ul>
<li>If Frames are that good, why a separate EEP?</li>
<li>It boils down to goals and constraints.</li>
</ul>

<p>A record replacement is just that, a replacement.
It's like asking the question, "What do we have?" instead of "What can we get?"
The instant rebuttal would be "What do we need?" I say Maps.</p>

<p>Frames has certainly inspired and influenced Maps. In many regards Maps also
encompasses Frames but Maps tries to do more. In the end I believe they are
two different things and have different goals.</p>

<p>This EEP suggests a new built in data-type for Erlang, the map, 
<code>#{ Key =&gt; Value }</code>.</p>

<p>The new data-type shall have semantics, syntax and operations that:</p>

<ul>
<li>provides an association set from key terms to value terms which can be
constructed, accessed and updated using language syntax</li>
<li>can be uniquely distinguished from every other data-type in the language</li>
<li>has no compile-time dependency for constructing, accessing or updating
contents of maps nor for passing maps between modules, processes or over
Erlang distribution</li>
<li>can be used in matching expressions in the language</li>
<li>has a one-to-one association between printing and parsing the data-type </li>
<li>has a well defined order between terms of the type and other Erlang types</li>
<li>has at most O(log N) time complexity in insert and lookup operations, where 
N is the number of key-value associations.</li>
</ul>

<p>Similar data-types exists in other languages, i.e.  <a href="http://perldoc.perl.org/perldata.html" title="perldata - perldoc.perl.org">perl hashes</a>,
<a href="http://ruby-doc.org/core-1.9.3/Hash.html" title="Class: Hash (Ruby 1.9.3)">ruby hashes</a>, <a href="http://docs.python.org/tutorial/datastructures.html#dictionaries" title="5. Data Structures - Python v2.7.3 documentation">python dictionaries</a>, or
<a href="http://docs.scala-lang.org/overviews/collections/maps.html" title="Collections - Maps - Scala Documentation">scala maps</a>.</p>

<h1>Specification</h1>

<p>A map <code>M</code> consists of a number of <em>associations</em> and keeps an association
from key terms <code>K1..Kn</code> to value terms <code>V1..Vn</code> where no two keys <em>match</em>.
Any term, compound or otherwise, is a viable key or value. Terms of type Map
are recognized by guard tests <code>erlang:is_map/1</code>. There are no operators
acting on maps. Within maps there are two infix operators. An association
operator, <code>=&gt;</code>, pairs a key to a value and is used in creation and updates.
A set-value operator, <code>:=</code>, is used to update a value on an already
existing and matching key. The set-value operator is also used in matching
to get the associated value from a key.</p>

<h2>Terminology</h2>

<p>The <em>size</em> of a map is the number of associations in its set.</p>

<p>An <em>association</em> is a key-value pair of key <em>K</em> to value <em>V</em> in a Map.</p>

<p>Two keys, <code>K1</code> and <code>K2</code> are <em>matching</em> if, <code>true = K1 =:= K2</code>.</p>

<h2>Syntax</h2>

<p>Defined syntax for declaring, updating and matching maps.</p>

<h3>Construction syntax</h3>

<p>Constructing a new map is done by letting an expression <code>K</code> be associated to
another expression <code>V</code>:</p>

<pre><code>#{ K =&gt; V }
</code></pre>

<p>New maps may include multiple associations at construction by listing every
association:</p>

<pre><code>#{ K1 =&gt; V1, .. Kn =&gt; Vn }
</code></pre>

<p>An empty map is constructed by not associating any terms with each other:</p>

<pre><code>#{}
</code></pre>

<p>All keys and values in the map are terms. Any expression is first evaluated and
then the resulting terms are used as <em>key</em> and <em>value</em> respectively.</p>

<p>Keys and values are separated by the <code>=&gt;</code> arrow and associations are
separated by <code>,</code>.</p>

<p>Examples:</p>

<pre><code>M0 = #{},                   % empty map
M1 = #{ a =&gt; &lt;&lt;"hello"&gt;&gt; }, % single association with literals
M2 = #{ 1 =&gt; 2, b =&gt; b },   % multiple associations with literals
M3 = #{ A =&gt; B },           % single association with variables
M4 = #{ {A, B} =&gt; f() }.    % compound key associated to an evaluated expression
</code></pre>

<p>where, <code>A</code> and <code>B</code> are any expressions and <code>M0</code> through <code>M4</code> are the resulting
map terms.</p>

<p>If two matching keys are declared, the latter key will take precedent.</p>

<p>Example:</p>

<pre><code>1&gt; #{ 1 =&gt; a, 1 =&gt; b }.
#{ 1 =&gt; b }
2&gt; #{ 1.0 =&gt; a, 1 =&gt; b }.
#{ 1 =&gt; b, 1.0 =&gt; a }
</code></pre>

<p>The order in which the expressions constructing the keys and their
associated values are evaluated is not defined. The syntactic order of
the key-value pairs in the construction is of no relevance, except in
the above mentioned case of two matching keys.</p>

<p>A simple BNF grammar for the construction follows:</p>

<pre><code> &lt;map-construct&gt;  ::= '#{' &lt;key-value-exprs&gt; '}'
&lt;key-value-exprs&gt; ::= /* empty */
                    | &lt;key-value-list&gt;
 &lt;key-value-list&gt; ::= &lt;key-value-assoc&gt; 
                    |¬†&lt;key-value-assoc&gt; ',' &lt;key-value-list&gt;
&lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;
           &lt;expr&gt; ::= &lt;Erlang-expression&gt;
</code></pre>

<h3>Update syntax</h3>

<p>Updating a map has similar syntax as constructing it.</p>

<p>An expression defining the map to be updated is put in front of the expression
defining the keys to be updated and their respective values.</p>

<pre><code>M#{ K =&gt; V }
</code></pre>

<p>where <code>M</code> is an term of type map and <code>K</code> and <code>V</code> are any expression.</p>

<p>If key <code>K</code> does not <em>match</em> any existing key in the map, a new association
will be created from key <code>K</code> to value <code>V</code>.  If key <code>K</code> <em>matches</em> an existing
key in map <code>M</code> its associated value will be replaced by the new value <code>V</code>. In both
cases the evaluated map expression will return a new map.</p>

<p>If <code>M</code> is not of type map an exception of type <code>badmap</code> is thrown.</p>

<p>To only update an existing value, the following syntax is used,</p>

<pre><code>M#{ K := V }
</code></pre>

<p>where <code>M</code> is an term of type map, <code>V</code> is an expression and <code>K</code> is an expression
which evaluates to an existing key in <code>M</code>.</p>

<p>If key <code>K</code> does not <em>match</em> any existing keys in map <code>M</code> an exception of type
<code>badarg</code> will be triggered at runtime. If a <em>matching</em> key <code>K</code> is present in
map <code>M</code> its associated value will be replaced by the new value <code>V</code> and the
evaluated map expression returns a new map.</p>

<p>If <code>M</code> is not of type map an exception of type <code>badmap</code> is thrown.</p>

<p>Examples:</p>

<pre><code>M0 = #{},
M1 = M0#{ a =&gt; 0 },
M2 = M1#{ a =&gt; 1, b =&gt; 2 },
M3 = M2#{ "function" =&gt; fun() -&gt; f() end },
M4 = M3#{ a := 2, b := 3 }.  % 'a' and 'b' was added in `M1` and `M2`.
</code></pre>

<p>where <code>M0</code> is any map. It follows that <code>M1 .. M4</code> are maps as well.</p>

<p>More Examples:</p>

<pre><code>1&gt; M = #{ 1 =&gt; a }.
#{ 1 =&gt; a }

2&gt; M#{ 1.0 =&gt; b }.
#{ 1 =&gt; a, 1.0 =&gt; b }.

3&gt; M#{ 1 := b }.
#{ 1 =&gt; b }

4&gt; M#{ 1.0 := b }.
** exception error: bad argument
</code></pre>

<p>As in construction, the order in which the key and value expressions
are evaluated are not defined. The
syntactic order of the key-value pairs in the update is of no
relevance, except in the case where two keys match, in which
case the latter value is used.</p>

<p>A simple BNF grammar for map updates follows:</p>

<pre><code> &lt;map-construct&gt;  ::= &lt;map-expr&gt; '#{' &lt;key-value-exprs&gt; '}'
&lt;key-value-exprs&gt; ::= /* empty */
                    | &lt;key-value-list&gt;
 &lt;key-value-list&gt; ::= &lt;key-value&gt; 
                    |¬†&lt;key-value&gt; ',' &lt;key-value-list&gt;
      &lt;key-value&gt; ::= &lt;key-value-assoc&gt;
                    | &lt;key-value-exact&gt;
&lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;
&lt;key-value-exact&gt; ::= &lt;expr&gt; ':=' &lt;expr&gt;
       &lt;map-expr&gt; ::= &lt;Erlang expression evaluating to a term of type map&gt;
           &lt;expr&gt; ::= &lt;Erlang expression&gt;
</code></pre>

<h3>Accessing a single value</h3>

<p>For accessing single values in maps, let us use an de-association:</p>

<pre><code>V = M#{ K }.
</code></pre>

<p>Where <code>M</code> is a Map and <code>K</code> is any term.</p>

<p>If key <code>K</code> <em>matches</em> to an existing key in map <code>M</code> the associated value
will be bound to <code>V</code>. If key <code>K</code> does not <em>match</em> to any existing key in
map <code>M</code> an exception <code>badarg</code> will occur in runtime.</p>

<p>Examples:</p>

<pre><code>M1 = #{ a =&gt; 1, c =&gt; 3 },
3 = M1#{ c }.

M2 = #{ 1.0 =&gt; a },
a = M2#{ 1 }.
</code></pre>

<h3>Matching syntax</h3>

<p>Matching of key-value associations from maps, exemplified with the
matching operator, is done in the following way:</p>

<pre><code>#{ K := V } = M
</code></pre>

<p>where <code>M</code> is any map. The key <code>K</code> has to be an expression with bound variables
or a literals, and <code>V</code> can be any pattern with either bound or unbound variables.
If variables in <code>V</code> are unbound, it will be bound to the value associated
with the key <code>K</code>, which has to exist in the map <code>M</code>. If variables in <code>V</code> are
bound, it has to match the value associated with <code>K</code> in <code>M</code>.</p>

<p>Example:</p>

<pre><code>M = #{ a =&gt; {1,2}},
#{ a := {1,B}} = M.
</code></pre>

<p>This will bind variable <code>B</code> to integer <code>2</code>.</p>

<p>Similarly, multiple values from the map may be matched:</p>

<pre><code>#{ K1 := V1, .., Kn := Vn } = M
</code></pre>

<p>where keys <code>K1 .. Kn</code> are any expressions with literals or bound variables. If all
keys exists in map <code>M</code> all variables in <code>V1 .. Vn</code> will be matched to the
associated values of there respective keys.</p>

<p>If the matching conditions are not met, the match will fail, either with</p>

<ol>
<li>a <code>badmatch</code> exception, if used in the context of the matching operator
 as in the example, </li>
<li>or resulting in the next clause being tested in function heads and
 case expressions.</li>
</ol>

<p>Matching in maps only allows for <code>:=</code> as delimiters of associations.</p>

<p>The order in which keys are declared in matching has no relevance.</p>

<p>Duplicate keys are allowed in matching and will match each pattern associated
to the keys.</p>

<pre><code>#{ K := V1, K := V2 } = M
</code></pre>

<p>Matching an expression against an empty map literal will match its type but
no variables will be bound:</p>

<pre><code>#{} = Expr
</code></pre>

<p>This expression will match if the expression <code>Expr</code> is of type map, otherwise
it will fail with an exception <code>badmatch</code>.</p>

<p>The grammar for the matching syntax is similar to that of construction.</p>

<h4>Matching syntax: Example with literals in function heads</h4>

<p>Matching of literals as keys are allowed in function heads.</p>

<pre><code>%% only start if not_started
handle_call(start, From, #{ state := not_started } = S) -&gt;
...
    {reply, ok, S#{ state := start }};

%% only change if started
handle_call(change, From, #{ state := start } = S) -&gt;
...
    {reply, ok, S#{ state := changed }};
</code></pre>

<h4>Matching syntax: Frequency example</h4>

<p>More matching syntax, calculating frequency of terms in a list.</p>

<pre><code>freq(Is)                    -&gt; freq(Is, #{}).
freq([I|Is], #{I := C} = M) -&gt; freq(Is, M#{ I := C + 1});
freq([I|Is], M)             -&gt; freq(Is, M#{ I =&gt; 1 });
freq([], M)                 -&gt; maps:to_list(M).
</code></pre>

<p>Equivalent code with <code>gb_trees</code> for comparison:</p>

<pre><code>freq(Is)        -&gt; freq(Is, gb_trees:empty()).
freq([I|Is], T) -&gt;
    case gb_trees:lookup(I, T) of 
        none       -&gt; freq(Is, gb_trees:enter(I, 1), T);
        {value, V} -&gt; freq(Is, gb_trees:enter(I, V + 1, T))
    end;
freq([], T) -&gt; gb_trees:to_list(T).
</code></pre>

<h4>Matching syntax: File information example</h4>

<p>Old API's could be refined to use map syntax:</p>

<pre><code>1&gt; {ok, #{ type := Type, mtime := Mtime }} = file:read_file_info(File).
2&gt; io:format("type: ~p, mtime: ~p~n", [Type, Mtime]).
type: regular, mtime: {{2012,7,18},{19,59,18}}
ok
3&gt;
</code></pre>

<h3>Map comprehension syntax</h3>

<p>Map comprehension declaration:</p>

<pre><code>M1 = #{ E0 =&gt; E1 || K := V &lt;- M0  }
</code></pre>

<p>where <code>M0</code> is any Map, <code>E0</code> and <code>E1</code> are any erlang expression, <code>K</code> and <code>V</code>
constitutes the pattern to be matched by each association in <code>M0</code>.</p>

<p>For each sequence in the generator an association is created from the evaluated
expression <code>E0</code> to the evaluated expression <code>E1</code>. </p>

<p>If <code>M0</code> is not a Map, then a runtime exception of type <code>{bad_generator, M0}</code>
will be generated.</p>

<p>A simple BNF grammar for map comprehension follows:</p>

<pre><code>      &lt;comprehension&gt; ::= '#{' &lt;key-value-assoc&gt; '||' &lt;comprehension-exprs&gt; '}'
&lt;comprehension-exprs&gt; ::= &lt;comprehension-expr&gt;
                        | &lt;comprehension-exprs&gt; ',' &lt;comprehension-expr&gt;
 &lt;comprehension-expr&gt; ::= &lt;generator&gt;
                        | &lt;filter&gt;
          &lt;generator&gt; ::= &lt;key-value-exact&gt; '&lt;-' &lt;expr&gt;
             &lt;filter&gt; ::= &lt;expr&gt;
    &lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;
    &lt;key-value-exact&gt; ::= &lt;expr&gt; ':=' &lt;expr&gt;
               &lt;expr&gt; ::= &lt;Erlang expression&gt;
</code></pre>

<p>Each association from all generators, which satisfies the filters, has an
environment that consist of the initial environment and the environment
for the association.  </p>

<p>Examples:</p>

<pre><code>M0 = #{ K =&gt; V*2  || K := V &lt;- map() },
M1 = #{ I =&gt; f(I) || I &lt;- list() },
M2 = #{ K =&gt; V    || &lt;&lt;L:8,K:L/binary,V/float&gt;&gt; &lt;= binary() }.
</code></pre>

<p>Map generators may also be used in binary and list comprehensions.</p>

<p>Examples:</p>

<pre><code>B1 = &lt;&lt; &lt;&lt;V:8&gt;&gt; || _ := V &lt;- map() &gt;&gt;,
L1 = [ {K,V} || K := V &lt;- map() ].
</code></pre>

<h3>Dialyzer and Type specification</h3>

<p>Keys known before hand can be specified directly and uniquely for a map.</p>

<pre><code>-spec func(Opt, M) -&gt; #{ 'status' =&gt; S, 'c' =&gt; integer() } when
      Opt :: 'inc' | 'dec',
        M :: #{ 'status' =&gt; S, 'c' =&gt; integer() },
        S :: 'update' | 'keep'.

func(inc, #{ status := update, c := C} = M) -&gt; M#{ c := C + 1};
func(dec, #{ status := update, c := C} = M) -&gt; M#{ c := C - 1};
func(_,   #{ status := keep } = M)          -&gt; M.
</code></pre>

<p>It could also be specified by type only.</p>

<pre><code>-spec plist_to_map(Ls) -&gt; #{ binary() =&gt; integer() } when
      Ls :: [{binary(), integer()}].

plist_to_map([], M) -&gt;
    M;
plist_to_map([{K,V}|Ls], M) when is_binary(K), is_integer(V) -&gt;
    plist_to_map(Ls, M#{ K =&gt; V });
plist_to_map([_|Ls], M) -&gt;
    plist_to_map(Ls, M).
</code></pre>

<p>It can similarly be specified as a type.</p>

<pre><code>-type map1() :: #{ binary() =&gt; integer() }.
-type map2() :: #{ &lt;&lt;"list1"&gt;&gt; | &lt;&lt;"list2"&gt;&gt; =&gt; [numbers()] }.
</code></pre>

<h2>Functions and Semantics</h2>

<p><em>The module implementing the functions is currently named in plural, <code>maps</code> in the
same spirit as <code>lists</code>, <code>gb_trees</code>, <code>sets</code> etc but the singular <code>map</code> is shorter
and may be more desirable.</em></p>

<p>Functions and semantics for maps. Originally much inspiration was from
Richard O'Keefes frames proposal.</p>

<h3>Erlang module extension</h3>

<h5><code>erlang:is_map(M :: term()) -&gt; boolean().</code></h5>

<p>This function is a guard function.</p>

<p>Syntax equivalence: <code>try #{} = M, true catch error:{badmatch,_} -&gt; false end</code>.</p>

<p>The function returns <code>true</code> if M is a map otherwise <code>false</code>.</p>

<h5><code>erlang:map_size(M :: map()) -&gt; non_neg_integer().</code></h5>

<p>This function is a guard function.</p>

<p>Syntax equivalence: <em>none</em>.</p>

<p>The function returns the number of key-value pairs in the map.
  This operation happens in constant time.</p>

<p>Same as <code>maps:size(M)</code>.</p>

<h3>maps module</h3>

<h5><code>maps:remove(K0 :: term(), M0 :: map()) -&gt; M1 :: map().</code></h5>

<p>Syntax equivalence: <code>#{ K =&gt; V || K := V &lt;- M0, K =/= K0 }</code>.
  <em>Only with comprehensions</em></p>

<p>The function removes the key <code>K0</code>, if it exists, and its associated value from
  map <code>M0</code> and returns a new map <code>M1</code> without key <code>K0</code>.</p>

<p>Same as, <code>maps:from_list([{K,V}||{K,V} &lt;- maps:to_list(M0), K =/= K0])</code></p>

<h5><code>maps:get(K :: term(), M :: map()) -&gt; V :: term().</code></h5>

<p>Syntax equivalence: <code>M#{ K }</code>.</p>

<p>Returns the value <code>V</code> associated with key <code>K</code> if map <code>M</code> contains a key
  that <em>matches</em> <code>K</code>.  If no value is associated with key <code>K</code> then the call will
  fail with an exception.</p>

<h5><code>maps:keys(M :: map()) -&gt; [K1, .., Kn].</code></h5>

<p>Syntax equivalence: <code>[K || K := _ &lt;- M]</code>.</p>

<p>Returns a complete list of Keys, in arbitrary order, which resides within
  map <code>M</code>.</p>

<p>Same as, <code>[K || {K,_} &lt;- maps:to_list(M)]</code>.</p>

<h5><code>maps:find(K :: term(), M :: map()) -&gt; {ok, V :: term()} | error.</code></h5>

<p>Syntax equivalence: <code>try #{ K := V } = M, V catch error:{badmatch,_} -&gt; error end</code>.</p>

<p>Returns a tuple <code>{ok, V}</code> with value <code>V</code> associated with key <code>K</code> if map <code>M</code>
  contains key <code>K</code>.  If no value is associated with key <code>K</code> then the function
  will return <code>error</code>.</p>

<h5><code>maps:fold(F :: fun((K :: term(), V :: term(), In :: term()) -&gt; Out :: term()), A :: term(), M :: map()) -&gt; Result :: term().</code></h5>

<p>Syntax equivalence: <em>none</em></p>

<p>Calls <code>F(K, V, In)</code> for every key <code>K</code> to value <code>V</code> association in map <code>M</code> in
  arbitrary order. The function fun <code>F/3</code> must return a new accumulator
  which is passed to the next successive call. <code>maps:fold/3</code> returns the final
  value of the accumulator. The initial accumulator value <code>A</code> is returned if
  the map is empty.</p>

<p>Same as, <code>lists:foldl(fun({K,V}, In) -&gt; F(K,V,In) end, A, maps:to_list(M))</code>.</p>

<h5><code>maps:from_list([{K1,V1}, .., {Kn,Vn}]) -&gt; M :: map().</code></h5>

<p>Syntax equivalence: <code>#{ K1 =&gt; V1, .., Kn =&gt; Vn }</code></p>

<p>The function takes a list of key-value tuples elements and builds a
  map. The associations may be in any order and both keys and values in the
  association may be of any term. If the same key appears more than once,
  the latter (rightmost) value is used and the previous values are ignored.</p>

<h5><code>maps:is_key(K :: term(), M :: map()) -&gt; bool().</code></h5>

<p>Syntax equivalence: <code>try #{ K := _ } = M, true catch error:{badmatch, _} -&gt; false end</code>.</p>

<p>Returns <code>true</code> if map <code>M</code> contains a key that <em>matches</em> <code>K</code>.</p>

<h5><code>maps:map(F :: function(), M0 :: map()) -&gt; M1 :: map().</code></h5>

<p>Syntax equivalence: <code>#{ K =&gt; F(K,V) || K := V &lt;- M }</code>.
  <em>Only with comprehensions</em></p>

<p>The function produces a new map <code>M1</code> by calling the function fun <code>F(K, V)</code> for
  every key <code>K</code> to value <code>V</code> association in map <code>M0</code> in arbitrary order.
  The function fun <code>F/2</code> must return the value to be associated with key <code>K</code> for
  the new map <code>M1</code>.</p>

<p>Same as, <code>maps:from_list(lists:map(fun({K,V}) -&gt; {K, F(K,V)} end, maps:to_list(M)))</code>.</p>

<h5><code>maps:new() -&gt; M :: map().</code></h5>

<p>Syntax equivalence: <code>#{}</code>.</p>

<p>Returns a new empty map.</p>

<p>Same as, <code>maps:from_list([])</code>.</p>

<h5><code>maps:size(M :: map()) -&gt; Size :: non_neg_integer().</code></h5>

<p>Syntax equivalence: <em>none</em>.</p>

<p>The function returns the number of key-value associations in the map.
  This operation happens in constant time.</p>

<p>Same as <code>erlang:map_size(M)</code>.</p>

<h5><code>maps:put(K :: term(), V :: term(), M0 :: map()) -&gt; M1 :: map().</code></h5>

<p>Syntax equivalence: <code>M0#{ K =&gt; V }</code>.</p>

<p>Associates key <code>K</code> with value <code>V</code> and inserts the association into map <code>M0</code>.
  If a key exists that <em>matches</em> <code>K</code>, the old associated value is
  replaced by value <code>V</code>.
  The function returns a new map <code>M1</code> containing the new association.</p>

<p>Same as, <code>maps:from_list(maps:to_list(M0) ++ [{K,V}])</code>.</p>

<h5><code>maps:to_list(M :: map()) -&gt; [{K1,V1}, ..., {Kn,Vn}].</code></h5>

<p>Syntax equivalence: <code>[{K, V} || K := V &lt;- M]</code>.</p>

<p>Where the pairs, <code>[{K1,V1}, ..., {Kn,Vn}]</code>, are returned in arbitrary order.</p>

<h5><code>maps:update(K :: term(), V :: term, M0 :: map()) -&gt; M1 :: map()</code></h5>

<p>Syntax equivalence: <code>M0#{ K := V }</code>.</p>

<p>If a key exists that <em>matches</em> <code>K</code>, the old associated value is
  replaced by value <code>V</code>. The function returns a new map <code>M1</code> containing
  the new associated value.</p>

<p>Same as, <code>maps:from_list(maps:to_list(M0) ++ [{K,V}])</code>.</p>

<h5><code>maps:values(M :: map()) -&gt; [V1, .., Vn].</code></h5>

<p>Syntax equivalence: <code>[V || _ := V &lt;- M]</code>.</p>

<p>Returns a complete list of values, in arbitrary order, contained in map <code>M</code>.</p>

<p>Same as, <code>[V || {_,V} &lt;- maps:to_list(M)]</code>.</p>

<h5><code>maps:without([K1, .., Kn] = Ks, M0 :: map()) -&gt; M1 :: map().</code></h5>

<p>Syntax equivalence: <code>#{ K =&gt; V || K := V &lt;- M0, not lists:member(K, Ks) }</code>. 
  <em>Only with comprehensions</em></p>

<p>Removes keys <code>K1</code> through <code>Kn</code>, and their associated values, from map <code>M0</code> and
  returns a new map <code>M1</code>.</p>

<p>Same as, <code>maps:from_list([{K,V}||{K,V} &lt;- maps:to_list(M0), not lists:member(K, Ks)])</code>.</p>

<h5><code>maps:merge(M0 :: map(), M1 :: map()) -&gt; M2 :: map().</code></h5>

<p>Syntax equivalence: <em>none</em></p>

<p>Merges two maps into a single map. If two <em>matching</em> keys exists in both maps the
  value in map <code>M0</code> will be superseded by the value in map <code>M1</code>.</p>

<h2>Equality and Ordering</h2>

<h3>Equality</h3>

<p>In the case of term <code>A</code> and term <code>B</code> both are maps,</p>

<ul>
<li>If <code>A</code> and <code>B</code> have different sizes, then <code>A</code> and <code>B</code> are not equal.</li>
<li>Otherwise, if all corresponding keys of <code>A</code> and <code>B</code> are pair-
wise equal with their corresponding values, then <code>A</code> and <code>B</code> are equal.</li>
<li>Otherwise, <code>A</code> and <code>B</code> are not equal.</li>
</ul>

<p>It follows that two maps are equal if, and only if, they are of
the same, <em>type</em>, <em>size</em> and all corresponding key-value associations are
pairwise equal.</p>

<h3>Ordering</h3>

<p>The term order is defined in <a href="http://www.Erlang.org/download/erl_spec47.ps.gz" title="Erlang specification 4.7">Erlang specification 4.7</a> and quoted
below:</p>

<blockquote>
  <ul>
<li><p>The terms are primarily ordered according to their type, in the following order: </p>

<pre><code>numbers &lt; atoms &lt; refs &lt; ports &lt; PIDs &lt; tuples &lt; empty list &lt; conses &lt; binary
</code></pre></li>
</ul>
</blockquote>

<p>The specification is incomplete here, the actual term order is:</p>

<pre><code>numbers &lt; atoms &lt; refs &lt; funs &lt; ports &lt; pids &lt; tuples &lt; empty list &lt; conses &lt; binaries
</code></pre>

<p>The Maps data-type are ordered next after tuples:</p>

<pre><code>numbers &lt; atoms &lt; refs &lt; funs &lt; ports &lt; pids &lt; tuples &lt; maps &lt; empty list &lt; conses &lt; binaries
                                                        ----
</code></pre>

<p>Maps are then ordered first by their size and then according to their
respective keys and lastly by the associated values in Erlang term order. </p>

<p>Given two maps, <code>M1</code> and <code>M2</code>, with the same size, they are compared
so that each key, in Erlang term order of the keys, in <code>M1</code>
is compared to the corresponding key of <code>M2</code>. All keys are
compared first, then the values, until a difference is found. If a key
or value differs, the order of the respective terms, in Erlang term
order, is the order of the maps. If no key-value pairs differ, the
maps are considered equal.</p>

<p>Example:</p>

<pre><code>&gt; #{ b =&gt; 2 } &gt; #{ a =&gt; 2 }.         % b &gt; a
true
&gt; #{ b =&gt; 2 } &gt; #{ a =&gt; 1, b =&gt; 2 }. % size 1 &lt; size 2
false
&gt; #{ b =&gt; 1 } &gt; #{ b =&gt; 2}.          % 1 &lt; 2
false
&gt; #{ b =&gt; 2, c =&gt; 3 } &gt; #{ b =&gt; 1, d =&gt; 3}.  % c &gt; d, compared before 2 and 1
false
&gt; #{ b =&gt; 1 } &gt; #{ 1 =&gt; 1}.          % b &gt; 1
true
&gt; #{ 1.0 =&gt; a } == #{ 1 =&gt; a }.      % 1.0 == 1
true
&gt; #{ 1.0 =&gt; a } =:= #{ 1 =&gt; a }.     % 1.0 =:= 1
false
</code></pre>

<p>Maps are printed with keys in arbitrary order.</p>

<h2>Operator Precedence</h2>

<p>Map association operator and set-value operator is ordered last,
after match-operator and <code>catch</code>.</p>

<pre><code>:
#
Unary + - bnot not
/ * div rem band and          Left associative
+ - bor bxor bsl bsr or xor   Left associative
++ --                         Right associative
== /= =&lt; &lt; &gt;= &gt; =:= =/=
andalso
orelse
= !                           Right associative
catch    
=&gt; :=
</code></pre>

<p>It follows that the map expression:</p>

<pre><code>#{ key =&gt; C = 1 + 2 }
</code></pre>

<p>will evaluate in the following order:</p>

<pre><code>#{ key =&gt; ( C = ( 1 + 2 ) ) }
</code></pre>

<h2>Pattern matching</h2>

<p>Pattern matching is very powerful Erlang tool. Maps introduces a couple of new
features with its pattern matching. </p>

<h3>Pattern matching: Basics</h3>

<p>We will exemplify using the match operator.</p>

<p>Pattern matching with maps is similar to records on the surface. Keys requested
in a LHS pattern will be bound with the values which is found in the
RHS association map.</p>

<pre><code>1&gt; #{ a := V } = #{ a =&gt; 1 }.
#{ a =&gt; 1 }
2&gt; 1 = V.
1
</code></pre>

<p>Keys requested in a LHS pattern which is not found in the RHS map will produce
an exception, <code>exception error: no match of right hand side value ...</code>.</p>

<pre><code>1&gt; #{ not_in_map := V } = #{ a =&gt; 1 }.
** exception error: no match of right hand side value #{ a =&gt; 1 }
</code></pre>

<p>Similarly, if a value for a requested key in the LHS pattern
does not match the keys associated value in the RHS map
the match will produce an exception.</p>

<pre><code>1&gt; #{ a := 10 } = #{ a =&gt; 1 }.
** exception error: no match of right hand side value #{ a =&gt; 1 }
</code></pre>

<p>Only the keys requested will bind to associations. Any unrequested keys which
resides within the map being matched will be ignored.</p>

<pre><code>1&gt; #{ a := V1, b := V2 } = #{ a =&gt; 1, b =&gt; 2, c =&gt; 3}.
#{ a =&gt; 1, b =&gt; 2, c =&gt; 3 }
2&gt; 1 = V1.
1
3&gt; 2 = V2.
2
</code></pre>

<p>The order of keys requested has no significance when pattern matching a map.</p>

<pre><code>1&gt; #{ a := "1", b := "2" } = #{ a =&gt; "1", b =&gt; "2" }.
#{ a =&gt; "1", b =&gt; "2" }
2&gt; #{ b := "2", a := "1" } = #{ a =&gt; "1", b =&gt; "2" }.
#{ a =&gt; "1", b =&gt; "2" }
</code></pre>

<h3>Pattern matching: Continued</h3>

<p>The example below is a constructed example to illustrate the power of map
pattern matching.</p>

<p>A match expression is evaluated so that variables used as keys in the expression
are bound before they are evaluated (if possible).</p>

<p>As an example, keys can be bound by other key-value associations.</p>

<pre><code>1&gt; #{ K := V, id := K } = M = #{ id =&gt; b, a =&gt; 1, b =&gt; 2, c =&gt; 3}.
#{ id =&gt; b, a =&gt; 1, b =&gt; 2, c =&gt; 3}
2&gt; b = K.
b
3&gt; 2 = V.
2
</code></pre>

<p>In this case, the bound key <code>id</code> is evaluated first and looked up in
M, binding the variable <code>K</code>. The <code>K</code> bound to <code>b</code> can then be used to
bind <code>V</code> to 2.</p>

<p>Binding variables used as keys requires that there is a possible order of
binding without cycles. The reordering extends to all terms in a matching
expression, so that:</p>

<pre><code>1&gt; { #{ X := Y }, X } = { #{ 5 =&gt; 10 }, 5 }.
</code></pre>

<p>with <code>X</code> and <code>Y</code> unbound, results in a successful match binding <code>X</code> to 5 and
<code>Y</code> to 10.</p>

<p>This is particular useful when updating specifics in map associations:</p>

<pre><code>%% Function declared in module map_example
update_values([{K, V1}|Ls], #{ K := V0 } = M) -&gt; update_values(Ls, M#{ K := V0 + V1 });
update_values([_|Ls], M) -&gt; update_values(Ls, M);
update_values([], M)     -&gt; M.
</code></pre>

<p>The first function clause is important here. Key <code>K</code> is bound in the tuple and
will be used to request value <code>V0</code> from map <code>M</code>. The map <code>M</code> is then updated to
associate key <code>K</code> with the new value <code>V0 + V1</code>.</p>

<pre><code>%% In the Erlang shell
1&gt; M = #{ "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }.
#{ "a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3 }

2&gt; map_example:update_values([{"b", 10}, {"c", 20}, {"d", 30 }], M).
#{ "a" =&gt; 1, "b" =&gt; 12, "c" =&gt; 23 }
</code></pre>

<p>Note that since key <code>"d"</code> does not reside in map <code>M</code> it fails to match the first
clause and does not update the map with the association <code>"d" =&gt; 40</code>.</p>

<p>An expression where the dependencies in the LHS of the match are cyclic, like:</p>

<pre><code>1&gt;  #{X := Y, Y := X} = #{5 =&gt; 10, 10 =&gt; 5}.
</code></pre>

<p>will result in an evaluator error (variable is unbound) or a compilation error.</p>

<h2>External Term Format</h2>

<p>There are 255 tags that can be used to encode terms for external binary
distribution.  All tags are defined in <code>external.h</code>. The encoding starts by a
magic byte <code>131</code>.</p>

<p>The encoding tags used in R15B01 are the following:</p>

<pre><code>SMALL_INTEGER_EXT        'a'     97
INTEGER_EXT              'b'     98
FLOAT_EXT                'c'     99 
ATOM_EXT                 'd'    100
SMALL_ATOM_EXT           's'    115
REFERENCE_EXT            'e'    101
NEW_REFERENCE_EXT        'r'    114
PORT_EXT                 'f'    102
NEW_FLOAT_EXT            'F'     70
PID_EXT                  'g'    103
SMALL_TUPLE_EXT          'h'    104
LARGE_TUPLE_EXT          'i'    105
NIL_EXT                  'j'    106 
STRING_EXT               'k'    107
LIST_EXT                 'l'    108 
BINARY_EXT               'm'    109 
BIT_BINARY_EXT           'M'     77                                         
SMALL_BIG_EXT            'n'    110
LARGE_BIG_EXT            'o'    111
NEW_FUN_EXT              'p'    112 
EXPORT_EXT               'q'    113
FUN_EXT                  'u'    117

DIST_HEADER              'D'     68
ATOM_CACHE_REF           'R'     82
ATOM_INTERNAL_REF2       'I'     73
ATOM_INTERNAL_REF3       'K'     75
BINARY_INTERNAL_REF      'J'     74
BIT_BINARY_INTERNAL_REF  'L'     76
COMPRESSED               'P'     80
</code></pre>

<p>For Maps we define tag <code>MAP_EXT</code> to 116 (<code>t</code>).</p>

<p>Data layout:</p>

<pre><code>MAP_EXT
|-----------------------------------    
|  1  |    4   |        |          |
|-----------------------------------
| 116 |  Size  |  Keys  |  Values  |
|-----------------------------------
</code></pre>

<p>The <code>Size</code> specifies the number of keys and values that follows the size
descriptor.</p>

<p>An open questions, optimize for:</p>

<ol>
<li>encoding/decoding speed?</li>
<li>ease of access?</li>
<li>memory size?</li>
</ol>

<p>Memory size should be a priority since we send this data over the wire. We
should promote ease of access so other languages can integrate towards the
format.</p>

<p>This leads to a flat and simple structure. It follows that encoding/decoding
takes a performance hit.</p>

<h1>Motivation</h1>

<p>Why would we need maps when we have <em>records</em>, <em>dicts</em>, <em>gb_trees</em>, <em>ets</em>
and <em>proplists</em>?</p>

<p>Maps are envisioned to be an easy to use, lightweight yet powerful key-value
association store.</p>

<p>Maps utilizes one of Erlang's major strengths, pattern matching, to enrich user
experience and provide a powerful tool to simplify code development. Pattern
matching gives Maps a clear edge over dicts, gb_trees or proplists in usability.</p>

<p>Maps provides the possibility to associate arbitrary terms as keys, not only
atoms, with arbitrary terms as values in a matching capable data-type.</p>

<p>Maps does not claim to be an replacement to records as the frames proposal does.
Instead maps targets a larger usage domain and wishes to be a complement to
records and supersede them where suitable.</p>

<h3>Maps - Two approaches</h3>

<ol>
<li>Maps as an association array with pattern matching and syntax for
constructing, accessing or updating them.</li>
<li>Maps as a record replacement.</li>
</ol>

<p>Maps were not envisioned as a record replacement at first, it was a hopeful
requirement added later. A record replacement approach does not necessarily
restrain any semantics but it may put some constraint on the implementation
and underlying structure.</p>

<h5>Records</h5>

<p>Records are powerful under the right circumstances:</p>

<ul>
<li>fast lookups, O(1), due to compile time indexing of keys, and fast stores for
small record sizes (~50 values),</li>
<li>no memory overhead to store keys, only values and a name: 2 + N words
consumption,</li>
<li>ease of use in function head matching.</li>
</ul>

<p>However some of the drawbacks are:</p>

<ul>
<li>compile-time dependency and forces header file inclusions for inter-module usage,</li>
<li>only atoms as keys,</li>
<li>keys are not accessible in runtime,</li>
<li>no dynamic access of values, i.e. we cannot use variables to access values,</li>
<li>it is not a data-type and cannot be distinguished from tuples.</li>
</ul>

<p>When comparing maps with records the drawbacks are easily remedied by Maps,
however the positive effects is not as easy to replicate in a built-in data-type
where values are determined at runtime instead of at compile time.</p>

<ul>
<li>Being faster than direct-indexing array, where indices and possibly the
resulting value are determined at compile time, is hard.
In fact it is impossible.</li>
<li>A memory model for Maps where the efficiency was near that of records
could be achieved by essentially using two tuples, one for keys and one for
values as demonstrated in Frames. This would be impact performance of
updates on Maps with a large number of entries and thus constrain the
capability of a dictionary approach.</li>
<li>Maps would be as easy, or even easier, to use with matching in function heads.</li>
</ul>

<h3>Protocol Construction</h3>

<p>Arguments for a simpler a JSON representation using frames or 
maps has been raised. Using frames and thereby atoms for dynamic creation of keys
would be a serious drawback.  Using maps would grant the possibility of string
binaries to represent keys and would not put the global atom pool in disarray.</p>

<h4>Pattern Matching Example: The JSON Files</h4>

<p>Changing json-decoding. Mochiwebs mochijson decodes Json dictionaries the as
the following:</p>

<pre><code>{"key": "value"} -&gt; {struct, [{"key", "value"}]}
</code></pre>

<p>This could instead be:</p>

<pre><code>{"key": "value"} -&gt; #{ "key" =&gt; "value"}
</code></pre>

<p>Consider the following JSON examples, from <a href="http://json.org/example.html" title="JSON Example">json.org</a>.</p>

<pre><code>{"menu": {
  "id": "file",
  "value": "File",
  "popup": {
    "menuitem": [
      {"value": "New", "onclick": "CreateNewDoc()"},
      {"value": "Open", "onclick": "OpenDoc()"},
      {"value": "Close", "onclick": "CloseDoc()"}
    ]
  }
}}
</code></pre>

<p><code>mochijson:decode/1</code> will currently look like:</p>

<pre><code>{struct, [
    {"menu", {struct, [
        {"id","file"},
        {"value","File"},
        {"popup", {struct, [
            {"menuitem", {array, [
                {struct, [{"value","New"},{"onclick","CreateNewDoc()"}]},
                {struct, [{"value","Open"},{"onclick","OpenDoc()"}]},
                {struct, [{"value","Close"}, {"onclick","CloseDoc()"}]}
            ]}}
        ]}}
    ]}}
]}
</code></pre>

<p><code>mochijson:decode/1</code> could look like:</p>

<pre><code>#{ "menu" =&gt; #{
    "id" =&gt; "file",
    "value" =&gt; "File",
    "popup" =&gt; #{
        "menuitem" =&gt; [
          #{ "value" =&gt; "New",   "onclick" =&gt; "CreateNewDoc()"},
          #{ "value" =&gt; "Open",  "onclick" =&gt; "OpenDoc()"},
          #{ "value" =&gt; "Close", "onclick" =&gt; "CloseDoc()"}
        ]
    }
}}
</code></pre>

<p>Let us find <code>"menu"</code> -> <code>"popup"</code> -> <code>"menuitem"</code>.</p>

<p>Traversing the first structure is a bit awkward. We would have to do
the following:</p>

<pre><code>Decoded         = mochijson:decode(Json),
{struct, Menu}  = proplists:get_value("menu", Decoded),
{struct, PopUp} = proplists:get_value("popup", Menu),
{struct, Items} = proplists:get_value("menuitem", PopUp),
</code></pre>

<p>With maps it could look like the following:</p>

<pre><code>#{ "menu"     := Menu  } = mochijson:decode(Json),
#{ "popup"    := PopUp } = Menu,
#{ "menuitem" := Items } = PopUp,
</code></pre>

<p>or even:</p>

<pre><code>Decoded = mochijson:decode(Json),
#{ "menu" := #{ "popup" := #{ "menuitem" := Items } } } = Decoded,
</code></pre>

<p>With maps, and single value access, it could look really simple:</p>

<pre><code>Decoded = mochijson:decode(Json),
Items = Decoded#{ "menu" }#{ "popup" }#{ "menuitem "}.
</code></pre>

<h3>Open Questions</h3>

<p>We have some usage scenarios that are still open for debate. A proposed answer
is given for each question and stems from discussions in this proposal.</p>

<ol>
<li>What type of keys will we need to store in our Map? Will atoms suffice? 
<ul>
<li>It is the authors view that we should refrain from any key restrictions
unless there is overwhelmingly evidence that we can gain something from
such a restriction.</li>
<li>A non atom key restriction satisfies our goal of a powerful Map mechanism.</li>
<li>Proposal: <em>Any term as keys.</em></li>
</ul></li>
<li>How many key-value associations will we store in our map?
<ul>
<li>This question has less to do with syntax and semantics than it has with
the choice of the underlying implementation.</li>
<li>If we enable the user to add key-value pairs dynamically surely he will
use it.  Since it is a powerful mechanism not afforded to us by records
the usage pattern will also be different. This will in all likelihood
produce larger Maps than records are today. This implies that we cannot
compare records sizes with that of maps sizes since the usage scenario
would be different.</li>
<li>Proposal: <em>Arbitrary number of keys-value pairs.</em></li>
</ul></li>
<li>How many Map instances will we create for each Map with a specific set of keys?
<ul>
<li>This question is closely related to how we use records and if Maps should
emulate this behavior and this should have no impact on semantics, only
implementation.</li>
<li>The significant difference is the memory overhead in the storing structure.
Since memory overhead for keys and values has the same behavior as in any
compound term or abstract data-type, i.e. dict or gb_trees, the main
difference occurs when comparing maps to records and frames. To ensure a
logarithmic worst-case performance in update or retrieval some sort tree
structure would likely be used for maps. Maps would then stores keys
together with its values whereas frames stores keys outside its value
structure and records generates key indexes at compile-time. This would
indicate a memory overhead for Maps over Frames and records for each
instance.</li>
<li>Proposal: <em>Two tier approach, similar to binaries. Use flat compact,
key-sharing approach for few associations (~50 associations). Use sorted
tree approach and store keys with values beyond first tier limit.
The rationale being it is more likely to have multiple instance where
we have few keys.</em></li>
</ul></li>
<li>Only allow updates of already defined keys within a Map in syntax?
<ul>
<li>The question stems from a record replacement approach and the argument for
it is to mitigate typos, i.e. trying to update key <code>behavior</code> where key
<code>behaviour</code> was actually intended. Instead of getting two different keys,
a runtime exception occurs at this point.</li>
<li>This approach will <em>deny</em> any dictionary like behavior, for instance
storing spawned processes as keys in the map using syntax.</li>
<li>Proposal: <em>Allow for any key to be stored by default syntax,
existing or not, and use a special syntax for setting of values of
existing keys only.</em></li>
</ul></li>
</ol>

<p>The answers from these questions are instrumental to how we should design and
implement Maps. What we also should keep in the back of our minds is that we
will never get rid of records completely and some of the frames arguments might
thus be superfluous.</p>

<h1>Rationale</h1>

<h2>What should we expect from our syntax?</h2>

<p>As stated earlier, the current syntax is not set in stone but what should we
expect from it?</p>

<ol>
<li><p>First and foremost it has to be unambiguous, meaning the syntax must produce
single clearly defined behavior that cannot be misinterpreted by humans
nor machines.</p>

<p>1.1  Here we also include the notion that similar syntax should have similar
    behavior, or at least not completely different behavior.
For example records, <code>#record{ key = Value }</code>, have O(1) performance and
2 + N words memory overhead.  If we use a similar syntax,
i.e. <code>#{ key = Value }</code>, we should also expect similar behavior both in
regard to semantics and performance for any and all sizes of the map.</p></li>
<li><p>The syntax must be as short as possible. It must not use more characters than
necessary to describe a certain behavior as long as it
does not violate rule 1.</p>

<p>2.2  We want to avoid verbosity in the language. Verbosity pushes away
information from our field of vision and obfuscates it.
This needs to be avoided.</p></li>
</ol>

<h2>Syntax choice for Maps</h2>

<p><em>The author argues for:</em> <code>=&gt;</code> <em>as delimiter in 'set-or-update' and</em>
<code>:=</code> <em>in 'set-existing' and 'matching' syntax.</em></p>

<p>In the examples below we use <code>#{ Key =&gt; Value }</code> to describe map semantics and
use-cases, but this is only one suggestion out of many.</p>

<p>Several syntax proposals exists, frames proposes <code>&lt;{ key ~ Value }&gt;</code> syntax and
another syntax suggestion is very similar to record syntax <code>#{ key = Value }</code>.</p>

<p>The current variable and atom definitions puts restrictions on what we can use
as delimiters and leaves us <code>~</code> and <code>=</code> as the only sane <em>single</em> character
delimiters we can use. The case is very well argued in Richard O'Keefes
<a href="http://www.cs.otago.ac.nz/staffpriv/ok/frames.pdf" title="No more need for records">No more need for records (fifth draft)</a>.</p>

<h3>Delimiter discussion</h3>

<p>Arguments against a <code>=</code> delimiter are:</p>

<ul>
<li>It lacks distinction from match, consider <code>#{ A = B = v }</code>,
 does <code>A</code> match <code>B</code> or does <code>B</code> match <code>v</code>?
 Which <code>=</code> is a match operation and which <code>=</code> delimits the key-value pair?</li>
<li>It might be interpreted as <code>Key</code> 'equal' <code>Value</code>,</li>
</ul>

<p>and hence <code>=</code> is in violation of rule #1 from <em>What do we expect from our syntax?</em>.
The interpretation of this syntax is ambiguous.</p>

<p>Arguments against a <code>~</code> delimiter are:</p>

<ul>
<li>it might be interpreted as <code>Key</code> 'NOT' <code>Value</code>
 as <code>~</code> is the bitwise NOT operator in C,</li>
<li>it might be interpreted as <code>Key</code> 'about equal' <code>Value</code>
 as <code>~</code> is similar to mathematics <code>‚âÉ</code>,</li>
<li>it lacks typographical distinction,
 i.e. it lacks distinction from <code>-</code> in certain fonts, 
 ex. <code>K ~ V</code> might be interpreted as <code>K - V</code>, consider <code>#{ K - 1 ~ 2 - V }</code>,</li>
</ul>

<p>and hence this is in violation of rule #1 from <em>What do we expect from our syntax?</em>.
The interpretation of this syntax is ambiguous.</p>

<p>Two two-character delimiter suggestions are <code>#{ Key := Value }</code> and
<code>#{ Key =&gt; Value}</code>, where <code>:=</code> is a common denominator for assignment and <code>=&gt;</code>
should be read as <em>maps to</em>. A two-character delimiter should be avoided if at
all possible since it increases the syntax footprint of the source code.</p>

<p>The assignment delimiter reads well for just assignment but suffers from the
same reversed logic flaw as records when it comes to pattern matching. The match
<code>#{ key := Value } = M</code> reads <em>match M to the map pattern where Value is equal
to key</em>. That does not read well unless we call the assignment delimiter <code>:=</code>
for something that its not meant to be.</p>

<p>However, <code>:=</code> is also similar to <code>=:=</code> which means "is exactly equal",
i.e. matches. This is a valuable meaning since we have a difference
between <code>==</code> and <code>=:=</code> when dealing with numbers and thus <code>:=</code> could be a more
correct delimiter for matching syntax.</p>

<p>The delimiter <code>-&gt;</code> would be suitable choice if it weren't for the fact that it
would overload the function clause meaning.</p>

<p>Both <code>-&gt;</code> and <code>=&gt;</code> might be confusing when dealing with binaries.
Consider <code>#{ &lt;&lt;"key"&gt;&gt; -&gt; &lt;&lt;"value"&gt;&gt; }</code> and <code>#{ &lt;&lt;"key"&gt;&gt; =&gt; &lt;&lt;"value"&gt;&gt; }</code>,
where <code>=&gt;</code> appears to be slightly more confusing than <code>-&gt;</code>.</p>

<p>Listing of delimiters from above perceived desirability: </p>

<ol>
<li><code>#{ K =&gt; V }</code> - No ambiguity, no overloading, reads as an association</li>
<li><code>#{ K := V }</code> - No ambiguity, no overloading, reads as an assignment or exact match</li>
<li><code>#{ K ~ V }</code>  - Typographical ambiguity, no overloading, no clear meaning</li>
<li><code>#{ K -&gt; V }</code> - Overloads function clause head and body separator, reads as an association</li>
<li><code>#{ K = V }</code>  - Overloads match operator, reads as a match or an assignment</li>
</ol>

<p>Using <code>:=</code> assignment for existing keys seems as a good choice. The choice for
set-or-update is between <code>=&gt;</code> and <code>~</code>.</p>

<h3>The case for two set-or-update semantics and its syntax</h3>

<p>A case for two different ways to update values in a Map is proposed.</p>

<p>One syntax if, and only if, we want to update a value for an already <em>existing</em>
key and another if we want to update the Map with any key.</p>

<ul>
<li>Use <code>M#{ K =&gt; V }</code> to declare new key value pairs <em>or</em> update already existing keys</li>
<li>Use <code>M#{ K := V }</code> to update already existing keys.</li>
<li>Use <code>#{ K := V } = M</code> to match maps.</li>
</ul>

<p>Example 1:</p>

<pre><code>foo() -&gt;
    M = #{ key1 =&gt; 1, key2 =&gt; 2 }, % M is declared with keys 'key1' and 'key2'
    bar(M).

bar(M) -&gt;
    M#{
        key1 := "1",  %% 'key1' will be set to "1"
        key2 := "2",  %% 'key2' will be set to "2"
        key3 := "3"   %% this causes an exception since 'key3' does not exist in M
    }.

&gt; foo().
** exception error: no match of 'key3' in map
</code></pre>

<p>Example 2:</p>

<pre><code>foo() -&gt;
    M = #{ key1 =&gt; 1, key2 =&gt; 2 }, % M is declared with keys 'key1' and 'key2'
    bar(M).

bar(M) -&gt;
    M#{
        key1 =&gt; "1",  %% 'key1' will be set to "1"
        key2 =&gt; "2",  %% 'key2' will be set to "2"
        key3 =&gt; "3"   %% 'key3' will be set to "3"
    }.

&gt; foo().
#{ key1 =&gt; 1, key2 =&gt; "2", key3 =&gt; "3" }
</code></pre>

<h2>Impact of syntax footprint</h2>

<p>We must lessen the syntax footprint impact on the source code and the language.</p>

<p>Currently the two normal ways of sending options to a functions are either via
records or property lists. Both have some drawbacks. Records are compile time
dependent and syntactic sugar for tuples. Property lists are generic but
produces a lot of texts when defining them and operating on them.</p>

<p>Consider this example when parsing a list of arguments:</p>

<pre><code>args(Args) -&gt; 
     args(Args, [{analyze, false}, {suppression, false}, {target, none}]).

args(["-r" | Args], Opts) -&gt; 
    args(Args, [{analyze, true}     | proplists:delete(analyze, Opts)]);
args(["-s="++File | Args], Opts) -&gt; 
    args(Args, [{suppression, File} | proplists:delete(suppression, Opts)]);
args([Target], Opts) -&gt; 
    [{target, Target} | proplists:delete(target, Opts)].
</code></pre>

<p>The textual impact, the number of characters, is quite heavy when operating on 
property lists.</p>

<p>If we instead use some kind of map with syntax, how would that look?</p>

<pre><code>args(Args) -&gt; 
    args(Args, #{ analyze =&gt; false, suppression =&gt; false, target =&gt; none}).

args(["-r" | Args], Opts)        -&gt; args(Args, Opts#{ analyze := true });
args(["-s="++File | Args], Opts) -&gt; args(Args, Opts#{ suppression := File});
args([Target], Opts)             -&gt; Opts#{ target := Target }.
</code></pre>

<p>This looks cleaner in my opinion but that is a very subjective view. To use some
data we can count the characters, and we see that the property lists example has
390 characters versus the map examples 306. Property lists uses almost 30% more
characters in this example.</p>

<h2>Semantics and API-functions</h2>

<h3>List conversions</h3>

<p>Perhaps the most sane <code>maps:from_list/1</code> semantics would be to have the key-value
significance order in left to right, meaning the first association is used and
the latter values with matching keys are ignored.</p>

<p>This differs from the <code>dict:from_list/1</code> behavior.</p>

<p>Consider the following <code>dict</code> example:</p>

<pre><code>[{a,2}] = dict:to_list(dict:from_list([{a,1}, {a,2}])).
</code></pre>

<p>By letting the leftmost be the most significant key we could simplify conversion
from and to lists. </p>

<p>Current suggestion has the following semantics:</p>

<pre><code>Ls = [{a,old}],
#{ a := old } = maps:from_list([{a,new}|Ls]).
</code></pre>

<p>The reversal would be:</p>

<pre><code>Ls = [{a,old}],
#{ a := new } = maps:from_list([{a,new}|Ls]).
</code></pre>

<h2>Equality and Ordering</h2>

<p>A restriction set on the implementation by the Erlang specification is that
order is total, i.e. satisfies <em>antisymmetry</em>, <em>transitivity</em> and <em>totality</em>.</p>

<ul>
<li>If <code>M1 =&lt; M2</code> and <code>M2 =&lt; M1</code> then <code>M1 == M2</code>,</li>
<li>If <code>M1 =&lt; M2</code> and <code>M2 =&lt; M3</code> then <code>M1 =&lt; M3</code>,</li>
<li>If <code>M1 =&lt; M2</code> or <code>M2 =&lt; M1</code> (always comparable)
where <code>M1</code>, <code>M2</code> and <code>M3</code> are any Map term.</li>
</ul>

<p>This only holds true in Erlang if we treat floats and integers as union of types,
namely numbers. In the case of a Maps, <code>true = #{ 1.0 =&gt; V } == #{ 1 =&gt; V}</code>.</p>

<ul>
<li>The need for order arises in a few cases.
<ul>
<li>comparison, for example sorting, <code>lists:sort([M1, .., Mn])</code></li>
<li>introspection, for example when printed.</li>
</ul></li>
<li>Ordered maps impose restrictions on the underlying implementation and a
hashing approach will be nearly impossible.</li>
<li>The underlying structure does not need to be sorted, an order could be
produced when needed,
<ul>
<li><code>M1</code> &lt; <code>M2</code>, would result in an internal sort but would cost
O( <em>N1</em> * lg <em>N1</em> + <em>N2</em> * lg <em>N2</em> ), where
<code>N1 = maps:size(M1) and N2 = maps:size(M2)</code></li>
</ul></li>
</ul>

<h2>Accessing a single value</h2>

<p>Do we need to have single access or is matching sufficient?</p>

<p>Consider the following,</p>

<pre><code>V = M#{ K }
</code></pre>

<p>is shorter than</p>

<pre><code>#{ K := V } = M
</code></pre>

<p>It also allows for easy access of associated values in deep structures.</p>

<p>The syntax for single value access is the least developed (and contemplated)
feature in this proposal and certainly could use some input.</p>

<p>More over, the dot syntax must be abolished. Currently it is used for records
but it will not be used for maps. Dot represents end of expression list in last
clause, or end of attribute.</p>

<p>It cannot be used to distinguish between floats or associations.</p>

<p>Example:</p>

<pre><code>1&gt; M = #{ 1.1 =&gt; a, 1 =&gt; #{ 1 =&gt; b } }.
#{ 1 =&gt; #{ 1 =&gt; b }, 1.1 =&gt; a }.

2&gt; #M.1.1.
a | b ?
</code></pre>

<h1>Backwards Compatibility</h1>

<p>Erlang code written with Maps will only be parseable, loadable and executable 
on Erlang/OTP R17A and later releases of Erlang/OTP but not on previous
releases.</p>

<p>Erlang code written before Erlang/OTP R17A will be perfectly compatible, i.e.
parseable, loadable and executable with these Maps changes.</p>

<p>Distribution will not be backwards compatible.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0043","content":"\u003cpre\u003e\u003ccode\u003eAuthor:         Bj√∂rn-Egil Dahlberg \u0026lt;egil(at)Erlang.org\u0026gt;\nStatus:         Draft\nType:           Standards Track\nCreated:        04-Apr-2013\nErlang-Version: R17A\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 43: \u003ca href=\"eep-0043.md\" title=\"EEP Source\"\u003e Maps\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThe journey of Maps and this EEP has been long and by no means a\nstraight-forward and continuous one. I had a crystal clear picture of what I\nwanted Maps to be when we first started discussing it within OTP about\ntwo-three years ago. This EEP resembles that vision but it has had a lot of\ncontributions of other ideas from both within and outside of OTP.\u003c/p\u003e\n\n\u003cp\u003eThe idea was a data-type, a syntax aware mapping of key-value associations\nwith pattern matching. A syntax similar to records but without the hazzle of\ncompile-time dependency and with arbitrary terms as keys. Order was not\nimportant and it could be implemented with a Hash-Array-Mapped-Trie with good\nperformance and memory trade-offs. This was a different approach than to replace\nrecords. It was meant to replace records where suitable and in other regards\nnot be a replacement but its own \u003cem\u003ething\u003c/em\u003e.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eFrom the community there has been many wishes of a Map like data-type and a\nfew suggestions.  The one suggestion that stands out is of course the Frames\nproposal from Richard O'Keefe. It is the most complete proposal I've seen and\nis very well thought out. Its goal is to be a record replacement and the\nproposal satisfies this goal very well.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cul\u003e\n\u003cli\u003eIf Frames are that good, why a separate EEP?\u003c/li\u003e\n\u003cli\u003eIt boils down to goals and constraints.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA record replacement is just that, a replacement.\nIt's like asking the question, \"What do we have?\" instead of \"What can we get?\"\nThe instant rebuttal would be \"What do we need?\" I say Maps.\u003c/p\u003e\n\n\u003cp\u003eFrames has certainly inspired and influenced Maps. In many regards Maps also\nencompasses Frames but Maps tries to do more. In the end I believe they are\ntwo different things and have different goals.\u003c/p\u003e\n\n\u003cp\u003eThis EEP suggests a new built in data-type for Erlang, the map, \n\u003ccode\u003e#{ Key =\u0026gt; Value }\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe new data-type shall have semantics, syntax and operations that:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eprovides an association set from key terms to value terms which can be\nconstructed, accessed and updated using language syntax\u003c/li\u003e\n\u003cli\u003ecan be uniquely distinguished from every other data-type in the language\u003c/li\u003e\n\u003cli\u003ehas no compile-time dependency for constructing, accessing or updating\ncontents of maps nor for passing maps between modules, processes or over\nErlang distribution\u003c/li\u003e\n\u003cli\u003ecan be used in matching expressions in the language\u003c/li\u003e\n\u003cli\u003ehas a one-to-one association between printing and parsing the data-type \u003c/li\u003e\n\u003cli\u003ehas a well defined order between terms of the type and other Erlang types\u003c/li\u003e\n\u003cli\u003ehas at most O(log N) time complexity in insert and lookup operations, where \nN is the number of key-value associations.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSimilar data-types exists in other languages, i.e.  \u003ca href=\"http://perldoc.perl.org/perldata.html\" title=\"perldata - perldoc.perl.org\"\u003eperl hashes\u003c/a\u003e,\n\u003ca href=\"http://ruby-doc.org/core-1.9.3/Hash.html\" title=\"Class: Hash (Ruby 1.9.3)\"\u003eruby hashes\u003c/a\u003e, \u003ca href=\"http://docs.python.org/tutorial/datastructures.html#dictionaries\" title=\"5. Data Structures - Python v2.7.3 documentation\"\u003epython dictionaries\u003c/a\u003e, or\n\u003ca href=\"http://docs.scala-lang.org/overviews/collections/maps.html\" title=\"Collections - Maps - Scala Documentation\"\u003escala maps\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eA map \u003ccode\u003eM\u003c/code\u003e consists of a number of \u003cem\u003eassociations\u003c/em\u003e and keeps an association\nfrom key terms \u003ccode\u003eK1..Kn\u003c/code\u003e to value terms \u003ccode\u003eV1..Vn\u003c/code\u003e where no two keys \u003cem\u003ematch\u003c/em\u003e.\nAny term, compound or otherwise, is a viable key or value. Terms of type Map\nare recognized by guard tests \u003ccode\u003eerlang:is_map/1\u003c/code\u003e. There are no operators\nacting on maps. Within maps there are two infix operators. An association\noperator, \u003ccode\u003e=\u0026gt;\u003c/code\u003e, pairs a key to a value and is used in creation and updates.\nA set-value operator, \u003ccode\u003e:=\u003c/code\u003e, is used to update a value on an already\nexisting and matching key. The set-value operator is also used in matching\nto get the associated value from a key.\u003c/p\u003e\n\n\u003ch2\u003eTerminology\u003c/h2\u003e\n\n\u003cp\u003eThe \u003cem\u003esize\u003c/em\u003e of a map is the number of associations in its set.\u003c/p\u003e\n\n\u003cp\u003eAn \u003cem\u003eassociation\u003c/em\u003e is a key-value pair of key \u003cem\u003eK\u003c/em\u003e to value \u003cem\u003eV\u003c/em\u003e in a Map.\u003c/p\u003e\n\n\u003cp\u003eTwo keys, \u003ccode\u003eK1\u003c/code\u003e and \u003ccode\u003eK2\u003c/code\u003e are \u003cem\u003ematching\u003c/em\u003e if, \u003ccode\u003etrue = K1 =:= K2\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eSyntax\u003c/h2\u003e\n\n\u003cp\u003eDefined syntax for declaring, updating and matching maps.\u003c/p\u003e\n\n\u003ch3\u003eConstruction syntax\u003c/h3\u003e\n\n\u003cp\u003eConstructing a new map is done by letting an expression \u003ccode\u003eK\u003c/code\u003e be associated to\nanother expression \u003ccode\u003eV\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ K =\u0026gt; V }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNew maps may include multiple associations at construction by listing every\nassociation:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ K1 =\u0026gt; V1, .. Kn =\u0026gt; Vn }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn empty map is constructed by not associating any terms with each other:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAll keys and values in the map are terms. Any expression is first evaluated and\nthen the resulting terms are used as \u003cem\u003ekey\u003c/em\u003e and \u003cem\u003evalue\u003c/em\u003e respectively.\u003c/p\u003e\n\n\u003cp\u003eKeys and values are separated by the \u003ccode\u003e=\u0026gt;\u003c/code\u003e arrow and associations are\nseparated by \u003ccode\u003e,\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eExamples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM0 = #{},                   % empty map\nM1 = #{ a =\u0026gt; \u0026lt;\u0026lt;\"hello\"\u0026gt;\u0026gt; }, % single association with literals\nM2 = #{ 1 =\u0026gt; 2, b =\u0026gt; b },   % multiple associations with literals\nM3 = #{ A =\u0026gt; B },           % single association with variables\nM4 = #{ {A, B} =\u0026gt; f() }.    % compound key associated to an evaluated expression\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere, \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e are any expressions and \u003ccode\u003eM0\u003c/code\u003e through \u003ccode\u003eM4\u003c/code\u003e are the resulting\nmap terms.\u003c/p\u003e\n\n\u003cp\u003eIf two matching keys are declared, the latter key will take precedent.\u003c/p\u003e\n\n\u003cp\u003eExample:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ 1 =\u0026gt; a, 1 =\u0026gt; b }.\n#{ 1 =\u0026gt; b }\n2\u0026gt; #{ 1.0 =\u0026gt; a, 1 =\u0026gt; b }.\n#{ 1 =\u0026gt; b, 1.0 =\u0026gt; a }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe order in which the expressions constructing the keys and their\nassociated values are evaluated is not defined. The syntactic order of\nthe key-value pairs in the construction is of no relevance, except in\nthe above mentioned case of two matching keys.\u003c/p\u003e\n\n\u003cp\u003eA simple BNF grammar for the construction follows:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e \u0026lt;map-construct\u0026gt;  ::= '#{' \u0026lt;key-value-exprs\u0026gt; '}'\n\u0026lt;key-value-exprs\u0026gt; ::= /* empty */\n                    | \u0026lt;key-value-list\u0026gt;\n \u0026lt;key-value-list\u0026gt; ::= \u0026lt;key-value-assoc\u0026gt; \n                    |¬†\u0026lt;key-value-assoc\u0026gt; ',' \u0026lt;key-value-list\u0026gt;\n\u0026lt;key-value-assoc\u0026gt; ::= \u0026lt;expr\u0026gt; '=\u0026gt;' \u0026lt;expr\u0026gt;\n           \u0026lt;expr\u0026gt; ::= \u0026lt;Erlang-expression\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eUpdate syntax\u003c/h3\u003e\n\n\u003cp\u003eUpdating a map has similar syntax as constructing it.\u003c/p\u003e\n\n\u003cp\u003eAn expression defining the map to be updated is put in front of the expression\ndefining the keys to be updated and their respective values.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM#{ K =\u0026gt; V }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eM\u003c/code\u003e is an term of type map and \u003ccode\u003eK\u003c/code\u003e and \u003ccode\u003eV\u003c/code\u003e are any expression.\u003c/p\u003e\n\n\u003cp\u003eIf key \u003ccode\u003eK\u003c/code\u003e does not \u003cem\u003ematch\u003c/em\u003e any existing key in the map, a new association\nwill be created from key \u003ccode\u003eK\u003c/code\u003e to value \u003ccode\u003eV\u003c/code\u003e.  If key \u003ccode\u003eK\u003c/code\u003e \u003cem\u003ematches\u003c/em\u003e an existing\nkey in map \u003ccode\u003eM\u003c/code\u003e its associated value will be replaced by the new value \u003ccode\u003eV\u003c/code\u003e. In both\ncases the evaluated map expression will return a new map.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003eM\u003c/code\u003e is not of type map an exception of type \u003ccode\u003ebadmap\u003c/code\u003e is thrown.\u003c/p\u003e\n\n\u003cp\u003eTo only update an existing value, the following syntax is used,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM#{ K := V }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eM\u003c/code\u003e is an term of type map, \u003ccode\u003eV\u003c/code\u003e is an expression and \u003ccode\u003eK\u003c/code\u003e is an expression\nwhich evaluates to an existing key in \u003ccode\u003eM\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf key \u003ccode\u003eK\u003c/code\u003e does not \u003cem\u003ematch\u003c/em\u003e any existing keys in map \u003ccode\u003eM\u003c/code\u003e an exception of type\n\u003ccode\u003ebadarg\u003c/code\u003e will be triggered at runtime. If a \u003cem\u003ematching\u003c/em\u003e key \u003ccode\u003eK\u003c/code\u003e is present in\nmap \u003ccode\u003eM\u003c/code\u003e its associated value will be replaced by the new value \u003ccode\u003eV\u003c/code\u003e and the\nevaluated map expression returns a new map.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003eM\u003c/code\u003e is not of type map an exception of type \u003ccode\u003ebadmap\u003c/code\u003e is thrown.\u003c/p\u003e\n\n\u003cp\u003eExamples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM0 = #{},\nM1 = M0#{ a =\u0026gt; 0 },\nM2 = M1#{ a =\u0026gt; 1, b =\u0026gt; 2 },\nM3 = M2#{ \"function\" =\u0026gt; fun() -\u0026gt; f() end },\nM4 = M3#{ a := 2, b := 3 }.  % 'a' and 'b' was added in `M1` and `M2`.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eM0\u003c/code\u003e is any map. It follows that \u003ccode\u003eM1 .. M4\u003c/code\u003e are maps as well.\u003c/p\u003e\n\n\u003cp\u003eMore Examples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; M = #{ 1 =\u0026gt; a }.\n#{ 1 =\u0026gt; a }\n\n2\u0026gt; M#{ 1.0 =\u0026gt; b }.\n#{ 1 =\u0026gt; a, 1.0 =\u0026gt; b }.\n\n3\u0026gt; M#{ 1 := b }.\n#{ 1 =\u0026gt; b }\n\n4\u0026gt; M#{ 1.0 := b }.\n** exception error: bad argument\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs in construction, the order in which the key and value expressions\nare evaluated are not defined. The\nsyntactic order of the key-value pairs in the update is of no\nrelevance, except in the case where two keys match, in which\ncase the latter value is used.\u003c/p\u003e\n\n\u003cp\u003eA simple BNF grammar for map updates follows:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e \u0026lt;map-construct\u0026gt;  ::= \u0026lt;map-expr\u0026gt; '#{' \u0026lt;key-value-exprs\u0026gt; '}'\n\u0026lt;key-value-exprs\u0026gt; ::= /* empty */\n                    | \u0026lt;key-value-list\u0026gt;\n \u0026lt;key-value-list\u0026gt; ::= \u0026lt;key-value\u0026gt; \n                    |¬†\u0026lt;key-value\u0026gt; ',' \u0026lt;key-value-list\u0026gt;\n      \u0026lt;key-value\u0026gt; ::= \u0026lt;key-value-assoc\u0026gt;\n                    | \u0026lt;key-value-exact\u0026gt;\n\u0026lt;key-value-assoc\u0026gt; ::= \u0026lt;expr\u0026gt; '=\u0026gt;' \u0026lt;expr\u0026gt;\n\u0026lt;key-value-exact\u0026gt; ::= \u0026lt;expr\u0026gt; ':=' \u0026lt;expr\u0026gt;\n       \u0026lt;map-expr\u0026gt; ::= \u0026lt;Erlang expression evaluating to a term of type map\u0026gt;\n           \u0026lt;expr\u0026gt; ::= \u0026lt;Erlang expression\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eAccessing a single value\u003c/h3\u003e\n\n\u003cp\u003eFor accessing single values in maps, let us use an de-association:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eV = M#{ K }.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhere \u003ccode\u003eM\u003c/code\u003e is a Map and \u003ccode\u003eK\u003c/code\u003e is any term.\u003c/p\u003e\n\n\u003cp\u003eIf key \u003ccode\u003eK\u003c/code\u003e \u003cem\u003ematches\u003c/em\u003e to an existing key in map \u003ccode\u003eM\u003c/code\u003e the associated value\nwill be bound to \u003ccode\u003eV\u003c/code\u003e. If key \u003ccode\u003eK\u003c/code\u003e does not \u003cem\u003ematch\u003c/em\u003e to any existing key in\nmap \u003ccode\u003eM\u003c/code\u003e an exception \u003ccode\u003ebadarg\u003c/code\u003e will occur in runtime.\u003c/p\u003e\n\n\u003cp\u003eExamples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM1 = #{ a =\u0026gt; 1, c =\u0026gt; 3 },\n3 = M1#{ c }.\n\nM2 = #{ 1.0 =\u0026gt; a },\na = M2#{ 1 }.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eMatching syntax\u003c/h3\u003e\n\n\u003cp\u003eMatching of key-value associations from maps, exemplified with the\nmatching operator, is done in the following way:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ K := V } = M\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eM\u003c/code\u003e is any map. The key \u003ccode\u003eK\u003c/code\u003e has to be an expression with bound variables\nor a literals, and \u003ccode\u003eV\u003c/code\u003e can be any pattern with either bound or unbound variables.\nIf variables in \u003ccode\u003eV\u003c/code\u003e are unbound, it will be bound to the value associated\nwith the key \u003ccode\u003eK\u003c/code\u003e, which has to exist in the map \u003ccode\u003eM\u003c/code\u003e. If variables in \u003ccode\u003eV\u003c/code\u003e are\nbound, it has to match the value associated with \u003ccode\u003eK\u003c/code\u003e in \u003ccode\u003eM\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eExample:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM = #{ a =\u0026gt; {1,2}},\n#{ a := {1,B}} = M.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis will bind variable \u003ccode\u003eB\u003c/code\u003e to integer \u003ccode\u003e2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSimilarly, multiple values from the map may be matched:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ K1 := V1, .., Kn := Vn } = M\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere keys \u003ccode\u003eK1 .. Kn\u003c/code\u003e are any expressions with literals or bound variables. If all\nkeys exists in map \u003ccode\u003eM\u003c/code\u003e all variables in \u003ccode\u003eV1 .. Vn\u003c/code\u003e will be matched to the\nassociated values of there respective keys.\u003c/p\u003e\n\n\u003cp\u003eIf the matching conditions are not met, the match will fail, either with\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003ea \u003ccode\u003ebadmatch\u003c/code\u003e exception, if used in the context of the matching operator\n as in the example, \u003c/li\u003e\n\u003cli\u003eor resulting in the next clause being tested in function heads and\n case expressions.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eMatching in maps only allows for \u003ccode\u003e:=\u003c/code\u003e as delimiters of associations.\u003c/p\u003e\n\n\u003cp\u003eThe order in which keys are declared in matching has no relevance.\u003c/p\u003e\n\n\u003cp\u003eDuplicate keys are allowed in matching and will match each pattern associated\nto the keys.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ K := V1, K := V2 } = M\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eMatching an expression against an empty map literal will match its type but\nno variables will be bound:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{} = Expr\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis expression will match if the expression \u003ccode\u003eExpr\u003c/code\u003e is of type map, otherwise\nit will fail with an exception \u003ccode\u003ebadmatch\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe grammar for the matching syntax is similar to that of construction.\u003c/p\u003e\n\n\u003ch4\u003eMatching syntax: Example with literals in function heads\u003c/h4\u003e\n\n\u003cp\u003eMatching of literals as keys are allowed in function heads.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e%% only start if not_started\nhandle_call(start, From, #{ state := not_started } = S) -\u0026gt;\n...\n    {reply, ok, S#{ state := start }};\n\n%% only change if started\nhandle_call(change, From, #{ state := start } = S) -\u0026gt;\n...\n    {reply, ok, S#{ state := changed }};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4\u003eMatching syntax: Frequency example\u003c/h4\u003e\n\n\u003cp\u003eMore matching syntax, calculating frequency of terms in a list.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efreq(Is)                    -\u0026gt; freq(Is, #{}).\nfreq([I|Is], #{I := C} = M) -\u0026gt; freq(Is, M#{ I := C + 1});\nfreq([I|Is], M)             -\u0026gt; freq(Is, M#{ I =\u0026gt; 1 });\nfreq([], M)                 -\u0026gt; maps:to_list(M).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eEquivalent code with \u003ccode\u003egb_trees\u003c/code\u003e for comparison:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efreq(Is)        -\u0026gt; freq(Is, gb_trees:empty()).\nfreq([I|Is], T) -\u0026gt;\n    case gb_trees:lookup(I, T) of \n        none       -\u0026gt; freq(Is, gb_trees:enter(I, 1), T);\n        {value, V} -\u0026gt; freq(Is, gb_trees:enter(I, V + 1, T))\n    end;\nfreq([], T) -\u0026gt; gb_trees:to_list(T).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4\u003eMatching syntax: File information example\u003c/h4\u003e\n\n\u003cp\u003eOld API's could be refined to use map syntax:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; {ok, #{ type := Type, mtime := Mtime }} = file:read_file_info(File).\n2\u0026gt; io:format(\"type: ~p, mtime: ~p~n\", [Type, Mtime]).\ntype: regular, mtime: {{2012,7,18},{19,59,18}}\nok\n3\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eMap comprehension syntax\u003c/h3\u003e\n\n\u003cp\u003eMap comprehension declaration:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM1 = #{ E0 =\u0026gt; E1 || K := V \u0026lt;- M0  }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eM0\u003c/code\u003e is any Map, \u003ccode\u003eE0\u003c/code\u003e and \u003ccode\u003eE1\u003c/code\u003e are any erlang expression, \u003ccode\u003eK\u003c/code\u003e and \u003ccode\u003eV\u003c/code\u003e\nconstitutes the pattern to be matched by each association in \u003ccode\u003eM0\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor each sequence in the generator an association is created from the evaluated\nexpression \u003ccode\u003eE0\u003c/code\u003e to the evaluated expression \u003ccode\u003eE1\u003c/code\u003e. \u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003eM0\u003c/code\u003e is not a Map, then a runtime exception of type \u003ccode\u003e{bad_generator, M0}\u003c/code\u003e\nwill be generated.\u003c/p\u003e\n\n\u003cp\u003eA simple BNF grammar for map comprehension follows:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e      \u0026lt;comprehension\u0026gt; ::= '#{' \u0026lt;key-value-assoc\u0026gt; '||' \u0026lt;comprehension-exprs\u0026gt; '}'\n\u0026lt;comprehension-exprs\u0026gt; ::= \u0026lt;comprehension-expr\u0026gt;\n                        | \u0026lt;comprehension-exprs\u0026gt; ',' \u0026lt;comprehension-expr\u0026gt;\n \u0026lt;comprehension-expr\u0026gt; ::= \u0026lt;generator\u0026gt;\n                        | \u0026lt;filter\u0026gt;\n          \u0026lt;generator\u0026gt; ::= \u0026lt;key-value-exact\u0026gt; '\u0026lt;-' \u0026lt;expr\u0026gt;\n             \u0026lt;filter\u0026gt; ::= \u0026lt;expr\u0026gt;\n    \u0026lt;key-value-assoc\u0026gt; ::= \u0026lt;expr\u0026gt; '=\u0026gt;' \u0026lt;expr\u0026gt;\n    \u0026lt;key-value-exact\u0026gt; ::= \u0026lt;expr\u0026gt; ':=' \u0026lt;expr\u0026gt;\n               \u0026lt;expr\u0026gt; ::= \u0026lt;Erlang expression\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eEach association from all generators, which satisfies the filters, has an\nenvironment that consist of the initial environment and the environment\nfor the association.  \u003c/p\u003e\n\n\u003cp\u003eExamples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eM0 = #{ K =\u0026gt; V*2  || K := V \u0026lt;- map() },\nM1 = #{ I =\u0026gt; f(I) || I \u0026lt;- list() },\nM2 = #{ K =\u0026gt; V    || \u0026lt;\u0026lt;L:8,K:L/binary,V/float\u0026gt;\u0026gt; \u0026lt;= binary() }.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eMap generators may also be used in binary and list comprehensions.\u003c/p\u003e\n\n\u003cp\u003eExamples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB1 = \u0026lt;\u0026lt; \u0026lt;\u0026lt;V:8\u0026gt;\u0026gt; || _ := V \u0026lt;- map() \u0026gt;\u0026gt;,\nL1 = [ {K,V} || K := V \u0026lt;- map() ].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eDialyzer and Type specification\u003c/h3\u003e\n\n\u003cp\u003eKeys known before hand can be specified directly and uniquely for a map.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec func(Opt, M) -\u0026gt; #{ 'status' =\u0026gt; S, 'c' =\u0026gt; integer() } when\n      Opt :: 'inc' | 'dec',\n        M :: #{ 'status' =\u0026gt; S, 'c' =\u0026gt; integer() },\n        S :: 'update' | 'keep'.\n\nfunc(inc, #{ status := update, c := C} = M) -\u0026gt; M#{ c := C + 1};\nfunc(dec, #{ status := update, c := C} = M) -\u0026gt; M#{ c := C - 1};\nfunc(_,   #{ status := keep } = M)          -\u0026gt; M.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt could also be specified by type only.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec plist_to_map(Ls) -\u0026gt; #{ binary() =\u0026gt; integer() } when\n      Ls :: [{binary(), integer()}].\n\nplist_to_map([], M) -\u0026gt;\n    M;\nplist_to_map([{K,V}|Ls], M) when is_binary(K), is_integer(V) -\u0026gt;\n    plist_to_map(Ls, M#{ K =\u0026gt; V });\nplist_to_map([_|Ls], M) -\u0026gt;\n    plist_to_map(Ls, M).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt can similarly be specified as a type.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-type map1() :: #{ binary() =\u0026gt; integer() }.\n-type map2() :: #{ \u0026lt;\u0026lt;\"list1\"\u0026gt;\u0026gt; | \u0026lt;\u0026lt;\"list2\"\u0026gt;\u0026gt; =\u0026gt; [numbers()] }.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eFunctions and Semantics\u003c/h2\u003e\n\n\u003cp\u003e\u003cem\u003eThe module implementing the functions is currently named in plural, \u003ccode\u003emaps\u003c/code\u003e in the\nsame spirit as \u003ccode\u003elists\u003c/code\u003e, \u003ccode\u003egb_trees\u003c/code\u003e, \u003ccode\u003esets\u003c/code\u003e etc but the singular \u003ccode\u003emap\u003c/code\u003e is shorter\nand may be more desirable.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eFunctions and semantics for maps. Originally much inspiration was from\nRichard O'Keefes frames proposal.\u003c/p\u003e\n\n\u003ch3\u003eErlang module extension\u003c/h3\u003e\n\n\u003ch5\u003e\u003ccode\u003eerlang:is_map(M :: term()) -\u0026gt; boolean().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eThis function is a guard function.\u003c/p\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003etry #{} = M, true catch error:{badmatch,_} -\u0026gt; false end\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe function returns \u003ccode\u003etrue\u003c/code\u003e if M is a map otherwise \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003eerlang:map_size(M :: map()) -\u0026gt; non_neg_integer().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eThis function is a guard function.\u003c/p\u003e\n\n\u003cp\u003eSyntax equivalence: \u003cem\u003enone\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe function returns the number of key-value pairs in the map.\n  This operation happens in constant time.\u003c/p\u003e\n\n\u003cp\u003eSame as \u003ccode\u003emaps:size(M)\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003emaps module\u003c/h3\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:remove(K0 :: term(), M0 :: map()) -\u0026gt; M1 :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e#{ K =\u0026gt; V || K := V \u0026lt;- M0, K =/= K0 }\u003c/code\u003e.\n  \u003cem\u003eOnly with comprehensions\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe function removes the key \u003ccode\u003eK0\u003c/code\u003e, if it exists, and its associated value from\n  map \u003ccode\u003eM0\u003c/code\u003e and returns a new map \u003ccode\u003eM1\u003c/code\u003e without key \u003ccode\u003eK0\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003emaps:from_list([{K,V}||{K,V} \u0026lt;- maps:to_list(M0), K =/= K0])\u003c/code\u003e\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:get(K :: term(), M :: map()) -\u0026gt; V :: term().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003eM#{ K }\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns the value \u003ccode\u003eV\u003c/code\u003e associated with key \u003ccode\u003eK\u003c/code\u003e if map \u003ccode\u003eM\u003c/code\u003e contains a key\n  that \u003cem\u003ematches\u003c/em\u003e \u003ccode\u003eK\u003c/code\u003e.  If no value is associated with key \u003ccode\u003eK\u003c/code\u003e then the call will\n  fail with an exception.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:keys(M :: map()) -\u0026gt; [K1, .., Kn].\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e[K || K := _ \u0026lt;- M]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns a complete list of Keys, in arbitrary order, which resides within\n  map \u003ccode\u003eM\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003e[K || {K,_} \u0026lt;- maps:to_list(M)]\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:find(K :: term(), M :: map()) -\u0026gt; {ok, V :: term()} | error.\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003etry #{ K := V } = M, V catch error:{badmatch,_} -\u0026gt; error end\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns a tuple \u003ccode\u003e{ok, V}\u003c/code\u003e with value \u003ccode\u003eV\u003c/code\u003e associated with key \u003ccode\u003eK\u003c/code\u003e if map \u003ccode\u003eM\u003c/code\u003e\n  contains key \u003ccode\u003eK\u003c/code\u003e.  If no value is associated with key \u003ccode\u003eK\u003c/code\u003e then the function\n  will return \u003ccode\u003eerror\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:fold(F :: fun((K :: term(), V :: term(), In :: term()) -\u0026gt; Out :: term()), A :: term(), M :: map()) -\u0026gt; Result :: term().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003cem\u003enone\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eCalls \u003ccode\u003eF(K, V, In)\u003c/code\u003e for every key \u003ccode\u003eK\u003c/code\u003e to value \u003ccode\u003eV\u003c/code\u003e association in map \u003ccode\u003eM\u003c/code\u003e in\n  arbitrary order. The function fun \u003ccode\u003eF/3\u003c/code\u003e must return a new accumulator\n  which is passed to the next successive call. \u003ccode\u003emaps:fold/3\u003c/code\u003e returns the final\n  value of the accumulator. The initial accumulator value \u003ccode\u003eA\u003c/code\u003e is returned if\n  the map is empty.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003elists:foldl(fun({K,V}, In) -\u0026gt; F(K,V,In) end, A, maps:to_list(M))\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:from_list([{K1,V1}, .., {Kn,Vn}]) -\u0026gt; M :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e#{ K1 =\u0026gt; V1, .., Kn =\u0026gt; Vn }\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eThe function takes a list of key-value tuples elements and builds a\n  map. The associations may be in any order and both keys and values in the\n  association may be of any term. If the same key appears more than once,\n  the latter (rightmost) value is used and the previous values are ignored.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:is_key(K :: term(), M :: map()) -\u0026gt; bool().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003etry #{ K := _ } = M, true catch error:{badmatch, _} -\u0026gt; false end\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns \u003ccode\u003etrue\u003c/code\u003e if map \u003ccode\u003eM\u003c/code\u003e contains a key that \u003cem\u003ematches\u003c/em\u003e \u003ccode\u003eK\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:map(F :: function(), M0 :: map()) -\u0026gt; M1 :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e#{ K =\u0026gt; F(K,V) || K := V \u0026lt;- M }\u003c/code\u003e.\n  \u003cem\u003eOnly with comprehensions\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe function produces a new map \u003ccode\u003eM1\u003c/code\u003e by calling the function fun \u003ccode\u003eF(K, V)\u003c/code\u003e for\n  every key \u003ccode\u003eK\u003c/code\u003e to value \u003ccode\u003eV\u003c/code\u003e association in map \u003ccode\u003eM0\u003c/code\u003e in arbitrary order.\n  The function fun \u003ccode\u003eF/2\u003c/code\u003e must return the value to be associated with key \u003ccode\u003eK\u003c/code\u003e for\n  the new map \u003ccode\u003eM1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003emaps:from_list(lists:map(fun({K,V}) -\u0026gt; {K, F(K,V)} end, maps:to_list(M)))\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:new() -\u0026gt; M :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e#{}\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns a new empty map.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003emaps:from_list([])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:size(M :: map()) -\u0026gt; Size :: non_neg_integer().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003cem\u003enone\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe function returns the number of key-value associations in the map.\n  This operation happens in constant time.\u003c/p\u003e\n\n\u003cp\u003eSame as \u003ccode\u003eerlang:map_size(M)\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:put(K :: term(), V :: term(), M0 :: map()) -\u0026gt; M1 :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003eM0#{ K =\u0026gt; V }\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAssociates key \u003ccode\u003eK\u003c/code\u003e with value \u003ccode\u003eV\u003c/code\u003e and inserts the association into map \u003ccode\u003eM0\u003c/code\u003e.\n  If a key exists that \u003cem\u003ematches\u003c/em\u003e \u003ccode\u003eK\u003c/code\u003e, the old associated value is\n  replaced by value \u003ccode\u003eV\u003c/code\u003e.\n  The function returns a new map \u003ccode\u003eM1\u003c/code\u003e containing the new association.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003emaps:from_list(maps:to_list(M0) ++ [{K,V}])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:to_list(M :: map()) -\u0026gt; [{K1,V1}, ..., {Kn,Vn}].\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e[{K, V} || K := V \u0026lt;- M]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhere the pairs, \u003ccode\u003e[{K1,V1}, ..., {Kn,Vn}]\u003c/code\u003e, are returned in arbitrary order.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:update(K :: term(), V :: term, M0 :: map()) -\u0026gt; M1 :: map()\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003eM0#{ K := V }\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf a key exists that \u003cem\u003ematches\u003c/em\u003e \u003ccode\u003eK\u003c/code\u003e, the old associated value is\n  replaced by value \u003ccode\u003eV\u003c/code\u003e. The function returns a new map \u003ccode\u003eM1\u003c/code\u003e containing\n  the new associated value.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003emaps:from_list(maps:to_list(M0) ++ [{K,V}])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:values(M :: map()) -\u0026gt; [V1, .., Vn].\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e[V || _ := V \u0026lt;- M]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eReturns a complete list of values, in arbitrary order, contained in map \u003ccode\u003eM\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003e[V || {_,V} \u0026lt;- maps:to_list(M)]\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:without([K1, .., Kn] = Ks, M0 :: map()) -\u0026gt; M1 :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003ccode\u003e#{ K =\u0026gt; V || K := V \u0026lt;- M0, not lists:member(K, Ks) }\u003c/code\u003e. \n  \u003cem\u003eOnly with comprehensions\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eRemoves keys \u003ccode\u003eK1\u003c/code\u003e through \u003ccode\u003eKn\u003c/code\u003e, and their associated values, from map \u003ccode\u003eM0\u003c/code\u003e and\n  returns a new map \u003ccode\u003eM1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSame as, \u003ccode\u003emaps:from_list([{K,V}||{K,V} \u0026lt;- maps:to_list(M0), not lists:member(K, Ks)])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch5\u003e\u003ccode\u003emaps:merge(M0 :: map(), M1 :: map()) -\u0026gt; M2 :: map().\u003c/code\u003e\u003c/h5\u003e\n\n\u003cp\u003eSyntax equivalence: \u003cem\u003enone\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eMerges two maps into a single map. If two \u003cem\u003ematching\u003c/em\u003e keys exists in both maps the\n  value in map \u003ccode\u003eM0\u003c/code\u003e will be superseded by the value in map \u003ccode\u003eM1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eEquality and Ordering\u003c/h2\u003e\n\n\u003ch3\u003eEquality\u003c/h3\u003e\n\n\u003cp\u003eIn the case of term \u003ccode\u003eA\u003c/code\u003e and term \u003ccode\u003eB\u003c/code\u003e both are maps,\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIf \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e have different sizes, then \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e are not equal.\u003c/li\u003e\n\u003cli\u003eOtherwise, if all corresponding keys of \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e are pair-\nwise equal with their corresponding values, then \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e are equal.\u003c/li\u003e\n\u003cli\u003eOtherwise, \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e are not equal.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIt follows that two maps are equal if, and only if, they are of\nthe same, \u003cem\u003etype\u003c/em\u003e, \u003cem\u003esize\u003c/em\u003e and all corresponding key-value associations are\npairwise equal.\u003c/p\u003e\n\n\u003ch3\u003eOrdering\u003c/h3\u003e\n\n\u003cp\u003eThe term order is defined in \u003ca href=\"http://www.Erlang.org/download/erl_spec47.ps.gz\" title=\"Erlang specification 4.7\"\u003eErlang specification 4.7\u003c/a\u003e and quoted\nbelow:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n\u003cli\u003e\u003cp\u003eThe terms are primarily ordered according to their type, in the following order: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enumbers \u0026lt; atoms \u0026lt; refs \u0026lt; ports \u0026lt; PIDs \u0026lt; tuples \u0026lt; empty list \u0026lt; conses \u0026lt; binary\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThe specification is incomplete here, the actual term order is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enumbers \u0026lt; atoms \u0026lt; refs \u0026lt; funs \u0026lt; ports \u0026lt; pids \u0026lt; tuples \u0026lt; empty list \u0026lt; conses \u0026lt; binaries\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe Maps data-type are ordered next after tuples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enumbers \u0026lt; atoms \u0026lt; refs \u0026lt; funs \u0026lt; ports \u0026lt; pids \u0026lt; tuples \u0026lt; maps \u0026lt; empty list \u0026lt; conses \u0026lt; binaries\n                                                        ----\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eMaps are then ordered first by their size and then according to their\nrespective keys and lastly by the associated values in Erlang term order. \u003c/p\u003e\n\n\u003cp\u003eGiven two maps, \u003ccode\u003eM1\u003c/code\u003e and \u003ccode\u003eM2\u003c/code\u003e, with the same size, they are compared\nso that each key, in Erlang term order of the keys, in \u003ccode\u003eM1\u003c/code\u003e\nis compared to the corresponding key of \u003ccode\u003eM2\u003c/code\u003e. All keys are\ncompared first, then the values, until a difference is found. If a key\nor value differs, the order of the respective terms, in Erlang term\norder, is the order of the maps. If no key-value pairs differ, the\nmaps are considered equal.\u003c/p\u003e\n\n\u003cp\u003eExample:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; #{ b =\u0026gt; 2 } \u0026gt; #{ a =\u0026gt; 2 }.         % b \u0026gt; a\ntrue\n\u0026gt; #{ b =\u0026gt; 2 } \u0026gt; #{ a =\u0026gt; 1, b =\u0026gt; 2 }. % size 1 \u0026lt; size 2\nfalse\n\u0026gt; #{ b =\u0026gt; 1 } \u0026gt; #{ b =\u0026gt; 2}.          % 1 \u0026lt; 2\nfalse\n\u0026gt; #{ b =\u0026gt; 2, c =\u0026gt; 3 } \u0026gt; #{ b =\u0026gt; 1, d =\u0026gt; 3}.  % c \u0026gt; d, compared before 2 and 1\nfalse\n\u0026gt; #{ b =\u0026gt; 1 } \u0026gt; #{ 1 =\u0026gt; 1}.          % b \u0026gt; 1\ntrue\n\u0026gt; #{ 1.0 =\u0026gt; a } == #{ 1 =\u0026gt; a }.      % 1.0 == 1\ntrue\n\u0026gt; #{ 1.0 =\u0026gt; a } =:= #{ 1 =\u0026gt; a }.     % 1.0 =:= 1\nfalse\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eMaps are printed with keys in arbitrary order.\u003c/p\u003e\n\n\u003ch2\u003eOperator Precedence\u003c/h2\u003e\n\n\u003cp\u003eMap association operator and set-value operator is ordered last,\nafter match-operator and \u003ccode\u003ecatch\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e:\n#\nUnary + - bnot not\n/ * div rem band and          Left associative\n+ - bor bxor bsl bsr or xor   Left associative\n++ --                         Right associative\n== /= =\u0026lt; \u0026lt; \u0026gt;= \u0026gt; =:= =/=\nandalso\norelse\n= !                           Right associative\ncatch    \n=\u0026gt; :=\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt follows that the map expression:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ key =\u0026gt; C = 1 + 2 }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewill evaluate in the following order:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ key =\u0026gt; ( C = ( 1 + 2 ) ) }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003ePattern matching\u003c/h2\u003e\n\n\u003cp\u003ePattern matching is very powerful Erlang tool. Maps introduces a couple of new\nfeatures with its pattern matching. \u003c/p\u003e\n\n\u003ch3\u003ePattern matching: Basics\u003c/h3\u003e\n\n\u003cp\u003eWe will exemplify using the match operator.\u003c/p\u003e\n\n\u003cp\u003ePattern matching with maps is similar to records on the surface. Keys requested\nin a LHS pattern will be bound with the values which is found in the\nRHS association map.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ a := V } = #{ a =\u0026gt; 1 }.\n#{ a =\u0026gt; 1 }\n2\u0026gt; 1 = V.\n1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eKeys requested in a LHS pattern which is not found in the RHS map will produce\nan exception, \u003ccode\u003eexception error: no match of right hand side value ...\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ not_in_map := V } = #{ a =\u0026gt; 1 }.\n** exception error: no match of right hand side value #{ a =\u0026gt; 1 }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSimilarly, if a value for a requested key in the LHS pattern\ndoes not match the keys associated value in the RHS map\nthe match will produce an exception.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ a := 10 } = #{ a =\u0026gt; 1 }.\n** exception error: no match of right hand side value #{ a =\u0026gt; 1 }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOnly the keys requested will bind to associations. Any unrequested keys which\nresides within the map being matched will be ignored.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ a := V1, b := V2 } = #{ a =\u0026gt; 1, b =\u0026gt; 2, c =\u0026gt; 3}.\n#{ a =\u0026gt; 1, b =\u0026gt; 2, c =\u0026gt; 3 }\n2\u0026gt; 1 = V1.\n1\n3\u0026gt; 2 = V2.\n2\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe order of keys requested has no significance when pattern matching a map.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ a := \"1\", b := \"2\" } = #{ a =\u0026gt; \"1\", b =\u0026gt; \"2\" }.\n#{ a =\u0026gt; \"1\", b =\u0026gt; \"2\" }\n2\u0026gt; #{ b := \"2\", a := \"1\" } = #{ a =\u0026gt; \"1\", b =\u0026gt; \"2\" }.\n#{ a =\u0026gt; \"1\", b =\u0026gt; \"2\" }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003ePattern matching: Continued\u003c/h3\u003e\n\n\u003cp\u003eThe example below is a constructed example to illustrate the power of map\npattern matching.\u003c/p\u003e\n\n\u003cp\u003eA match expression is evaluated so that variables used as keys in the expression\nare bound before they are evaluated (if possible).\u003c/p\u003e\n\n\u003cp\u003eAs an example, keys can be bound by other key-value associations.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; #{ K := V, id := K } = M = #{ id =\u0026gt; b, a =\u0026gt; 1, b =\u0026gt; 2, c =\u0026gt; 3}.\n#{ id =\u0026gt; b, a =\u0026gt; 1, b =\u0026gt; 2, c =\u0026gt; 3}\n2\u0026gt; b = K.\nb\n3\u0026gt; 2 = V.\n2\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this case, the bound key \u003ccode\u003eid\u003c/code\u003e is evaluated first and looked up in\nM, binding the variable \u003ccode\u003eK\u003c/code\u003e. The \u003ccode\u003eK\u003c/code\u003e bound to \u003ccode\u003eb\u003c/code\u003e can then be used to\nbind \u003ccode\u003eV\u003c/code\u003e to 2.\u003c/p\u003e\n\n\u003cp\u003eBinding variables used as keys requires that there is a possible order of\nbinding without cycles. The reordering extends to all terms in a matching\nexpression, so that:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; { #{ X := Y }, X } = { #{ 5 =\u0026gt; 10 }, 5 }.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewith \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e unbound, results in a successful match binding \u003ccode\u003eX\u003c/code\u003e to 5 and\n\u003ccode\u003eY\u003c/code\u003e to 10.\u003c/p\u003e\n\n\u003cp\u003eThis is particular useful when updating specifics in map associations:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e%% Function declared in module map_example\nupdate_values([{K, V1}|Ls], #{ K := V0 } = M) -\u0026gt; update_values(Ls, M#{ K := V0 + V1 });\nupdate_values([_|Ls], M) -\u0026gt; update_values(Ls, M);\nupdate_values([], M)     -\u0026gt; M.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe first function clause is important here. Key \u003ccode\u003eK\u003c/code\u003e is bound in the tuple and\nwill be used to request value \u003ccode\u003eV0\u003c/code\u003e from map \u003ccode\u003eM\u003c/code\u003e. The map \u003ccode\u003eM\u003c/code\u003e is then updated to\nassociate key \u003ccode\u003eK\u003c/code\u003e with the new value \u003ccode\u003eV0 + V1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e%% In the Erlang shell\n1\u0026gt; M = #{ \"a\" =\u0026gt; 1, \"b\" =\u0026gt; 2, \"c\" =\u0026gt; 3 }.\n#{ \"a\" =\u0026gt; 1, \"b\" =\u0026gt; 2, \"c\" =\u0026gt; 3 }\n\n2\u0026gt; map_example:update_values([{\"b\", 10}, {\"c\", 20}, {\"d\", 30 }], M).\n#{ \"a\" =\u0026gt; 1, \"b\" =\u0026gt; 12, \"c\" =\u0026gt; 23 }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that since key \u003ccode\u003e\"d\"\u003c/code\u003e does not reside in map \u003ccode\u003eM\u003c/code\u003e it fails to match the first\nclause and does not update the map with the association \u003ccode\u003e\"d\" =\u0026gt; 40\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAn expression where the dependencies in the LHS of the match are cyclic, like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt;  #{X := Y, Y := X} = #{5 =\u0026gt; 10, 10 =\u0026gt; 5}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewill result in an evaluator error (variable is unbound) or a compilation error.\u003c/p\u003e\n\n\u003ch2\u003eExternal Term Format\u003c/h2\u003e\n\n\u003cp\u003eThere are 255 tags that can be used to encode terms for external binary\ndistribution.  All tags are defined in \u003ccode\u003eexternal.h\u003c/code\u003e. The encoding starts by a\nmagic byte \u003ccode\u003e131\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe encoding tags used in R15B01 are the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSMALL_INTEGER_EXT        'a'     97\nINTEGER_EXT              'b'     98\nFLOAT_EXT                'c'     99 \nATOM_EXT                 'd'    100\nSMALL_ATOM_EXT           's'    115\nREFERENCE_EXT            'e'    101\nNEW_REFERENCE_EXT        'r'    114\nPORT_EXT                 'f'    102\nNEW_FLOAT_EXT            'F'     70\nPID_EXT                  'g'    103\nSMALL_TUPLE_EXT          'h'    104\nLARGE_TUPLE_EXT          'i'    105\nNIL_EXT                  'j'    106 \nSTRING_EXT               'k'    107\nLIST_EXT                 'l'    108 \nBINARY_EXT               'm'    109 \nBIT_BINARY_EXT           'M'     77                                         \nSMALL_BIG_EXT            'n'    110\nLARGE_BIG_EXT            'o'    111\nNEW_FUN_EXT              'p'    112 \nEXPORT_EXT               'q'    113\nFUN_EXT                  'u'    117\n\nDIST_HEADER              'D'     68\nATOM_CACHE_REF           'R'     82\nATOM_INTERNAL_REF2       'I'     73\nATOM_INTERNAL_REF3       'K'     75\nBINARY_INTERNAL_REF      'J'     74\nBIT_BINARY_INTERNAL_REF  'L'     76\nCOMPRESSED               'P'     80\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor Maps we define tag \u003ccode\u003eMAP_EXT\u003c/code\u003e to 116 (\u003ccode\u003et\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eData layout:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eMAP_EXT\n|-----------------------------------    \n|  1  |    4   |        |          |\n|-----------------------------------\n| 116 |  Size  |  Keys  |  Values  |\n|-----------------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eSize\u003c/code\u003e specifies the number of keys and values that follows the size\ndescriptor.\u003c/p\u003e\n\n\u003cp\u003eAn open questions, optimize for:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eencoding/decoding speed?\u003c/li\u003e\n\u003cli\u003eease of access?\u003c/li\u003e\n\u003cli\u003ememory size?\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eMemory size should be a priority since we send this data over the wire. We\nshould promote ease of access so other languages can integrate towards the\nformat.\u003c/p\u003e\n\n\u003cp\u003eThis leads to a flat and simple structure. It follows that encoding/decoding\ntakes a performance hit.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eWhy would we need maps when we have \u003cem\u003erecords\u003c/em\u003e, \u003cem\u003edicts\u003c/em\u003e, \u003cem\u003egb_trees\u003c/em\u003e, \u003cem\u003eets\u003c/em\u003e\nand \u003cem\u003eproplists\u003c/em\u003e?\u003c/p\u003e\n\n\u003cp\u003eMaps are envisioned to be an easy to use, lightweight yet powerful key-value\nassociation store.\u003c/p\u003e\n\n\u003cp\u003eMaps utilizes one of Erlang's major strengths, pattern matching, to enrich user\nexperience and provide a powerful tool to simplify code development. Pattern\nmatching gives Maps a clear edge over dicts, gb_trees or proplists in usability.\u003c/p\u003e\n\n\u003cp\u003eMaps provides the possibility to associate arbitrary terms as keys, not only\natoms, with arbitrary terms as values in a matching capable data-type.\u003c/p\u003e\n\n\u003cp\u003eMaps does not claim to be an replacement to records as the frames proposal does.\nInstead maps targets a larger usage domain and wishes to be a complement to\nrecords and supersede them where suitable.\u003c/p\u003e\n\n\u003ch3\u003eMaps - Two approaches\u003c/h3\u003e\n\n\u003col\u003e\n\u003cli\u003eMaps as an association array with pattern matching and syntax for\nconstructing, accessing or updating them.\u003c/li\u003e\n\u003cli\u003eMaps as a record replacement.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eMaps were not envisioned as a record replacement at first, it was a hopeful\nrequirement added later. A record replacement approach does not necessarily\nrestrain any semantics but it may put some constraint on the implementation\nand underlying structure.\u003c/p\u003e\n\n\u003ch5\u003eRecords\u003c/h5\u003e\n\n\u003cp\u003eRecords are powerful under the right circumstances:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003efast lookups, O(1), due to compile time indexing of keys, and fast stores for\nsmall record sizes (~50 values),\u003c/li\u003e\n\u003cli\u003eno memory overhead to store keys, only values and a name: 2 + N words\nconsumption,\u003c/li\u003e\n\u003cli\u003eease of use in function head matching.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eHowever some of the drawbacks are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ecompile-time dependency and forces header file inclusions for inter-module usage,\u003c/li\u003e\n\u003cli\u003eonly atoms as keys,\u003c/li\u003e\n\u003cli\u003ekeys are not accessible in runtime,\u003c/li\u003e\n\u003cli\u003eno dynamic access of values, i.e. we cannot use variables to access values,\u003c/li\u003e\n\u003cli\u003eit is not a data-type and cannot be distinguished from tuples.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWhen comparing maps with records the drawbacks are easily remedied by Maps,\nhowever the positive effects is not as easy to replicate in a built-in data-type\nwhere values are determined at runtime instead of at compile time.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eBeing faster than direct-indexing array, where indices and possibly the\nresulting value are determined at compile time, is hard.\nIn fact it is impossible.\u003c/li\u003e\n\u003cli\u003eA memory model for Maps where the efficiency was near that of records\ncould be achieved by essentially using two tuples, one for keys and one for\nvalues as demonstrated in Frames. This would be impact performance of\nupdates on Maps with a large number of entries and thus constrain the\ncapability of a dictionary approach.\u003c/li\u003e\n\u003cli\u003eMaps would be as easy, or even easier, to use with matching in function heads.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eProtocol Construction\u003c/h3\u003e\n\n\u003cp\u003eArguments for a simpler a JSON representation using frames or \nmaps has been raised. Using frames and thereby atoms for dynamic creation of keys\nwould be a serious drawback.  Using maps would grant the possibility of string\nbinaries to represent keys and would not put the global atom pool in disarray.\u003c/p\u003e\n\n\u003ch4\u003ePattern Matching Example: The JSON Files\u003c/h4\u003e\n\n\u003cp\u003eChanging json-decoding. Mochiwebs mochijson decodes Json dictionaries the as\nthe following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{\"key\": \"value\"} -\u0026gt; {struct, [{\"key\", \"value\"}]}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis could instead be:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{\"key\": \"value\"} -\u0026gt; #{ \"key\" =\u0026gt; \"value\"}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConsider the following JSON examples, from \u003ca href=\"http://json.org/example.html\" title=\"JSON Example\"\u003ejson.org\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{\"menu\": {\n  \"id\": \"file\",\n  \"value\": \"File\",\n  \"popup\": {\n    \"menuitem\": [\n      {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},\n      {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},\n      {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}\n    ]\n  }\n}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emochijson:decode/1\u003c/code\u003e will currently look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{struct, [\n    {\"menu\", {struct, [\n        {\"id\",\"file\"},\n        {\"value\",\"File\"},\n        {\"popup\", {struct, [\n            {\"menuitem\", {array, [\n                {struct, [{\"value\",\"New\"},{\"onclick\",\"CreateNewDoc()\"}]},\n                {struct, [{\"value\",\"Open\"},{\"onclick\",\"OpenDoc()\"}]},\n                {struct, [{\"value\",\"Close\"}, {\"onclick\",\"CloseDoc()\"}]}\n            ]}}\n        ]}}\n    ]}}\n]}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003emochijson:decode/1\u003c/code\u003e could look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ \"menu\" =\u0026gt; #{\n    \"id\" =\u0026gt; \"file\",\n    \"value\" =\u0026gt; \"File\",\n    \"popup\" =\u0026gt; #{\n        \"menuitem\" =\u0026gt; [\n          #{ \"value\" =\u0026gt; \"New\",   \"onclick\" =\u0026gt; \"CreateNewDoc()\"},\n          #{ \"value\" =\u0026gt; \"Open\",  \"onclick\" =\u0026gt; \"OpenDoc()\"},\n          #{ \"value\" =\u0026gt; \"Close\", \"onclick\" =\u0026gt; \"CloseDoc()\"}\n        ]\n    }\n}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet us find \u003ccode\u003e\"menu\"\u003c/code\u003e -\u003e \u003ccode\u003e\"popup\"\u003c/code\u003e -\u003e \u003ccode\u003e\"menuitem\"\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTraversing the first structure is a bit awkward. We would have to do\nthe following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eDecoded         = mochijson:decode(Json),\n{struct, Menu}  = proplists:get_value(\"menu\", Decoded),\n{struct, PopUp} = proplists:get_value(\"popup\", Menu),\n{struct, Items} = proplists:get_value(\"menuitem\", PopUp),\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWith maps it could look like the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ \"menu\"     := Menu  } = mochijson:decode(Json),\n#{ \"popup\"    := PopUp } = Menu,\n#{ \"menuitem\" := Items } = PopUp,\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor even:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eDecoded = mochijson:decode(Json),\n#{ \"menu\" := #{ \"popup\" := #{ \"menuitem\" := Items } } } = Decoded,\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWith maps, and single value access, it could look really simple:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eDecoded = mochijson:decode(Json),\nItems = Decoded#{ \"menu\" }#{ \"popup\" }#{ \"menuitem \"}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eOpen Questions\u003c/h3\u003e\n\n\u003cp\u003eWe have some usage scenarios that are still open for debate. A proposed answer\nis given for each question and stems from discussions in this proposal.\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eWhat type of keys will we need to store in our Map? Will atoms suffice? \n\u003cul\u003e\n\u003cli\u003eIt is the authors view that we should refrain from any key restrictions\nunless there is overwhelmingly evidence that we can gain something from\nsuch a restriction.\u003c/li\u003e\n\u003cli\u003eA non atom key restriction satisfies our goal of a powerful Map mechanism.\u003c/li\u003e\n\u003cli\u003eProposal: \u003cem\u003eAny term as keys.\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eHow many key-value associations will we store in our map?\n\u003cul\u003e\n\u003cli\u003eThis question has less to do with syntax and semantics than it has with\nthe choice of the underlying implementation.\u003c/li\u003e\n\u003cli\u003eIf we enable the user to add key-value pairs dynamically surely he will\nuse it.  Since it is a powerful mechanism not afforded to us by records\nthe usage pattern will also be different. This will in all likelihood\nproduce larger Maps than records are today. This implies that we cannot\ncompare records sizes with that of maps sizes since the usage scenario\nwould be different.\u003c/li\u003e\n\u003cli\u003eProposal: \u003cem\u003eArbitrary number of keys-value pairs.\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eHow many Map instances will we create for each Map with a specific set of keys?\n\u003cul\u003e\n\u003cli\u003eThis question is closely related to how we use records and if Maps should\nemulate this behavior and this should have no impact on semantics, only\nimplementation.\u003c/li\u003e\n\u003cli\u003eThe significant difference is the memory overhead in the storing structure.\nSince memory overhead for keys and values has the same behavior as in any\ncompound term or abstract data-type, i.e. dict or gb_trees, the main\ndifference occurs when comparing maps to records and frames. To ensure a\nlogarithmic worst-case performance in update or retrieval some sort tree\nstructure would likely be used for maps. Maps would then stores keys\ntogether with its values whereas frames stores keys outside its value\nstructure and records generates key indexes at compile-time. This would\nindicate a memory overhead for Maps over Frames and records for each\ninstance.\u003c/li\u003e\n\u003cli\u003eProposal: \u003cem\u003eTwo tier approach, similar to binaries. Use flat compact,\nkey-sharing approach for few associations (~50 associations). Use sorted\ntree approach and store keys with values beyond first tier limit.\nThe rationale being it is more likely to have multiple instance where\nwe have few keys.\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eOnly allow updates of already defined keys within a Map in syntax?\n\u003cul\u003e\n\u003cli\u003eThe question stems from a record replacement approach and the argument for\nit is to mitigate typos, i.e. trying to update key \u003ccode\u003ebehavior\u003c/code\u003e where key\n\u003ccode\u003ebehaviour\u003c/code\u003e was actually intended. Instead of getting two different keys,\na runtime exception occurs at this point.\u003c/li\u003e\n\u003cli\u003eThis approach will \u003cem\u003edeny\u003c/em\u003e any dictionary like behavior, for instance\nstoring spawned processes as keys in the map using syntax.\u003c/li\u003e\n\u003cli\u003eProposal: \u003cem\u003eAllow for any key to be stored by default syntax,\nexisting or not, and use a special syntax for setting of values of\nexisting keys only.\u003c/em\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe answers from these questions are instrumental to how we should design and\nimplement Maps. What we also should keep in the back of our minds is that we\nwill never get rid of records completely and some of the frames arguments might\nthus be superfluous.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003ch2\u003eWhat should we expect from our syntax?\u003c/h2\u003e\n\n\u003cp\u003eAs stated earlier, the current syntax is not set in stone but what should we\nexpect from it?\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eFirst and foremost it has to be unambiguous, meaning the syntax must produce\nsingle clearly defined behavior that cannot be misinterpreted by humans\nnor machines.\u003c/p\u003e\n\n\u003cp\u003e1.1  Here we also include the notion that similar syntax should have similar\n    behavior, or at least not completely different behavior.\nFor example records, \u003ccode\u003e#record{ key = Value }\u003c/code\u003e, have O(1) performance and\n2 + N words memory overhead.  If we use a similar syntax,\ni.e. \u003ccode\u003e#{ key = Value }\u003c/code\u003e, we should also expect similar behavior both in\nregard to semantics and performance for any and all sizes of the map.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe syntax must be as short as possible. It must not use more characters than\nnecessary to describe a certain behavior as long as it\ndoes not violate rule 1.\u003c/p\u003e\n\n\u003cp\u003e2.2  We want to avoid verbosity in the language. Verbosity pushes away\ninformation from our field of vision and obfuscates it.\nThis needs to be avoided.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2\u003eSyntax choice for Maps\u003c/h2\u003e\n\n\u003cp\u003e\u003cem\u003eThe author argues for:\u003c/em\u003e \u003ccode\u003e=\u0026gt;\u003c/code\u003e \u003cem\u003eas delimiter in 'set-or-update' and\u003c/em\u003e\n\u003ccode\u003e:=\u003c/code\u003e \u003cem\u003ein 'set-existing' and 'matching' syntax.\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eIn the examples below we use \u003ccode\u003e#{ Key =\u0026gt; Value }\u003c/code\u003e to describe map semantics and\nuse-cases, but this is only one suggestion out of many.\u003c/p\u003e\n\n\u003cp\u003eSeveral syntax proposals exists, frames proposes \u003ccode\u003e\u0026lt;{ key ~ Value }\u0026gt;\u003c/code\u003e syntax and\nanother syntax suggestion is very similar to record syntax \u003ccode\u003e#{ key = Value }\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe current variable and atom definitions puts restrictions on what we can use\nas delimiters and leaves us \u003ccode\u003e~\u003c/code\u003e and \u003ccode\u003e=\u003c/code\u003e as the only sane \u003cem\u003esingle\u003c/em\u003e character\ndelimiters we can use. The case is very well argued in Richard O'Keefes\n\u003ca href=\"http://www.cs.otago.ac.nz/staffpriv/ok/frames.pdf\" title=\"No more need for records\"\u003eNo more need for records (fifth draft)\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3\u003eDelimiter discussion\u003c/h3\u003e\n\n\u003cp\u003eArguments against a \u003ccode\u003e=\u003c/code\u003e delimiter are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIt lacks distinction from match, consider \u003ccode\u003e#{ A = B = v }\u003c/code\u003e,\n does \u003ccode\u003eA\u003c/code\u003e match \u003ccode\u003eB\u003c/code\u003e or does \u003ccode\u003eB\u003c/code\u003e match \u003ccode\u003ev\u003c/code\u003e?\n Which \u003ccode\u003e=\u003c/code\u003e is a match operation and which \u003ccode\u003e=\u003c/code\u003e delimits the key-value pair?\u003c/li\u003e\n\u003cli\u003eIt might be interpreted as \u003ccode\u003eKey\u003c/code\u003e 'equal' \u003ccode\u003eValue\u003c/code\u003e,\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eand hence \u003ccode\u003e=\u003c/code\u003e is in violation of rule #1 from \u003cem\u003eWhat do we expect from our syntax?\u003c/em\u003e.\nThe interpretation of this syntax is ambiguous.\u003c/p\u003e\n\n\u003cp\u003eArguments against a \u003ccode\u003e~\u003c/code\u003e delimiter are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eit might be interpreted as \u003ccode\u003eKey\u003c/code\u003e 'NOT' \u003ccode\u003eValue\u003c/code\u003e\n as \u003ccode\u003e~\u003c/code\u003e is the bitwise NOT operator in C,\u003c/li\u003e\n\u003cli\u003eit might be interpreted as \u003ccode\u003eKey\u003c/code\u003e 'about equal' \u003ccode\u003eValue\u003c/code\u003e\n as \u003ccode\u003e~\u003c/code\u003e is similar to mathematics \u003ccode\u003e‚âÉ\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003eit lacks typographical distinction,\n i.e. it lacks distinction from \u003ccode\u003e-\u003c/code\u003e in certain fonts, \n ex. \u003ccode\u003eK ~ V\u003c/code\u003e might be interpreted as \u003ccode\u003eK - V\u003c/code\u003e, consider \u003ccode\u003e#{ K - 1 ~ 2 - V }\u003c/code\u003e,\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eand hence this is in violation of rule #1 from \u003cem\u003eWhat do we expect from our syntax?\u003c/em\u003e.\nThe interpretation of this syntax is ambiguous.\u003c/p\u003e\n\n\u003cp\u003eTwo two-character delimiter suggestions are \u003ccode\u003e#{ Key := Value }\u003c/code\u003e and\n\u003ccode\u003e#{ Key =\u0026gt; Value}\u003c/code\u003e, where \u003ccode\u003e:=\u003c/code\u003e is a common denominator for assignment and \u003ccode\u003e=\u0026gt;\u003c/code\u003e\nshould be read as \u003cem\u003emaps to\u003c/em\u003e. A two-character delimiter should be avoided if at\nall possible since it increases the syntax footprint of the source code.\u003c/p\u003e\n\n\u003cp\u003eThe assignment delimiter reads well for just assignment but suffers from the\nsame reversed logic flaw as records when it comes to pattern matching. The match\n\u003ccode\u003e#{ key := Value } = M\u003c/code\u003e reads \u003cem\u003ematch M to the map pattern where Value is equal\nto key\u003c/em\u003e. That does not read well unless we call the assignment delimiter \u003ccode\u003e:=\u003c/code\u003e\nfor something that its not meant to be.\u003c/p\u003e\n\n\u003cp\u003eHowever, \u003ccode\u003e:=\u003c/code\u003e is also similar to \u003ccode\u003e=:=\u003c/code\u003e which means \"is exactly equal\",\ni.e. matches. This is a valuable meaning since we have a difference\nbetween \u003ccode\u003e==\u003c/code\u003e and \u003ccode\u003e=:=\u003c/code\u003e when dealing with numbers and thus \u003ccode\u003e:=\u003c/code\u003e could be a more\ncorrect delimiter for matching syntax.\u003c/p\u003e\n\n\u003cp\u003eThe delimiter \u003ccode\u003e-\u0026gt;\u003c/code\u003e would be suitable choice if it weren't for the fact that it\nwould overload the function clause meaning.\u003c/p\u003e\n\n\u003cp\u003eBoth \u003ccode\u003e-\u0026gt;\u003c/code\u003e and \u003ccode\u003e=\u0026gt;\u003c/code\u003e might be confusing when dealing with binaries.\nConsider \u003ccode\u003e#{ \u0026lt;\u0026lt;\"key\"\u0026gt;\u0026gt; -\u0026gt; \u0026lt;\u0026lt;\"value\"\u0026gt;\u0026gt; }\u003c/code\u003e and \u003ccode\u003e#{ \u0026lt;\u0026lt;\"key\"\u0026gt;\u0026gt; =\u0026gt; \u0026lt;\u0026lt;\"value\"\u0026gt;\u0026gt; }\u003c/code\u003e,\nwhere \u003ccode\u003e=\u0026gt;\u003c/code\u003e appears to be slightly more confusing than \u003ccode\u003e-\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eListing of delimiters from above perceived desirability: \u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e#{ K =\u0026gt; V }\u003c/code\u003e - No ambiguity, no overloading, reads as an association\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e#{ K := V }\u003c/code\u003e - No ambiguity, no overloading, reads as an assignment or exact match\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e#{ K ~ V }\u003c/code\u003e  - Typographical ambiguity, no overloading, no clear meaning\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e#{ K -\u0026gt; V }\u003c/code\u003e - Overloads function clause head and body separator, reads as an association\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e#{ K = V }\u003c/code\u003e  - Overloads match operator, reads as a match or an assignment\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eUsing \u003ccode\u003e:=\u003c/code\u003e assignment for existing keys seems as a good choice. The choice for\nset-or-update is between \u003ccode\u003e=\u0026gt;\u003c/code\u003e and \u003ccode\u003e~\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003eThe case for two set-or-update semantics and its syntax\u003c/h3\u003e\n\n\u003cp\u003eA case for two different ways to update values in a Map is proposed.\u003c/p\u003e\n\n\u003cp\u003eOne syntax if, and only if, we want to update a value for an already \u003cem\u003eexisting\u003c/em\u003e\nkey and another if we want to update the Map with any key.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eUse \u003ccode\u003eM#{ K =\u0026gt; V }\u003c/code\u003e to declare new key value pairs \u003cem\u003eor\u003c/em\u003e update already existing keys\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003eM#{ K := V }\u003c/code\u003e to update already existing keys.\u003c/li\u003e\n\u003cli\u003eUse \u003ccode\u003e#{ K := V } = M\u003c/code\u003e to match maps.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample 1:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efoo() -\u0026gt;\n    M = #{ key1 =\u0026gt; 1, key2 =\u0026gt; 2 }, % M is declared with keys 'key1' and 'key2'\n    bar(M).\n\nbar(M) -\u0026gt;\n    M#{\n        key1 := \"1\",  %% 'key1' will be set to \"1\"\n        key2 := \"2\",  %% 'key2' will be set to \"2\"\n        key3 := \"3\"   %% this causes an exception since 'key3' does not exist in M\n    }.\n\n\u0026gt; foo().\n** exception error: no match of 'key3' in map\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eExample 2:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efoo() -\u0026gt;\n    M = #{ key1 =\u0026gt; 1, key2 =\u0026gt; 2 }, % M is declared with keys 'key1' and 'key2'\n    bar(M).\n\nbar(M) -\u0026gt;\n    M#{\n        key1 =\u0026gt; \"1\",  %% 'key1' will be set to \"1\"\n        key2 =\u0026gt; \"2\",  %% 'key2' will be set to \"2\"\n        key3 =\u0026gt; \"3\"   %% 'key3' will be set to \"3\"\n    }.\n\n\u0026gt; foo().\n#{ key1 =\u0026gt; 1, key2 =\u0026gt; \"2\", key3 =\u0026gt; \"3\" }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eImpact of syntax footprint\u003c/h2\u003e\n\n\u003cp\u003eWe must lessen the syntax footprint impact on the source code and the language.\u003c/p\u003e\n\n\u003cp\u003eCurrently the two normal ways of sending options to a functions are either via\nrecords or property lists. Both have some drawbacks. Records are compile time\ndependent and syntactic sugar for tuples. Property lists are generic but\nproduces a lot of texts when defining them and operating on them.\u003c/p\u003e\n\n\u003cp\u003eConsider this example when parsing a list of arguments:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eargs(Args) -\u0026gt; \n     args(Args, [{analyze, false}, {suppression, false}, {target, none}]).\n\nargs([\"-r\" | Args], Opts) -\u0026gt; \n    args(Args, [{analyze, true}     | proplists:delete(analyze, Opts)]);\nargs([\"-s=\"++File | Args], Opts) -\u0026gt; \n    args(Args, [{suppression, File} | proplists:delete(suppression, Opts)]);\nargs([Target], Opts) -\u0026gt; \n    [{target, Target} | proplists:delete(target, Opts)].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe textual impact, the number of characters, is quite heavy when operating on \nproperty lists.\u003c/p\u003e\n\n\u003cp\u003eIf we instead use some kind of map with syntax, how would that look?\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eargs(Args) -\u0026gt; \n    args(Args, #{ analyze =\u0026gt; false, suppression =\u0026gt; false, target =\u0026gt; none}).\n\nargs([\"-r\" | Args], Opts)        -\u0026gt; args(Args, Opts#{ analyze := true });\nargs([\"-s=\"++File | Args], Opts) -\u0026gt; args(Args, Opts#{ suppression := File});\nargs([Target], Opts)             -\u0026gt; Opts#{ target := Target }.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis looks cleaner in my opinion but that is a very subjective view. To use some\ndata we can count the characters, and we see that the property lists example has\n390 characters versus the map examples 306. Property lists uses almost 30% more\ncharacters in this example.\u003c/p\u003e\n\n\u003ch2\u003eSemantics and API-functions\u003c/h2\u003e\n\n\u003ch3\u003eList conversions\u003c/h3\u003e\n\n\u003cp\u003ePerhaps the most sane \u003ccode\u003emaps:from_list/1\u003c/code\u003e semantics would be to have the key-value\nsignificance order in left to right, meaning the first association is used and\nthe latter values with matching keys are ignored.\u003c/p\u003e\n\n\u003cp\u003eThis differs from the \u003ccode\u003edict:from_list/1\u003c/code\u003e behavior.\u003c/p\u003e\n\n\u003cp\u003eConsider the following \u003ccode\u003edict\u003c/code\u003e example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[{a,2}] = dict:to_list(dict:from_list([{a,1}, {a,2}])).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBy letting the leftmost be the most significant key we could simplify conversion\nfrom and to lists. \u003c/p\u003e\n\n\u003cp\u003eCurrent suggestion has the following semantics:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eLs = [{a,old}],\n#{ a := old } = maps:from_list([{a,new}|Ls]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe reversal would be:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eLs = [{a,old}],\n#{ a := new } = maps:from_list([{a,new}|Ls]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eEquality and Ordering\u003c/h2\u003e\n\n\u003cp\u003eA restriction set on the implementation by the Erlang specification is that\norder is total, i.e. satisfies \u003cem\u003eantisymmetry\u003c/em\u003e, \u003cem\u003etransitivity\u003c/em\u003e and \u003cem\u003etotality\u003c/em\u003e.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eIf \u003ccode\u003eM1 =\u0026lt; M2\u003c/code\u003e and \u003ccode\u003eM2 =\u0026lt; M1\u003c/code\u003e then \u003ccode\u003eM1 == M2\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003eIf \u003ccode\u003eM1 =\u0026lt; M2\u003c/code\u003e and \u003ccode\u003eM2 =\u0026lt; M3\u003c/code\u003e then \u003ccode\u003eM1 =\u0026lt; M3\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003eIf \u003ccode\u003eM1 =\u0026lt; M2\u003c/code\u003e or \u003ccode\u003eM2 =\u0026lt; M1\u003c/code\u003e (always comparable)\nwhere \u003ccode\u003eM1\u003c/code\u003e, \u003ccode\u003eM2\u003c/code\u003e and \u003ccode\u003eM3\u003c/code\u003e are any Map term.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis only holds true in Erlang if we treat floats and integers as union of types,\nnamely numbers. In the case of a Maps, \u003ccode\u003etrue = #{ 1.0 =\u0026gt; V } == #{ 1 =\u0026gt; V}\u003c/code\u003e.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eThe need for order arises in a few cases.\n\u003cul\u003e\n\u003cli\u003ecomparison, for example sorting, \u003ccode\u003elists:sort([M1, .., Mn])\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eintrospection, for example when printed.\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003eOrdered maps impose restrictions on the underlying implementation and a\nhashing approach will be nearly impossible.\u003c/li\u003e\n\u003cli\u003eThe underlying structure does not need to be sorted, an order could be\nproduced when needed,\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eM1\u003c/code\u003e \u0026lt; \u003ccode\u003eM2\u003c/code\u003e, would result in an internal sort but would cost\nO( \u003cem\u003eN1\u003c/em\u003e * lg \u003cem\u003eN1\u003c/em\u003e + \u003cem\u003eN2\u003c/em\u003e * lg \u003cem\u003eN2\u003c/em\u003e ), where\n\u003ccode\u003eN1 = maps:size(M1) and N2 = maps:size(M2)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eAccessing a single value\u003c/h2\u003e\n\n\u003cp\u003eDo we need to have single access or is matching sufficient?\u003c/p\u003e\n\n\u003cp\u003eConsider the following,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eV = M#{ K }\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis shorter than\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{ K := V } = M\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt also allows for easy access of associated values in deep structures.\u003c/p\u003e\n\n\u003cp\u003eThe syntax for single value access is the least developed (and contemplated)\nfeature in this proposal and certainly could use some input.\u003c/p\u003e\n\n\u003cp\u003eMore over, the dot syntax must be abolished. Currently it is used for records\nbut it will not be used for maps. Dot represents end of expression list in last\nclause, or end of attribute.\u003c/p\u003e\n\n\u003cp\u003eIt cannot be used to distinguish between floats or associations.\u003c/p\u003e\n\n\u003cp\u003eExample:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; M = #{ 1.1 =\u0026gt; a, 1 =\u0026gt; #{ 1 =\u0026gt; b } }.\n#{ 1 =\u0026gt; #{ 1 =\u0026gt; b }, 1.1 =\u0026gt; a }.\n\n2\u0026gt; #M.1.1.\na | b ?\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eErlang code written with Maps will only be parseable, loadable and executable \non Erlang/OTP R17A and later releases of Erlang/OTP but not on previous\nreleases.\u003c/p\u003e\n\n\u003cp\u003eErlang code written before Erlang/OTP R17A will be perfectly compatible, i.e.\nparseable, loadable and executable with these Maps changes.\u003c/p\u003e\n\n\u003cp\u003eDistribution will not be backwards compatible.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0043"},"buildId":"7cVY434Wa3Wl232pkfXk2","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_buildManifest.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_ssgManifest.js" async=""></script></body></html>