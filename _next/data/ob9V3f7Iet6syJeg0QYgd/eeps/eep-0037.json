{"pageProps":{"index":{"id":"0037","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Accepted\nType: Standards Track\nErlang-Version: R14B04\nContent-Type: text/plain\nCreated: 27-May-2011\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 37: <a href=\"eep-0037.md\" title=\"EEP Source\"> Funs with names</a></h2>\n\n<h1>Abstract</h1>\n\n<p>The syntax of funs is extended to allow a variable name to\nbe consistently present before each argument list.  This\nallows funs to be recursive.  The knot is tied in the\nopcodes that apply a fun to its arguments, so no change to\nthe garbage collector design is required.</p>\n\n<h1>Specification</h1>\n\n<p>Currently, there are three forms for a fun:</p>\n\n<pre><code>fun Name/Arity\nfun Module:Name/Arity\n</code></pre>\n\n<p>and</p>\n\n<pre><code>fun Fun_Clause {; Fun_Clause}... end\n</code></pre>\n\n<p>We add another form:</p>\n\n<pre><code>fun Variable Fun_Clause {; Variable Fun_Clause}... end\n</code></pre>\n\n<p>If any <code>Fun_Clause</code> has a <code>Variable</code>, all must, and they must all\nbe the same variable.  Like the variables in the argument list(s),\nthis variable is local to the fun, not shared with its context.\nWithin the fun, the variable is bound to the value of the fun\nexpression.</p>\n\n<p>There are several possible ways to implement this.  One is\nrather neat because it preserves the cycle-freedom of the\ndata structures the garbage collector has to deal with.</p>\n\n<p>One way to implement existing funs is this:</p>\n\n<ul>\n<li><p><strong>a</strong> Create an auxiliary function with a generated name</p>\n\n<pre><code>&lt;foo&gt;(...,X1,...,Xk) ...;\n...\n&lt;foo&gt;(...,X1,...,Xk) ....\n</code></pre>\n\n<p>having the same argument lists, guards, and clause bodies\nas the fun, except that each variable shared with the context\nappears as an extra argument.</p></li>\n<li><p><strong>b</strong> Translate the fun expression as</p>\n\n<pre><code>'%mk-fun'({fun &lt;foo&gt;/n+k, X1, ..., Xk})\n</code></pre>\n\n<p>which gives the tuple a special tag to say that it represents\na fun value.</p></li>\n<li><p><strong>c</strong> Translate  <code>Foo(E1,...,Em)</code>\nas <code>A1 := E1, ..., Am := Em; funcall_m(Foo)</code>\nwhere the <code>funcall_m</code> instruction checks that its argument is\na closure expecting <code>m</code> arguments, moves the <code>X1,...,Xk</code> fields\nof the tuple to argument registers <code>A&lt;m+1&gt;..A&lt;m+k&gt;</code>, and then\njumps to the address in the first field.</p></li>\n</ul>\n\n<p>All it takes to implement recursive funs is</p>\n\n<ul>\n<li><p><strong>a'</strong> Create an auxiliary function</p>\n\n<pre><code>&lt;foo&gt;(...,X1,...,Xk,Variable) ...;\n...\n&lt;foo&gt;(...,X1,...,Xk,Variable) ....\n</code></pre></li>\n<li><p><strong>b'</strong> Translate the fun expression as</p>\n\n<pre><code>'%mk-rec-fun'({fun &lt;foo&gt;/&lt;n+k+1&gt;, X1, ..., Xk})\n</code></pre>\n\n<p>which simply applies a second special tag.</p></li>\n<li><p><strong>c'</strong> The <code>funcall_m</code> opcode acts the same for both old and\nrecursive funs, except that just before jumping, it\nadds tne fun value <code>Foo</code> itself as argument <code>A&lt;m+k+1&gt;</code>.\nThis \"ties the knot\".</p></li>\n</ul>\n\n<p>So a recursive fun takes no more space or time to create than\nan existing one, and does not involve creating any cycles of\npointers.  Its code can be inserted into the failure path for\nthe <code>funcall_m</code> instructions, whatever their form.</p>\n\n<h1>Motivation</h1>\n\n<p>Fun names can serve three purposes.</p>\n\n<p>First, they can simply be documentation.  For example,</p>\n\n<pre><code>cfun_files(CFun) -&gt;\n    fun(F1, F2) -&gt;\n        [[?OBJ(T1,_) | _] | _] = F1,\n        [[?OBJ(T2,_) | _] | _] = F2,\n        CFun(T1, T2)\n    end.\n</code></pre>\n\n<p>can be written as</p>\n\n<pre><code>cfun_files(CFun) -&gt;\n    fun Compare([[?OBJ(T1,_)|_]|_], [[?OBJ(T2,_)|_]|_]) -&gt;\n    CFun(T1, T2)\n    end.\n</code></pre>\n\n<p>A named fun whose name is not used can be implemented as if\nthe name were not there.</p>\n\n<p>Second, the fun's name can be built into its generated name.\nAt the time of writing, we might have</p>\n\n<pre><code>'-F/N-fun-K-'\n</code></pre>\n\n<p>where <code>F/N</code> is the name of the function that includes the fun\nand <code>K</code> is the number of earlier funs in <code>F/N</code>.  We could build\nthe name in instead, using</p>\n\n<pre><code>'-F/N-fun-Name-[K-]'\n</code></pre>\n\n<p>where <code>K</code> is present only if the outer function contains more\nthan one fun with the same name.  The point of this is that\nsuch names are more likely to be useful after hot loading.\nFor example, if we start with</p>\n\n<pre><code>f(...Xs, Ys, ...) -&gt;\n    ...\n    sort(Xs, fun X_Key({_,N,_}) -&gt; N end),\n    sort(Ys, fun Y_Key({N,_,_}) -&gt; N end),\n    ...\n</code></pre>\n\n<p>and then we revise it, swapping the two calls to <code>sort/2</code>.\nWith named funs, the two funs retain their generated names,\nand the module is safe.  With anonymous functions, the\nchances are that the two funs with swap names; oops!</p>\n\n<p>Third, a frequently asked question in the Erlang mailing\nlist is \"why can't I have recursive funs?\" to which we\nwill now be able to rely, \"you can; here is what they\nlook like.\"</p>\n\n<p>This still does not permit mutually recursive funs, but\npeople do not seem to ask for that much.</p>\n\n<p>Finally, the next time someone argues that Erlang syntax\nis inconsistent because function clauses have repeated\nnames and fun clauses do not, we shall be able to reply\n\"but fun clauses CAN have repeated names and probably\nshould.\"</p>\n\n<h1>Rationale</h1>\n\n<p>There really seemed to be only two main questions.</p>\n\n<p>What should the scope of the fun name variable be?\nSome variables in a fun are shared between the fun\nand its context.  Doing that would let us write</p>\n\n<pre><code>f(...) -&gt;\n    fun G(...) -&gt; ... end,\n    fun H(...) -&gt; ... end,\n    ... use G and H ...\n</code></pre>\n\n<p>rather like using nested \"define\" in Scheme, except that\nwhile <code>H</code> could use <code>G</code>, <code>G</code> couldn't use <code>H</code>.</p>\n\n<p>Since you do not get mutual recursion this way, you should\nnot be tricked into thinking you might.  It's better that\nyou have to write</p>\n\n<pre><code>f(...) -&gt;\n    GG = fun G(...) -&gt; ... end,\n    HH = fun H(...) -&gt; ... end,\n    ... use GG and HH ...\n</code></pre>\n\n<p>so that you understand clearly what you are getting.</p>\n\n<p>While variables in the body of a fun clause may be shared\nwith the context, variables in the arguments are not,\nsomething I have found confusing.  At least this way the\nfun name follows the same scope rule as the variables in\nthe argument list right next to it.</p>\n\n<p>The other main question was whether recursive fun values\nshould be exactly the same representation as existing\nfun values, but with a cycle in it (tying the knot at\nconstruction time), or whether to introduce a new tag\n(tying the knot at call time).  The lack of cycles in\nErlang heaps has been a major factor in the design of\nseveral garbage collectors.  I would expect changing\nthat to be an order of magnitude harder than the\nchanges required for this proposal.  It was seeing that\nthe knot could be tied at call with (without slowing\ndown calls to existing funs) that made me dare to hope\nthat this proposal might some day be accepted.</p>\n\n<p>The main issue now is that this does not let us define\na group of mutually recursive local functions.\nAdopting this proposal now might get in the way of a\nbetter proposal that handles mutual recursion as well.</p>\n\n<p>I don't see such a proposal as being likely to arrive soon.</p>\n\n<p>There is a special case of this where the fun name is used\nonly in tail call positions, which can be handled entirely\nby the compiler generating a jump back to the beginning.\nThis need not have any consequences for the run time system\nat all.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Code that does not use the new feature does not change its\nmeaning.  There may be code that relies on the form of\ngenerated function names; that would need changing.</p>\n\n<p>All syntax tools would need to be revised to handle the new form.\nExisting parse transforms might well fail on code containing the\nnew form, but would work unchanged on code that does not.</p>\n\n<p>At least one new instruction is needed to create suitably\ndistinguished closures.  Existing programs that analyse BEAM\nfiles will not understand this until they are revised.</p>\n\n<p>As described under 'motivation', naming functions is\nuseful even if you do not use the name in any clause body.\nThis means that we can have a staged delivery of the feature.</p>\n\n<ol>\n<li><p>Make the parser recognise fun names and check their identity.\nHave it report an error if the fun name is used in a body.\nHave it erase the fun names from the AST before any\ndownstream tool sees it.</p>\n\n<p>At this stage, fun names may serve as documentation.</p></li>\n<li><p>Upgrade the downstream tools to recognise an extended <code>'fun'</code>\nAST node with two extra fields:  the fun name as an atom and\na flag saying whether it is not used, used only in tail\nposition, or used more generally.</p>\n\n<p>Upgrade the parser to report fun names, but retain the\ncheck that they are not used.  Test the down stream tools.</p></li>\n<li><p>Modify the compiler to use the new, safer, form of generated\nname.  Ensure that the generated names are accessed only\nthrough an interface, so all is consistent.</p>\n\n<p>At this stage, fun names help to reduce the danger from\ncode revisions that add, remove, or re-order funs; a\nchange that does not alter the number of funs with a\nparticular name in a function should not change its name.</p></li>\n<li><p>(Optional.)  Revise the code generator to accept the fun\nname in tail call position and generate a jump.  Modify\nthe parser to allow this.</p>\n\n<p>At this point, it is possible to pass a loop as a parameter,\nlike a list traversal or a binary search.  No changes to the\nrepresentation of Erlang terms or the BEAM engine have been\nrequired yet.</p></li>\n<li><p>Add a new tag.  Revise the funcall instructions to check for\nit if the existing check fails, and push the closure itself.\nAdd a new instruction to make a new closure.  Revise the\nErlang term representation to encode recursive funs.  Revise\nthe type test instructions to recognise the new values.\nTeach HiPE what to do.</p>\n\n<p>This is the last stage.</p></li>\n</ol>\n\n<h1>Reference Implementation</h1>\n\n<p>None in this draft.  Stage 1 can be done fairly easily.\nStage 2 would be hard for me because I'm not even sure what\nall the relevant modules are.</p>\n\n<h1>References</h1>\n\n<p>None.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}