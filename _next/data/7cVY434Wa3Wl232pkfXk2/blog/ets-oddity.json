{"pageProps":{"item":{"id":"ets-oddity","title":"ETS oddity","author":"Lukas Larsson","excerpt":"\nWhen working with the implementation of the new [scalable ordered_set](https://github.com/erlang/otp/pull/1952)\nwe came across a strangeness with the guarantees when iterating over a table\nwhile inserting elements in parallel.","article_date":1546819200000,"tags":["ets write_concurrency first next"],"frontmatter":{"layout":"post","title":"ETS oddity","tags":"ets write_concurrency first next","author":"Lukas Larsson"},"content":"\nWhen working with the implementation of the new [scalable ordered_set](https://github.com/erlang/otp/pull/1952)\nwe came across a strangeness with the guarantees when iterating over a table\nwhile inserting elements in parallel.\n\n### Scenario:\n\n```\n> Tab = ets:new(test_table,\n                [set, public, {write_concurrency, true}]).\n#Ref<0.1705802953.985792516.98626>\n> P1 = spawn(fun() ->\n               ets:insert(Tab, {fir, 1}),\n               ets:insert(Tab, {sec, 2})\n             end).\n> K1 = ets:first(Tab), K2 = ets:next(Tab, K1).\n```\n\nWhat are the theoretical possible values of `K1` and `K2`? Let us first list the obvious:\n\n* `K1 = fir`, `K2 = sec` - both values inserted and found in term order\n* `K1 = sec`, `K2 = fir` - since this is a `set`, the hash algorithm may put `sec` before `fir`\n* `K1 = fir`, `K2 = '$end_of_table'` - only `fir` had time to be inserted\n* `K1 = '$end_of_table'`, `K2 = badarg` - no elements were inserted\n\nHowever it is also possible to get:\n\n* `K1 = sec`, `K2 = '$end_of_table'`\n\nThis was, at first, very counter-intuitive to me. How can the `ets:first/1` find the\nsecond value inserted, but then when iterating not find the value inserted before it?\n\nThe answer can be found in the way that the `write_concurrency` functionality is\nimplemented. Imagine we have a [hash table](https://en.wikipedia.org/wiki/Hash_table)\nwhere each bucket is protected by a mutex. When inserting a new element the mutex for\nthe current bucket has to be taken and when iterating over the hash table we take\neach mutex in turn for the buckets we iterate through.\n\n### Initial Table:\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[]`          |\n| 2             | `[]`          |\n| 3             | `[]`          |\n| 4             | `[]`          |\n\n### Finished Table:\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[{fir,1}]`   |\n| 2             | `[]`          |\n| 3             | `[]`          |\n| 4             | `[{sec,2}]`   |\n\nSo, in the scenario that leads to the strange behaviour the following will happen:\n\n* `ets:first/1` is called when the table is empty and iterates to Bucket #2.\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[]`          |\n| 2 (first)     | `[]`          |\n| 3             | `[]`          |\n| 4             | `[]`          |\n\n\n* The OS does a context switch and P1 is allowed to run.\n* P1 inserts both `{fir,1}` and `{sec,2}` and then exits.\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[{fir,a}]`   |\n| 2 (first)     | `[]`          |\n| 3             | `[]`          |\n| 4             | `[{sec,b}]`   |\n\n* The `ets:first/1` call resumes and will only see `sec` and then `'$end_of_table'`.\n\nWhen spelled out like this it becomes more logical that it is possible to get only\nthe element inserted as the second element. This is not normally a problem for\ntables of type `set` which have an arbitrary iteration order that you can't depend on anyway.\n\nHowever, for `ordered_set` you may very well depend on the defined iteration order\nand expect `ets:first/1` to return a key that has at least been first in the table\nat some point in time. But for the same reasons as with `set`, that is not guaranteed\nif you need that guarantee you have to either not use `write_concurrency`,\nfind some other way to synchronize or rely on luck... these races are very rare, but in heavily\nused tables they will eventually happen.\n\nThe same oddity applies to all kinds of table iterations; `ets:next/1`,\n`ets:select/1-3`, `ets:match/1-3` and friends. They may all miss concurrently\ninserted keys and return a key that has never existed in the table ordered\ndirectly after the previously returned key.\n"}},"__N_SSG":true}