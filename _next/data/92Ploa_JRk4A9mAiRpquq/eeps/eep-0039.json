{"pageProps":{"index":{"id":"0039","content":"<pre><code>Author: Yurii Rashkovskii &lt;yrashk(at)gmail(dot)com&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R15A\nCreated: 2-Jul-2011\nPost-History: 2-Jul-2011\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 39: <a href=\"eep-0039.md\" title=\"EEP Source\"> Scoped Group Leaders</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Scoped group leaders is an extension of the existing group leader\nmechanism that allows one to use the group leader mechanism beyond\nits original intent (which is I/O only).</p>\n\n<h1>Specification</h1>\n\n<p>Every process is given a \"dictionary\" of group leaders, with one\n<code>io</code> group leader defined by default, representing the only group\nleader that exists currently in Erlang. Every process created is\ngiven a copy of the dictionary exactly as before.</p>\n\n<p>Two new functions have been added to the <code>erlang</code> module.</p>\n\n<p>Firstly, scoped group leader retrieval:</p>\n\n<pre><code>erlang:group_leader(Scope :: atom()) -&gt; 'undefined' | pid()\n</code></pre>\n\n<p>This function retrieves the group leader for the scope <code>Scope</code>.  Existing\nargument-free function <code>erlang:group_leader/0</code> is now implemented as</p>\n\n<pre><code>erlang:group_leader(io)\n</code></pre>\n\n<p>Secondly, scoped group leader setup:</p>\n\n<pre><code>erlang:group_leader(Scope :: atom(), GroupLeader :: pid(),\n                                     Proc :: pid()) -&gt; true.\n</code></pre>\n\n<p>This function sets the group leader for scope the <code>Scope</code> to the <code>GroupLeader</code>\nfor a process <code>Proc</code>.  The existing function <code>erlang:group_leader/2</code> is\nnow implemented as</p>\n\n<pre><code>erlang:group_leader(io, GroupLeader, Proc)\n</code></pre>\n\n<p>Process information available through <code>erlang:process_info/1</code> and\n<code>erlang:process_info/2</code> has been extended with a new key, <code>group_leaders</code>.\nIt contains a proplist of group leaders associated with the process given.\nThe list will at the very least contain the tuple <code>{io, &lt;0.24.0&gt;}</code>\nNote: this group leader is currently the default one in every single process.</p>\n\n<p>Distribution mechanism(s) get extended to support these scoped group leaders\nas well, so processes spawned on remote nodes get the whole list of group\nleaders copied.</p>\n\n<h2>Example</h2>\n\n<p>In this example, we'll set a group leader for the scope of <code>test</code>\nand we'll retrieve it from the current and the child processes.\nAlso, we'll retrieve the <code>io</code> scoped group leader using both the\noriginal and the new API:</p>\n\n<pre><code>1&gt; erlang:group_leader(test, self(), self()).\ntrue\n2&gt;  erlang:group_leader().\n&lt;0.24.0&gt;\n3&gt; erlang:group_leader(io).\n&lt;0.24.0&gt;\n4&gt; erlang:group_leader(test).\n&lt;0.31.0&gt;\n5&gt; spawn(fun() -&gt; io:format(\"~p~n\",[erlang:group_leader()]) end), ok.\n&lt;0.24.0&gt;\nok\n6&gt; spawn(fun() -&gt; io:format(\"~p~n\",[erlang:group_leader(io)]) end), ok.\n&lt;0.24.0&gt;\nok\n7&gt; spawn(fun() -&gt; io:format(\"~p~n\",[erlang:group_leader(test)]) end), ok.\n&lt;0.31.0&gt;\nok\n8&gt; spawn(fun() -&gt; io:format(\"~p~n\",[erlang:process_info(self())]) end), ok.\n[{current_function,{erl_eval,do_apply,5}},\n {initial_call,{erlang,apply,2}},\n {status,running},\n {message_queue_len,0},\n {messages,[]},\n {links,[]},\n {dictionary,[]},\n {trap_exit,false},\n {error_handler,error_handler},\n {priority,normal},\n {group_leader,&lt;0.24.0&gt;},\n {group_leaders,[{test,&lt;0.31.0&gt;},{io,&lt;0.24.0&gt;}]},\n {total_heap_size,233},\n {heap_size,233},\n {stack_size,24},\n {reductions,93},\n {garbage_collection,[{min_bin_vheap_size,46368},\n                      {min_heap_size,233},\n                      {fullsweep_after,65535},\n                      {minor_gcs,0}]},\n {suspending,[]}]\nok\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>The I/O system is not the only domain where the concept of group leaders\ncomes in handy.  Implicit configurations, security groups and many other\nproblems could benefit from being able to extend the standard group leader\nmechanism.</p>\n\n<p>One of the potential uses of this technique could be an extension of the\nI/O leader paradigm into Web Development, with a <code>web</code> group leader\nrepresented as an HTTP connection, WebSocket, or Session.  With this simple\napproach one can use the same technique used by I/O primitives to allow\ntransparent and/or multiplexed access to other HTTP communication channels,\nwithin either local or remote processes.</p>\n\n<h1>Rationale</h1>\n\n<p>We have chosen to extend the existing API instead of introducing a new one\nsimply because we believe this concept to be a natural evolution of the\ngroup leaders concept with which people are already familiar.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The proposed changes keep existing API's intact and only provide some new\nfunctions for this pre-described functionality.  While this change maintains\nbackwards compatibility, the existing behaviour's are not altered and newly\nintroduced behaviour's are fashioned to mimic existing ones.</p>\n\n<p>The Proplist returned by <code>erlang:process_info/1</code> has all pre-existing keys\nunmodified and features, with the addition of a new key called <code>group_leaders</code>.\nIn the unlikely event that code exists which relies on a specific set of keys\nused in this proplist, no backwards compatibility issues should exist.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>There is no reference implementation at this point.  However, a proof\nof concept implementation is <a href=\"https://github.com/spawngrid/otp/tree/group_leader_scope\">available</a>.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}