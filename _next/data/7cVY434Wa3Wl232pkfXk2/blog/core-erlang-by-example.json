{"pageProps":{"item":{"id":"core-erlang-by-example","title":"Core Erlang by Example","author":"Björn Gustavsson","excerpt":"\nThis blog post is the first about the Core Erlang format. In this\nblog post, we introduce the Core Erlang format through examples\nthat compare Erlang code to the corresponding Core Erlang\ncode.","article_date":1525651200000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Core Erlang by Example","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post is the first about the Core Erlang format. In this\nblog post, we introduce the Core Erlang format through examples\nthat compare Erlang code to the corresponding Core Erlang\ncode.\n\nI used the following command to translate my example module to\nCore Erlang code:\n\n```\n$ erlc +time +to_core core_example.erl\nCompiling \"core_example\"\n parse_module                  :      0.000 s      10.8 kB\n transform_module              :      0.000 s      10.8 kB\n lint_module                   :      0.003 s      10.8 kB\n expand_records                :      0.000 s      10.8 kB\n core                          :      0.000 s      89.9 kB\n sys_core_fold                 :      0.000 s      58.6 kB\n core_transforms               :      0.000 s      58.6 kB\n listing                       :      0.002 s      58.6 kB\n```\n\nThe [previous blog post](http://blog.erlang.org/compiler-lost-in-translation/)\nexplored the passes from `parse_module` to `expand_records`. The\n`core` passes translates from the abstract code to Core Erlang. We\nwill talk more about the Core Erlang passes in future blog posts.\n\nI have slightly edited the examples to make them somewhat easier to\nread. There will be an unedited example at the very end of this blog post.\n\nThere's a lot to cover, so let's get started!\n\n## The simplest function\n\nLet start with the simplest possible function, a function with no\narguments returning an atom:\n\n```erlang\nsimplest() -> 'ok'.\n```\n\nIn Core Erlang, that will be:\n\n```\n'simplest'/0 =\n    fun () ->\n\t'ok'\n```\n\nFrom that example, we can work out the following principles:\n\n* Atoms are always quoted.\n\n* Naming of the function has been separated from implementation\nof the function.\n\n* The body of a `fun` is not followed by an `end` as in Erlang.\n\n\n## Slightly less simple\n\nHere is as slightly more complicated function:\n\n```erlang\nid(I) -> I.\n```\n\nIn Core Erlang:\n\n```\n'id'/1 =\n    fun (_@c0) ->\n\t_@c0\n```\n\n**Note**: All examples were compiled with OTP 20. The name of the\ngenerated variables will be different in the upcoming OTP 21.\n\nEssentially, variables are named as in Erlang. In the translation\nto Core Erlang, the compiler generates new variable names for the\narguments in a function head. The following code is also valid\nCore Erlang:\n\n\n```\n'id'/1 =\n    fun (I) ->\n\tI\n```\n\n## More than one clause\n\nHere is a function with more than one clause:\n\n```erlang\na(42) -> ok;\na(_) -> error.\n```\n\nIn Core Erlang:\n\n```\n'a'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  <_@c2> when 'true' ->\n\t      'error'\n\tend\n```\n\n* A `fun` can only have a single clause.\n\n* Pattern matching must be done in a `case`, not in the `fun` head.\n\n* Guards are mandatory for each clause in a `case`.\n\n* `_` is **not** a valid variable name in Core Erlang. Uninteresting\nvalues must be bound to a new variable.\n\n* The `<` and `>` around the patterns will be explained soon.\n\nIn Erlang, multiple function clauses can also be written with a\n`case` like this:\n\n```erlang\nb(N) ->\n    case N of\n        42 -> ok;\n        _ -> error\n    end.\n```\n\nThe Core Erlang code will be essentially the same as the Core Erlang\ncode for `a/1`:\n\n```\n'b'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  <_@c3> when 'true' ->\n\t      'error'\n\tend\n```\n\n## Two clauses, three arguments\n\nLet's try multiple arguments:\n\n```erlang\nc(inc, Base, N) ->\n    Base+N;\nc(_, Base, _) ->\n    Base.\n```\n\nIn Core Erlang:\n\n```\n'c'/3 =\n    fun (_@c2,_@c1,_@c0) ->\n\tcase <_@c2,_@c1,_@c0> of\n\t  <'inc',Base,N> when 'true' ->\n\t      call 'erlang':'+'(Base, N)\n\t  <_@c6,Base,_@c7> when 'true' ->\n\t      Base\n\tend\n```\n\n* `<` and `>` denote a **value list**. The patterns in each clause in\nthe `case` are always part of a value list. The `case` expression is\na value list unless there is only one expression.\n\n* Operators such as `+` are not part of the Core Erlang language,\nso the compiler has translated the use of `+` to a call to the\nBIF `erlang:'+'/2`.\n\n## If\n\nLet's see how `if` is implemented:\n\n```erlang\nd(A, B) ->\n    if\n        A > B ->\n            greater;\n        true ->\n            not_greater\n    end.\n```\n\nIn Core Erlang:\n\n```\n'd'/2 =\n    fun (_@c1,_@c0) ->\n\tcase <> of\n\t  <> when call 'erlang':'>'(_@c1, _@c0) ->\n\t      'greater'\n\t  <> when 'true' ->\n\t      'not_greater'\n\tend\n```\n\n* The `case` expression and the patterns are each value lists with\nzero elements. All the action is in the guards.\n\n## Repeated variables\n\nIn Erlang, a variable can be repeated in a clause or within a\npattern to indicate that the values must be the same:\n\n```erlang\ncmp(Same, Same) -> same;\ncmp(_, _) -> different.\n```\n\nCore Erlang does not allow repeating a variable:\n\n```\n'cmp'/2 =\n    fun (_@c1,_@c0) ->\n\tcase <_@c1,_@c0> of\n\t  <Same,_@c4> when call 'erlang':'=:='(_@c4, Same) ->\n\t      'same'\n\t  <_@c5,_@c6> when 'true' ->\n\t      'different'\n\tend\n```\n\n* Here the second occurence of the variable `Same` has been renamed to\na new variable named `_@c4`, and a guard has been added to compare\n`Same` and `_@c4`.\n\n## Exceptions\n\nThis function will fail with a `function_clause` exception if it is called\nwith any other value than `42`:\n\n```erlang\ne(42) -> ok.\n```\n\nIn Core Erlang:\n\n```\n'e'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  <_@c1> when 'true' ->\n\t      primop 'match_fail'({'function_clause',_@c1})\n\tend\n```\n\n* A `case` in Core Erlang must not fall off at the end, that is,\nthere must always be a clause that will match.\n\n* In this example, the last clause with a variable pattern and\na `true` guard is guaranteed to match.\n\n* The body for the last clause calls a **primop** to generate\na function clause exception. Primops are primitive operations\nprovided by the Erlang implementation, but not specified in the\nCore Erlang language specification.\n\nHere is a similar function excepts that is uses `case` and therefore\nwill generate a `case_clause` exception if called with any other\nargument than `42`:\n\n```erlang\nf(N) ->\n    case N of\n        42 -> ok\n    end.\n```\n\nThe Core Erlang code is similar to the code for `e/1`:\n\n\n```\n'f'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  <_@c1> when 'true' ->\n\t      primop 'match_fail'({'case_clause',_@c1})\n\tend\n```\n\n* The only difference is the argument for the `match_fail` primop.\n\nLet's rewrite this function one more time:\n\n```erlang\ng(N) ->\n    42 = N,\n    ok.\n```\n\nIn Core Erlang:\n\n```\n'g'/1 =\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  <_@c1> when 'true' ->\n\t      primop 'match_fail'({'badmatch',_@c1})\n\tend\n```\n\n* Again, the only difference is the argument for the `match_fail` primop.\n\n## Binding variables using 'let'\n\nHere is a function that binds the variable `I`:\n\n```erlang\nh(A) ->\n    I = id(A),\n    I + A.\n```\n\nIn Core Erlang:\n\n```\n'h'/1 =\n    fun (_@c0) ->\n\tlet <I> =\n              apply 'id'/1(_@c0)\n\tin\n              call 'erlang':'+'(I, _@c0)\n```\n\n\n* `apply` calls a fun or local function.\n\n* The return value of the `apply` is bound to the variable `I`.\n\n* The variable `I` can only be used in the code that follows the\n`in` keyword.\n\n* The variable name is in a value list. That is because `let`\ncan bind several variables at once.\n\n## Binding more than one variable in a 'let'\n\nErlang has essentially no scoping. When a variable has been bound,\nit remains bound to the end of the function. For example, variables bound\nin a `case` can be used after the `case`:\n\n```erlang\ni(E) ->\n    case E of\n        a ->\n            X = 1,\n            Y = 10;\n        b ->\n            X = 23,\n            Y = 17\n    end,\n    {X,Y}.\n```\n\nIn Core Erlang:\n\n```\n'i'/1 =\n    fun (_@c0) ->\n\tlet <_@c7,X,Y> =\n\t    case _@c0 of\n\t      <'a'> when 'true' ->\n\t\t  <10,1,10>\n\t      <'b'> when 'true' ->\n\t\t  <17,23,17>\n\t      <_@c5> when 'true' ->\n\t\t  primop 'match_fail'({'case_clause',_@c5})\n\t    end\n\tin\n\t    {X,Y}\n```\n\n* A `case` in Core Erlang does not export any variables. All variables\nthat are to be used after the `case` must be explicitly returned.\n\n* In this example, the first two clauses of the `case` return a\nvalue list with **three** values. The first value is the return value\nof the case, which in this case is ignored. The other two values are\nthe values assigned to the `X` and `Y` variables, respectively.\n\n* The values returned from the `case` is bound in the `let`. The ignored\nreturn value is bound to a new variable (`_@c7`), which is never used.\nThe exported values are bound to the `X` and `Y` variables.\n\n## The unedited Core Erlang code\n\nSo far all Core Erlang examples have been edited to make the points\nI am trying to make stand out clearer. Let's have a look at the unedited\nversion of a previous example:\n\n```\n'e'/1 =\n    %% Line 33\n    fun (_@c0) ->\n\tcase _@c0 of\n\t  <42> when 'true' ->\n\t      'ok'\n\t  ( <_@c1> when 'true' ->\n\t\t( primop 'match_fail'\n\t\t      ({'function_clause',_@c1})\n\t\t  -| [{'function_name',{'e',1}}] )\n\t    -| ['compiler_generated'] )\n\tend\n```\n\n* The `-|` associates an annotation with a Core Erlang construct.\nThe meaning of an annotation is not specified in the Core Erlang\nlanguage specification.\n\n* The `compiler_generated` annotation associated with the last clause\nis a hint added by the compiler that subsequent optimization passes should\nnot generate a warning if the clause was found to never match and dropped.\n\n* The comment \"Line 33\" at the beginning is actually an annotation that\nthe pretty printer has turned into a comment to avoid rendering the\npretty-printed code unreadable.\n\n## Conclusion\n\nCore Erlang is less complicated than Erlang, and is therefore more\nsuited than the abstract format for code analyzing tools (such as\n[Dialyzer][dialyzer]) and optimizers.\n\n[dialyzer]: http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html\n\n## To learn more about Core Erlang\n\nAll details can be found in [Core Erlang 1.0.3 language specification][core].\n\n[core]: https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf\n"}},"__N_SSG":true}