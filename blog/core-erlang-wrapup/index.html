<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.ea40b862c8a8db76db57.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/core-erlang-wrapup/">Core Erlang Wrap Up</a></h3><p><em>Wednesday, 30 May 2018<!-- --> - <!-- -->Björn Gustavsson</em></p><p>This blog post wraps up the exploration of Core Erlang started in the
previous two blog posts. The remaining default Core Erlang
passes are described, followed by a look at how Core Erlang is
represented internally in the compiler.</p><p>Here are the Core Erlang passes that will be run when using
OTP 21 RC1 or the <code>master</code> branch in the git repository:</p><pre><code>$ erlc +time core_wrapup.erl
Compiling &quot;core_wrapup&quot;
     .
     .
     .
 core                          :      0.000 s      15.7 kB
 sys_core_fold                 :      0.000 s       9.0 kB
 sys_core_alias                :      0.000 s       9.0 kB
 core_transforms               :      0.000 s       9.0 kB
 sys_core_bsm                  :      0.000 s       9.0 kB
 sys_core_dsetel               :      0.000 s       9.0 kB
     .
     .
     .</code></pre><p>We have covered <code>core</code> and <code>sys_core_fold</code> in the two previous
blog posts about Core Erlang.</p><h2>The other Core Erlang passes</h2><h3>sys_core_alias</h3><p>In the upcoming OTP 21 release, there is a new <code>sys_core_alias</code> pass
contributed by <a href="https://github.com/josevalim">José Valim</a>.</p><p>The purpose of the pass is to avoid rebuilding terms that
have been matched, such as in this example:</p><pre><code class="language-erlang">remove_even([{Key,Val}|T]) -&gt;
    case Val rem 2 =:= 0 of
        true -&gt; remove_even(T);
        false -&gt;  [{Key,Val}|remove_even(T)]
    end;
remove_even([]) -&gt; [].</code></pre><p>In the function head, the pattern <code>{Key,Val}</code> binds two elements of a
tuple to the variables <code>Key</code> and <code>Val</code>, but the original tuple is not
captured. In the <code>false</code> clause of the <code>case</code>, a new tuple will be
constructed from <code>Key</code> and <code>Val</code>.</p><p>It is possible to avoid creating a new tuple by using the <code>=</code> operator
to bind the complete tuple to a variable:</p><pre><code class="language-erlang">remove_even([{Key,Val}=Tuple|T]) -&gt;
    case Val rem 2 =:= 0 of
        true -&gt; remove_even(T);
        false -&gt;  [Tuple|remove_even(T)]
    end;
remove_even([]) -&gt; [].</code></pre><p>Essentially, the new <code>sys_core_alias</code> pass does that transformation
automatically. Here is the Core Erlang code before applying this
optimization:</p><pre><code>&#x27;remove_even&#x27;/1 =
    fun (_0) -&gt;
	case _0 of
	  &lt;[{Key,Val}|T]&gt; when &#x27;true&#x27; -&gt;
	      let &lt;_1&gt; =
		  call
		       &#x27;erlang&#x27;:&#x27;rem&#x27;(Val, 2)
	      in
		  case &lt;&gt; of
		    &lt;&gt;
			when call &#x27;erlang&#x27;:&#x27;=:=&#x27;(_1, 0) -&gt;
			    apply &#x27;remove_even&#x27;/1(T)
		    &lt;&gt; when &#x27;true&#x27; -&gt;
			let &lt;_2&gt; =
			    apply &#x27;remove_even&#x27;/1(T)
			in
                            [{Key,Val}|_2]      % BUILDING TUPLE
		  end
	  &lt;[]&gt; when &#x27;true&#x27; -&gt;
	      []
	  &lt;_4&gt; when &#x27;true&#x27; -&gt;
		primop &#x27;match_fail&#x27;({&#x27;function_clause&#x27;,_4})
	end</code></pre><p>Here is the code after running the <code>sys_core_alias</code> pass:</p><pre><code>&#x27;remove_even&#x27;/1 =
    fun (_0) -&gt;
	case _0 of
	  &lt;[_@r0 = {Key,Val}|T]&gt; when &#x27;true&#x27; -&gt;
	      let &lt;_1&gt; =
		  call &#x27;erlang&#x27;:&#x27;rem&#x27;(Val, 2)
	      in
		  case &lt;&gt; of
		    &lt;&gt;
			when call &#x27;erlang&#x27;:&#x27;=:=&#x27;(_1, 0) -&gt;
			    apply &#x27;remove_even&#x27;/1(T)
		    &lt;&gt; when &#x27;true&#x27; -&gt;
			let &lt;_2&gt; =
			    apply &#x27;remove_even&#x27;/1(T)
			in
			    [_@r0|_2]          % REUSING EXISTING TUPLE
		  end
	  &lt;[]&gt; when &#x27;true&#x27; -&gt;
	      []
	  &lt;_4&gt; when &#x27;true&#x27; -&gt;
		primop &#x27;match_fail&#x27;({&#x27;function_clause&#x27;,_4})
	end</code></pre><h3>core_transforms</h3><p>Similar to parse transforms, the <code>core_transforms</code> pass makes it possible to
add compiler passes that transform the Core Erlang code without modifying
the compiler.</p><p>As an example, here is a simple core transform module:</p><pre><code class="language-erlang">-module(my_core_transform).
-export([core_transform/2]).

core_transform(Core, _Options) -&gt;
    Module = cerl:concrete(cerl:module_name(Core)),
    io:format(&quot;Module name: ~p\n&quot;, [Module]),
    io:format(&quot;Number of nodes in Core Erlang tree: ~p\n&quot;,
              [cerl_trees:size(Core)]),
    Core.</code></pre><p>Before explaining the code, let&#x27;s see it in action:</p><pre><code>$ erlc my_core_transform
$ erlc -pa . &#x27;+{core_transform,my_core_transform}&#x27; core_wrapup.erl
Module name: core_wrapup
Number of nodes in Core Erlang tree: 220
$</code></pre><p>The <code>{core_transform,Name}</code> option instructs the compiler to run a
core transformation. In this case, the core transform module is
<code>my_core_transform</code>. After doing the standard optimizing passes,
the compiler will call <code>my_core_transform:core_transform/2</code>, passing
the Core Erlang code as the first argument and the compiler options
as the second argument.</p><p>The first line in the <code>core_transform/2</code> functions calls
<code>cerl:module_name(Core)</code> to retrieve the module name. The return value
of <code>cerl:module_name/1</code> is a record representing any literal term. To
retrieve the actual term (an atom in this case), <code>cerl:concrete/1</code>
is called.</p><p>In the second <code>io:format/2</code> call, we call <code>cerl_trees:size/1</code> to
count the number of nodes in the tree that represents the Core Erlang
code for the module.</p><p>This core transform does not do any real transforming, since the last
line returns the Core Erlang code without any modifications.</p><h3>sys_core_bsm</h3><p><code>sys_core_bsm</code> is the first of three passes that implement the delayed
sub binary optimization described in the <a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html">Efficiency
Guide</a>.  <code>sys_core_bsm</code> adds annotations that are
later used by <code>v3_codegen</code> and <code>beam_bsm</code> to optimize matching of
binaries.</p><h3>sys_core_dsetel</h3><p>The <code>sys_core_dsetel</code> pass will optimize chained or nested
applications of <code>setelement/3</code> as in this example:</p><pre><code class="language-erlang">update_tuple(T0) -&gt;
    T = setelement(3, T0, y),
    setelement(2, T, x).</code></pre><p>Translated to Core Erlang it looks like this:</p><pre><code>&#x27;update_tuple&#x27;/1 =
    fun (_0) -&gt;
	let &lt;T&gt; =
	    call &#x27;erlang&#x27;:&#x27;setelement&#x27;(3, _0, &#x27;y&#x27;)
	in
	    call &#x27;erlang&#x27;:&#x27;setelement&#x27;(2, T, &#x27;x&#x27;)</code></pre><p>The <code>sys_core_dsetel</code> pass replaces the second call to <code>setelement/3</code>
with the primop <code>dsetelement/3</code>, which destructively updates a tuple:</p><pre><code>&#x27;update_tuple&#x27;/1 =
    fun (_0) -&gt;
	let &lt;T&gt; =
	    call &#x27;erlang&#x27;:&#x27;setelement&#x27;(3, _0, &#x27;y&#x27;)
	in  do
		primop &#x27;dsetelement&#x27;(2, T, &#x27;x&#x27;)
		T</code></pre><p><code>do</code> evalutes two expressions in sequence, ignoring the value of the
first expression. It is used here because the primop <code>dsetelement/3</code>
updates its tuple argument without returning a value.</p><p>The <code>sys_core_dsetel</code> pass is intentionally run as the very last
Core Erlang pass. Doing other optimizations might render the optimization
unsafe. For example, there must not occur a garbage collection between
the call to <code>setelement/3</code> and <code>dsetelement/3</code>.</p><p>Why is this optimization useful? Surely a sequence of <code>setelement/3</code>
calls must be rare?</p><p>Consider this function that updates two elements in a record:</p><pre><code>-record(rec, {a,b,c,d,e,f,g,h}).

update_record(R) -&gt;
    R#rec{a=x,b=y}.</code></pre><p>In <a href="http://blog.erlang.org/compiler-lost-in-translation/">a previous blog post</a> we saw that the <code>-E</code> option
will produce an <code>.E</code> file with the code after records have been translated
to tuple operations:</p><pre><code>$ erlc -E core_wrapup.erl</code></pre><p>Here is the code for <code>update_record/1</code> after record translation:</p><pre><code>update_record(R) -&gt;
    begin
        rec0 = R,
        case rec0 of
            {rec,_,_,_,_,_,_,_,_} -&gt;
                setelement(2, setelement(3, rec0, y), x);
            _ -&gt;
                error({badrecord,rec})
        end
    end.</code></pre><p>After verifying that <code>R</code> is indeed a record of the correct type (that is,
that the size and first element of the tuple are correct), nested calls
to <code>setelement/3</code> is used to update two elements of the tuple.</p><p>The optimized Core Erlang code for <code>update_record/1</code> will look like
this:</p><pre><code>&#x27;update_record&#x27;/1 =
    fun (_0) -&gt;
	case _0 of
	  &lt;{&#x27;rec&#x27;,_5,_6,_7,_8,_9,_10,_11,_12}&gt; when &#x27;true&#x27; -&gt;
	      let &lt;_2&gt; =
		  call &#x27;erlang&#x27;:&#x27;setelement&#x27;(3, _0, &#x27;y&#x27;)
	      in  do  primop &#x27;dsetelement&#x27;(2, _2, &#x27;x&#x27;)
		      _2
	  &lt;_13&gt; when &#x27;true&#x27; -&gt;
		call &#x27;erlang&#x27;:&#x27;error&#x27;({&#x27;badrecord&#x27;,&#x27;rec&#x27;})
	end</code></pre><h2>The representation of Core Erlang code</h2><p>So far we have looked at the external (pretty-printed) representation of
Core Erlang. Before leaving Core Erlang, we will take a brief look at
the internal representation of Core Erlang that the compiler uses.</p><p>There are ~~two~~ three ways to work with Core Erlang within an
optimizer pass:</p><ul><li><p>Using the API functions in the <code>cerl</code> module</p></li><li><p>Using the <code>c_*</code> records defined in <code>core_parse.hrl</code></p></li><li><p>Mixing use of records with use of the API functions</p></li></ul><h3>Using the cerl module and friends</h3><p>The <code>cerl</code> module provides API functions to construct, deconstruct, update,
and query each of the constructs in Core Erlang.</p><p>Here are some examples:</p><ul><li><p><code>cerl:c_var(Name)</code> constructs the Core Erlang representation
of a variable with the name <code>Name</code>.</p></li><li><p><code>cerl:is_c_var(Core)</code> returns <code>true</code> if the <code>Core</code> represents a Core
Erlang variable, and <code>false</code> otherwise.</p></li><li><p><code>cerl:var_name(Core)</code> returns the name of a variable (and crashes if
<code>Core</code> does not represent a Core Erlang variable).</p></li></ul><p>There are also the <code>cerl_trees</code> and <code>cerl_clauses</code> modules that provide
useful utility functions for manipulating Core Erlang code.</p><h3>Using the records</h3><p>In <code>core_parse.hrl</code>, there is one record for each kind of Core Erlang
construct. All record names start with the prefix <code>c_</code>.</p><p>For example, the record <code>#c_var{}</code> represents a variable, the record
<code>#c_call{}</code> the <code>call</code> expression, the record <code>c_tuple{}</code> a tuple, and
so on.</p><p>As a complete example, we can rewrite our previous core transform
to use record matching instead of <code>cerl</code> to retrieve the module name:</p><pre><code>-module(my_core_transform).
-export([core_transform/2]).

-include_lib(&quot;compiler/src/core_parse.hrl&quot;).

core_transform(Core, _Options) -&gt;
    #c_module{name=#c_literal{val=Module}} = Core,
    io:format(&quot;Module name: ~p\n&quot;, [Module]),
    io:format(&quot;Number of nodes in Core Erlang tree: ~p\n&quot;,
              [cerl_trees:size(Core)]),
    Core.</code></pre><h3>Mixing the <code>cerl</code> API with records</h3><p>The <code>cerl</code> module internally use the records in <code>core_parse.hrl</code>, so
the two approaches can be mixed. For example, <code>sys_core_fold</code> mostly
use the records, but sometimes uses <code>cerl</code> when it is more convenient.</p><h2>Wrapping up the wrap up</h2><p>It seems that there is enough material for several more blog posts
about Core Erlang. For instance, I haven&#x27;t even mentioned the inliners
(not a typo, there are <em>two</em> inliners). That means that there might be
more blog posts about Core Erlang in the future.</p><p>But in the very near future, it is time to explore the compiler passes
that follow Core Erlang, and perhaps answer the eternal question about
the <code>v3_</code> prefix. Was there ever a <code>v2_kernel</code> (spoiler: yes) or a
<code>v1_kernel</code> (spoiler: no)?</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"core-erlang-wrapup","title":"Core Erlang Wrap Up","author":"Björn Gustavsson","excerpt":"\nThis blog post wraps up the exploration of Core Erlang started in the\nprevious two blog posts. The remaining default Core Erlang\npasses are described, followed by a look at how Core Erlang is\nrepresented internally in the compiler.","article_date":1527638400000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Core Erlang Wrap Up","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post wraps up the exploration of Core Erlang started in the\nprevious two blog posts. The remaining default Core Erlang\npasses are described, followed by a look at how Core Erlang is\nrepresented internally in the compiler.\n\nHere are the Core Erlang passes that will be run when using\nOTP 21 RC1 or the `master` branch in the git repository:\n\n```\n$ erlc +time core_wrapup.erl\nCompiling \"core_wrapup\"\n     .\n     .\n     .\n core                          :      0.000 s      15.7 kB\n sys_core_fold                 :      0.000 s       9.0 kB\n sys_core_alias                :      0.000 s       9.0 kB\n core_transforms               :      0.000 s       9.0 kB\n sys_core_bsm                  :      0.000 s       9.0 kB\n sys_core_dsetel               :      0.000 s       9.0 kB\n     .\n     .\n     .\n```\n\nWe have covered `core` and `sys_core_fold` in the two previous\nblog posts about Core Erlang.\n\n## The other Core Erlang passes\n\n### sys_core_alias\n\nIn the upcoming OTP 21 release, there is a new `sys_core_alias` pass\ncontributed by [José Valim](https://github.com/josevalim).\n\nThe purpose of the pass is to avoid rebuilding terms that\nhave been matched, such as in this example:\n\n```erlang\nremove_even([{Key,Val}|T]) -\u003e\n    case Val rem 2 =:= 0 of\n        true -\u003e remove_even(T);\n        false -\u003e  [{Key,Val}|remove_even(T)]\n    end;\nremove_even([]) -\u003e [].\n```\n\nIn the function head, the pattern `{Key,Val}` binds two elements of a\ntuple to the variables `Key` and `Val`, but the original tuple is not\ncaptured. In the `false` clause of the `case`, a new tuple will be\nconstructed from `Key` and `Val`.\n\nIt is possible to avoid creating a new tuple by using the `=` operator\nto bind the complete tuple to a variable:\n\n```erlang\nremove_even([{Key,Val}=Tuple|T]) -\u003e\n    case Val rem 2 =:= 0 of\n        true -\u003e remove_even(T);\n        false -\u003e  [Tuple|remove_even(T)]\n    end;\nremove_even([]) -\u003e [].\n```\n\nEssentially, the new `sys_core_alias` pass does that transformation\nautomatically. Here is the Core Erlang code before applying this\noptimization:\n\n```\n'remove_even'/1 =\n    fun (_0) -\u003e\n\tcase _0 of\n\t  \u003c[{Key,Val}|T]\u003e when 'true' -\u003e\n\t      let \u003c_1\u003e =\n\t\t  call\n\t\t       'erlang':'rem'(Val, 2)\n\t      in\n\t\t  case \u003c\u003e of\n\t\t    \u003c\u003e\n\t\t\twhen call 'erlang':'=:='(_1, 0) -\u003e\n\t\t\t    apply 'remove_even'/1(T)\n\t\t    \u003c\u003e when 'true' -\u003e\n\t\t\tlet \u003c_2\u003e =\n\t\t\t    apply 'remove_even'/1(T)\n\t\t\tin\n                            [{Key,Val}|_2]      % BUILDING TUPLE\n\t\t  end\n\t  \u003c[]\u003e when 'true' -\u003e\n\t      []\n\t  \u003c_4\u003e when 'true' -\u003e\n\t\tprimop 'match_fail'({'function_clause',_4})\n\tend\n```\n\nHere is the code after running the `sys_core_alias` pass:\n\n```\n'remove_even'/1 =\n    fun (_0) -\u003e\n\tcase _0 of\n\t  \u003c[_@r0 = {Key,Val}|T]\u003e when 'true' -\u003e\n\t      let \u003c_1\u003e =\n\t\t  call 'erlang':'rem'(Val, 2)\n\t      in\n\t\t  case \u003c\u003e of\n\t\t    \u003c\u003e\n\t\t\twhen call 'erlang':'=:='(_1, 0) -\u003e\n\t\t\t    apply 'remove_even'/1(T)\n\t\t    \u003c\u003e when 'true' -\u003e\n\t\t\tlet \u003c_2\u003e =\n\t\t\t    apply 'remove_even'/1(T)\n\t\t\tin\n\t\t\t    [_@r0|_2]          % REUSING EXISTING TUPLE\n\t\t  end\n\t  \u003c[]\u003e when 'true' -\u003e\n\t      []\n\t  \u003c_4\u003e when 'true' -\u003e\n\t\tprimop 'match_fail'({'function_clause',_4})\n\tend\n```\n\n### core_transforms\n\nSimilar to parse transforms, the `core_transforms` pass makes it possible to\nadd compiler passes that transform the Core Erlang code without modifying\nthe compiler.\n\nAs an example, here is a simple core transform module:\n\n```erlang\n-module(my_core_transform).\n-export([core_transform/2]).\n\ncore_transform(Core, _Options) -\u003e\n    Module = cerl:concrete(cerl:module_name(Core)),\n    io:format(\"Module name: ~p\\n\", [Module]),\n    io:format(\"Number of nodes in Core Erlang tree: ~p\\n\",\n              [cerl_trees:size(Core)]),\n    Core.\n```\n\nBefore explaining the code, let's see it in action:\n\n```\n$ erlc my_core_transform\n$ erlc -pa . '+{core_transform,my_core_transform}' core_wrapup.erl\nModule name: core_wrapup\nNumber of nodes in Core Erlang tree: 220\n$\n```\n\nThe `{core_transform,Name}` option instructs the compiler to run a\ncore transformation. In this case, the core transform module is\n`my_core_transform`. After doing the standard optimizing passes,\nthe compiler will call `my_core_transform:core_transform/2`, passing\nthe Core Erlang code as the first argument and the compiler options\nas the second argument.\n\nThe first line in the `core_transform/2` functions calls\n`cerl:module_name(Core)` to retrieve the module name. The return value\nof `cerl:module_name/1` is a record representing any literal term. To\nretrieve the actual term (an atom in this case), `cerl:concrete/1`\nis called.\n\nIn the second `io:format/2` call, we call `cerl_trees:size/1` to\ncount the number of nodes in the tree that represents the Core Erlang\ncode for the module.\n\nThis core transform does not do any real transforming, since the last\nline returns the Core Erlang code without any modifications.\n\n### sys_core_bsm\n\n`sys_core_bsm` is the first of three passes that implement the delayed\nsub binary optimization described in the [Efficiency\nGuide][efficiency_guide].  `sys_core_bsm` adds annotations that are\nlater used by `v3_codegen` and `beam_bsm` to optimize matching of\nbinaries.\n\n[efficiency_guide]: http://erlang.org/doc/efficiency_guide/binaryhandling.html\n\n### sys_core_dsetel\n\nThe `sys_core_dsetel` pass will optimize chained or nested\napplications of `setelement/3` as in this example:\n\n```erlang\nupdate_tuple(T0) -\u003e\n    T = setelement(3, T0, y),\n    setelement(2, T, x).\n```\n\nTranslated to Core Erlang it looks like this:\n\n```\n'update_tuple'/1 =\n    fun (_0) -\u003e\n\tlet \u003cT\u003e =\n\t    call 'erlang':'setelement'(3, _0, 'y')\n\tin\n\t    call 'erlang':'setelement'(2, T, 'x')\n```\n\nThe `sys_core_dsetel` pass replaces the second call to `setelement/3`\nwith the primop `dsetelement/3`, which destructively updates a tuple:\n\n```\n'update_tuple'/1 =\n    fun (_0) -\u003e\n\tlet \u003cT\u003e =\n\t    call 'erlang':'setelement'(3, _0, 'y')\n\tin  do\n\t\tprimop 'dsetelement'(2, T, 'x')\n\t\tT\n```\n\n`do` evalutes two expressions in sequence, ignoring the value of the\nfirst expression. It is used here because the primop `dsetelement/3`\nupdates its tuple argument without returning a value.\n\nThe `sys_core_dsetel` pass is intentionally run as the very last\nCore Erlang pass. Doing other optimizations might render the optimization\nunsafe. For example, there must not occur a garbage collection between\nthe call to `setelement/3` and `dsetelement/3`.\n\nWhy is this optimization useful? Surely a sequence of `setelement/3`\ncalls must be rare?\n\nConsider this function that updates two elements in a record:\n\n```\n-record(rec, {a,b,c,d,e,f,g,h}).\n\nupdate_record(R) -\u003e\n    R#rec{a=x,b=y}.\n```\n\nIn [a previous blog post][lost in translation] we saw that the `-E` option\nwill produce an `.E` file with the code after records have been translated\nto tuple operations:\n\n[lost in translation]: http://blog.erlang.org/compiler-lost-in-translation/\n\n```\n$ erlc -E core_wrapup.erl\n```\n\nHere is the code for `update_record/1` after record translation:\n\n```\nupdate_record(R) -\u003e\n    begin\n        rec0 = R,\n        case rec0 of\n            {rec,_,_,_,_,_,_,_,_} -\u003e\n                setelement(2, setelement(3, rec0, y), x);\n            _ -\u003e\n                error({badrecord,rec})\n        end\n    end.\n```\n\nAfter verifying that `R` is indeed a record of the correct type (that is,\nthat the size and first element of the tuple are correct), nested calls\nto `setelement/3` is used to update two elements of the tuple.\n\nThe optimized Core Erlang code for `update_record/1` will look like\nthis:\n\n```\n'update_record'/1 =\n    fun (_0) -\u003e\n\tcase _0 of\n\t  \u003c{'rec',_5,_6,_7,_8,_9,_10,_11,_12}\u003e when 'true' -\u003e\n\t      let \u003c_2\u003e =\n\t\t  call 'erlang':'setelement'(3, _0, 'y')\n\t      in  do  primop 'dsetelement'(2, _2, 'x')\n\t\t      _2\n\t  \u003c_13\u003e when 'true' -\u003e\n\t\tcall 'erlang':'error'({'badrecord','rec'})\n\tend\n```\n\n## The representation of Core Erlang code\n\nSo far we have looked at the external (pretty-printed) representation of\nCore Erlang. Before leaving Core Erlang, we will take a brief look at\nthe internal representation of Core Erlang that the compiler uses.\n\nThere are ~~two~~ three ways to work with Core Erlang within an\noptimizer pass:\n\n* Using the API functions in the `cerl` module\n\n* Using the `c_*` records defined in `core_parse.hrl`\n\n* Mixing use of records with use of the API functions\n\n### Using the cerl module and friends\n\nThe `cerl` module provides API functions to construct, deconstruct, update,\nand query each of the constructs in Core Erlang.\n\nHere are some examples:\n\n* `cerl:c_var(Name)` constructs the Core Erlang representation\nof a variable with the name `Name`.\n\n* `cerl:is_c_var(Core)` returns `true` if the `Core` represents a Core\nErlang variable, and `false` otherwise.\n\n* `cerl:var_name(Core)` returns the name of a variable (and crashes if\n`Core` does not represent a Core Erlang variable).\n\nThere are also the `cerl_trees` and `cerl_clauses` modules that provide\nuseful utility functions for manipulating Core Erlang code.\n\n### Using the records\n\nIn `core_parse.hrl`, there is one record for each kind of Core Erlang\nconstruct. All record names start with the prefix `c_`.\n\nFor example, the record `#c_var{}` represents a variable, the record\n`#c_call{}` the `call` expression, the record `c_tuple{}` a tuple, and\nso on.\n\nAs a complete example, we can rewrite our previous core transform\nto use record matching instead of `cerl` to retrieve the module name:\n\n```\n-module(my_core_transform).\n-export([core_transform/2]).\n\n-include_lib(\"compiler/src/core_parse.hrl\").\n\ncore_transform(Core, _Options) -\u003e\n    #c_module{name=#c_literal{val=Module}} = Core,\n    io:format(\"Module name: ~p\\n\", [Module]),\n    io:format(\"Number of nodes in Core Erlang tree: ~p\\n\",\n              [cerl_trees:size(Core)]),\n    Core.\n```\n\n### Mixing the `cerl` API with records\n\nThe `cerl` module internally use the records in `core_parse.hrl`, so\nthe two approaches can be mixed. For example, `sys_core_fold` mostly\nuse the records, but sometimes uses `cerl` when it is more convenient.\n\n## Wrapping up the wrap up\n\nIt seems that there is enough material for several more blog posts\nabout Core Erlang. For instance, I haven't even mentioned the inliners\n(not a typo, there are *two* inliners). That means that there might be\nmore blog posts about Core Erlang in the future.\n\nBut in the very near future, it is time to explore the compiler passes\nthat follow Core Erlang, and perhaps answer the eternal question about\nthe `v3_` prefix. Was there ever a `v2_kernel` (spoiler: yes) or a\n`v1_kernel` (spoiler: no)?\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"core-erlang-wrapup"},"buildId":"7cVY434Wa3Wl232pkfXk2","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.ea40b862c8a8db76db57.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_buildManifest.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_ssgManifest.js" async=""></script></body></html>