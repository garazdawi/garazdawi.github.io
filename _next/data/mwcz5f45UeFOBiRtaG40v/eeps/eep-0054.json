{"pageProps":{"index":{"id":"0054","content":"<pre><code>Author: Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;\nStatus: Draft\nType: Standards Track\nCreated: 14-Sep-2020\nErlang-Version: 24\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 54: <a href=\"eep-0054.md\" title=\"EEP Source\"> Provide more information about errors</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP proposes a mechanism for reporting more human-readable\ninformation about what went wrong when a BIF raises an exception.  The\nsame mechanism can be used by libraries or applications to provide\nmore detailed error messages.</p>\n\n<h1>Specification</h1>\n\n<p>In OTP 23 and earlier, the shell prints a terse message when a call\nto a built-in function (BIF) fails:</p>\n\n<pre><code>1&gt; element(a,b).\n** exception error: bad argument\n     in function  element/2\n        called as element(a,b)\n</code></pre>\n\n<p>The <code>bad argument</code> message informs us that one or more of the\narguments to the call were incorrect in some way (in this example,\nboth arguments have wrong types).</p>\n\n<p>We propose a mechanism that enables the shell to print more helpful\nerror messages.  Here is how the message would be printed with the\nreference implementation of this EEP:</p>\n\n<pre><code>1&gt; element(a, b).\n** exception error: bad argument\n     in function  element/2\n        called as element(a,b)\n        *** argument 1: not an integer\n        *** argument 2: not a tuple\n</code></pre>\n\n<p>Note that the exact formatting and phrasing of the messages is an implementation\ndetail outside the scope of this EEP.  What will be specified here are the APIs\nand conventions that make these messages possible.</p>\n\n<h3>Proposals in this EEP</h3>\n\n<ul>\n<li><p>An extension of the format of the call-stack back trace (<strong>stacktrace</strong>) format\nto indicate that there exists extended error information for that call, and\na convention for how extended error information can be provided.</p></li>\n<li><p>A new <code>erlang:error/3</code> BIF to allow libraries and applications to\nraise an exception with extended error information in the stacktrace.</p></li>\n<li><p>New functions <code>erl_error:format_exception/3</code> and\n<code>erl_error:format_exception/4</code> to allow libraries and applications to\nformat stacktraces in the same style as the shell.</p></li>\n</ul>\n\n<h3>Extending the stacktrace</h3>\n\n<p>The stack back-trace (<strong>stacktrace</strong>) is currently a list of tuples.\nFor the purpose of this EEP we are only interested in the first entry\nin the stacktrace.  It looks like\n<code>{Module,Function,Arguments,ExtraInfo}</code>, where <code>ExtraInfo</code> is a list\nof two-tuples.  As an indication that extended error info is available,\nwe propose adding an <code>{error_info,ErrorInfoMap}</code> tuple to <code>ExtraInfo</code>\nin the first element in the stacktrace.</p>\n\n<p>The map <code>ErrorInfoMap</code> contains further information about the error.\nThis should contain at least the key <code>reason</code>.  The corresponding\nvalue could contain additional information about the error.  When there\nis no additional information avaiable, the value is a dummy value such\nas <code>none</code> or <code>[]</code>.</p>\n\n<p>To obtain more information about the error, the <code>format_error/4</code>\nfunction in module <code>Module</code> can be called to provide additional information about\nthe error.</p>\n\n<p>The arguments for <code>format_error/4</code> are <code>Function</code>, <code>Arguments</code>, the\nexception reason (usually <code>badarg</code> for BIF calls), and <code>ErrorInfoMap</code>.</p>\n\n<p>Thus, if a call to <code>element/2</code> fails with a <code>badarg</code> exception and the\nfirst entry in the stacktrace is:</p>\n\n<pre><code>{erlang,element,[1,no_tuple],[{error_info,ErrorInfoMap}]}\n</code></pre>\n\n<p>the following call will provide provide additional information about\nthe error:</p>\n\n<pre><code>erlang:format_error(element, [1,no_tuple], badarg, ErrorInfoMap)\n</code></pre>\n\n<p>The <code>format_error/4</code> function should return a map.  For each argument\nthat was in error, there should be a map element with the argument number\nas the key (that is, <code>1</code> for the first argument, <code>2</code> for the second, and so on)\nand a <code>unicode:chardata()</code> term as the value.</p>\n\n<p>As an example:</p>\n\n<pre><code>erlang:format_error(element, [1,no_tuple], badarg, ErrorInfoMap)\n</code></pre>\n\n<p>could return:</p>\n\n<pre><code>#{2 =&gt; &lt;&lt;\"not a tuple\"&gt;&gt;}\n</code></pre>\n\n<p>And:</p>\n\n<pre><code>erlang:format_error(element, [0, b], badarg, ErrorInfo)\n</code></pre>\n\n<p>could return:</p>\n\n<pre><code>#{1 =&gt; &lt;&lt;\"out of range\"&gt;&gt;, 2 =&gt; &lt;&lt;\"not a tuple\"&gt;&gt;}\n</code></pre>\n\n<p>Note that the <code>ErrorInfoMap</code> term is only to be used by\n<code>Module:format_error/4</code>.  It is not to be matched by code in other\nmodules.  The particular value for the key <code>reason</code> in the map\n<code>ErrorInfoMap</code> for a particular error could change at any time.  Also\nnote that <code>Module:format_error/4</code> may choose not to use the <code>reason</code>\nkey at all.  For example, the reference implementation of\n<code>erlang:format_error/4</code> only examines the arguments for <code>element/2</code>.</p>\n\n<p>The value for the key <code>reason</code> term will typically have a meaningful\nvalue when an error occurs in a BIF that depends on the internal state\nin the runtime system (such as <code>register/2</code> or the ETS BIFs), or for\nBIFs with complex arguments (such as <code>system_flag/2</code>) that would\nmake it tedious and error prone to figure out which argument was\nin error.</p>\n\n<p>Here is one way that <code>format_error/4</code> for the <code>erlang</code> module could\nbe implemented:</p>\n\n<pre><code>format_error(F, As, ExceptionReason, ErrorInfoMap) -&gt;\n    Reason = maps:get(reason, ErrorInfoMap, none),\n    do_format_error(F, As, ExceptionReason, Reason).\n\ndo_format_error(_, _, system_limit, _) -&gt;\n    %% The explanation for system_limit is clear enough, so we don't\n    %% need any detailed explanations for the arguments.\n    #{};\ndo_format_error(F, As, _, Reason) -&gt;\n    do_format_error(F, As, Reason).\n\ndo_format_error(element, [Index, Tuple], _) -&gt;\n    Arg1 = if\n               not is_integer(Index) -&gt;\n                   &lt;&lt;\"not an integer\"&gt;&gt;;\n               Index =&lt; 0; Index &gt; tuple_size(Tuple) -&gt;\n                   &lt;&lt;\"out of range\"&gt;&gt;;\n               true -&gt;\n                   []\n           end,\n    Arg2 = if\n               not is_tuple(Tuple) -&gt; &lt;&lt;\"not a tuple\"&gt;&gt;;\n               true -&gt; []\n           end,\n    PotentialErrors = [{1, Arg1}, {2, Arg2}],\n    maps:from_list([{ArgNum, Err} ||\n                       {ArgNum, Err} &lt;- PotentialErrors,\n                       Err =/= []]);\n\ndo_format_error(list_to_atom, _, _) -&gt;\n    #{1 =&gt; &lt;&lt;\"not a flat list of characters\"&gt;&gt;};\n\ndo_format_error(register, [Name,PidOrPort], Reason) -&gt;\n    [Arg1, Arg2] =\n    case Reason of\n        registered_name -&gt;\n            [[],&lt;&lt;\"this process or port already has a name\"&gt;&gt;];\n        notalive -&gt;\n            [[],&lt;&lt;\"the pid does not refer to an existing process\"&gt;&gt;];\n        _ -&gt;\n            Errors =\n                [if\n                     Name =:= undefined -&gt; &lt;&lt;\"'undefined' is not a valid name\"&gt;&gt;;\n                     is_atom(Name) -&gt; [];\n                     true -&gt; &lt;&lt;\"not an atom\"&gt;&gt;\n                 end,\n                 if\n                     is_pid(PidOrPort) -&gt; [];\n                     is_port(PidOrPort) -&gt; [];\n                     true -&gt; &lt;&lt;\"not a pid or a port\"&gt;&gt;\n                 end],\n            case Errors of\n                [[],[]] -&gt;\n                    [&lt;&lt;\"name is in use\"&gt;&gt;];\n                [_,_] -&gt;\n                    Errors\n            end,\n    PotentialErrors = [{1, Arg1}, {2, Arg2}],\n    maps:from_list([{ArgNum, Err} ||\n                       {ArgNum, Err} &lt;- PotentialErrors,\n                       Err =/= []]);\n      .\n      .\n      .\n\ndo_format_error(_, _, _) -&gt;\n    #{}.\n</code></pre>\n\n<p>The <code>register/2</code> BIF will provide specific error reasons for two of\nthe possible failure reasons.  If the reason is not one of the two,\n<code>format_error/4</code> will figure out the other reasons based on the\narguments.</p>\n\n<h3>Supplying extended error information using <code>erlang:error/3</code></h3>\n\n<p>A library or application can raise an error exception with extended error\ninformation by calling <code>erlang:error(Reason, Arguments, Options)</code>.\n<code>Reason</code> should be the error reason (for example <code>badarg</code>), <code>Arguments</code>\nshould be arguments for the calling function, and <code>Options</code> should\nbe <code>[{error_info,ErrorInfoMap}]</code>, where <code>ErrorInfoMap</code> with at\nleast the key <code>reason</code>.</p>\n\n<p>The module that raises the exception should export a <code>format_error/4</code>\nfunction that behaves as described in the previous section.</p>\n\n<h3>Formatting stacktraces</h3>\n\n<p>To make it possible for applications and libraries to format\nstacktraces in the same style as the shell, the functions\n<code>erl_error:format_exception/3</code> and <code>erl_error:format_exception/4</code> are\nprovided.  Here is an example how <code>erl_error:format_exception/3</code> can\nbe used:</p>\n\n<pre><code>try\n    .\n    .\n    .\ncatch\n    C:R:Stk -&gt;\n        Message = erl_error:format_exception(C, R, Stk),\n        io:format(LogFile, \"~ts\\n\", [Message])\nend.\n</code></pre>\n\n<p>The <code>erl_error:format_exception/4</code> function is similar but has a\nfourth option argument to support customizing the message.  See the\ndocumentation in the reference implementation for details.</p>\n\n<h3>Possible future extensions</h3>\n\n<p>Since the <code>error_info</code> tuple in the stacktrace contains a map, more\ndata could be added to the map.  For example, there could be <code>module</code>\nand <code>function</code> keys to allow pointing out a <code>format_error/4</code> function\nwith an arbitrary name.  That could be useful if the compiler were to\ngenerate extended error information for <code>badmatch</code> or\n<code>function_clause</code> errors.</p>\n\n<p>Since the return value of <code>format_error/4</code> is a map, additional keys\nin the map could be assigned a meaning in the future.</p>\n\n<p>For example, the value for the key <code>hint</code> could be a longer message\nthat gives more context or provides concrete advice on how to\ninvestigate or avoid the error.</p>\n\n<h3>Additional examples</h3>\n\n<p>Let's look at some examples using ETS:</p>\n\n<pre><code>1&gt; T = ets:new(table, []).\n#Ref&lt;0.2290824696.4161404930.5168&gt;\n2&gt; ets:update_counter(T, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5168&gt;,k,1)\n        *** argument 2: not a key that exists in the table\n</code></pre>\n\n<p>Note that when an error occurs while evaluating an expression entered in the\nshell, the evaluator process terminates and any ETS tables created by that\nprocess are deleted.  Thus, calling <code>update_counter</code> a second time with the\nsame arguments results in a different message:</p>\n\n<pre><code>3&gt; ets:update_counter(T, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5168&gt;,k,1)\n        *** argument 1: the table identifier does not refer to an existing ETS table\n</code></pre>\n\n<p>Starting over, creating a new ETS table:</p>\n\n<pre><code>4&gt; f(T), T = ets:new(table, []).\n#Ref&lt;0.2290824696.4161404930.5205&gt;\n5&gt; ets:insert(T, {k,a,0}).\ntrue\n6&gt; ets:update_counter(T, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5205&gt;,k,1)\n        *** argument 3: the value in the given position in the object is not an integer\n7&gt; ets:update_counter(T, k, bad).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5205&gt;,k,bad)\n        *** argument 1: the table identifier does not refer to an existing ETS table\n        *** argument 3: not a valid update operation\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>When a call to a BIF fails with the reason <code>badarg</code> it is not always\nobvious even to an experienced developer exactly which argument was\n\"bad\" and in which way.  For a newcomer, having to figure out what a\n<code>badarg</code> means is another stumbling block standing in the way of\nmastering a new language.</p>\n\n<p>Even for an experienced developer, figuring out the reason for a\n<code>badarg</code> exception for some BIFs is hard or impossible.  For example,\n<a href=\"http://erlang.org/doc/man/ets.html#update_counter-4\">the documentation for <code>ets:update_counter/4</code></a> at the\ntime of writing lists 8 situations in which <code>ets:update_counter/4</code>\nwill fail. That number is too low.  Missing from list are, for\nexample, reasons such as the ETS table having been deleted or having\ninsufficient access right.</p>\n\n<h1>Rationale</h1>\n\n<h3>Why not change <code>badarg</code> to something more informational?</h3>\n\n<p>An alternative way to provide more information about errors would be\nto introduce additional exception reasons.  For example, the call:</p>\n\n<pre><code>element(a, b)\n</code></pre>\n\n<p>could raise the exception:</p>\n\n<pre><code>{badarg,[{1,not_integer},{2,not_tuple}]}\n</code></pre>\n\n<p>That change could break code that expects that BIFs should raise a\n<code>badarg</code> exception.  It is less likely that existing code would match\nthe fourth entry in the stacktrace.</p>\n\n<p>A related reason is the amount of work needed to revise the error\nhandling code for all built-in functions.  Implementing building of\nErlang terms in C is tedious and error prone.  There would always be a\nrisk that bugs in that code would crash the runtime system when an\nerror occurred.  The test suite would have to be extremely thorough\nto ensure that all bugs were found, because error handling code is\ntypically infrequently executed.</p>\n\n<h3>Why can't the stacktrace contain the complete error reason?</h3>\n\n<p>We did consider modifying the implementation of all BIFs so that they\nwould produce complete error information in the stacktrace when they\nfailed.  However, as mentioned earlier, building Erlang terms in C is\ntedious and error prone.</p>\n\n<p>With the approach we have taken to let Erlang code do most of the\nanalysis of the error reason, there is a much lower risk that error\nhandling would crash the application or runtime system.</p>\n\n<h3>Why are the the reasons in the <code>ErrorInfoMap</code> undocumented?</h3>\n\n<p>The reason in the <code>ErrorInfoMap</code> is not meant to be used for\nprogrammatically figure out why an error occurred, but only to be used\nby <code>Module:format_error/4</code> to produce a human-readable message.</p>\n\n<p>Also, for many BIFs the reason will not have a meaningful\nvalue, as the <code>Module:format/4</code> function will produce the messages\nbased solely on the name of the BIF and its arguments.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All exceptions from BIFs will now have a <code>ExtraInfo</code> element (called\n<code>Location</code> in the documentation for OTP 23) in the call-stack back\ntrace (stacktrace) that includes an <code>error_info</code> tuple.  In previous\nreleases the <code>ExtraInfo</code> element would be an empty list for a failed\nBIF call.</p>\n\n<p>Applications that explicitly do matching on the stacktrace and do\nassumptions of the layout of the <code>ExtraInfo</code> element (for example,\nassuming that <code>Location</code> is either an empty list or a list of <code>file</code>\nand <code>line</code> tuples in a specific order) may need modifications.  Note\nthat such assumptions have never been safe and that the <a href=\"http://erlang.org/doc/reference_manual/errors.html#exceptions\">documentation\nfor error handling</a> strongly discourages developers to rely on\nstacktrace entries for purposes other than debugging.</p>\n\n<h1>Implementation</h1>\n\n<p>The reference implementation includes extended error information for\nmost BIFs implemented in C in the <code>erlang</code> and <code>ets</code> modules.\nIt can be found in <a href=\"https://github.com/erlang/otp/pull/2849\">PR #2849</a>.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}