{"pageProps":{"index":{"id":"0014","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 10-Jul-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 14: <a href=\"eep-0014.md\" title=\"EEP Source\"> Guard clarification and extension</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Allow Pattern = Guard_Expression as a simple guard test.\nMake obviously silly guards syntax errors.</p>\n\n<h1>Specification</h1>\n\n<p>Replace the opening text of section 6.24 \"Guard Sequences\"\nas follows.</p>\n\n<pre><code>&lt;guard&gt; ::= &lt;OR guard&gt;\n&lt;OR guard&gt; ::= &lt;AND guard&gt; {';' &lt;AND guard&gt;}*\n</code></pre>\n\n<p>An <code>&lt;OR guard&gt;</code> is a sequence of <code>&lt;AND guards&gt;</code> separated by\nsemicolons.  Here, as elsewhere in Erlang, semicolon means\nsequential OR:  an <code>&lt;OR guard&gt;</code> evaluates its <code>&lt;AND guards&gt;</code>\none at a time from left to right, until one succeeds or\nuntil all have failed.</p>\n\n<pre><code>&lt;AND guard&gt; ::= &lt;guard test&gt; {',' &lt;guard test&gt;}*\n</code></pre>\n\n<p>An <code>&lt;AND guard&gt;</code> is a sequence of <code>&lt;guard tests&gt;</code> separated by\nsemicolons.  Here, as is often the case in Erlang, comma\nmeans sequential AND:  an <code>&lt;AND guard&gt;</code> evaluates its\n<code>&lt;guard tests&gt;</code> one at a time from left to right, until all\nhave succeeded or one has failed.</p>\n\n<pre><code>&lt;guard test&gt; ::= &lt;guard match&gt;\n              | &lt;Boolean expression&gt;\n\n&lt;guard match&gt; ::= &lt;pattern&gt; '=' &lt;guard expr&gt;\n               |  &lt;pattern&gt; '=' &lt;guard match&gt;\n</code></pre>\n\n<p>A <code>&lt;guard test&gt;</code> is either a match or a Boolean expression.\nIn a guard, a match suceeds if and only if the <code>&lt;guard expr&gt;</code>\ncan be evaluated without exception, and the result can be\nmatched with the <code>&lt;pattern&gt;</code>, possibly binding some variables.</p>\n\n<p>If a variable is bound in one <code>&lt;guard test&gt;</code>, it may be used in\nlater <code>&lt;guard test&gt;</code>s of the same <code>&lt;AND guard&gt;</code>.  If a variable\nis bound in all of the <code>&lt;AND guard&gt;</code>s of an <code>&lt;OR guard&gt;</code> it may\nbe used in the guarded code, so</p>\n\n<pre><code>if  X = 1, is_atom(element(X, Tup))\n ;  X = 2, is_atom(element(X, Tup))\n -&gt; ... uses X ...\n</code></pre>\n\n<p>is OK.  If a variable is bound in one of the <code>&lt;AND guard&gt;</code>s of\nan <code>&lt;OR guard&gt;</code> but not all of them it may not be used in the\nguarded code, so</p>\n\n<pre><code>if  X = a\n ;  Y = b\n -&gt; ... uses X ...\n</code></pre>\n\n<p>is not allowed.</p>\n\n<p>A <code>&lt;Boolean expression&gt;</code> in a guard consists of a number\nof subexpressions\n    constant 'false'\n    constant 'true'\n    variable (must be bound to 'false' or 'true')\n    term comparison with <code>&lt;guard expr&gt;</code> operands\n    calls to type test BIFs with <code>&lt;guard expr&gt;</code> operands\n    <code>&lt;Boolean expression&gt;</code>s in parentheses\ncombined using the operators 'not', 'and', 'or',\n'andalso', and 'orelse'.  Thus</p>\n\n<pre><code>X+1 == Y\n</code></pre>\n\n<p>is a <code>&lt;Boolean expression&gt;</code> that can be used as a <code>&lt;guard test&gt;</code>\nbut</p>\n\n<pre><code>X+1\n</code></pre>\n\n<p>is not.  You are advised never to use the 'and' and 'or' operators\nand to avoid 'andalso' and 'orelse' whenever ',' and ';' will do\nwhat you need.</p>\n\n<p>The set of <code>&lt;guard expr&gt;</code>s is a subset of the set of valid Erlang\nexpressions.  The reason for restricting the set of valid\nexpressions is that evaluation of a guard expression must be\nguaranteed to be free of side effects and to terminate.</p>\n\n<p>A <code>&lt;guard expr&gt;</code> consists of a number of subexpressions</p>\n\n<ul>\n<li>constants</li>\n<li>variables</li>\n<li>calls to \"other BIFs Allowed in Guard Expressions\"\n(see table) with <code>&lt;guard expr&gt;</code> arguments</li>\n<li>record field selections</li>\n<li><code>&lt;guard expr&gt;</code>s in parentheses</li>\n</ul>\n\n<p>combined using the built in arithmetic and bitwise operators.</p>\n\n<h1>Motivation</h1>\n\n<p>There are two parts to this EEP.  It was originally going to\nbe just about allowing matches in guards.  Then it was going\nto be two, because the current situation is just too messy,\nbut then it became one again for brevity.</p>\n\n<p>Consider this case.  A function is given a tuple and an index.\nIf the element at that index is in the range 0..127, it\nshould be returned.  Otherwise some other clause should apply.\nCurrently, we have to write</p>\n\n<pre><code>f(Tuple, Index)\n    when is_integer(element(Tuple, Index)),\n     0 =&lt; element(Tuple, Index),\n     element(Tuple, Index) =&lt; 127\n      -&gt; element(Tuple, Index);\n...\n</code></pre>\n\n<p>or something else which is even clumsier.  Why can't we write</p>\n\n<pre><code>f(Tuple, Index)\n    when X = element(Tuple, Index),\n         is_integer(X), 0 =&lt; X, X =&lt; 127\n      -&gt; X;\n...\n</code></pre>\n\n<p>In trying to explain how to add this to the language, I found\nthat the current description of guards in the Erlang reference\nmanual is remarkably fuzzy.  Dismayingly, this is matched\nby an equally fuzzy implementation.  The description mixes\nup things that can be used as arguments of guard BIFs\n(guard expressions) with simple guards.</p>\n\n<p>Consider the example</p>\n\n<pre><code>X = 1,\nif X+1 -&gt; true\n ; X-1 -&gt; false\nend.\n</code></pre>\n\n<p>This clearly makes no sense at all, and should be rejected\nas bad syntax.  According to the current reference manual,\nit is legal; X+1 and X-1 are legal \"guard expressions\".</p>\n\n<p>In the shell, this exampel crashes, which indeed makes\na lot of sense.  But 'erlc' says:</p>\n\n<pre><code>{X+1} Warning: the guard for this clause evaluates to 'false'\n{X-1} Warning: the guard for this clause evaluates to 'false'\n</code></pre>\n\n<p>It is good that there is a warning, but bad that the text of\nthe warning is wrong.  These things DON'T evaluate to 'false',\nthey evaluate to numbers.  Then, despite having given a warning,\nyou get a run-time error.</p>\n\n<pre><code>exited: {if_clause,[{a,f,0},{shell,exprs,6},{shell,eval_loop,3}]}\n</code></pre>\n\n<p>What happened in this example, of course, was that all of the\nclauses of the 'if' were eliminated because all of them were\nmalformed.  More realistic examples would simply quietly do the\nwrong thing at run time.</p>\n\n<h1>Rationale</h1>\n\n<p>The syntax for allowing matches in guards is obvious;\nno other syntax would be tolerable.  The only real question\nis whether they can be embedded inside 'andalso' and 'orelse'\nor not, and in order to avoid questions of backtracking, I\nhave said \"no\".  This is really the simplest extension of\nguards to allow matches that I can think of.</p>\n\n<p>The rest of the EEP is concerned with trying to rule out\nobviously silly guard tests at compile time.  Precisely how\nthis is done is debateable.  That it should be done surely\nisn't.  What benefit do we currently obtain (other than\nunwarranted simplicity in the compiler) from allowing \"27\"\nand \"X+5\" as guards?</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Matches are currently not allowed in guards, so no existing\napplication code can be broken by adding them.  Obviously,\nanything that works with Erlang parse trees will need to be\nextended.</p>\n\n<p>Cleaning up what's allowed in guards may affect existing code.\nHowever, in most cases the compiler would already have warned\nabout this, and the compatibility issue amounts to turning a\nwarning message into an error message.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}