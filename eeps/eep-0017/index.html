<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 23-Jul-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 17: <a href="eep-0017.md" title="EEP Source"> Fix andalso and orelse</a></h2>

<h1>Abstract</h1>

<p>Erlang 5.1 added the ability to use 'andalso', 'orelse',
'and', and 'or' in guards.  However, the semantics for
'andalso' and 'orelse' differs from that in other related
languages, causing confusion and inefficiency.</p>

<p>I propose making 'andalso' and 'orelse' work like Lisp
AND and OR respectively.</p>

<h1>Specification</h1>

<p>Currently, (E1 andalso E2) as an expression acts like</p>

<pre><code>case E1
 of false -&gt; false
  ; true  -&gt; case E2 
               of false -&gt; false
                ; true  -&gt; true
             end
end
</code></pre>

<p>except that in my tests the former raises <code>{badarg,NonBool}</code>
exceptions and the latter raises <code>{case_clause,NonBool}</code> ones.</p>

<p>This should be changed to</p>

<pre><code>case E1
  of false -&gt; false
   ; true   -&gt; E2
end.
</code></pre>

<p>Currently, (E1 orelse E2) as an expression acts like</p>

<pre><code>case E1
  of true  -&gt; true
   ; false -&gt; case E2
                of true  -&gt; true
                 ; false -&gt; false
              end
end
</code></pre>

<p>except that in my tests the former raises <code>{badarg,NonBool}</code>
exceptions and the latter raises <code>{case_clause,NonBool}</code> ones.</p>

<p>This should be changed to</p>

<pre><code>case E1
  of true  -&gt; true
   ; false -&gt; E2
end
</code></pre>

<p>There is apparently a folklore belief that using 'andalso' (or
'orelse') in a guard will somehow give you better code than using
',' (or ';').  On the contrary, you will get rather worse code.
See "Motivation" for an example.  This should change.</p>

<pre><code>guard ::= gconj {';' gconj}*
gconj ::= gtest {',' gtest}*
gtest ::= '(' guard ')' | ...
</code></pre>

<p>First, we allow ',' and ';' to nest, using parentheses.
Second, we rule that as outer operators in a guard, the
only difference between ',' and 'andalso' is precedence,
and the only difference between ';' and 'orelse' is also
precedence.  In a guard test like</p>

<pre><code>is_atom(X andalso Y)
</code></pre>

<p>the 'andalso' cannot be replaced by ',', but whenever one
COULD be replaced by the other, they should have the same effect.</p>

<h1>Motivation</h1>

<h3>Cultural consistency</h3>

<ul>
<li><p>Common Lisp</p>

<pre><code>(defun member-p (X Xs)
  (and (consp Xs)
       (or (equal X (first Xs))
           (member-p X (rest Xs)))))
</code></pre></li>
<li><p>Scheme</p>

<pre><code>(define (member? X Xs)
  (and (pair? Xs)
       (or (equal? X (car Xs))
           (member? X (cdr Xs)))))
</code></pre></li>
<li><p>Standard ML</p>

<pre><code>fun is_member(x, xs) =
    not (null xs) andalso (
    x = hd xs orelse is_member(x, tl xs))
</code></pre></li>
<li><p>Haskell</p>

<pre><code>x `is_member_of` xs =
   not (null xs) &amp;&amp; (x == head xs || x `is_member_of` tail xs)
</code></pre></li>
<li><p>Dylan</p>

<p>I don't know Dylan syntax well enough to finish this
example, but I do know that '&amp;' and '|' in Dylan are exactly
like AND and OR in Common Lisp except for syntax.  (They are
documented as allowing the right operand to return anything,
including multiple values.)</p></li>
<li><p>Python</p>

<pre><code>def is_member(x, xs):
    n = len(xs)
    return n &gt; 0 and (x == xs[0] or is_member(x, xs[1:n]))
</code></pre>

<p>I'm not perfectly sure about this, but the reference manual
is very explicit that the second operand of 'and' or 'or' can
be anything.</p></li>
<li><p>Smalltalk</p>

<p>Doing this example this way in Smalltalk requires considerable
pain in going against the grain of Smalltalk, however the
'and:' and 'or:' selectors in Smalltalk DO check that their
first argument is Boolean and DON'T check anything about (the
result of) their second argument.</p></li>
</ul>

<p>In all of these, the "and" and "or" operations work exactly the
same way, and in the languages whose implementations support tail
recursion (Common Lisp, Scheme, Standard ML, Haskell), the
function shown above is tail recursive.  (I could have added more
languages to the list.)</p>

<p>Erlang stands out.  The behaviour of 'andalso' is surprising, and
the fact that 'andalso' and 'orelse' block tail recursion is quite
astonishing.  I am all in favour of giving programmers shocks that
teach them something useful about programming, but this one is not
a useful lesson.  Testing both arguments of 'and' and 'or' makes
sense, because the code executed for those operators always GETS
the values of both operands.  But 'andalso' and 'orelse' only test
their second operand SOME of the time.</p>

<pre><code>X = 1, X &gt;= 0 andalso X    % checked error
X = 1, X &lt; 0 andalso X     % unchecked error
</code></pre>

<p>There doesn't seem to be much point in checking SOME of the time,
especially when it does something as dramatic as blocking tail
recursion.</p>

<h3>Guards code</h3>

<p>As for guards, here is a small example</p>

<pre><code>f(X) when X &gt;= 0, X &lt; 1 -&gt; math:sqrt(X).
</code></pre>

<p>This compiles to the following rather obvious code:</p>

<pre><code>function, f, 1, 2}.
  {label,1}.
    {func_info,{atom,bar},{atom,f},1}.
  {label,2}.
    {test,is_ge,{f,1},[{x,0},{integer,0}]}.
    {test,is_lt,{f,1},[{x,0},{integer,1}]}.
    {call_ext_only,1,{extfunc,math,sqrt,1}}.
</code></pre>

<p>Some people expect 'andalso' to do as well or better.
I expected it to do the same, and this EEP requires it to.
Here's the source code:</p>

<pre><code>g(X) when X &gt;= 0 andalso X &lt; 1 -&gt; math:sqrt(X).
</code></pre>

<p>and here are the BEAM instructions:</p>

<pre><code>{function, g, 1, 4}.
  {label,3}.
    {func_info,{atom,bar},{atom,g},1}.
  {label,4}.
    {allocate,1,1}.
    {move,{x,0},{y,0}}.
    {test,is_ge,{f,5},[{x,0},{integer,0}]}.
    {bif,'&lt;',{f,7},[{x,0},{integer,1}],{x,0}}.
    {jump,{f,6}}.
  {label,5}.
    {move,{atom,false},{x,0}}.
  {label,6}.
    {test,is_eq_exact,{f,7},[{x,0},{atom,true}]}.
    {move,{y,0},{x,0}}.
    {call_ext_last,1,{extfunc,math,sqrt,1},1}.
  {label,7}.
    {move,{y,0},{x,0}}.
    {deallocate,1}.
    {jump,{f,3}}.
</code></pre>

<p>It not only does a lot more work, it even allocates a stack
frame that the traditional code does not.</p>

<h1>Rationale</h1>

<p>There are several ways to deal with the surprising behaviour
of 'andalso' and 'orelse'.</p>

<ol>
<li><p>Leave things the way they are.</p>

<p>The manual should have lots of warnings added,
saying not to use these operators, because they block
tail recursion and are inefficient in guards.</p>

<p>It is reasonable to address other issues first, but it just
will not do long term.  You don't have to rush around
bandaging everyone you meet, but you shouldn't build pit
traps in front of them either.</p></li>
<li><p>Remove them from the language.</p>

<p>I would prefer this.  And that goes double for 'and' and 'or',
which seem to be completely pointless, as well as confusing.
I do not think this would be practical politics.</p></li>
<li><p>Add new operators with sensible semantics.</p>

<p>But what would we call them?  'and' and 'or' are taken,
and both '|' and '||' are used for something else.  Above
all, 'andalso' and 'orelse' would still be there, and still
be surprising (in a bad way).  We have too many ways to
spell "or" as it is.</p></li>
<li><p>Fix them.</p></li>
</ol>

<p>As for the recommendation that ',' and ';' should nest,
I want Erlang to be simple to think.  If 'andalso' and 'orelse'
are to act like ',' and ';' in guards -- which I've argued
above -- then clearly ',' and ';' should act like 'andalso'
and 'orelse' in guards.</p>

<h1>Backwards Compatibility</h1>

<p>Any code that ran without raising exceptions will continue
to produce the same results, except for running faster.</p>

<p>Code that did raise exceptions may raise different exceptions
elsewhere later, or may quietly complete in unexpected ways.
I believe it to be unlikely that anyone deliberately relied
on (E1 andelse 0) raising an exception.</p>

<p>Code that was previously broken because these operators have
such surprising behaviour will now work in more cases.</p>

<h1>Reference Implementation</h1>

<p>None.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0017","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 23-Jul-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 17: \u003ca href=\"eep-0017.md\" title=\"EEP Source\"\u003e Fix andalso and orelse\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eErlang 5.1 added the ability to use 'andalso', 'orelse',\n'and', and 'or' in guards.  However, the semantics for\n'andalso' and 'orelse' differs from that in other related\nlanguages, causing confusion and inefficiency.\u003c/p\u003e\n\n\u003cp\u003eI propose making 'andalso' and 'orelse' work like Lisp\nAND and OR respectively.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eCurrently, (E1 andalso E2) as an expression acts like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1\n of false -\u0026gt; false\n  ; true  -\u0026gt; case E2 \n               of false -\u0026gt; false\n                ; true  -\u0026gt; true\n             end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eexcept that in my tests the former raises \u003ccode\u003e{badarg,NonBool}\u003c/code\u003e\nexceptions and the latter raises \u003ccode\u003e{case_clause,NonBool}\u003c/code\u003e ones.\u003c/p\u003e\n\n\u003cp\u003eThis should be changed to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1\n  of false -\u0026gt; false\n   ; true   -\u0026gt; E2\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCurrently, (E1 orelse E2) as an expression acts like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1\n  of true  -\u0026gt; true\n   ; false -\u0026gt; case E2\n                of true  -\u0026gt; true\n                 ; false -\u0026gt; false\n              end\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eexcept that in my tests the former raises \u003ccode\u003e{badarg,NonBool}\u003c/code\u003e\nexceptions and the latter raises \u003ccode\u003e{case_clause,NonBool}\u003c/code\u003e ones.\u003c/p\u003e\n\n\u003cp\u003eThis should be changed to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E1\n  of true  -\u0026gt; true\n   ; false -\u0026gt; E2\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere is apparently a folklore belief that using 'andalso' (or\n'orelse') in a guard will somehow give you better code than using\n',' (or ';').  On the contrary, you will get rather worse code.\nSee \"Motivation\" for an example.  This should change.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eguard ::= gconj {';' gconj}*\ngconj ::= gtest {',' gtest}*\ngtest ::= '(' guard ')' | ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFirst, we allow ',' and ';' to nest, using parentheses.\nSecond, we rule that as outer operators in a guard, the\nonly difference between ',' and 'andalso' is precedence,\nand the only difference between ';' and 'orelse' is also\nprecedence.  In a guard test like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eis_atom(X andalso Y)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ethe 'andalso' cannot be replaced by ',', but whenever one\nCOULD be replaced by the other, they should have the same effect.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003ch3\u003eCultural consistency\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eCommon Lisp\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(defun member-p (X Xs)\n  (and (consp Xs)\n       (or (equal X (first Xs))\n           (member-p X (rest Xs)))))\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eScheme\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(define (member? X Xs)\n  (and (pair? Xs)\n       (or (equal? X (car Xs))\n           (member? X (cdr Xs)))))\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStandard ML\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun is_member(x, xs) =\n    not (null xs) andalso (\n    x = hd xs orelse is_member(x, tl xs))\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eHaskell\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ex `is_member_of` xs =\n   not (null xs) \u0026amp;\u0026amp; (x == head xs || x `is_member_of` tail xs)\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eDylan\u003c/p\u003e\n\n\u003cp\u003eI don't know Dylan syntax well enough to finish this\nexample, but I do know that '\u0026amp;' and '|' in Dylan are exactly\nlike AND and OR in Common Lisp except for syntax.  (They are\ndocumented as allowing the right operand to return anything,\nincluding multiple values.)\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ePython\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003edef is_member(x, xs):\n    n = len(xs)\n    return n \u0026gt; 0 and (x == xs[0] or is_member(x, xs[1:n]))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eI'm not perfectly sure about this, but the reference manual\nis very explicit that the second operand of 'and' or 'or' can\nbe anything.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eSmalltalk\u003c/p\u003e\n\n\u003cp\u003eDoing this example this way in Smalltalk requires considerable\npain in going against the grain of Smalltalk, however the\n'and:' and 'or:' selectors in Smalltalk DO check that their\nfirst argument is Boolean and DON'T check anything about (the\nresult of) their second argument.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIn all of these, the \"and\" and \"or\" operations work exactly the\nsame way, and in the languages whose implementations support tail\nrecursion (Common Lisp, Scheme, Standard ML, Haskell), the\nfunction shown above is tail recursive.  (I could have added more\nlanguages to the list.)\u003c/p\u003e\n\n\u003cp\u003eErlang stands out.  The behaviour of 'andalso' is surprising, and\nthe fact that 'andalso' and 'orelse' block tail recursion is quite\nastonishing.  I am all in favour of giving programmers shocks that\nteach them something useful about programming, but this one is not\na useful lesson.  Testing both arguments of 'and' and 'or' makes\nsense, because the code executed for those operators always GETS\nthe values of both operands.  But 'andalso' and 'orelse' only test\ntheir second operand SOME of the time.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eX = 1, X \u0026gt;= 0 andalso X    % checked error\nX = 1, X \u0026lt; 0 andalso X     % unchecked error\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere doesn't seem to be much point in checking SOME of the time,\nespecially when it does something as dramatic as blocking tail\nrecursion.\u003c/p\u003e\n\n\u003ch3\u003eGuards code\u003c/h3\u003e\n\n\u003cp\u003eAs for guards, here is a small example\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(X) when X \u0026gt;= 0, X \u0026lt; 1 -\u0026gt; math:sqrt(X).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis compiles to the following rather obvious code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efunction, f, 1, 2}.\n  {label,1}.\n    {func_info,{atom,bar},{atom,f},1}.\n  {label,2}.\n    {test,is_ge,{f,1},[{x,0},{integer,0}]}.\n    {test,is_lt,{f,1},[{x,0},{integer,1}]}.\n    {call_ext_only,1,{extfunc,math,sqrt,1}}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSome people expect 'andalso' to do as well or better.\nI expected it to do the same, and this EEP requires it to.\nHere's the source code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eg(X) when X \u0026gt;= 0 andalso X \u0026lt; 1 -\u0026gt; math:sqrt(X).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand here are the BEAM instructions:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{function, g, 1, 4}.\n  {label,3}.\n    {func_info,{atom,bar},{atom,g},1}.\n  {label,4}.\n    {allocate,1,1}.\n    {move,{x,0},{y,0}}.\n    {test,is_ge,{f,5},[{x,0},{integer,0}]}.\n    {bif,'\u0026lt;',{f,7},[{x,0},{integer,1}],{x,0}}.\n    {jump,{f,6}}.\n  {label,5}.\n    {move,{atom,false},{x,0}}.\n  {label,6}.\n    {test,is_eq_exact,{f,7},[{x,0},{atom,true}]}.\n    {move,{y,0},{x,0}}.\n    {call_ext_last,1,{extfunc,math,sqrt,1},1}.\n  {label,7}.\n    {move,{y,0},{x,0}}.\n    {deallocate,1}.\n    {jump,{f,3}}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt not only does a lot more work, it even allocates a stack\nframe that the traditional code does not.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThere are several ways to deal with the surprising behaviour\nof 'andalso' and 'orelse'.\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eLeave things the way they are.\u003c/p\u003e\n\n\u003cp\u003eThe manual should have lots of warnings added,\nsaying not to use these operators, because they block\ntail recursion and are inefficient in guards.\u003c/p\u003e\n\n\u003cp\u003eIt is reasonable to address other issues first, but it just\nwill not do long term.  You don't have to rush around\nbandaging everyone you meet, but you shouldn't build pit\ntraps in front of them either.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eRemove them from the language.\u003c/p\u003e\n\n\u003cp\u003eI would prefer this.  And that goes double for 'and' and 'or',\nwhich seem to be completely pointless, as well as confusing.\nI do not think this would be practical politics.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAdd new operators with sensible semantics.\u003c/p\u003e\n\n\u003cp\u003eBut what would we call them?  'and' and 'or' are taken,\nand both '|' and '||' are used for something else.  Above\nall, 'andalso' and 'orelse' would still be there, and still\nbe surprising (in a bad way).  We have too many ways to\nspell \"or\" as it is.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFix them.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eAs for the recommendation that ',' and ';' should nest,\nI want Erlang to be simple to think.  If 'andalso' and 'orelse'\nare to act like ',' and ';' in guards -- which I've argued\nabove -- then clearly ',' and ';' should act like 'andalso'\nand 'orelse' in guards.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eAny code that ran without raising exceptions will continue\nto produce the same results, except for running faster.\u003c/p\u003e\n\n\u003cp\u003eCode that did raise exceptions may raise different exceptions\nelsewhere later, or may quietly complete in unexpected ways.\nI believe it to be unlikely that anyone deliberately relied\non (E1 andelse 0) raising an exception.\u003c/p\u003e\n\n\u003cp\u003eCode that was previously broken because these operators have\nsuch surprising behaviour will now work in more cases.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0017"},"buildId":"L68tPJnB-kPxrFxsY9AoN","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_buildManifest.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_ssgManifest.js" async=""></script></body></html>