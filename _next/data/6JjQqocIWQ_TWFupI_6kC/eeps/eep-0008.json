{"pageProps":{"index":{"id":"0008","content":"<pre><code>Author: Tobias Lindahl &lt;tobias(dot)lindahl(at)it(dot)uu(dot)se&gt;,\n        Kostis Sagonas &lt;kostis(at)it(dot)uu(dot)se&gt;\nStatus: Draft\nType: Standards Track\nCreated: 2-Dec-2007\nErlang-Version: R12B\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 8: <a href=\"eep-0008.md\" title=\"EEP Source\"> Types and function specifications</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP describes an extension to the Erlang language for\ndeclaring sets of Erlang terms to form a particular type, effectively\nforming a specific subtype of the set of all Erlang terms.\nSubsequently, these types can be used to specify types of record\nfields and argument and return values of functions.</p>\n\n<h1>Rationale</h1>\n\n<p>Type information can be used to document function interfaces, provide\nmore information for bug detection tools such as Dialyzer, and can be\nexploited by documentation tools such as Edoc for generating program\ndocumentation of various forms. It is expected that the type language\ndescribed in this document will supersede and eventually replace the\npurely comment-based @type and @spec declarations used by Edoc.</p>\n\n<h1>Specification</h1>\n\n<h2>Types and their syntax</h2>\n\n<p>Types describe sets of Erlang terms. Types consist and are built from\na set of predefined types (e.g. <code>integer()</code>, <code>atom()</code>, <code>pid()</code>, ...)\ndescribed below. Predefined types represent a typically infinite set\nof Erlang terms which belong to this type. For example, the type\n<code>atom()</code> stands for the set of all Erlang atoms.</p>\n\n<p>For integers and atoms, we allow for singleton types (e.g. the\nintegers <code>-1</code> and <code>42</code> or the atoms <code>'foo'</code> and <code>'bar'</code>).</p>\n\n<p>All other types are built using unions of either predefined types or\nsingleton types. In a type union between a type and one of its\nsubtypes the subtype is absorbed by the supertype and the union is\nsubsequently treated as if the subtype was not a constituent of the\nunion. For example, the type union::</p>\n\n<pre><code>atom() | 'bar' | integer() | 42\n</code></pre>\n\n<p>describes the same set of terms as the type union::</p>\n\n<p>atom() | integer()</p>\n\n<p>Because of subtype relations that exist between types, types form a\nlattice where the topmost element, <code>any()</code>, denotes the set of all Erlang\nterms and the bottommost element, <code>none()</code>, denotes the empty set of terms.</p>\n\n<p>The set of predefined types and the syntax for types is given below::</p>\n\n<pre><code>Type :: any()            %% The top type, the set of all Erlang terms.\n      | none()           %% The bottom type, contains no terms.\n      | pid()\n      | port()\n      | ref()\n      | []               %% nil\n      | Atom\n      | Binary\n      | float()\n      | Fun\n      | Integer\n      | List\n      | Tuple\n      | Union\n      | UserDefined      %% described in Section 2\n\nUnion :: Type1 | Type2\n\nAtom :: atom()\n      | Erlang_Atom      %% 'foo', 'bar', ...\n\nBinary :: binary()                        %% &lt;&lt;_:_ * 8&gt;&gt;\n        | &lt;&lt;&gt;&gt;\n        | &lt;&lt;_:Erlang_Integer&gt;&gt;            %% Base size\n        | &lt;&lt;_:_*Erlang_Integer&gt;&gt;          %% Unit size\n        | &lt;&lt;_:Erlang_Integer, _:_*Erlang_Integer&gt;&gt;\n\nFun :: fun()                              %% any function\n     | fun((...) -&gt; Type)                 %% any arity, returning Type\n     | fun(() -&gt; Type)\n     | fun((TList) -&gt; Type)\n\nInteger :: integer()\n         | Erlang_Integer                 %% ..., -1, 0, 1, ... 42 ...\n         | Erlang_Integer..Erlang_Integer %% specifies an integer range\n\nList :: list(Type)                        %% Proper list ([]-terminated)\n      | improper_list(Type1, Type2)       %% Type1=contents, Type2=termination\n      | maybe_improper_list(Type1, Type2) %% Type1 and Type2 as above\n\nTuple :: tuple()                          %% stands for a tuple of any size\n       | {}\n       | {TList}\n\nTList :: Type\n       | Type, TList\n</code></pre>\n\n<p>Because lists are commonly used, they have shorthand type notations.\nThe type <code>list(T)</code> has the shorthand <code>[T]</code>. The shorthand <code>[T,...]</code>\nstands for the set of non-empty proper lists whose elements are of type <code>T</code>.\nThe only difference between the two shorthands is that <code>[T]</code> may be an\nempty list but <code>[T,...]</code> may not.</p>\n\n<p>Notice that the shorthand for <code>list()</code>, i.e. the list of elements of\nunknown type, is <code>[_]</code> (or <code>[any()]</code>), not <code>[]</code>. The notation <code>[]</code>\nspecifies the singleton type for the empty list.</p>\n\n<p>For convenience, the following types are also built-in. They can be\nthought as predefined aliases for the type unions also shown in the\ntable. (Some type unions below slightly abuse the syntax of types.)</p>\n\n<pre><code>==========================  =====================================\n      Built-in type                   Stands for\n==========================  =====================================\n``term()``                  ``any()``\n``bool()``                  ``'false' | 'true'``\n``byte()``                  ``0..255``\n``char()``                  ``0..16#10ffff``\n``non_neg_integer()``       ``0..``\n``pos_integer()``           ``1..``\n``neg_integer()``           ``..-1``\n``number()``                ``integer() | float()``\n``list()``                  ``[any()]``\n``maybe_improper_list()``   ``maybe_improper_list(any(), any())``\n``maybe_improper_list(T)``  ``maybe_improper_list(T, any())``\n``string()``                ``[char()]``\n``nonempty_string()``       ``[char(),...]``\n``iolist()``                ``maybe_improper_list(``\n                                ``char() | binary() |``\n                                ``iolist(), binary() | [])``\n``module()``                ``atom()``\n``mfa()``                   ``{atom(),atom(),byte()}``\n``node()``                  ``atom()``\n``timeout()``               ``'infinity' | non_neg_integer()``\n``no_return()``             ``none()``\n==========================  =====================================\n</code></pre>\n\n<p>Users are not allowed to define types with the same names as the\npredefined or built-in ones. This is checked by the compiler and its\nviolation results in a compilation error. (For bootstrapping purposes,\nit can also result to just a warning if this involves a built-in type\nwhich has just been introduced.)</p>\n\n<p><strong>NOTE</strong>: The following built-in list types also exist, but they are\nexpected to be rarely used. Hence, they have long names:</p>\n\n<pre><code>nonempty_maybe_improper_list(Type) :: nonempty_maybe_improper_list(Type, any())\nnonempty_maybe_improper_list() :: nonempty_maybe_improper_list(any())\n</code></pre>\n\n<p>where the following two types</p>\n\n<pre><code>nonempty_improper_list(Type1, Type2)\nnonempty_maybe_improper_list(Type1, Type2)\n</code></pre>\n\n<p>define the set of Erlang terms one would expect.</p>\n\n<p>Also for convenience, we allow for record notation to be used. Records\nare just shorthands for the corresponding tuples:</p>\n\n<pre><code>Record :: #Erlang_Atom{}\n        | #Erlang_Atom{Fields}\n</code></pre>\n\n<p>Records have been extended to possibly contain type information. This\nis described in Section 3 below.</p>\n\n<h2>Type declarations of user-defined types</h2>\n\n<p>As seen, the basic syntax of a type is an atom followed by closed\nparentheses. New types are declared using <code>'type'</code> compiler attributes\nas in the following:</p>\n\n<pre><code>-type my_type() :: Type.\n</code></pre>\n\n<p>where the type name is an atom (<code>'my_type'</code> in the above) followed by\nparenthesis. Type is a type as defined in the previous section. A\ncurrent restriction is that Type can contain only predefined types or\nuser-defined types which have been previously defined. This\nrestriction is enforced by the compiler and results in a compilation\nerror. (A similar restriction currently exists for records).</p>\n\n<p>This means that general recursive types cannot be defined. Lifting\nthis restriction is future work.</p>\n\n<p>Type declarations can also be parametrized by including type variables\nbetween the parentheses. The syntax of type variables is the same as\nErlang variables (starts with an upper case letter). Naturally, these\nvariables can - and should - appear on the RHS of the definition.\nA concrete example appears below:</p>\n\n<pre><code>-type orddict(Key, Val) :: [{Key, Val}].\n</code></pre>\n\n<h2>Type information in record declarations</h2>\n\n<p>The types of record fields can be specified in the declaration of the\nrecord. The syntax for this is:</p>\n\n<pre><code>-record(rec, {field1 :: Type1, field2, field3 :: Type3}).\n</code></pre>\n\n<p>For fields without type annotations, their type defaults to <code>any()</code>.\nI.e., the above is a shorthand for:</p>\n\n<pre><code>-record(rec, {field1 :: Type1, field2 :: any(), field3 :: Type3}).\n</code></pre>\n\n<p>In the presence of initial values for fields, the type must be\ndeclared after the initialisation as in the following:</p>\n\n<pre><code>-record(rec, {field1 = [] :: Type1, field2, field3 = 42 :: Type3}).\n</code></pre>\n\n<p>Naturally, the initial values for fields should be compatible with\n(i.e. a member of) the corresponding types. This is checked by the\ncompiler and results in a compilation error if a violation is\ndetected. For fields without initial values, the singleton type\n<code>'undefined'</code> is added to all declared types. In other words, the\nfollowing two record declarations have identical effects:</p>\n\n<pre><code>-record(rec, {f1 = 42 :: integer(),\n              f2      :: float(),\n              f3      :: 'a' | 'b').\n\n-record(rec, {f1 = 42 :: integer(),\n              f2      :: 'undefined' | float(),\n              f3      :: 'undefined' | 'a' | 'b').\n</code></pre>\n\n<p>For this reason, it is recommended that records contain initializers,\nwhenever possible.</p>\n\n<p>Any record, containing type information or not, once defined, can be\nused as a type using the syntax:</p>\n\n<pre><code>#rec{}\n</code></pre>\n\n<p>In addition, the record fields can be further specified when using a\nrecord type by adding type information about the field in the\nfollowing manner:</p>\n\n<pre><code>#rec{some_field :: Type}\n</code></pre>\n\n<p>Any unspecified fields are assumed to have the type in the original\nrecord declaration.</p>\n\n<h2>Specifications (contracts) for functions</h2>\n\n<p>A contract (or specification) for a function is given using the new\ncompiler attribute <code>'spec'</code>. The basic format is as follows:</p>\n\n<pre><code>-spec Module:Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.\n</code></pre>\n\n<p>The arity of the function has to match the number of arguments, or\nelse a compilation error occurs.</p>\n\n<p>This form can also be used in header files (.hrl) to declare type\ninformation for exported functions. Then these header files can be\nincluded in files that (implicitly or explicitly) import these\nfunctions.</p>\n\n<p>For most uses within a given module, the following shorthand is allowed:</p>\n\n<pre><code>-spec Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.\n</code></pre>\n\n<p>Also, for documentation purposes, argument names can be given:</p>\n\n<pre><code>-spec Function(ArgName1 :: Type1, ..., ArgNameN :: TypeN) -&gt; RT.\n</code></pre>\n\n<p>A function specification can be overloaded. That is, it can have\nseveral types, separated by a semicolon (;):</p>\n\n<pre><code>-spec foo(T1, T2) -&gt; T3\n       ; (T4, T5) -&gt; T6.\n</code></pre>\n\n<p>A current restriction, which currently results in a warning (<em>OBS</em>: not\nan error) by the compiler, is that the domains of the argument types\ncannot be overlapping. For example, the following specification\nresults in a warning:</p>\n\n<pre><code>-spec foo(pos_integer()) -&gt; pos_integer()\n       ; (integer()) -&gt; integer().\n</code></pre>\n\n<p>Type variables can be used in specifications to specify relations for\nthe input and output arguments of a function. For example, the\nfollowing specification defines the type of a polymorphic identity\nfunction:</p>\n\n<pre><code>-spec id(X) -&gt; X.\n</code></pre>\n\n<p>However, note that the above specification does not restrict the input\nand output type in any way. We can constrain these types by guard-like\nsubtype constraints:</p>\n\n<pre><code>-spec id(X) -&gt; X when is_subtype(X, tuple()).\n</code></pre>\n\n<p>and provide bounded quantification. Currently, the <code>is_subtype/2</code> guard\nis the only guard which can be used in a <code>'spec'</code> attribute.</p>\n\n<p>The scope of an <code>is_subtype/2</code> constraint is the <code>(...) -&gt; RetType</code>\nspecification after which it appears. To avoid confusion, we suggest\nthat different variables are used in different constituents of an\noverloaded contract as in the example below:</p>\n\n<pre><code>-spec foo({X, integer()}) -&gt; X when is_subtype(X, atom())\n       ; ([Y]) -&gt; Y when is_subtype(Y, number()).\n</code></pre>\n\n<p>Some functions in Erlang are not meant to return; either because they\ndefine servers or because they are used to throw exceptions as the\nfunction below::</p>\n\n<pre><code>my_error(Err) -&gt; erlang:throw({error, Err}).\n</code></pre>\n\n<p>For such functions we recommend the use of the special <code>no_return()</code>\ntype for their \"return\", via a contract of the form::</p>\n\n<pre><code>-spec my_error(term()) -&gt; no_return().\n</code></pre>\n\n<h2>Current limitations</h2>\n\n<p>The main limitation is the inability to define recursive types.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}