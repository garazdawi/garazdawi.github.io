<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Created: 09-Feb-2010
Erlang-Version: R13B-3
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 32: <a href="eep-0032.md" title="EEP Source"> Module-local process names</a></h2>

<h1>Abstract</h1>

<p>The process registry in Erlang is convenient, but counts as
a global shared mutable variable, with two major defects:
the possibility of data races (shared mutable variable) and
the impossibility of encapsulation (global).  This EEP
resurrects the old (1997 or earlier) proposal of module-
local process-valued variables, providing a replacement for
node-local uses of the registry with encapsulation and without
races.</p>

<h1>Specification</h1>

<p>A module (or an instance of a parameterized module) may have
one or more top level pid-valued variables, and if so, has a
lock associated with them.  The directive has the form</p>

<pre><code>-pid_name(Atom).
</code></pre>

<p>where Atom is an atom.  To avoid confusing programmers who
still have to deal with the registry, this Atom may not be
'undefined'.</p>

<p>If there is at least one such directive in a module, the
compiler automatically generates a function called
<code>pid_name/1</code>.  In the scope of directives</p>

<pre><code>-pid_name(pn_1).
...
-pid_name(pn_k).
</code></pre>

<p>the <code>pid_name/1</code> function is rather like</p>

<pre><code>pid_name(pn_1) -&gt;
    with_module_lock(read) -&gt; X = *pn_1 end, X;
...
pid_name(pn_k) -&gt;
    with_module_lock(read) -&gt; X = *pn_k end, X.
</code></pre>

<p>except that we expect there to be a VM instruction
<code>get_pid_safely(Address)</code>, and we expect the compiler to
inline calls to pid_name(Atom) when Atom is known.
On a machine like the <code>X86</code> or <code>X86_64</code>, this could be a
single locked load instruction.</p>

<p>The value of a <code>-pid_name</code> is always a process id. <br />
There is a special process id value which at all times represents
a dead process.  So within a module,</p>

<pre><code>pid_name(X) ! Message
</code></pre>

<p>is legal if and only if X is one of the pid-names declared in
the module, and whether or not the process it names has died.</p>

<p>If there is a need to discover whether a <code>-pid_name</code> has within
the recent but unpredictable past been associated with a live
process, that can be found out by combining <code>pid_name/1</code> with
<code>process_info/2</code>.</p>

<p>As with the registry, a process may have at most one <code>pid_name</code>.
For debugging purposes, I suppose that <code>process_info</code> could be
extended to return a <code>{pid_name,{Module,Name}}</code> tuple.</p>

<p>When a process exits, it is automatically unregistered.
That is, if it was bound to a <code>-pid_name</code>, that <code>-pid_name</code>
now refers to the conventional dead process.  This draft of
this EEP includes no other way for a process to be unregistered.</p>

<p>The important thing about registering a process is that it
should be atomic.  So there are two new functions</p>

<pre><code>pid_name_spawn(Name, Fun)
pid_name_spawn_link(Name, Fun)
</code></pre>

<p>We can understand them as</p>

<pre><code>pid_name_spawn(Name, Fun)
  when is_atom(Name), is_function(Fun, 0) -&gt;
    with_module_lock(write) -&gt;
    P = *Name,
    if P is a live process -&gt;
        P
     ; P is a dead process -&gt;
        Q = spawn(Fun),
        *Name := Q,
        Q
    end
    end.

pid_name_spawn_link(Name, Fun)
  when is_atom(Name), is_function(Fun, 0) -&gt;
    with_module_lock(write) -&gt;
    P = *Name,
    if P is a live process -&gt;
        P
     ; P is a dead process -&gt;
        Q = spawn(Fun),
        *Name := Q,
        Q
    end
    end.
</code></pre>

<p>Here, as earlier, <code>with_module_lock</code> is pseudo-code, meant to
suggest some sort of reader-writer locking on a private lock,
existing only inside a module that has declared a <code>-pid_name</code>.</p>

<p>These two functions are automatically declared inside the
module, like <code>pid_name/1</code>.  The three functions are not functions
automatically inherited from the <code>erlang:</code> module but functions
that are logically inside the module, however they might be
actually implemented.  There doesn't seem to be any good
reason for a module to export any of these functions, and the
compiler should at least warn if that is attempted.</p>

<h1>Motivation</h1>

<ul>
<li><p>Encapsulation.</p>

<p>The process registry is often used when clients of a module
need to communicate with one or more servers managed by the
module, but the interface code is inside the module.  There
is no advantage, and much risk, in exposing the process.  A
big reason for this process is to get the benefit of having
mutable process variables without the loss of encapsulation.</p></li>
<li><p>Efficiency.</p>

<p>As a shared mutable data structure, the registry has to be
accessed within the scope of suitable locks.  With this
approach, each module has its own lock, contention ought
to be pretty nearly zero, and the commonest use case of
the registry can, I believe, be a simple load instruction.</p></li>
<li><p>Safety.</p>

<p>It is actually surprisingly hard to register a process
safely, and the use of registered names is oddly inconsistent
with the use of direct process ids.  This interface is meant
to be simpler to use safely.</p></li>
</ul>

<h1>Rationale</h1>

<p>The old Erlang book describes four functions for dealing with
registered process names.  There are two more main interfaces.</p>

<pre><code>Name ! Message when is_atom(Name) -&gt;
  % Also available as erlang:send(Name, Message).
  % A 'badarg' exception results if Pid is an atom that is
  % not the registered name of a live local process or port.
    whereis(Name) ! Message.

register(Name, Pid) when is_atom(Name), is_pid(Pid) -&gt;
  % A 'badarg' exception results if Pid is not a live local
  % process or port, if Name is not an atom or is already in
  % use, if Pid already has a registered name, or if Name is
  % 'undefined'.
    "whereis(Name) := Pid".

unregister(Name) when is_atom(Name) -&gt;
  % A 'badarg' exception results if Name is not an atom
  % currently in use as the registered name of some process
  % or port.  'undefined' is always an error.
    "whereis(Name) := undefined".

whereis(Name) when is_atom(Name) -&gt;
  % A 'badarg' exception results if Name is not a name.
  % in effect, a global mutable hash table with
  % atom keys and pid-or-'undefined' values.

registered() -&gt;
    % yes, I know this is not executable Erlang.
    [Name || is_atom(Name), is_pid(whereis(Name))].

process_info(Pid, registered_name) when is_pid(Pid) -&gt;
    % yes, I know this is not executable Erlang.
    case [Name || is_atom(Name), whereis(Name) =:= Pid]
      of [N] -&gt; {registered_name,N}
       ; []  -&gt; []
    end.
</code></pre>

<p>When a process terminates, for whatever reason, it does the
equivalent of</p>

<pre><code>case process_info(self(), registered_name)
  of {_,Name} -&gt; unregister(Name)
   ; []       -&gt; ok
end.
</code></pre>

<p>This has an astonishing consequence.</p>

<p>Suppose I do</p>

<pre><code>Pid = spawn(Fun),
...
Pid ! Message
</code></pre>

<p>and between the time the process was created and the time I send
the message to it, the process dies.  In Erlang this is
perfectly ok, and the message just disappears.</p>

<p>Now suppose I do</p>

<pre><code>register(Name, spawn(Fun)),
...
Name ! Message
</code></pre>

<p>and between the time the process was created and the time I send
the message to it, the process dies.  Anyone would expect the
result to be exactly the same: because the <code>Name</code> pointed to a
process which has died, this amounts to sending a message to a
dead process, which is perfectly ok, and the message just
disappears.  Most confusingly, that is not what happens, and
instead you get a 'badarg' exception.</p>

<p>Now suppose I do</p>

<pre><code>send(Pid, Message) when is_pid(Pid) -&gt;
    Pid ! Message;
send(Name, Message) when is_atom(Name) -&gt;
    case whereis(Name)
      of undefined -&gt; ok
       ; Pid when is_pid(Pid) -&gt; Pid ! Message
    end.
...
    register(Name, spawn(Fun)),
    ...
    send(Name, Message)
</code></pre>

<p>This works the way we would expect, but why is it necessary?</p>

<p>In Erlang as it stands, <code>Name ! Message</code> will raise an error if
<code>Name</code> would have referred to the right process but that process
has died.  It might be argued that this is a useful debugging
aid, but nothing helps us if <code>Name</code> now refers to the WRONG
process.  Right now, consider</p>

<pre><code>whereis(Name) ! Message
</code></pre>

<p>This will raise an exception if the named process had died
before whereis/1 was called, but consider this timing:</p>

<pre><code>live           dies
   whereis runs      message sent
</code></pre>

<p>A slight change in timing can unpredictably change the
behaviour from silence-on-late-death to error-on-early-death
and vice versa.</p>

<pre><code>pid_name(Name) ! Message
</code></pre>

<p>is <em>consistently</em> silent.</p>

<p>The current process registry is also used for ports, which act in
many ways like processes.</p>

<p>The old Erlang book is absolutely right that sometimes you
need a way to talk to a process you haven't been previously
introduced to.  However, it is not true that this must be
done by means of a global hash table.  You could always ask
a module for the information.</p>

<p>Let's take program 5.5 from the book.</p>

<pre><code>-module(number_analyser). 
-export([start/0,server/1]). 
-export([add_number/2,analyse/1]). 

start() -&gt; 
    register(number_analyser, 
    spawn(number_analyser, server, [nil])). 

%% The interface functions. 

add_number(Seq, Dest) -&gt; 
    request({add_number,Seq,Dest}). 

analyse(Seq) -&gt; 
    request({analyse,Seq}). 

request(Req) -&gt; 
    number_analyser ! {self(), Req}, 
    receive 
    {number_analyser,Reply} -&gt; 
            Reply 
    end. 

%% The server. 

server(Analyser_Table) -&gt; 
    receive 
        {From, {analyse, Seq}} -&gt; 
        Result = lookup(Seq, Analyser_Table), 
        From ! {number_analyser, Result}, 
        server(Analyser_Table)
      ; {From, {add_number, Seq, Dest}} -&gt; 
        From ! {number_analyser, ack}, 
        server(insert(Seq, Dest, Analyser_Table)) 
    end.
</code></pre>

<p>The first thing we notice about this is that the registry is used
to allow a process that is a client of this module to communicate
with a process managed by this module through interface functions
in this module.  There is no reason why the process should be
given a GLOBALLY visible name, and every reason why it should NOT.
We would like to ensure that all communication with the server
process goes through the interface functions, and as long as the
process is in a global registry, anything could happen.  The
global process registry thus defeats its own purpose.</p>

<p>Similarly, because the reply messages to the interface functions
are tagged, not with the server's identity, but with its public
name, they are easy to forge.  Both of these problems also apply
to Program 5.6 in the old book.</p>

<p>But there is worse.  It is NEVER safe to call <code>register/2</code> or
<code>unregister/1</code>.  Recall that the precondition for <code>register/2</code>
requires that the <code>Name</code> not be in use.  But there is no way to
ever be sure of that.  For example, you might try</p>

<pre><code>spawn_if_necessary(Name, Fun) -&gt;
    case whereis(Name)      % T1
      of undefined -&gt;
     Pid = spawn(Fun),  % T2
     register(Name, Pid)    % T3
       ; Pid when is_pid(Pid) -&gt;
         ok
    end,
    Pid.
</code></pre>

<p>Unfortunately, between time T1, when <code>whereis/1</code> reports that the
<code>Name</code> is not in use, and time T3, when we try to assign it, some
other process might have been registered.  Also, between time T2,
when the new process is created, and T3, when we use the <code>Pid</code>, the
process might have died.</p>

<p>Because the registry is global, it is no use searching existing
code to see whether the <code>Name</code> is clobbered; the bug might be
introduced in future code.</p>

<p>There appears to be no way to protect against the possibility of a
process dying between T2 and T3.  The obvious hack,</p>

<pre><code>Pid = spawn(Fun),
erlang:suspend_process(Pid),
register(Name, Pid),
erlang:resume_process(Pid)
</code></pre>

<p>won't work because <code>erlang:suspend_process/1</code> is documented as
having the same 'badarg if Pid is not the pid of a live local
process' snafu as <code>register/2</code>.  The only really safe way around the
issue would be for the new process to be born suspended, and
there's no way to do that.  There is no 'suspended' option allowed
in the options list of <code>spawn_opt/[2-5]</code>.</p>

<p>In practice, of course, the new process WON'T die, typically
because it goes into a loop waiting for a message.  Even so, this
amount of fragility in a primitive is a bit worrying.</p>

<p>Let's take a quick check to see how real all this is.</p>

<p><code>sounder.erl</code> has</p>

<pre><code>start() -&gt;
    case whereis(sounder) of
        undefined -&gt;
        case file:read_file_info('/dev/audio') of
            {ok, FI} when FI#file_info.access==read_write -&gt;
            register(sounder, spawn(sounder,go,[])),
            ok;
            _Other -&gt;
            register(sounder, spawn(sounder,nosound,[])),
            silent
        end;
        _Pid -&gt;
        ok
    end.
</code></pre>

<p>Here's a curious thing:  the first time <code>sounder:start/0</code> is
called, it will return different values (ok, silent) depending
on whether sound (is, is not) supported.  Later calls always
return ok.  This contradicts the documentation.  Whoops!
Apart from that, it's a straightforward <code>spawn_if_necessary</code>.</p>

<p><code>man.erl</code> has</p>

<pre><code>start() -&gt;
    case whereis(man) of
        undefined -&gt;
        register(man,Pid=spawn(man,init,[])),
        Pid;
        Pid -&gt;
        Pid
    end.
</code></pre>

<p>This is precisely</p>

<pre><code>start() -&gt; spawn_if_necessary(fun () -&gt; man:init() end).
</code></pre>

<p><code>tv_table_owner</code> has</p>

<pre><code>start() -&gt;
    case whereis(?REGISTERED_NAME) of
        undefined -&gt;
        ServerPid = spawn(?MODULE, init, []),
        case catch register(?REGISTERED_NAME, ServerPid) of
            true -&gt;
            ok;
            {'EXIT', _Reason} -&gt;
            exit(ServerPid, kill),
            timer:sleep(500),
            start()
        end;
        Pid when is_pid(Pid) -&gt;
        ok
    end.
</code></pre>

<p>Let's repackage that to see what's going on:</p>

<pre><code>spawn_if_necessary(Name, Fun) -&gt;
    case whereis(Name)
      of undefined -&gt;
         Pid = spawn(Fun),          
         case catch register(Name, Pid)
           of true -&gt;
              Pid
            ; {'EXIT', _} -&gt;
              exit(Pid, kill),
              timer:sleep(500),
              spawn_if_necessary(Name, Fun)
         end
       ; Pid when is_pid(Pid) -&gt;
     ok
    end.
</code></pre>

<p>If there is a live local process registered under <code>Name</code>, return its
<code>Pid</code>.  Of course, after the function returns to believe that there
is STILL a live local process registered under Name, but that's
just as true of <code>whereis/1</code>.</p>

<p>If there is not, then create a new process, regardless of whether
that turns out to be useful.  Try to register it.  The <code>Pid</code> will be
the pid of a live local process that is not registered under any
other name, and <code>Name</code> must be an atom other than 'undefined', or
<code>whereis/1</code> would have crashed.  So it should be that the only thing
that can go wrong is that some other process has snuck in and
swiped the registry slot.  In that case, kill the process, wait a
long time, and try again.</p>

<p>In theory, it is possible for this to loop forever, with just the
right malevolent timing by an adversary.  In practice, I'm sure it
works very well.</p>

<p>The thing is, if the 'primitives' are this fragile, I would rather
not expose beginners to them.  Or for that matter, most people:
there are plenty of uses of <code>register/1</code> in the Erlang/OTP sources
that are not this well protected.</p>

<p>The simplest fix to the 'registration race' problem would be to
verify that <code>spawn_if_necessary/2</code> is sound, correct it if
necessary, and put it in a library.  However, that does nothing to
fix the globality of the registry.</p>

<p>There is no analogue of registered().  Inside a module, you can
see what names are available; outside the module, you have no
right to know.</p>

<p>This EEP does not propose abolishing the old registry.  There
is a lot of code, and a lot of training material, that still
uses or mentions it.  Above all, the old registry can do one
thing that this EEP cannot do and isn't meant to, and that is
to provide names that can be used in other nodes, in <code>{Node,Name}</code>
form.  The aim of this proposal is to provide something that can
replace MOST uses of the registry with something safer, and in
particular to allow gradual migration to per-module registration.</p>

<h1>Backwards Compatibility</h1>

<p>The only modules that are affected by the new feature are
those that visibly contain an explicit <code>-pid_name</code> directive.</p>

<h1>Reference Implementation</h1>

<p>None.</p>

<h1>Example</h1>

<p>Here is the old book's Program 5.5 again, brought up to date.</p>

<pre><code>-module(number_analyser). 
-export([
    add_number/2,
    analyse/1,
    start/0,
    stop/0
 ]).
-pid_name(server).

start() -&gt;
    pid_name_spawn(server, fun () -&gt; server(nil) end).

stop() -&gt;
    pid_name(server) ! stop.

add_number(Seq, Dest) -&gt;
    request({add_number,Seq,Dest}).

analyse(Seq) -&gt;
    request({analyse,Seq}).

request(Request) -&gt;
    P = pid_name(server),
    P ! {self(), Request},
    receive {P,Reply} -&gt; Reply end.

server(Analyser_Table) -&gt;
    receive 
        {From, {analyse, Seq}} -&gt; 
        From ! {self(), lookup(Seq, Analyser_Table)},
        server(Analyser_Table)
      ; {From, {add_number, Seq, Dest}} -&gt; 
        From ! {self(), ok}, 
        server(insert(Seq, Dest, Analyser_Table)) 
    end.
</code></pre>

<ul>
<li><p>It is now possible to use a programming convention where the
<code>-pid_name</code> of every server is 'server'.</p></li>
<li><p>It is no longer possible for code outside the module to send
messages to the server process.</p></li>
<li><p>It is no longer possible (well, no longer embarrassingly easy)
for an outsider to forge responses from the server.</p></li>
</ul>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0032","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 09-Feb-2010\nErlang-Version: R13B-3\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 32: \u003ca href=\"eep-0032.md\" title=\"EEP Source\"\u003e Module-local process names\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThe process registry in Erlang is convenient, but counts as\na global shared mutable variable, with two major defects:\nthe possibility of data races (shared mutable variable) and\nthe impossibility of encapsulation (global).  This EEP\nresurrects the old (1997 or earlier) proposal of module-\nlocal process-valued variables, providing a replacement for\nnode-local uses of the registry with encapsulation and without\nraces.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eA module (or an instance of a parameterized module) may have\none or more top level pid-valued variables, and if so, has a\nlock associated with them.  The directive has the form\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-pid_name(Atom).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere Atom is an atom.  To avoid confusing programmers who\nstill have to deal with the registry, this Atom may not be\n'undefined'.\u003c/p\u003e\n\n\u003cp\u003eIf there is at least one such directive in a module, the\ncompiler automatically generates a function called\n\u003ccode\u003epid_name/1\u003c/code\u003e.  In the scope of directives\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-pid_name(pn_1).\n...\n-pid_name(pn_k).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ethe \u003ccode\u003epid_name/1\u003c/code\u003e function is rather like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epid_name(pn_1) -\u0026gt;\n    with_module_lock(read) -\u0026gt; X = *pn_1 end, X;\n...\npid_name(pn_k) -\u0026gt;\n    with_module_lock(read) -\u0026gt; X = *pn_k end, X.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eexcept that we expect there to be a VM instruction\n\u003ccode\u003eget_pid_safely(Address)\u003c/code\u003e, and we expect the compiler to\ninline calls to pid_name(Atom) when Atom is known.\nOn a machine like the \u003ccode\u003eX86\u003c/code\u003e or \u003ccode\u003eX86_64\u003c/code\u003e, this could be a\nsingle locked load instruction.\u003c/p\u003e\n\n\u003cp\u003eThe value of a \u003ccode\u003e-pid_name\u003c/code\u003e is always a process id. \u003cbr /\u003e\nThere is a special process id value which at all times represents\na dead process.  So within a module,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epid_name(X) ! Message\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis legal if and only if X is one of the pid-names declared in\nthe module, and whether or not the process it names has died.\u003c/p\u003e\n\n\u003cp\u003eIf there is a need to discover whether a \u003ccode\u003e-pid_name\u003c/code\u003e has within\nthe recent but unpredictable past been associated with a live\nprocess, that can be found out by combining \u003ccode\u003epid_name/1\u003c/code\u003e with\n\u003ccode\u003eprocess_info/2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs with the registry, a process may have at most one \u003ccode\u003epid_name\u003c/code\u003e.\nFor debugging purposes, I suppose that \u003ccode\u003eprocess_info\u003c/code\u003e could be\nextended to return a \u003ccode\u003e{pid_name,{Module,Name}}\u003c/code\u003e tuple.\u003c/p\u003e\n\n\u003cp\u003eWhen a process exits, it is automatically unregistered.\nThat is, if it was bound to a \u003ccode\u003e-pid_name\u003c/code\u003e, that \u003ccode\u003e-pid_name\u003c/code\u003e\nnow refers to the conventional dead process.  This draft of\nthis EEP includes no other way for a process to be unregistered.\u003c/p\u003e\n\n\u003cp\u003eThe important thing about registering a process is that it\nshould be atomic.  So there are two new functions\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epid_name_spawn(Name, Fun)\npid_name_spawn_link(Name, Fun)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can understand them as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epid_name_spawn(Name, Fun)\n  when is_atom(Name), is_function(Fun, 0) -\u0026gt;\n    with_module_lock(write) -\u0026gt;\n    P = *Name,\n    if P is a live process -\u0026gt;\n        P\n     ; P is a dead process -\u0026gt;\n        Q = spawn(Fun),\n        *Name := Q,\n        Q\n    end\n    end.\n\npid_name_spawn_link(Name, Fun)\n  when is_atom(Name), is_function(Fun, 0) -\u0026gt;\n    with_module_lock(write) -\u0026gt;\n    P = *Name,\n    if P is a live process -\u0026gt;\n        P\n     ; P is a dead process -\u0026gt;\n        Q = spawn(Fun),\n        *Name := Q,\n        Q\n    end\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere, as earlier, \u003ccode\u003ewith_module_lock\u003c/code\u003e is pseudo-code, meant to\nsuggest some sort of reader-writer locking on a private lock,\nexisting only inside a module that has declared a \u003ccode\u003e-pid_name\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThese two functions are automatically declared inside the\nmodule, like \u003ccode\u003epid_name/1\u003c/code\u003e.  The three functions are not functions\nautomatically inherited from the \u003ccode\u003eerlang:\u003c/code\u003e module but functions\nthat are logically inside the module, however they might be\nactually implemented.  There doesn't seem to be any good\nreason for a module to export any of these functions, and the\ncompiler should at least warn if that is attempted.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eEncapsulation.\u003c/p\u003e\n\n\u003cp\u003eThe process registry is often used when clients of a module\nneed to communicate with one or more servers managed by the\nmodule, but the interface code is inside the module.  There\nis no advantage, and much risk, in exposing the process.  A\nbig reason for this process is to get the benefit of having\nmutable process variables without the loss of encapsulation.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eEfficiency.\u003c/p\u003e\n\n\u003cp\u003eAs a shared mutable data structure, the registry has to be\naccessed within the scope of suitable locks.  With this\napproach, each module has its own lock, contention ought\nto be pretty nearly zero, and the commonest use case of\nthe registry can, I believe, be a simple load instruction.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eSafety.\u003c/p\u003e\n\n\u003cp\u003eIt is actually surprisingly hard to register a process\nsafely, and the use of registered names is oddly inconsistent\nwith the use of direct process ids.  This interface is meant\nto be simpler to use safely.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe old Erlang book describes four functions for dealing with\nregistered process names.  There are two more main interfaces.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eName ! Message when is_atom(Name) -\u0026gt;\n  % Also available as erlang:send(Name, Message).\n  % A 'badarg' exception results if Pid is an atom that is\n  % not the registered name of a live local process or port.\n    whereis(Name) ! Message.\n\nregister(Name, Pid) when is_atom(Name), is_pid(Pid) -\u0026gt;\n  % A 'badarg' exception results if Pid is not a live local\n  % process or port, if Name is not an atom or is already in\n  % use, if Pid already has a registered name, or if Name is\n  % 'undefined'.\n    \"whereis(Name) := Pid\".\n\nunregister(Name) when is_atom(Name) -\u0026gt;\n  % A 'badarg' exception results if Name is not an atom\n  % currently in use as the registered name of some process\n  % or port.  'undefined' is always an error.\n    \"whereis(Name) := undefined\".\n\nwhereis(Name) when is_atom(Name) -\u0026gt;\n  % A 'badarg' exception results if Name is not a name.\n  % in effect, a global mutable hash table with\n  % atom keys and pid-or-'undefined' values.\n\nregistered() -\u0026gt;\n    % yes, I know this is not executable Erlang.\n    [Name || is_atom(Name), is_pid(whereis(Name))].\n\nprocess_info(Pid, registered_name) when is_pid(Pid) -\u0026gt;\n    % yes, I know this is not executable Erlang.\n    case [Name || is_atom(Name), whereis(Name) =:= Pid]\n      of [N] -\u0026gt; {registered_name,N}\n       ; []  -\u0026gt; []\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen a process terminates, for whatever reason, it does the\nequivalent of\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase process_info(self(), registered_name)\n  of {_,Name} -\u0026gt; unregister(Name)\n   ; []       -\u0026gt; ok\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis has an astonishing consequence.\u003c/p\u003e\n\n\u003cp\u003eSuppose I do\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePid = spawn(Fun),\n...\nPid ! Message\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand between the time the process was created and the time I send\nthe message to it, the process dies.  In Erlang this is\nperfectly ok, and the message just disappears.\u003c/p\u003e\n\n\u003cp\u003eNow suppose I do\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eregister(Name, spawn(Fun)),\n...\nName ! Message\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand between the time the process was created and the time I send\nthe message to it, the process dies.  Anyone would expect the\nresult to be exactly the same: because the \u003ccode\u003eName\u003c/code\u003e pointed to a\nprocess which has died, this amounts to sending a message to a\ndead process, which is perfectly ok, and the message just\ndisappears.  Most confusingly, that is not what happens, and\ninstead you get a 'badarg' exception.\u003c/p\u003e\n\n\u003cp\u003eNow suppose I do\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003esend(Pid, Message) when is_pid(Pid) -\u0026gt;\n    Pid ! Message;\nsend(Name, Message) when is_atom(Name) -\u0026gt;\n    case whereis(Name)\n      of undefined -\u0026gt; ok\n       ; Pid when is_pid(Pid) -\u0026gt; Pid ! Message\n    end.\n...\n    register(Name, spawn(Fun)),\n    ...\n    send(Name, Message)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis works the way we would expect, but why is it necessary?\u003c/p\u003e\n\n\u003cp\u003eIn Erlang as it stands, \u003ccode\u003eName ! Message\u003c/code\u003e will raise an error if\n\u003ccode\u003eName\u003c/code\u003e would have referred to the right process but that process\nhas died.  It might be argued that this is a useful debugging\naid, but nothing helps us if \u003ccode\u003eName\u003c/code\u003e now refers to the WRONG\nprocess.  Right now, consider\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ewhereis(Name) ! Message\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis will raise an exception if the named process had died\nbefore whereis/1 was called, but consider this timing:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003elive           dies\n   whereis runs      message sent\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA slight change in timing can unpredictably change the\nbehaviour from silence-on-late-death to error-on-early-death\nand vice versa.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epid_name(Name) ! Message\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis \u003cem\u003econsistently\u003c/em\u003e silent.\u003c/p\u003e\n\n\u003cp\u003eThe current process registry is also used for ports, which act in\nmany ways like processes.\u003c/p\u003e\n\n\u003cp\u003eThe old Erlang book is absolutely right that sometimes you\nneed a way to talk to a process you haven't been previously\nintroduced to.  However, it is not true that this must be\ndone by means of a global hash table.  You could always ask\na module for the information.\u003c/p\u003e\n\n\u003cp\u003eLet's take program 5.5 from the book.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-module(number_analyser). \n-export([start/0,server/1]). \n-export([add_number/2,analyse/1]). \n\nstart() -\u0026gt; \n    register(number_analyser, \n    spawn(number_analyser, server, [nil])). \n\n%% The interface functions. \n\nadd_number(Seq, Dest) -\u0026gt; \n    request({add_number,Seq,Dest}). \n\nanalyse(Seq) -\u0026gt; \n    request({analyse,Seq}). \n\nrequest(Req) -\u0026gt; \n    number_analyser ! {self(), Req}, \n    receive \n    {number_analyser,Reply} -\u0026gt; \n            Reply \n    end. \n\n%% The server. \n\nserver(Analyser_Table) -\u0026gt; \n    receive \n        {From, {analyse, Seq}} -\u0026gt; \n        Result = lookup(Seq, Analyser_Table), \n        From ! {number_analyser, Result}, \n        server(Analyser_Table)\n      ; {From, {add_number, Seq, Dest}} -\u0026gt; \n        From ! {number_analyser, ack}, \n        server(insert(Seq, Dest, Analyser_Table)) \n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe first thing we notice about this is that the registry is used\nto allow a process that is a client of this module to communicate\nwith a process managed by this module through interface functions\nin this module.  There is no reason why the process should be\ngiven a GLOBALLY visible name, and every reason why it should NOT.\nWe would like to ensure that all communication with the server\nprocess goes through the interface functions, and as long as the\nprocess is in a global registry, anything could happen.  The\nglobal process registry thus defeats its own purpose.\u003c/p\u003e\n\n\u003cp\u003eSimilarly, because the reply messages to the interface functions\nare tagged, not with the server's identity, but with its public\nname, they are easy to forge.  Both of these problems also apply\nto Program 5.6 in the old book.\u003c/p\u003e\n\n\u003cp\u003eBut there is worse.  It is NEVER safe to call \u003ccode\u003eregister/2\u003c/code\u003e or\n\u003ccode\u003eunregister/1\u003c/code\u003e.  Recall that the precondition for \u003ccode\u003eregister/2\u003c/code\u003e\nrequires that the \u003ccode\u003eName\u003c/code\u003e not be in use.  But there is no way to\never be sure of that.  For example, you might try\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003espawn_if_necessary(Name, Fun) -\u0026gt;\n    case whereis(Name)      % T1\n      of undefined -\u0026gt;\n     Pid = spawn(Fun),  % T2\n     register(Name, Pid)    % T3\n       ; Pid when is_pid(Pid) -\u0026gt;\n         ok\n    end,\n    Pid.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUnfortunately, between time T1, when \u003ccode\u003ewhereis/1\u003c/code\u003e reports that the\n\u003ccode\u003eName\u003c/code\u003e is not in use, and time T3, when we try to assign it, some\nother process might have been registered.  Also, between time T2,\nwhen the new process is created, and T3, when we use the \u003ccode\u003ePid\u003c/code\u003e, the\nprocess might have died.\u003c/p\u003e\n\n\u003cp\u003eBecause the registry is global, it is no use searching existing\ncode to see whether the \u003ccode\u003eName\u003c/code\u003e is clobbered; the bug might be\nintroduced in future code.\u003c/p\u003e\n\n\u003cp\u003eThere appears to be no way to protect against the possibility of a\nprocess dying between T2 and T3.  The obvious hack,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePid = spawn(Fun),\nerlang:suspend_process(Pid),\nregister(Name, Pid),\nerlang:resume_process(Pid)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewon't work because \u003ccode\u003eerlang:suspend_process/1\u003c/code\u003e is documented as\nhaving the same 'badarg if Pid is not the pid of a live local\nprocess' snafu as \u003ccode\u003eregister/2\u003c/code\u003e.  The only really safe way around the\nissue would be for the new process to be born suspended, and\nthere's no way to do that.  There is no 'suspended' option allowed\nin the options list of \u003ccode\u003espawn_opt/[2-5]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn practice, of course, the new process WON'T die, typically\nbecause it goes into a loop waiting for a message.  Even so, this\namount of fragility in a primitive is a bit worrying.\u003c/p\u003e\n\n\u003cp\u003eLet's take a quick check to see how real all this is.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003esounder.erl\u003c/code\u003e has\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003estart() -\u0026gt;\n    case whereis(sounder) of\n        undefined -\u0026gt;\n        case file:read_file_info('/dev/audio') of\n            {ok, FI} when FI#file_info.access==read_write -\u0026gt;\n            register(sounder, spawn(sounder,go,[])),\n            ok;\n            _Other -\u0026gt;\n            register(sounder, spawn(sounder,nosound,[])),\n            silent\n        end;\n        _Pid -\u0026gt;\n        ok\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere's a curious thing:  the first time \u003ccode\u003esounder:start/0\u003c/code\u003e is\ncalled, it will return different values (ok, silent) depending\non whether sound (is, is not) supported.  Later calls always\nreturn ok.  This contradicts the documentation.  Whoops!\nApart from that, it's a straightforward \u003ccode\u003espawn_if_necessary\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eman.erl\u003c/code\u003e has\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003estart() -\u0026gt;\n    case whereis(man) of\n        undefined -\u0026gt;\n        register(man,Pid=spawn(man,init,[])),\n        Pid;\n        Pid -\u0026gt;\n        Pid\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis is precisely\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003estart() -\u0026gt; spawn_if_necessary(fun () -\u0026gt; man:init() end).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003etv_table_owner\u003c/code\u003e has\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003estart() -\u0026gt;\n    case whereis(?REGISTERED_NAME) of\n        undefined -\u0026gt;\n        ServerPid = spawn(?MODULE, init, []),\n        case catch register(?REGISTERED_NAME, ServerPid) of\n            true -\u0026gt;\n            ok;\n            {'EXIT', _Reason} -\u0026gt;\n            exit(ServerPid, kill),\n            timer:sleep(500),\n            start()\n        end;\n        Pid when is_pid(Pid) -\u0026gt;\n        ok\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet's repackage that to see what's going on:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003espawn_if_necessary(Name, Fun) -\u0026gt;\n    case whereis(Name)\n      of undefined -\u0026gt;\n         Pid = spawn(Fun),          \n         case catch register(Name, Pid)\n           of true -\u0026gt;\n              Pid\n            ; {'EXIT', _} -\u0026gt;\n              exit(Pid, kill),\n              timer:sleep(500),\n              spawn_if_necessary(Name, Fun)\n         end\n       ; Pid when is_pid(Pid) -\u0026gt;\n     ok\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf there is a live local process registered under \u003ccode\u003eName\u003c/code\u003e, return its\n\u003ccode\u003ePid\u003c/code\u003e.  Of course, after the function returns to believe that there\nis STILL a live local process registered under Name, but that's\njust as true of \u003ccode\u003ewhereis/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf there is not, then create a new process, regardless of whether\nthat turns out to be useful.  Try to register it.  The \u003ccode\u003ePid\u003c/code\u003e will be\nthe pid of a live local process that is not registered under any\nother name, and \u003ccode\u003eName\u003c/code\u003e must be an atom other than 'undefined', or\n\u003ccode\u003ewhereis/1\u003c/code\u003e would have crashed.  So it should be that the only thing\nthat can go wrong is that some other process has snuck in and\nswiped the registry slot.  In that case, kill the process, wait a\nlong time, and try again.\u003c/p\u003e\n\n\u003cp\u003eIn theory, it is possible for this to loop forever, with just the\nright malevolent timing by an adversary.  In practice, I'm sure it\nworks very well.\u003c/p\u003e\n\n\u003cp\u003eThe thing is, if the 'primitives' are this fragile, I would rather\nnot expose beginners to them.  Or for that matter, most people:\nthere are plenty of uses of \u003ccode\u003eregister/1\u003c/code\u003e in the Erlang/OTP sources\nthat are not this well protected.\u003c/p\u003e\n\n\u003cp\u003eThe simplest fix to the 'registration race' problem would be to\nverify that \u003ccode\u003espawn_if_necessary/2\u003c/code\u003e is sound, correct it if\nnecessary, and put it in a library.  However, that does nothing to\nfix the globality of the registry.\u003c/p\u003e\n\n\u003cp\u003eThere is no analogue of registered().  Inside a module, you can\nsee what names are available; outside the module, you have no\nright to know.\u003c/p\u003e\n\n\u003cp\u003eThis EEP does not propose abolishing the old registry.  There\nis a lot of code, and a lot of training material, that still\nuses or mentions it.  Above all, the old registry can do one\nthing that this EEP cannot do and isn't meant to, and that is\nto provide names that can be used in other nodes, in \u003ccode\u003e{Node,Name}\u003c/code\u003e\nform.  The aim of this proposal is to provide something that can\nreplace MOST uses of the registry with something safer, and in\nparticular to allow gradual migration to per-module registration.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThe only modules that are affected by the new feature are\nthose that visibly contain an explicit \u003ccode\u003e-pid_name\u003c/code\u003e directive.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone.\u003c/p\u003e\n\n\u003ch1\u003eExample\u003c/h1\u003e\n\n\u003cp\u003eHere is the old book's Program 5.5 again, brought up to date.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-module(number_analyser). \n-export([\n    add_number/2,\n    analyse/1,\n    start/0,\n    stop/0\n ]).\n-pid_name(server).\n\nstart() -\u0026gt;\n    pid_name_spawn(server, fun () -\u0026gt; server(nil) end).\n\nstop() -\u0026gt;\n    pid_name(server) ! stop.\n\nadd_number(Seq, Dest) -\u0026gt;\n    request({add_number,Seq,Dest}).\n\nanalyse(Seq) -\u0026gt;\n    request({analyse,Seq}).\n\nrequest(Request) -\u0026gt;\n    P = pid_name(server),\n    P ! {self(), Request},\n    receive {P,Reply} -\u0026gt; Reply end.\n\nserver(Analyser_Table) -\u0026gt;\n    receive \n        {From, {analyse, Seq}} -\u0026gt; \n        From ! {self(), lookup(Seq, Analyser_Table)},\n        server(Analyser_Table)\n      ; {From, {add_number, Seq, Dest}} -\u0026gt; \n        From ! {self(), ok}, \n        server(insert(Seq, Dest, Analyser_Table)) \n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIt is now possible to use a programming convention where the\n\u003ccode\u003e-pid_name\u003c/code\u003e of every server is 'server'.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIt is no longer possible for code outside the module to send\nmessages to the server process.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIt is no longer possible (well, no longer embarrassingly easy)\nfor an outsider to forge responses from the server.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0032"},"buildId":"BGhkIUi1bNl03TKudis6o","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/BGhkIUi1bNl03TKudis6o/_buildManifest.js" async=""></script><script src="/_next/static/BGhkIUi1bNl03TKudis6o/_ssgManifest.js" async=""></script></body></html>