{"pageProps":{"index":{"id":"0042","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R16A\nCreated: 07-Feb-2013\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 42: <a href=\"eep-0042.md\" title=\"EEP Source\"> setrlimit(2) analogue for Erlang</a></h2>\n\n<h1>Abstract</h1>\n\n<p>A new function <code>erlang:set_process_info_limit/2</code> is added,\nallowing a process to set limits on its own memory use.</p>\n\n<h1>Specification</h1>\n\n<pre><code>erlang:set_process_info_limit(Item, Limit :: integer()) -&gt;\n    Old_Limit :: integer()\n</code></pre>\n\n<p>An <code>Old_Limit</code> of 0 means that no limit has been set.\nA Limit of 0 means that no limit is to be set.</p>\n\n<p>The Items that can be set are</p>\n\n<ul>\n<li><p><code>memory</code>, the number of bytes that may be used for stack, heap, and\ninternal structures.</p></li>\n<li><p><code>memory_words</code>, the same value as <code>memory</code>, but expressed in\nwords to be consistent with <code>heap_size</code>, <code>total_heap_size</code>, and\n<code>stack_size</code> in <code>erlang:process_info/[1,2]</code>.  Those functions should\nalso be revised to accept this Item.</p></li>\n<li><p><code>message_queue_len</code>, the number of unprocessed messages.\n(Aside.) The documentation refers to <code>message_queue_len</code>\nbut the system generates and recognises <code>message_queue_len</code>.\n(End aside.)</p></li>\n</ul>\n\n<p>The values that are actually set may be less than Limit as\nlong as any physically realisable system in the node as\nconfigured cannot exceed the value used.</p>\n\n<p>A non-zero memory limit is checked after each garbage\ncollection or other memory restructuring; setting the memory\nlimit to a non-zero value less than the current\n<code>process_info(self(), 'memory')</code> forces an immediate garbage\ncollection.</p>\n\n<p>If the memory required by a process exceeds its limit, the\nprocess is exited with reason <code>memory</code>.</p>\n\n<p>A non-zero message queue length limit is checked whenever\nthe message queue length is about to be incremented, or\nwhen such a limit is set.</p>\n\n<p>If the message queue length limit is exceeded, the process\nis exited with reason <code>message_queue_len</code>.</p>\n\n<h1>Motivation</h1>\n\n<p>It is currently possible for an Erlang process to grab\nmemory without limit and eventually take down the whole\nnode.  This problem is frequently reported in the Erlang\nmailing list.</p>\n\n<p>It is also possible for the message queue of an Erlang\nprocess to grow without limit.  This problem too is\nreported often enough to be recognised.</p>\n\n<p>This is an EEP rather than a library change request because\nit requires low level runtime system changes to support it.\nFor example, the limits have to be <em>stored</em> somewhere,\nsuggesting a change in the data structure holding information\nabout a process.  The limits have to be <em>checked</em>, meaning\nthat changes to the garbage collector and the message sending\ncore are required.  The limits have to be <em>enforced</em>,\nmeaning that two new exit reasons have to be supported.  And\nthe new exit reasons and the new function have to be\n<em>documented</em>, requiring changes to more than one document.</p>\n\n<p>The need is long-standing, and at least the presence of this\nEEP may provoke discussion leading to <em>some</em> resolution.</p>\n\n<h1>Rationale</h1>\n\n<p>The function that sets a limit should have a name based\nin the name of the function that reports current use.\nThat function is <code>process_info</code>, hence the name I've\nchosen here is <code>set_process_info_limit</code>.</p>\n\n<p>The <code>erlang:process_info/[1,2]</code> functions can report on\nany Erlang process.  But it is clearly dangerous to let\na process set another process's limits.  All we actually\n<em>need</em> is for a process to be able to set its own limits\nin a startup phase.  That could be done by adding\n<code>{'memory',Size}</code> and <code>{'message_queue_len',Count}</code> options\nto <code>spawn_opt/[2,3]</code>.  However,</p>\n\n<pre><code>spawn_opt(Fun, [{memory,128*1024}])\n</code></pre>\n\n<p>can be mimicked by</p>\n\n<pre><code>spawn(fun () -&gt;\n    erlang:set_process_info_limit(memory, 128*1024),\n    Fun()\nend)\n</code></pre>\n\n<p>and <code>set_process_info_limit/2</code> allows a process to set\ndifferent limits at different times.  If you are trying\nto protect the system from <em>malice</em>, setting limits in\n<code>spawn_opt/[2,3]</code> is the way to go.  If you are trying to\nprotect the system from <em>accident</em>, letting a process\nset its own limits is the way to go.</p>\n\n<p>The names for the Items to be set clearly must be identical\nto the names used for the same thing elsewhere.</p>\n\n<p>The <code>memory_words</code> item is introduced because in a world where\nsome of my programs run 32-bit and some run 64-bit it is just\ntoo confusing to count bytes, especially as stack size and so\non are measured in words, not bytes.</p>\n\n<p>I considered allowing <code>total_heap_size</code> and <code>stack_size</code> and so on\nto be given their own limits, but on finding that <code>total_heap_size</code>\n\"currently includes the stack of the process\", decided that it\nwas \"currently\" a bad idea.</p>\n\n<p>I would have liked to allow setting a limit on the number\nof reductions, so that a process that doesn't intend to\nlive forever can ensure its own eventual death.  However,\nthe documentation warns that <code>erlang:bump_reductions/1</code>\n\"might be removed\", so presumably reduction counting\n<em>per se</em> might well disappear.</p>\n\n<p>The point of letting the value actually set for a limit\nto be smaller is to allow an implementation to use only\nvalues that will fit in a <code>size_t</code>, so that low level\ncode does not need to deal with bignums.  On a\nPOSIX-compliant operating system, an Erlang implementation\nmay use the <code>RLIMIT_DATA</code> value for the UNIX process\nif the memory limit is bigger, and may use <code>RLIMIT_DATA</code>\ndivided by the minimum size of a message for the message\nqueue length.  Or it might use other appropriate system\nlimits.</p>\n\n<p>The biggest question is \"what happens if a limit is exceeded?\"</p>\n\n<p>For memory, we could exit with <code>system_limit</code> as reason, but\nthat wouldn't make clear <em>what</em> limit had been exceeded.  It\nseems advisable to introduce a new reason, and making the\nreason the same as the name of the limit seems the least\nconfusing approach.</p>\n\n<p>For message queue length, I would prefer it if the process\nthat <em>sends</em> the message were the one to get a run time error.\nHowever, the Erlang documentation guarantees that sending a\nmessage to a pid always succeeds, whether the process is live\nor dead, and I don't want to change too much.  A message queue\nmight build up because some process(es) is(are) sending junk;\nwe would prefer exiting junk senders to exiting junk receivers.\nHowever, if the junk receiver isn't cleaning out the junk, that\njunk is <em>never</em> going away, so it's <em>always</em> going to be costing\ntime to skip over as well as memory to store.  That argument\napplies to another option that I considered: just discarding\nmessages that would make the queue too long.  The Erlang Way is\nto let subsystems that get into trouble crash.  So let it be.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The new function is not exported by default\nso it cannot be called accidentally.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None in this draft.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}