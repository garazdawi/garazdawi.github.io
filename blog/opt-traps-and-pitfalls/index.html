<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/opt-traps-and-pitfalls/">Optimization Traps and Pitfalls</a></h3><p><em>Friday, 24 August 2018<!-- --> - <!-- -->Bj√∂rn Gustavsson</em></p><p>Back after the summer holidays, this blog will now change tracks and
start a series of blog posts about Static Single Assignment (SSA).
This first installment will set the scene for the posts that follow by
looking at the traps and pitfalls one can fall into when trying to
optimize BEAM assembly code.</p><h2>A brief introduction to BEAM assembly language</h2><p>We will look at the BEAM code for the following function:</p><pre><code class="language-erlang">foo({tag,A,_,_}) -&gt;
    {ok,A}.</code></pre><p>The (unoptimized) BEAM code looks like this:</p><pre><code>{function, foo, 1, 2}.
  {label,1}.
    {line,[{location,&quot;ex1.erl&quot;,4}]}.
    {func_info,{atom,ex1},{atom,foo},1}.
  {label,2}.
    {test,is_tuple,{f,3},[{x,0}]}.
    {test,test_arity,{f,3},[{x,0},4]}.
    {get_tuple_element,{x,0},0,{x,1}}.
    {get_tuple_element,{x,0},1,{x,2}}.
    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.
    {test_heap,3,3}.
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
  {label,3}.
    {test_heap,2,1}.
    {put_list,{x,0},nil,{x,1}}.
    {move,{atom,function_clause},{x,0}}.
    {line,[{location,&quot;ex1.erl&quot;,4}]}.
    {call_ext_only,2,{extfunc,erlang,error,2}}.</code></pre><p>We will concentrate on the part of the code that does
the actual work:</p><pre><code>    {test,is_tuple,{f,3},[{x,0}]}.
    {test,test_arity,{f,3},[{x,0},4]}.
    {get_tuple_element,{x,0},0,{x,1}}.
    {get_tuple_element,{x,0},1,{x,2}}.
    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.
    {test_heap,3,3}.
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
  {label,3}.
    %% Cause a function_clause exception.</code></pre><p>We will now explain what each instruction does.</p><pre><code>    {test,is_tuple,{f,3},[{x,0}]}.</code></pre><p><code>test</code> instructions test whether a condition is true. If it
is, the next instruction will be executed. Otherwise,
there will be a branch to the failure label.</p><p>The condition tested by this instruction is <code>is_tuple</code>, that is
whether its operand is a tuple.  The operand is <code>{x,0}</code>, which is the
register for the first argument for the function. If <code>{x,0}</code> does not
contain a tuple, execution will continue at the failure label. <code>{f,3}</code>
means that that the failure label is <code>3</code>. The code at label <code>3</code> will
cause a <code>function_clause</code> exception.</p><pre><code>    {test,test_arity,{f,3},[{x,0},4]}.</code></pre><p>The <code>test_arity</code> instruction tests whether the first operand (which
must be a tuple) has the size given by the second operand. The first
operand is <code>{x,0}</code> and the second operand is <code>4</code>. The failure label is
the same as for the previous instruction.</p><pre><code>    {get_tuple_element,{x,0},0,{x,1}}.
    {get_tuple_element,{x,0},1,{x,2}}.</code></pre><p>When those two instructions are executed, the previous instructions have
established that <code>{x,0}</code> contains a tuple of arity 4.
<code>get_tuple_element</code> takes three operands. The first is the source
tuple, <code>{x,0}</code>, the second is the <strong>zero-based</strong> index into the tuple,
and the third operand is the register into which the element from the
tuple should be stored. Note that there is no failure label because it
cannot fail.</p><p>So the first <code>get_tuple_element</code> instruction fetches the first element
of the tuple and stores it in the <code>{x,1}</code> register, and the second
<code>get_tuple_element</code> instruction fetches the second element and stores
it into the <code>{x,2}</code> register.</p><pre><code>    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.</code></pre><p><code>is_eq_exact</code> is again a <code>test</code> instruction. It tests
whether the contents of <code>{x,1}</code> is exactly equal (that is,
<code>=:=</code>) to the atom <code>tag</code>. If not, execution will continue
at the failure label <code>3</code>.</p><p>That concludes the function header. The next instruction is in the
body of the function that will build the <code>{ok,A}</code> tuple:</p><pre><code>    {test_heap,3,3}.</code></pre><p>The <code>test_heap</code> instruction ensures that there is sufficient free
space on the heap to construct a term. The first operand (the first
<code>3</code>) says that the following instructions will need 3 words on the
heap. A tuple has a header word, followed by the elements, so a tuple
with 2 elements needs 3 heap words in total.</p><p>If there is not sufficient room on the heap, the <code>test_heap</code>
instruction will do a garbage collection to find some fresh heap
space. The second operand (the second <code>3</code>) is the number of <code>x</code>
registers that have values that must be preserved during garbage
collection. The <code>3</code> means that <code>{x,0}</code>, <code>{x,1}</code>, and <code>{x,2}</code> have live
values.</p><pre><code>    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.</code></pre><p>Those three instructions build the tuple, putting a tagged
pointer to the tuple in <code>{x,0}</code>.</p><pre><code>    return.</code></pre><p><code>return</code> returns from the function. The return value is the
value in <code>{x,0}</code>.</p><h2>Optimizing this code</h2><p>Testing that a term is a tuple of a certain size with a specific atom
as the first element is a common operation (think records). Therefore
the BEAM machine has an <code>is_tagged_tuple</code> instruction that does the
work of 4 other instructions.</p><p>Using that instruction, this code:</p>&lt;pre class=&quot;highlight&quot;&gt;
    &lt;b&gt;{test,is_tuple,{f,3},[{x,0}]}.&lt;/b&gt;
    &lt;b&gt;{test,test_arity,{f,3},[{x,0},4]}.&lt;/b&gt;
    &lt;b&gt;{get_tuple_element,{x,0},0,{x,1}}.&lt;/b&gt;
    {get_tuple_element,{x,0},1,{x,2}}.
    &lt;b&gt;{test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.&lt;/b&gt;
    {test_heap,3,3}.
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
&lt;/pre&gt;<p>can be rewritten like this:</p>&lt;pre class=&quot;highlight&quot;&gt;
    &lt;b&gt;{test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.&lt;/b&gt;
    {get_tuple_element,{x,0},1,{x,2}}.
    {test_heap,3,3}.
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
&lt;/pre&gt;<p>This is a nice reduction in code size and execution
time. However, this optimization is not safe.</p><p>Why?</p><p>Consider the <code>{test_heap,3,3}</code> instruction. The second <code>3</code> says
that 3 <code>x</code> registers are live, namely <code>{x,0}</code>, <code>{x,1}</code>, and <code>{x,2}</code>.
Clearly, <code>{x,0}</code> and <code>{x,2}</code> are live, but what about <code>{x,1}</code>?
We removed the <code>get_tuple_element</code> instruction that assigned <code>{x,1}</code>
a value, so the value of <code>{x,1}</code> is undefined.</p><p>Passing undefined register values to the garbage collector is the kind
of bug that could take weeks to track down. In fact, there will
probably be a future blog post about that kind of bug and how two
tools were born as result of that bug.</p><p>Reluctantly, in order to make the optimization safe, we must keep
the <code>get_tuple_element</code> instruction that assigns to <code>{x,1}</code>:</p>&lt;pre class=&quot;highlight&quot;&gt;
    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.
    &lt;b&gt;{get_tuple_element,{x,0},0,{x,1}}.&lt;/b&gt;
    {get_tuple_element,{x,0},1,{x,2}}.
    {test_heap,3,3}.
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
&lt;/pre&gt;<p>Another possibility in this case would be to assign an empty list
(called <code>nil</code> in the BEAM assembly language) to <code>{x,1}</code>:</p>&lt;pre class=&quot;highlight&quot;&gt;
    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.
    &lt;b&gt;{move,nil,{x,1}}.&lt;/b&gt;
    {get_tuple_element,{x,0},1,{x,2}}.
    {test_heap,3,3}.
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
&lt;/pre&gt;<p>However, in this very simple example, another optimization will
actually allow the compiler to remove the assignment to <code>{x,1}</code>:</p>&lt;pre class=&quot;highlight&quot;&gt;
    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.
    &lt;b&gt;{test_heap,3,1}.&lt;/b&gt;
    &lt;b&gt;{get_tuple_element,{x,0},1,{x,2}}.&lt;/b&gt;
    {put_tuple,2,{x,0}}.
    {put,{atom,ok}}.
    {put,{x,2}}.
    return.
&lt;/pre&gt;<p>The <code>test_heap</code> and <code>get_tuple_element</code> instructions have been swapped.
Note that the number of live register have been adjusted in the <code>test_heap</code>
instruction. It is now <code>1</code> instead of <code>3</code>.</p><p>In general, though, the compiler might have to abandon an optimization
or keep an instruction that assigns a register to avoiding feeding the
garbage collector undefined values.</p><h2>The final straw</h2><p>During the development of OTP 21, we realized that we have reached the
limit for improving the optimizations that operates on the BEAM
assembly language. In particular, we wanted to make the optimization
called the <a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries">delayed sub binary creation</a> applicable in
more circumstances. It turned out that would it be hard or impossible
to substantially improve the optimization by working on BEAM assembly
language.</p><p>Apart from the problem of leaving undefined registers, as illustrated
in the previous optimization example, there is also the complexity of
traversing and analyzing BEAM instructions. The BEAM instruction set
was not designed to be optimizer-friendly.</p><h2>Conclusion</h2><p>As I have tried to show with the example above, one of the hardest
parts of working with BEAM code is that register allocation has
already been done and that instructions that may do a garbage
collection (such as <code>test_heap</code>) have already been added.</p><p>Early this year (2018), we decided that we should introduce a new
intermediate format to alleviate the problems with optimizing BEAM
code. It should be close enough to BEAM code to allow
low-level optimizations such as the <code>is_tagged_tuple</code> optimization
described in this blog post, but register allocation should not have
been done, and <code>test_heap</code> and similar instructions should not have
been added. It should also be more regular to make it easier to
traverse while doing optimizations.</p><p>We decided to make the new intermediate format <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA-based</a>.
In the next blog post, we will re-visit the example from this blog
post and see what it looks like in the <a href="https://github.com/erlang/otp/pull/1935">new SSA-based intermediate
format</a>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"opt-traps-and-pitfalls","title":"Optimization Traps and Pitfalls","author":"Bj√∂rn Gustavsson","excerpt":"\nBack after the summer holidays, this blog will now change tracks and\nstart a series of blog posts about Static Single Assignment (SSA).\nThis first installment will set the scene for the posts that follow by\nlooking at the traps and pitfalls one can fall into when trying to\noptimize BEAM assembly code.\n\n[bin_matching]: http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries,\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form,\n[pr1935]: https://github.com/erlang/otp/pull/1935","article_date":1535068800000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Optimization Traps and Pitfalls","tags":"compiler BEAM","author":"Bj√∂rn Gustavsson"},"content":"\nBack after the summer holidays, this blog will now change tracks and\nstart a series of blog posts about Static Single Assignment (SSA).\nThis first installment will set the scene for the posts that follow by\nlooking at the traps and pitfalls one can fall into when trying to\noptimize BEAM assembly code.\n\n## A brief introduction to BEAM assembly language\n\nWe will look at the BEAM code for the following function:\n\n```erlang\nfoo({tag,A,_,_}) -\u003e\n    {ok,A}.\n```\n\nThe (unoptimized) BEAM code looks like this:\n\n```\n{function, foo, 1, 2}.\n  {label,1}.\n    {line,[{location,\"ex1.erl\",4}]}.\n    {func_info,{atom,ex1},{atom,foo},1}.\n  {label,2}.\n    {test,is_tuple,{f,3},[{x,0}]}.\n    {test,test_arity,{f,3},[{x,0},4]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n  {label,3}.\n    {test_heap,2,1}.\n    {put_list,{x,0},nil,{x,1}}.\n    {move,{atom,function_clause},{x,0}}.\n    {line,[{location,\"ex1.erl\",4}]}.\n    {call_ext_only,2,{extfunc,erlang,error,2}}.\n```\n\nWe will concentrate on the part of the code that does\nthe actual work:\n\n```\n    {test,is_tuple,{f,3},[{x,0}]}.\n    {test,test_arity,{f,3},[{x,0},4]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n  {label,3}.\n    %% Cause a function_clause exception.\n```\n\nWe will now explain what each instruction does.\n\n```\n    {test,is_tuple,{f,3},[{x,0}]}.\n```\n\n`test` instructions test whether a condition is true. If it\nis, the next instruction will be executed. Otherwise,\nthere will be a branch to the failure label.\n\nThe condition tested by this instruction is `is_tuple`, that is\nwhether its operand is a tuple.  The operand is `{x,0}`, which is the\nregister for the first argument for the function. If `{x,0}` does not\ncontain a tuple, execution will continue at the failure label. `{f,3}`\nmeans that that the failure label is `3`. The code at label `3` will\ncause a `function_clause` exception.\n\n```\n    {test,test_arity,{f,3},[{x,0},4]}.\n```\n\nThe `test_arity` instruction tests whether the first operand (which\nmust be a tuple) has the size given by the second operand. The first\noperand is `{x,0}` and the second operand is `4`. The failure label is\nthe same as for the previous instruction.\n\n```\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n```\n\nWhen those two instructions are executed, the previous instructions have\nestablished that `{x,0}` contains a tuple of arity 4.\n`get_tuple_element` takes three operands. The first is the source\ntuple, `{x,0}`, the second is the **zero-based** index into the tuple,\nand the third operand is the register into which the element from the\ntuple should be stored. Note that there is no failure label because it\ncannot fail.\n\nSo the first `get_tuple_element` instruction fetches the first element\nof the tuple and stores it in the `{x,1}` register, and the second\n`get_tuple_element` instruction fetches the second element and stores\nit into the `{x,2}` register.\n\n```\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n```\n\n`is_eq_exact` is again a `test` instruction. It tests\nwhether the contents of `{x,1}` is exactly equal (that is,\n`=:=`) to the atom `tag`. If not, execution will continue\nat the failure label `3`.\n\nThat concludes the function header. The next instruction is in the\nbody of the function that will build the `{ok,A}` tuple:\n\n```\n    {test_heap,3,3}.\n```\n\nThe `test_heap` instruction ensures that there is sufficient free\nspace on the heap to construct a term. The first operand (the first\n`3`) says that the following instructions will need 3 words on the\nheap. A tuple has a header word, followed by the elements, so a tuple\nwith 2 elements needs 3 heap words in total.\n\nIf there is not sufficient room on the heap, the `test_heap`\ninstruction will do a garbage collection to find some fresh heap\nspace. The second operand (the second `3`) is the number of `x`\nregisters that have values that must be preserved during garbage\ncollection. The `3` means that `{x,0}`, `{x,1}`, and `{x,2}` have live\nvalues.\n\n```\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n```\n\nThose three instructions build the tuple, putting a tagged\npointer to the tuple in `{x,0}`.\n\n```\n    return.\n```\n\n`return` returns from the function. The return value is the\nvalue in `{x,0}`.\n\n## Optimizing this code\n\nTesting that a term is a tuple of a certain size with a specific atom\nas the first element is a common operation (think records). Therefore\nthe BEAM machine has an `is_tagged_tuple` instruction that does the\nwork of 4 other instructions.\n\nUsing that instruction, this code:\n\n\u003cpre class=\"highlight\"\u003e\n    \u003cb\u003e{test,is_tuple,{f,3},[{x,0}]}.\u003c/b\u003e\n    \u003cb\u003e{test,test_arity,{f,3},[{x,0},4]}.\u003c/b\u003e\n    \u003cb\u003e{get_tuple_element,{x,0},0,{x,1}}.\u003c/b\u003e\n    {get_tuple_element,{x,0},1,{x,2}}.\n    \u003cb\u003e{test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\u003c/b\u003e\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n\u003c/pre\u003e\n\ncan be rewritten like this:\n\n\u003cpre class=\"highlight\"\u003e\n    \u003cb\u003e{test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\u003c/b\u003e\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n\u003c/pre\u003e\n\nThis is a nice reduction in code size and execution\ntime. However, this optimization is not safe.\n\nWhy?\n\nConsider the `{test_heap,3,3}` instruction. The second `3` says\nthat 3 `x` registers are live, namely `{x,0}`, `{x,1}`, and `{x,2}`.\nClearly, `{x,0}` and `{x,2}` are live, but what about `{x,1}`?\nWe removed the `get_tuple_element` instruction that assigned `{x,1}`\na value, so the value of `{x,1}` is undefined.\n\nPassing undefined register values to the garbage collector is the kind\nof bug that could take weeks to track down. In fact, there will\nprobably be a future blog post about that kind of bug and how two\ntools were born as result of that bug.\n\nReluctantly, in order to make the optimization safe, we must keep\nthe `get_tuple_element` instruction that assigns to `{x,1}`:\n\n\u003cpre class=\"highlight\"\u003e\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    \u003cb\u003e{get_tuple_element,{x,0},0,{x,1}}.\u003c/b\u003e\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n\u003c/pre\u003e\n\nAnother possibility in this case would be to assign an empty list\n(called `nil` in the BEAM assembly language) to `{x,1}`:\n\n\u003cpre class=\"highlight\"\u003e\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    \u003cb\u003e{move,nil,{x,1}}.\u003c/b\u003e\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n\u003c/pre\u003e\n\nHowever, in this very simple example, another optimization will\nactually allow the compiler to remove the assignment to `{x,1}`:\n\n\u003cpre class=\"highlight\"\u003e\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    \u003cb\u003e{test_heap,3,1}.\u003c/b\u003e\n    \u003cb\u003e{get_tuple_element,{x,0},1,{x,2}}.\u003c/b\u003e\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n\u003c/pre\u003e\n\nThe `test_heap` and `get_tuple_element` instructions have been swapped.\nNote that the number of live register have been adjusted in the `test_heap`\ninstruction. It is now `1` instead of `3`.\n\nIn general, though, the compiler might have to abandon an optimization\nor keep an instruction that assigns a register to avoiding feeding the\ngarbage collector undefined values.\n\n## The final straw\n\nDuring the development of OTP 21, we realized that we have reached the\nlimit for improving the optimizations that operates on the BEAM\nassembly language. In particular, we wanted to make the optimization\ncalled the [delayed sub binary creation][bin_matching] applicable in\nmore circumstances. It turned out that would it be hard or impossible\nto substantially improve the optimization by working on BEAM assembly\nlanguage.\n\n[bin_matching]: http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries\n\nApart from the problem of leaving undefined registers, as illustrated\nin the previous optimization example, there is also the complexity of\ntraversing and analyzing BEAM instructions. The BEAM instruction set\nwas not designed to be optimizer-friendly.\n\n## Conclusion\n\nAs I have tried to show with the example above, one of the hardest\nparts of working with BEAM code is that register allocation has\nalready been done and that instructions that may do a garbage\ncollection (such as `test_heap`) have already been added.\n\nEarly this year (2018), we decided that we should introduce a new\nintermediate format to alleviate the problems with optimizing BEAM\ncode. It should be close enough to BEAM code to allow\nlow-level optimizations such as the `is_tagged_tuple` optimization\ndescribed in this blog post, but register allocation should not have\nbeen done, and `test_heap` and similar instructions should not have\nbeen added. It should also be more regular to make it easier to\ntraverse while doing optimizations.\n\nWe decided to make the new intermediate format [SSA-based][ssa].\nIn the next blog post, we will re-visit the example from this blog\npost and see what it looks like in the [new SSA-based intermediate\nformat][pr1935].\n\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form\n[pr1935]: https://github.com/erlang/otp/pull/1935\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"opt-traps-and-pitfalls"},"buildId":"ob9V3f7Iet6syJeg0QYgd","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_buildManifest.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_ssgManifest.js" async=""></script></body></html>