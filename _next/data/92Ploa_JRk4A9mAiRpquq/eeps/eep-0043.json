{"pageProps":{"index":{"id":"0043","content":"<pre><code>Author:         Björn-Egil Dahlberg &lt;egil(at)Erlang.org&gt;\nStatus:         Draft\nType:           Standards Track\nCreated:        04-Apr-2013\nErlang-Version: R17A\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 43: <a href=\"eep-0043.md\" title=\"EEP Source\"> Maps</a></h2>\n\n<h1>Abstract</h1>\n\n<p>The journey of Maps and this EEP has been long and by no means a\nstraight-forward and continuous one. I had a crystal clear picture of what I\nwanted Maps to be when we first started discussing it within OTP about\ntwo-three years ago. This EEP resembles that vision but it has had a lot of\ncontributions of other ideas from both within and outside of OTP.</p>\n\n<p>The idea was a data-type, a syntax aware mapping of key-value associations\nwith pattern matching. A syntax similar to records but without the hazzle of\ncompile-time dependency and with arbitrary terms as keys. Order was not\nimportant and it could be implemented with a Hash-Array-Mapped-Trie with good\nperformance and memory trade-offs. This was a different approach than to replace\nrecords. It was meant to replace records where suitable and in other regards\nnot be a replacement but its own <em>thing</em>.</p>\n\n<blockquote>\n  <p>From the community there has been many wishes of a Map like data-type and a\nfew suggestions.  The one suggestion that stands out is of course the Frames\nproposal from Richard O'Keefe. It is the most complete proposal I've seen and\nis very well thought out. Its goal is to be a record replacement and the\nproposal satisfies this goal very well.</p>\n</blockquote>\n\n<ul>\n<li>If Frames are that good, why a separate EEP?</li>\n<li>It boils down to goals and constraints.</li>\n</ul>\n\n<p>A record replacement is just that, a replacement.\nIt's like asking the question, \"What do we have?\" instead of \"What can we get?\"\nThe instant rebuttal would be \"What do we need?\" I say Maps.</p>\n\n<p>Frames has certainly inspired and influenced Maps. In many regards Maps also\nencompasses Frames but Maps tries to do more. In the end I believe they are\ntwo different things and have different goals.</p>\n\n<p>This EEP suggests a new built in data-type for Erlang, the map, \n<code>#{ Key =&gt; Value }</code>.</p>\n\n<p>The new data-type shall have semantics, syntax and operations that:</p>\n\n<ul>\n<li>provides an association set from key terms to value terms which can be\nconstructed, accessed and updated using language syntax</li>\n<li>can be uniquely distinguished from every other data-type in the language</li>\n<li>has no compile-time dependency for constructing, accessing or updating\ncontents of maps nor for passing maps between modules, processes or over\nErlang distribution</li>\n<li>can be used in matching expressions in the language</li>\n<li>has a one-to-one association between printing and parsing the data-type </li>\n<li>has a well defined order between terms of the type and other Erlang types</li>\n<li>has at most O(log N) time complexity in insert and lookup operations, where \nN is the number of key-value associations.</li>\n</ul>\n\n<p>Similar data-types exists in other languages, i.e.  <a href=\"http://perldoc.perl.org/perldata.html\" title=\"perldata - perldoc.perl.org\">perl hashes</a>,\n<a href=\"http://ruby-doc.org/core-1.9.3/Hash.html\" title=\"Class: Hash (Ruby 1.9.3)\">ruby hashes</a>, <a href=\"http://docs.python.org/tutorial/datastructures.html#dictionaries\" title=\"5. Data Structures - Python v2.7.3 documentation\">python dictionaries</a>, or\n<a href=\"http://docs.scala-lang.org/overviews/collections/maps.html\" title=\"Collections - Maps - Scala Documentation\">scala maps</a>.</p>\n\n<h1>Specification</h1>\n\n<p>A map <code>M</code> consists of a number of <em>associations</em> and keeps an association\nfrom key terms <code>K1..Kn</code> to value terms <code>V1..Vn</code> where no two keys <em>match</em>.\nAny term, compound or otherwise, is a viable key or value. Terms of type Map\nare recognized by guard tests <code>erlang:is_map/1</code>. There are no operators\nacting on maps. Within maps there are two infix operators. An association\noperator, <code>=&gt;</code>, pairs a key to a value and is used in creation and updates.\nA set-value operator, <code>:=</code>, is used to update a value on an already\nexisting and matching key. The set-value operator is also used in matching\nto get the associated value from a key.</p>\n\n<h2>Terminology</h2>\n\n<p>The <em>size</em> of a map is the number of associations in its set.</p>\n\n<p>An <em>association</em> is a key-value pair of key <em>K</em> to value <em>V</em> in a Map.</p>\n\n<p>Two keys, <code>K1</code> and <code>K2</code> are <em>matching</em> if, <code>true = K1 =:= K2</code>.</p>\n\n<h2>Syntax</h2>\n\n<p>Defined syntax for declaring, updating and matching maps.</p>\n\n<h3>Construction syntax</h3>\n\n<p>Constructing a new map is done by letting an expression <code>K</code> be associated to\nanother expression <code>V</code>:</p>\n\n<pre><code>#{ K =&gt; V }\n</code></pre>\n\n<p>New maps may include multiple associations at construction by listing every\nassociation:</p>\n\n<pre><code>#{ K1 =&gt; V1, .. Kn =&gt; Vn }\n</code></pre>\n\n<p>An empty map is constructed by not associating any terms with each other:</p>\n\n<pre><code>#{}\n</code></pre>\n\n<p>All keys and values in the map are terms. Any expression is first evaluated and\nthen the resulting terms are used as <em>key</em> and <em>value</em> respectively.</p>\n\n<p>Keys and values are separated by the <code>=&gt;</code> arrow and associations are\nseparated by <code>,</code>.</p>\n\n<p>Examples:</p>\n\n<pre><code>M0 = #{},                   % empty map\nM1 = #{ a =&gt; &lt;&lt;\"hello\"&gt;&gt; }, % single association with literals\nM2 = #{ 1 =&gt; 2, b =&gt; b },   % multiple associations with literals\nM3 = #{ A =&gt; B },           % single association with variables\nM4 = #{ {A, B} =&gt; f() }.    % compound key associated to an evaluated expression\n</code></pre>\n\n<p>where, <code>A</code> and <code>B</code> are any expressions and <code>M0</code> through <code>M4</code> are the resulting\nmap terms.</p>\n\n<p>If two matching keys are declared, the latter key will take precedent.</p>\n\n<p>Example:</p>\n\n<pre><code>1&gt; #{ 1 =&gt; a, 1 =&gt; b }.\n#{ 1 =&gt; b }\n2&gt; #{ 1.0 =&gt; a, 1 =&gt; b }.\n#{ 1 =&gt; b, 1.0 =&gt; a }\n</code></pre>\n\n<p>The order in which the expressions constructing the keys and their\nassociated values are evaluated is not defined. The syntactic order of\nthe key-value pairs in the construction is of no relevance, except in\nthe above mentioned case of two matching keys.</p>\n\n<p>A simple BNF grammar for the construction follows:</p>\n\n<pre><code> &lt;map-construct&gt;  ::= '#{' &lt;key-value-exprs&gt; '}'\n&lt;key-value-exprs&gt; ::= /* empty */\n                    | &lt;key-value-list&gt;\n &lt;key-value-list&gt; ::= &lt;key-value-assoc&gt; \n                    | &lt;key-value-assoc&gt; ',' &lt;key-value-list&gt;\n&lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;\n           &lt;expr&gt; ::= &lt;Erlang-expression&gt;\n</code></pre>\n\n<h3>Update syntax</h3>\n\n<p>Updating a map has similar syntax as constructing it.</p>\n\n<p>An expression defining the map to be updated is put in front of the expression\ndefining the keys to be updated and their respective values.</p>\n\n<pre><code>M#{ K =&gt; V }\n</code></pre>\n\n<p>where <code>M</code> is an term of type map and <code>K</code> and <code>V</code> are any expression.</p>\n\n<p>If key <code>K</code> does not <em>match</em> any existing key in the map, a new association\nwill be created from key <code>K</code> to value <code>V</code>.  If key <code>K</code> <em>matches</em> an existing\nkey in map <code>M</code> its associated value will be replaced by the new value <code>V</code>. In both\ncases the evaluated map expression will return a new map.</p>\n\n<p>If <code>M</code> is not of type map an exception of type <code>badmap</code> is thrown.</p>\n\n<p>To only update an existing value, the following syntax is used,</p>\n\n<pre><code>M#{ K := V }\n</code></pre>\n\n<p>where <code>M</code> is an term of type map, <code>V</code> is an expression and <code>K</code> is an expression\nwhich evaluates to an existing key in <code>M</code>.</p>\n\n<p>If key <code>K</code> does not <em>match</em> any existing keys in map <code>M</code> an exception of type\n<code>badarg</code> will be triggered at runtime. If a <em>matching</em> key <code>K</code> is present in\nmap <code>M</code> its associated value will be replaced by the new value <code>V</code> and the\nevaluated map expression returns a new map.</p>\n\n<p>If <code>M</code> is not of type map an exception of type <code>badmap</code> is thrown.</p>\n\n<p>Examples:</p>\n\n<pre><code>M0 = #{},\nM1 = M0#{ a =&gt; 0 },\nM2 = M1#{ a =&gt; 1, b =&gt; 2 },\nM3 = M2#{ \"function\" =&gt; fun() -&gt; f() end },\nM4 = M3#{ a := 2, b := 3 }.  % 'a' and 'b' was added in `M1` and `M2`.\n</code></pre>\n\n<p>where <code>M0</code> is any map. It follows that <code>M1 .. M4</code> are maps as well.</p>\n\n<p>More Examples:</p>\n\n<pre><code>1&gt; M = #{ 1 =&gt; a }.\n#{ 1 =&gt; a }\n\n2&gt; M#{ 1.0 =&gt; b }.\n#{ 1 =&gt; a, 1.0 =&gt; b }.\n\n3&gt; M#{ 1 := b }.\n#{ 1 =&gt; b }\n\n4&gt; M#{ 1.0 := b }.\n** exception error: bad argument\n</code></pre>\n\n<p>As in construction, the order in which the key and value expressions\nare evaluated are not defined. The\nsyntactic order of the key-value pairs in the update is of no\nrelevance, except in the case where two keys match, in which\ncase the latter value is used.</p>\n\n<p>A simple BNF grammar for map updates follows:</p>\n\n<pre><code> &lt;map-construct&gt;  ::= &lt;map-expr&gt; '#{' &lt;key-value-exprs&gt; '}'\n&lt;key-value-exprs&gt; ::= /* empty */\n                    | &lt;key-value-list&gt;\n &lt;key-value-list&gt; ::= &lt;key-value&gt; \n                    | &lt;key-value&gt; ',' &lt;key-value-list&gt;\n      &lt;key-value&gt; ::= &lt;key-value-assoc&gt;\n                    | &lt;key-value-exact&gt;\n&lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;\n&lt;key-value-exact&gt; ::= &lt;expr&gt; ':=' &lt;expr&gt;\n       &lt;map-expr&gt; ::= &lt;Erlang expression evaluating to a term of type map&gt;\n           &lt;expr&gt; ::= &lt;Erlang expression&gt;\n</code></pre>\n\n<h3>Accessing a single value</h3>\n\n<p>For accessing single values in maps, let us use an de-association:</p>\n\n<pre><code>V = M#{ K }.\n</code></pre>\n\n<p>Where <code>M</code> is a Map and <code>K</code> is any term.</p>\n\n<p>If key <code>K</code> <em>matches</em> to an existing key in map <code>M</code> the associated value\nwill be bound to <code>V</code>. If key <code>K</code> does not <em>match</em> to any existing key in\nmap <code>M</code> an exception <code>badarg</code> will occur in runtime.</p>\n\n<p>Examples:</p>\n\n<pre><code>M1 = #{ a =&gt; 1, c =&gt; 3 },\n3 = M1#{ c }.\n\nM2 = #{ 1.0 =&gt; a },\na = M2#{ 1 }.\n</code></pre>\n\n<h3>Matching syntax</h3>\n\n<p>Matching of key-value associations from maps, exemplified with the\nmatching operator, is done in the following way:</p>\n\n<pre><code>#{ K := V } = M\n</code></pre>\n\n<p>where <code>M</code> is any map. The key <code>K</code> has to be an expression with bound variables\nor a literals, and <code>V</code> can be any pattern with either bound or unbound variables.\nIf variables in <code>V</code> are unbound, it will be bound to the value associated\nwith the key <code>K</code>, which has to exist in the map <code>M</code>. If variables in <code>V</code> are\nbound, it has to match the value associated with <code>K</code> in <code>M</code>.</p>\n\n<p>Example:</p>\n\n<pre><code>M = #{ a =&gt; {1,2}},\n#{ a := {1,B}} = M.\n</code></pre>\n\n<p>This will bind variable <code>B</code> to integer <code>2</code>.</p>\n\n<p>Similarly, multiple values from the map may be matched:</p>\n\n<pre><code>#{ K1 := V1, .., Kn := Vn } = M\n</code></pre>\n\n<p>where keys <code>K1 .. Kn</code> are any expressions with literals or bound variables. If all\nkeys exists in map <code>M</code> all variables in <code>V1 .. Vn</code> will be matched to the\nassociated values of there respective keys.</p>\n\n<p>If the matching conditions are not met, the match will fail, either with</p>\n\n<ol>\n<li>a <code>badmatch</code> exception, if used in the context of the matching operator\n as in the example, </li>\n<li>or resulting in the next clause being tested in function heads and\n case expressions.</li>\n</ol>\n\n<p>Matching in maps only allows for <code>:=</code> as delimiters of associations.</p>\n\n<p>The order in which keys are declared in matching has no relevance.</p>\n\n<p>Duplicate keys are allowed in matching and will match each pattern associated\nto the keys.</p>\n\n<pre><code>#{ K := V1, K := V2 } = M\n</code></pre>\n\n<p>Matching an expression against an empty map literal will match its type but\nno variables will be bound:</p>\n\n<pre><code>#{} = Expr\n</code></pre>\n\n<p>This expression will match if the expression <code>Expr</code> is of type map, otherwise\nit will fail with an exception <code>badmatch</code>.</p>\n\n<p>The grammar for the matching syntax is similar to that of construction.</p>\n\n<h4>Matching syntax: Example with literals in function heads</h4>\n\n<p>Matching of literals as keys are allowed in function heads.</p>\n\n<pre><code>%% only start if not_started\nhandle_call(start, From, #{ state := not_started } = S) -&gt;\n...\n    {reply, ok, S#{ state := start }};\n\n%% only change if started\nhandle_call(change, From, #{ state := start } = S) -&gt;\n...\n    {reply, ok, S#{ state := changed }};\n</code></pre>\n\n<h4>Matching syntax: Frequency example</h4>\n\n<p>More matching syntax, calculating frequency of terms in a list.</p>\n\n<pre><code>freq(Is)                    -&gt; freq(Is, #{}).\nfreq([I|Is], #{I := C} = M) -&gt; freq(Is, M#{ I := C + 1});\nfreq([I|Is], M)             -&gt; freq(Is, M#{ I =&gt; 1 });\nfreq([], M)                 -&gt; maps:to_list(M).\n</code></pre>\n\n<p>Equivalent code with <code>gb_trees</code> for comparison:</p>\n\n<pre><code>freq(Is)        -&gt; freq(Is, gb_trees:empty()).\nfreq([I|Is], T) -&gt;\n    case gb_trees:lookup(I, T) of \n        none       -&gt; freq(Is, gb_trees:enter(I, 1), T);\n        {value, V} -&gt; freq(Is, gb_trees:enter(I, V + 1, T))\n    end;\nfreq([], T) -&gt; gb_trees:to_list(T).\n</code></pre>\n\n<h4>Matching syntax: File information example</h4>\n\n<p>Old API's could be refined to use map syntax:</p>\n\n<pre><code>1&gt; {ok, #{ type := Type, mtime := Mtime }} = file:read_file_info(File).\n2&gt; io:format(\"type: ~p, mtime: ~p~n\", [Type, Mtime]).\ntype: regular, mtime: {{2012,7,18},{19,59,18}}\nok\n3&gt;\n</code></pre>\n\n<h3>Map comprehension syntax</h3>\n\n<p>Map comprehension declaration:</p>\n\n<pre><code>M1 = #{ E0 =&gt; E1 || K := V &lt;- M0  }\n</code></pre>\n\n<p>where <code>M0</code> is any Map, <code>E0</code> and <code>E1</code> are any erlang expression, <code>K</code> and <code>V</code>\nconstitutes the pattern to be matched by each association in <code>M0</code>.</p>\n\n<p>For each sequence in the generator an association is created from the evaluated\nexpression <code>E0</code> to the evaluated expression <code>E1</code>. </p>\n\n<p>If <code>M0</code> is not a Map, then a runtime exception of type <code>{bad_generator, M0}</code>\nwill be generated.</p>\n\n<p>A simple BNF grammar for map comprehension follows:</p>\n\n<pre><code>      &lt;comprehension&gt; ::= '#{' &lt;key-value-assoc&gt; '||' &lt;comprehension-exprs&gt; '}'\n&lt;comprehension-exprs&gt; ::= &lt;comprehension-expr&gt;\n                        | &lt;comprehension-exprs&gt; ',' &lt;comprehension-expr&gt;\n &lt;comprehension-expr&gt; ::= &lt;generator&gt;\n                        | &lt;filter&gt;\n          &lt;generator&gt; ::= &lt;key-value-exact&gt; '&lt;-' &lt;expr&gt;\n             &lt;filter&gt; ::= &lt;expr&gt;\n    &lt;key-value-assoc&gt; ::= &lt;expr&gt; '=&gt;' &lt;expr&gt;\n    &lt;key-value-exact&gt; ::= &lt;expr&gt; ':=' &lt;expr&gt;\n               &lt;expr&gt; ::= &lt;Erlang expression&gt;\n</code></pre>\n\n<p>Each association from all generators, which satisfies the filters, has an\nenvironment that consist of the initial environment and the environment\nfor the association.  </p>\n\n<p>Examples:</p>\n\n<pre><code>M0 = #{ K =&gt; V*2  || K := V &lt;- map() },\nM1 = #{ I =&gt; f(I) || I &lt;- list() },\nM2 = #{ K =&gt; V    || &lt;&lt;L:8,K:L/binary,V/float&gt;&gt; &lt;= binary() }.\n</code></pre>\n\n<p>Map generators may also be used in binary and list comprehensions.</p>\n\n<p>Examples:</p>\n\n<pre><code>B1 = &lt;&lt; &lt;&lt;V:8&gt;&gt; || _ := V &lt;- map() &gt;&gt;,\nL1 = [ {K,V} || K := V &lt;- map() ].\n</code></pre>\n\n<h3>Dialyzer and Type specification</h3>\n\n<p>Keys known before hand can be specified directly and uniquely for a map.</p>\n\n<pre><code>-spec func(Opt, M) -&gt; #{ 'status' =&gt; S, 'c' =&gt; integer() } when\n      Opt :: 'inc' | 'dec',\n        M :: #{ 'status' =&gt; S, 'c' =&gt; integer() },\n        S :: 'update' | 'keep'.\n\nfunc(inc, #{ status := update, c := C} = M) -&gt; M#{ c := C + 1};\nfunc(dec, #{ status := update, c := C} = M) -&gt; M#{ c := C - 1};\nfunc(_,   #{ status := keep } = M)          -&gt; M.\n</code></pre>\n\n<p>It could also be specified by type only.</p>\n\n<pre><code>-spec plist_to_map(Ls) -&gt; #{ binary() =&gt; integer() } when\n      Ls :: [{binary(), integer()}].\n\nplist_to_map([], M) -&gt;\n    M;\nplist_to_map([{K,V}|Ls], M) when is_binary(K), is_integer(V) -&gt;\n    plist_to_map(Ls, M#{ K =&gt; V });\nplist_to_map([_|Ls], M) -&gt;\n    plist_to_map(Ls, M).\n</code></pre>\n\n<p>It can similarly be specified as a type.</p>\n\n<pre><code>-type map1() :: #{ binary() =&gt; integer() }.\n-type map2() :: #{ &lt;&lt;\"list1\"&gt;&gt; | &lt;&lt;\"list2\"&gt;&gt; =&gt; [numbers()] }.\n</code></pre>\n\n<h2>Functions and Semantics</h2>\n\n<p><em>The module implementing the functions is currently named in plural, <code>maps</code> in the\nsame spirit as <code>lists</code>, <code>gb_trees</code>, <code>sets</code> etc but the singular <code>map</code> is shorter\nand may be more desirable.</em></p>\n\n<p>Functions and semantics for maps. Originally much inspiration was from\nRichard O'Keefes frames proposal.</p>\n\n<h3>Erlang module extension</h3>\n\n<h5><code>erlang:is_map(M :: term()) -&gt; boolean().</code></h5>\n\n<p>This function is a guard function.</p>\n\n<p>Syntax equivalence: <code>try #{} = M, true catch error:{badmatch,_} -&gt; false end</code>.</p>\n\n<p>The function returns <code>true</code> if M is a map otherwise <code>false</code>.</p>\n\n<h5><code>erlang:map_size(M :: map()) -&gt; non_neg_integer().</code></h5>\n\n<p>This function is a guard function.</p>\n\n<p>Syntax equivalence: <em>none</em>.</p>\n\n<p>The function returns the number of key-value pairs in the map.\n  This operation happens in constant time.</p>\n\n<p>Same as <code>maps:size(M)</code>.</p>\n\n<h3>maps module</h3>\n\n<h5><code>maps:remove(K0 :: term(), M0 :: map()) -&gt; M1 :: map().</code></h5>\n\n<p>Syntax equivalence: <code>#{ K =&gt; V || K := V &lt;- M0, K =/= K0 }</code>.\n  <em>Only with comprehensions</em></p>\n\n<p>The function removes the key <code>K0</code>, if it exists, and its associated value from\n  map <code>M0</code> and returns a new map <code>M1</code> without key <code>K0</code>.</p>\n\n<p>Same as, <code>maps:from_list([{K,V}||{K,V} &lt;- maps:to_list(M0), K =/= K0])</code></p>\n\n<h5><code>maps:get(K :: term(), M :: map()) -&gt; V :: term().</code></h5>\n\n<p>Syntax equivalence: <code>M#{ K }</code>.</p>\n\n<p>Returns the value <code>V</code> associated with key <code>K</code> if map <code>M</code> contains a key\n  that <em>matches</em> <code>K</code>.  If no value is associated with key <code>K</code> then the call will\n  fail with an exception.</p>\n\n<h5><code>maps:keys(M :: map()) -&gt; [K1, .., Kn].</code></h5>\n\n<p>Syntax equivalence: <code>[K || K := _ &lt;- M]</code>.</p>\n\n<p>Returns a complete list of Keys, in arbitrary order, which resides within\n  map <code>M</code>.</p>\n\n<p>Same as, <code>[K || {K,_} &lt;- maps:to_list(M)]</code>.</p>\n\n<h5><code>maps:find(K :: term(), M :: map()) -&gt; {ok, V :: term()} | error.</code></h5>\n\n<p>Syntax equivalence: <code>try #{ K := V } = M, V catch error:{badmatch,_} -&gt; error end</code>.</p>\n\n<p>Returns a tuple <code>{ok, V}</code> with value <code>V</code> associated with key <code>K</code> if map <code>M</code>\n  contains key <code>K</code>.  If no value is associated with key <code>K</code> then the function\n  will return <code>error</code>.</p>\n\n<h5><code>maps:fold(F :: fun((K :: term(), V :: term(), In :: term()) -&gt; Out :: term()), A :: term(), M :: map()) -&gt; Result :: term().</code></h5>\n\n<p>Syntax equivalence: <em>none</em></p>\n\n<p>Calls <code>F(K, V, In)</code> for every key <code>K</code> to value <code>V</code> association in map <code>M</code> in\n  arbitrary order. The function fun <code>F/3</code> must return a new accumulator\n  which is passed to the next successive call. <code>maps:fold/3</code> returns the final\n  value of the accumulator. The initial accumulator value <code>A</code> is returned if\n  the map is empty.</p>\n\n<p>Same as, <code>lists:foldl(fun({K,V}, In) -&gt; F(K,V,In) end, A, maps:to_list(M))</code>.</p>\n\n<h5><code>maps:from_list([{K1,V1}, .., {Kn,Vn}]) -&gt; M :: map().</code></h5>\n\n<p>Syntax equivalence: <code>#{ K1 =&gt; V1, .., Kn =&gt; Vn }</code></p>\n\n<p>The function takes a list of key-value tuples elements and builds a\n  map. The associations may be in any order and both keys and values in the\n  association may be of any term. If the same key appears more than once,\n  the latter (rightmost) value is used and the previous values are ignored.</p>\n\n<h5><code>maps:is_key(K :: term(), M :: map()) -&gt; bool().</code></h5>\n\n<p>Syntax equivalence: <code>try #{ K := _ } = M, true catch error:{badmatch, _} -&gt; false end</code>.</p>\n\n<p>Returns <code>true</code> if map <code>M</code> contains a key that <em>matches</em> <code>K</code>.</p>\n\n<h5><code>maps:map(F :: function(), M0 :: map()) -&gt; M1 :: map().</code></h5>\n\n<p>Syntax equivalence: <code>#{ K =&gt; F(K,V) || K := V &lt;- M }</code>.\n  <em>Only with comprehensions</em></p>\n\n<p>The function produces a new map <code>M1</code> by calling the function fun <code>F(K, V)</code> for\n  every key <code>K</code> to value <code>V</code> association in map <code>M0</code> in arbitrary order.\n  The function fun <code>F/2</code> must return the value to be associated with key <code>K</code> for\n  the new map <code>M1</code>.</p>\n\n<p>Same as, <code>maps:from_list(lists:map(fun({K,V}) -&gt; {K, F(K,V)} end, maps:to_list(M)))</code>.</p>\n\n<h5><code>maps:new() -&gt; M :: map().</code></h5>\n\n<p>Syntax equivalence: <code>#{}</code>.</p>\n\n<p>Returns a new empty map.</p>\n\n<p>Same as, <code>maps:from_list([])</code>.</p>\n\n<h5><code>maps:size(M :: map()) -&gt; Size :: non_neg_integer().</code></h5>\n\n<p>Syntax equivalence: <em>none</em>.</p>\n\n<p>The function returns the number of key-value associations in the map.\n  This operation happens in constant time.</p>\n\n<p>Same as <code>erlang:map_size(M)</code>.</p>\n\n<h5><code>maps:put(K :: term(), V :: term(), M0 :: map()) -&gt; M1 :: map().</code></h5>\n\n<p>Syntax equivalence: <code>M0#{ K =&gt; V }</code>.</p>\n\n<p>Associates key <code>K</code> with value <code>V</code> and inserts the association into map <code>M0</code>.\n  If a key exists that <em>matches</em> <code>K</code>, the old associated value is\n  replaced by value <code>V</code>.\n  The function returns a new map <code>M1</code> containing the new association.</p>\n\n<p>Same as, <code>maps:from_list(maps:to_list(M0) ++ [{K,V}])</code>.</p>\n\n<h5><code>maps:to_list(M :: map()) -&gt; [{K1,V1}, ..., {Kn,Vn}].</code></h5>\n\n<p>Syntax equivalence: <code>[{K, V} || K := V &lt;- M]</code>.</p>\n\n<p>Where the pairs, <code>[{K1,V1}, ..., {Kn,Vn}]</code>, are returned in arbitrary order.</p>\n\n<h5><code>maps:update(K :: term(), V :: term, M0 :: map()) -&gt; M1 :: map()</code></h5>\n\n<p>Syntax equivalence: <code>M0#{ K := V }</code>.</p>\n\n<p>If a key exists that <em>matches</em> <code>K</code>, the old associated value is\n  replaced by value <code>V</code>. The function returns a new map <code>M1</code> containing\n  the new associated value.</p>\n\n<p>Same as, <code>maps:from_list(maps:to_list(M0) ++ [{K,V}])</code>.</p>\n\n<h5><code>maps:values(M :: map()) -&gt; [V1, .., Vn].</code></h5>\n\n<p>Syntax equivalence: <code>[V || _ := V &lt;- M]</code>.</p>\n\n<p>Returns a complete list of values, in arbitrary order, contained in map <code>M</code>.</p>\n\n<p>Same as, <code>[V || {_,V} &lt;- maps:to_list(M)]</code>.</p>\n\n<h5><code>maps:without([K1, .., Kn] = Ks, M0 :: map()) -&gt; M1 :: map().</code></h5>\n\n<p>Syntax equivalence: <code>#{ K =&gt; V || K := V &lt;- M0, not lists:member(K, Ks) }</code>. \n  <em>Only with comprehensions</em></p>\n\n<p>Removes keys <code>K1</code> through <code>Kn</code>, and their associated values, from map <code>M0</code> and\n  returns a new map <code>M1</code>.</p>\n\n<p>Same as, <code>maps:from_list([{K,V}||{K,V} &lt;- maps:to_list(M0), not lists:member(K, Ks)])</code>.</p>\n\n<h5><code>maps:merge(M0 :: map(), M1 :: map()) -&gt; M2 :: map().</code></h5>\n\n<p>Syntax equivalence: <em>none</em></p>\n\n<p>Merges two maps into a single map. If two <em>matching</em> keys exists in both maps the\n  value in map <code>M0</code> will be superseded by the value in map <code>M1</code>.</p>\n\n<h2>Equality and Ordering</h2>\n\n<h3>Equality</h3>\n\n<p>In the case of term <code>A</code> and term <code>B</code> both are maps,</p>\n\n<ul>\n<li>If <code>A</code> and <code>B</code> have different sizes, then <code>A</code> and <code>B</code> are not equal.</li>\n<li>Otherwise, if all corresponding keys of <code>A</code> and <code>B</code> are pair-\nwise equal with their corresponding values, then <code>A</code> and <code>B</code> are equal.</li>\n<li>Otherwise, <code>A</code> and <code>B</code> are not equal.</li>\n</ul>\n\n<p>It follows that two maps are equal if, and only if, they are of\nthe same, <em>type</em>, <em>size</em> and all corresponding key-value associations are\npairwise equal.</p>\n\n<h3>Ordering</h3>\n\n<p>The term order is defined in <a href=\"http://www.Erlang.org/download/erl_spec47.ps.gz\" title=\"Erlang specification 4.7\">Erlang specification 4.7</a> and quoted\nbelow:</p>\n\n<blockquote>\n  <ul>\n<li><p>The terms are primarily ordered according to their type, in the following order: </p>\n\n<pre><code>numbers &lt; atoms &lt; refs &lt; ports &lt; PIDs &lt; tuples &lt; empty list &lt; conses &lt; binary\n</code></pre></li>\n</ul>\n</blockquote>\n\n<p>The specification is incomplete here, the actual term order is:</p>\n\n<pre><code>numbers &lt; atoms &lt; refs &lt; funs &lt; ports &lt; pids &lt; tuples &lt; empty list &lt; conses &lt; binaries\n</code></pre>\n\n<p>The Maps data-type are ordered next after tuples:</p>\n\n<pre><code>numbers &lt; atoms &lt; refs &lt; funs &lt; ports &lt; pids &lt; tuples &lt; maps &lt; empty list &lt; conses &lt; binaries\n                                                        ----\n</code></pre>\n\n<p>Maps are then ordered first by their size and then according to their\nrespective keys and lastly by the associated values in Erlang term order. </p>\n\n<p>Given two maps, <code>M1</code> and <code>M2</code>, with the same size, they are compared\nso that each key, in Erlang term order of the keys, in <code>M1</code>\nis compared to the corresponding key of <code>M2</code>. All keys are\ncompared first, then the values, until a difference is found. If a key\nor value differs, the order of the respective terms, in Erlang term\norder, is the order of the maps. If no key-value pairs differ, the\nmaps are considered equal.</p>\n\n<p>Example:</p>\n\n<pre><code>&gt; #{ b =&gt; 2 } &gt; #{ a =&gt; 2 }.         % b &gt; a\ntrue\n&gt; #{ b =&gt; 2 } &gt; #{ a =&gt; 1, b =&gt; 2 }. % size 1 &lt; size 2\nfalse\n&gt; #{ b =&gt; 1 } &gt; #{ b =&gt; 2}.          % 1 &lt; 2\nfalse\n&gt; #{ b =&gt; 2, c =&gt; 3 } &gt; #{ b =&gt; 1, d =&gt; 3}.  % c &gt; d, compared before 2 and 1\nfalse\n&gt; #{ b =&gt; 1 } &gt; #{ 1 =&gt; 1}.          % b &gt; 1\ntrue\n&gt; #{ 1.0 =&gt; a } == #{ 1 =&gt; a }.      % 1.0 == 1\ntrue\n&gt; #{ 1.0 =&gt; a } =:= #{ 1 =&gt; a }.     % 1.0 =:= 1\nfalse\n</code></pre>\n\n<p>Maps are printed with keys in arbitrary order.</p>\n\n<h2>Operator Precedence</h2>\n\n<p>Map association operator and set-value operator is ordered last,\nafter match-operator and <code>catch</code>.</p>\n\n<pre><code>:\n#\nUnary + - bnot not\n/ * div rem band and          Left associative\n+ - bor bxor bsl bsr or xor   Left associative\n++ --                         Right associative\n== /= =&lt; &lt; &gt;= &gt; =:= =/=\nandalso\norelse\n= !                           Right associative\ncatch    \n=&gt; :=\n</code></pre>\n\n<p>It follows that the map expression:</p>\n\n<pre><code>#{ key =&gt; C = 1 + 2 }\n</code></pre>\n\n<p>will evaluate in the following order:</p>\n\n<pre><code>#{ key =&gt; ( C = ( 1 + 2 ) ) }\n</code></pre>\n\n<h2>Pattern matching</h2>\n\n<p>Pattern matching is very powerful Erlang tool. Maps introduces a couple of new\nfeatures with its pattern matching. </p>\n\n<h3>Pattern matching: Basics</h3>\n\n<p>We will exemplify using the match operator.</p>\n\n<p>Pattern matching with maps is similar to records on the surface. Keys requested\nin a LHS pattern will be bound with the values which is found in the\nRHS association map.</p>\n\n<pre><code>1&gt; #{ a := V } = #{ a =&gt; 1 }.\n#{ a =&gt; 1 }\n2&gt; 1 = V.\n1\n</code></pre>\n\n<p>Keys requested in a LHS pattern which is not found in the RHS map will produce\nan exception, <code>exception error: no match of right hand side value ...</code>.</p>\n\n<pre><code>1&gt; #{ not_in_map := V } = #{ a =&gt; 1 }.\n** exception error: no match of right hand side value #{ a =&gt; 1 }\n</code></pre>\n\n<p>Similarly, if a value for a requested key in the LHS pattern\ndoes not match the keys associated value in the RHS map\nthe match will produce an exception.</p>\n\n<pre><code>1&gt; #{ a := 10 } = #{ a =&gt; 1 }.\n** exception error: no match of right hand side value #{ a =&gt; 1 }\n</code></pre>\n\n<p>Only the keys requested will bind to associations. Any unrequested keys which\nresides within the map being matched will be ignored.</p>\n\n<pre><code>1&gt; #{ a := V1, b := V2 } = #{ a =&gt; 1, b =&gt; 2, c =&gt; 3}.\n#{ a =&gt; 1, b =&gt; 2, c =&gt; 3 }\n2&gt; 1 = V1.\n1\n3&gt; 2 = V2.\n2\n</code></pre>\n\n<p>The order of keys requested has no significance when pattern matching a map.</p>\n\n<pre><code>1&gt; #{ a := \"1\", b := \"2\" } = #{ a =&gt; \"1\", b =&gt; \"2\" }.\n#{ a =&gt; \"1\", b =&gt; \"2\" }\n2&gt; #{ b := \"2\", a := \"1\" } = #{ a =&gt; \"1\", b =&gt; \"2\" }.\n#{ a =&gt; \"1\", b =&gt; \"2\" }\n</code></pre>\n\n<h3>Pattern matching: Continued</h3>\n\n<p>The example below is a constructed example to illustrate the power of map\npattern matching.</p>\n\n<p>A match expression is evaluated so that variables used as keys in the expression\nare bound before they are evaluated (if possible).</p>\n\n<p>As an example, keys can be bound by other key-value associations.</p>\n\n<pre><code>1&gt; #{ K := V, id := K } = M = #{ id =&gt; b, a =&gt; 1, b =&gt; 2, c =&gt; 3}.\n#{ id =&gt; b, a =&gt; 1, b =&gt; 2, c =&gt; 3}\n2&gt; b = K.\nb\n3&gt; 2 = V.\n2\n</code></pre>\n\n<p>In this case, the bound key <code>id</code> is evaluated first and looked up in\nM, binding the variable <code>K</code>. The <code>K</code> bound to <code>b</code> can then be used to\nbind <code>V</code> to 2.</p>\n\n<p>Binding variables used as keys requires that there is a possible order of\nbinding without cycles. The reordering extends to all terms in a matching\nexpression, so that:</p>\n\n<pre><code>1&gt; { #{ X := Y }, X } = { #{ 5 =&gt; 10 }, 5 }.\n</code></pre>\n\n<p>with <code>X</code> and <code>Y</code> unbound, results in a successful match binding <code>X</code> to 5 and\n<code>Y</code> to 10.</p>\n\n<p>This is particular useful when updating specifics in map associations:</p>\n\n<pre><code>%% Function declared in module map_example\nupdate_values([{K, V1}|Ls], #{ K := V0 } = M) -&gt; update_values(Ls, M#{ K := V0 + V1 });\nupdate_values([_|Ls], M) -&gt; update_values(Ls, M);\nupdate_values([], M)     -&gt; M.\n</code></pre>\n\n<p>The first function clause is important here. Key <code>K</code> is bound in the tuple and\nwill be used to request value <code>V0</code> from map <code>M</code>. The map <code>M</code> is then updated to\nassociate key <code>K</code> with the new value <code>V0 + V1</code>.</p>\n\n<pre><code>%% In the Erlang shell\n1&gt; M = #{ \"a\" =&gt; 1, \"b\" =&gt; 2, \"c\" =&gt; 3 }.\n#{ \"a\" =&gt; 1, \"b\" =&gt; 2, \"c\" =&gt; 3 }\n\n2&gt; map_example:update_values([{\"b\", 10}, {\"c\", 20}, {\"d\", 30 }], M).\n#{ \"a\" =&gt; 1, \"b\" =&gt; 12, \"c\" =&gt; 23 }\n</code></pre>\n\n<p>Note that since key <code>\"d\"</code> does not reside in map <code>M</code> it fails to match the first\nclause and does not update the map with the association <code>\"d\" =&gt; 40</code>.</p>\n\n<p>An expression where the dependencies in the LHS of the match are cyclic, like:</p>\n\n<pre><code>1&gt;  #{X := Y, Y := X} = #{5 =&gt; 10, 10 =&gt; 5}.\n</code></pre>\n\n<p>will result in an evaluator error (variable is unbound) or a compilation error.</p>\n\n<h2>External Term Format</h2>\n\n<p>There are 255 tags that can be used to encode terms for external binary\ndistribution.  All tags are defined in <code>external.h</code>. The encoding starts by a\nmagic byte <code>131</code>.</p>\n\n<p>The encoding tags used in R15B01 are the following:</p>\n\n<pre><code>SMALL_INTEGER_EXT        'a'     97\nINTEGER_EXT              'b'     98\nFLOAT_EXT                'c'     99 \nATOM_EXT                 'd'    100\nSMALL_ATOM_EXT           's'    115\nREFERENCE_EXT            'e'    101\nNEW_REFERENCE_EXT        'r'    114\nPORT_EXT                 'f'    102\nNEW_FLOAT_EXT            'F'     70\nPID_EXT                  'g'    103\nSMALL_TUPLE_EXT          'h'    104\nLARGE_TUPLE_EXT          'i'    105\nNIL_EXT                  'j'    106 \nSTRING_EXT               'k'    107\nLIST_EXT                 'l'    108 \nBINARY_EXT               'm'    109 \nBIT_BINARY_EXT           'M'     77                                         \nSMALL_BIG_EXT            'n'    110\nLARGE_BIG_EXT            'o'    111\nNEW_FUN_EXT              'p'    112 \nEXPORT_EXT               'q'    113\nFUN_EXT                  'u'    117\n\nDIST_HEADER              'D'     68\nATOM_CACHE_REF           'R'     82\nATOM_INTERNAL_REF2       'I'     73\nATOM_INTERNAL_REF3       'K'     75\nBINARY_INTERNAL_REF      'J'     74\nBIT_BINARY_INTERNAL_REF  'L'     76\nCOMPRESSED               'P'     80\n</code></pre>\n\n<p>For Maps we define tag <code>MAP_EXT</code> to 116 (<code>t</code>).</p>\n\n<p>Data layout:</p>\n\n<pre><code>MAP_EXT\n|-----------------------------------    \n|  1  |    4   |        |          |\n|-----------------------------------\n| 116 |  Size  |  Keys  |  Values  |\n|-----------------------------------\n</code></pre>\n\n<p>The <code>Size</code> specifies the number of keys and values that follows the size\ndescriptor.</p>\n\n<p>An open questions, optimize for:</p>\n\n<ol>\n<li>encoding/decoding speed?</li>\n<li>ease of access?</li>\n<li>memory size?</li>\n</ol>\n\n<p>Memory size should be a priority since we send this data over the wire. We\nshould promote ease of access so other languages can integrate towards the\nformat.</p>\n\n<p>This leads to a flat and simple structure. It follows that encoding/decoding\ntakes a performance hit.</p>\n\n<h1>Motivation</h1>\n\n<p>Why would we need maps when we have <em>records</em>, <em>dicts</em>, <em>gb_trees</em>, <em>ets</em>\nand <em>proplists</em>?</p>\n\n<p>Maps are envisioned to be an easy to use, lightweight yet powerful key-value\nassociation store.</p>\n\n<p>Maps utilizes one of Erlang's major strengths, pattern matching, to enrich user\nexperience and provide a powerful tool to simplify code development. Pattern\nmatching gives Maps a clear edge over dicts, gb_trees or proplists in usability.</p>\n\n<p>Maps provides the possibility to associate arbitrary terms as keys, not only\natoms, with arbitrary terms as values in a matching capable data-type.</p>\n\n<p>Maps does not claim to be an replacement to records as the frames proposal does.\nInstead maps targets a larger usage domain and wishes to be a complement to\nrecords and supersede them where suitable.</p>\n\n<h3>Maps - Two approaches</h3>\n\n<ol>\n<li>Maps as an association array with pattern matching and syntax for\nconstructing, accessing or updating them.</li>\n<li>Maps as a record replacement.</li>\n</ol>\n\n<p>Maps were not envisioned as a record replacement at first, it was a hopeful\nrequirement added later. A record replacement approach does not necessarily\nrestrain any semantics but it may put some constraint on the implementation\nand underlying structure.</p>\n\n<h5>Records</h5>\n\n<p>Records are powerful under the right circumstances:</p>\n\n<ul>\n<li>fast lookups, O(1), due to compile time indexing of keys, and fast stores for\nsmall record sizes (~50 values),</li>\n<li>no memory overhead to store keys, only values and a name: 2 + N words\nconsumption,</li>\n<li>ease of use in function head matching.</li>\n</ul>\n\n<p>However some of the drawbacks are:</p>\n\n<ul>\n<li>compile-time dependency and forces header file inclusions for inter-module usage,</li>\n<li>only atoms as keys,</li>\n<li>keys are not accessible in runtime,</li>\n<li>no dynamic access of values, i.e. we cannot use variables to access values,</li>\n<li>it is not a data-type and cannot be distinguished from tuples.</li>\n</ul>\n\n<p>When comparing maps with records the drawbacks are easily remedied by Maps,\nhowever the positive effects is not as easy to replicate in a built-in data-type\nwhere values are determined at runtime instead of at compile time.</p>\n\n<ul>\n<li>Being faster than direct-indexing array, where indices and possibly the\nresulting value are determined at compile time, is hard.\nIn fact it is impossible.</li>\n<li>A memory model for Maps where the efficiency was near that of records\ncould be achieved by essentially using two tuples, one for keys and one for\nvalues as demonstrated in Frames. This would be impact performance of\nupdates on Maps with a large number of entries and thus constrain the\ncapability of a dictionary approach.</li>\n<li>Maps would be as easy, or even easier, to use with matching in function heads.</li>\n</ul>\n\n<h3>Protocol Construction</h3>\n\n<p>Arguments for a simpler a JSON representation using frames or \nmaps has been raised. Using frames and thereby atoms for dynamic creation of keys\nwould be a serious drawback.  Using maps would grant the possibility of string\nbinaries to represent keys and would not put the global atom pool in disarray.</p>\n\n<h4>Pattern Matching Example: The JSON Files</h4>\n\n<p>Changing json-decoding. Mochiwebs mochijson decodes Json dictionaries the as\nthe following:</p>\n\n<pre><code>{\"key\": \"value\"} -&gt; {struct, [{\"key\", \"value\"}]}\n</code></pre>\n\n<p>This could instead be:</p>\n\n<pre><code>{\"key\": \"value\"} -&gt; #{ \"key\" =&gt; \"value\"}\n</code></pre>\n\n<p>Consider the following JSON examples, from <a href=\"http://json.org/example.html\" title=\"JSON Example\">json.org</a>.</p>\n\n<pre><code>{\"menu\": {\n  \"id\": \"file\",\n  \"value\": \"File\",\n  \"popup\": {\n    \"menuitem\": [\n      {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},\n      {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},\n      {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}\n    ]\n  }\n}}\n</code></pre>\n\n<p><code>mochijson:decode/1</code> will currently look like:</p>\n\n<pre><code>{struct, [\n    {\"menu\", {struct, [\n        {\"id\",\"file\"},\n        {\"value\",\"File\"},\n        {\"popup\", {struct, [\n            {\"menuitem\", {array, [\n                {struct, [{\"value\",\"New\"},{\"onclick\",\"CreateNewDoc()\"}]},\n                {struct, [{\"value\",\"Open\"},{\"onclick\",\"OpenDoc()\"}]},\n                {struct, [{\"value\",\"Close\"}, {\"onclick\",\"CloseDoc()\"}]}\n            ]}}\n        ]}}\n    ]}}\n]}\n</code></pre>\n\n<p><code>mochijson:decode/1</code> could look like:</p>\n\n<pre><code>#{ \"menu\" =&gt; #{\n    \"id\" =&gt; \"file\",\n    \"value\" =&gt; \"File\",\n    \"popup\" =&gt; #{\n        \"menuitem\" =&gt; [\n          #{ \"value\" =&gt; \"New\",   \"onclick\" =&gt; \"CreateNewDoc()\"},\n          #{ \"value\" =&gt; \"Open\",  \"onclick\" =&gt; \"OpenDoc()\"},\n          #{ \"value\" =&gt; \"Close\", \"onclick\" =&gt; \"CloseDoc()\"}\n        ]\n    }\n}}\n</code></pre>\n\n<p>Let us find <code>\"menu\"</code> -> <code>\"popup\"</code> -> <code>\"menuitem\"</code>.</p>\n\n<p>Traversing the first structure is a bit awkward. We would have to do\nthe following:</p>\n\n<pre><code>Decoded         = mochijson:decode(Json),\n{struct, Menu}  = proplists:get_value(\"menu\", Decoded),\n{struct, PopUp} = proplists:get_value(\"popup\", Menu),\n{struct, Items} = proplists:get_value(\"menuitem\", PopUp),\n</code></pre>\n\n<p>With maps it could look like the following:</p>\n\n<pre><code>#{ \"menu\"     := Menu  } = mochijson:decode(Json),\n#{ \"popup\"    := PopUp } = Menu,\n#{ \"menuitem\" := Items } = PopUp,\n</code></pre>\n\n<p>or even:</p>\n\n<pre><code>Decoded = mochijson:decode(Json),\n#{ \"menu\" := #{ \"popup\" := #{ \"menuitem\" := Items } } } = Decoded,\n</code></pre>\n\n<p>With maps, and single value access, it could look really simple:</p>\n\n<pre><code>Decoded = mochijson:decode(Json),\nItems = Decoded#{ \"menu\" }#{ \"popup\" }#{ \"menuitem \"}.\n</code></pre>\n\n<h3>Open Questions</h3>\n\n<p>We have some usage scenarios that are still open for debate. A proposed answer\nis given for each question and stems from discussions in this proposal.</p>\n\n<ol>\n<li>What type of keys will we need to store in our Map? Will atoms suffice? \n<ul>\n<li>It is the authors view that we should refrain from any key restrictions\nunless there is overwhelmingly evidence that we can gain something from\nsuch a restriction.</li>\n<li>A non atom key restriction satisfies our goal of a powerful Map mechanism.</li>\n<li>Proposal: <em>Any term as keys.</em></li>\n</ul></li>\n<li>How many key-value associations will we store in our map?\n<ul>\n<li>This question has less to do with syntax and semantics than it has with\nthe choice of the underlying implementation.</li>\n<li>If we enable the user to add key-value pairs dynamically surely he will\nuse it.  Since it is a powerful mechanism not afforded to us by records\nthe usage pattern will also be different. This will in all likelihood\nproduce larger Maps than records are today. This implies that we cannot\ncompare records sizes with that of maps sizes since the usage scenario\nwould be different.</li>\n<li>Proposal: <em>Arbitrary number of keys-value pairs.</em></li>\n</ul></li>\n<li>How many Map instances will we create for each Map with a specific set of keys?\n<ul>\n<li>This question is closely related to how we use records and if Maps should\nemulate this behavior and this should have no impact on semantics, only\nimplementation.</li>\n<li>The significant difference is the memory overhead in the storing structure.\nSince memory overhead for keys and values has the same behavior as in any\ncompound term or abstract data-type, i.e. dict or gb_trees, the main\ndifference occurs when comparing maps to records and frames. To ensure a\nlogarithmic worst-case performance in update or retrieval some sort tree\nstructure would likely be used for maps. Maps would then stores keys\ntogether with its values whereas frames stores keys outside its value\nstructure and records generates key indexes at compile-time. This would\nindicate a memory overhead for Maps over Frames and records for each\ninstance.</li>\n<li>Proposal: <em>Two tier approach, similar to binaries. Use flat compact,\nkey-sharing approach for few associations (~50 associations). Use sorted\ntree approach and store keys with values beyond first tier limit.\nThe rationale being it is more likely to have multiple instance where\nwe have few keys.</em></li>\n</ul></li>\n<li>Only allow updates of already defined keys within a Map in syntax?\n<ul>\n<li>The question stems from a record replacement approach and the argument for\nit is to mitigate typos, i.e. trying to update key <code>behavior</code> where key\n<code>behaviour</code> was actually intended. Instead of getting two different keys,\na runtime exception occurs at this point.</li>\n<li>This approach will <em>deny</em> any dictionary like behavior, for instance\nstoring spawned processes as keys in the map using syntax.</li>\n<li>Proposal: <em>Allow for any key to be stored by default syntax,\nexisting or not, and use a special syntax for setting of values of\nexisting keys only.</em></li>\n</ul></li>\n</ol>\n\n<p>The answers from these questions are instrumental to how we should design and\nimplement Maps. What we also should keep in the back of our minds is that we\nwill never get rid of records completely and some of the frames arguments might\nthus be superfluous.</p>\n\n<h1>Rationale</h1>\n\n<h2>What should we expect from our syntax?</h2>\n\n<p>As stated earlier, the current syntax is not set in stone but what should we\nexpect from it?</p>\n\n<ol>\n<li><p>First and foremost it has to be unambiguous, meaning the syntax must produce\nsingle clearly defined behavior that cannot be misinterpreted by humans\nnor machines.</p>\n\n<p>1.1  Here we also include the notion that similar syntax should have similar\n    behavior, or at least not completely different behavior.\nFor example records, <code>#record{ key = Value }</code>, have O(1) performance and\n2 + N words memory overhead.  If we use a similar syntax,\ni.e. <code>#{ key = Value }</code>, we should also expect similar behavior both in\nregard to semantics and performance for any and all sizes of the map.</p></li>\n<li><p>The syntax must be as short as possible. It must not use more characters than\nnecessary to describe a certain behavior as long as it\ndoes not violate rule 1.</p>\n\n<p>2.2  We want to avoid verbosity in the language. Verbosity pushes away\ninformation from our field of vision and obfuscates it.\nThis needs to be avoided.</p></li>\n</ol>\n\n<h2>Syntax choice for Maps</h2>\n\n<p><em>The author argues for:</em> <code>=&gt;</code> <em>as delimiter in 'set-or-update' and</em>\n<code>:=</code> <em>in 'set-existing' and 'matching' syntax.</em></p>\n\n<p>In the examples below we use <code>#{ Key =&gt; Value }</code> to describe map semantics and\nuse-cases, but this is only one suggestion out of many.</p>\n\n<p>Several syntax proposals exists, frames proposes <code>&lt;{ key ~ Value }&gt;</code> syntax and\nanother syntax suggestion is very similar to record syntax <code>#{ key = Value }</code>.</p>\n\n<p>The current variable and atom definitions puts restrictions on what we can use\nas delimiters and leaves us <code>~</code> and <code>=</code> as the only sane <em>single</em> character\ndelimiters we can use. The case is very well argued in Richard O'Keefes\n<a href=\"http://www.cs.otago.ac.nz/staffpriv/ok/frames.pdf\" title=\"No more need for records\">No more need for records (fifth draft)</a>.</p>\n\n<h3>Delimiter discussion</h3>\n\n<p>Arguments against a <code>=</code> delimiter are:</p>\n\n<ul>\n<li>It lacks distinction from match, consider <code>#{ A = B = v }</code>,\n does <code>A</code> match <code>B</code> or does <code>B</code> match <code>v</code>?\n Which <code>=</code> is a match operation and which <code>=</code> delimits the key-value pair?</li>\n<li>It might be interpreted as <code>Key</code> 'equal' <code>Value</code>,</li>\n</ul>\n\n<p>and hence <code>=</code> is in violation of rule #1 from <em>What do we expect from our syntax?</em>.\nThe interpretation of this syntax is ambiguous.</p>\n\n<p>Arguments against a <code>~</code> delimiter are:</p>\n\n<ul>\n<li>it might be interpreted as <code>Key</code> 'NOT' <code>Value</code>\n as <code>~</code> is the bitwise NOT operator in C,</li>\n<li>it might be interpreted as <code>Key</code> 'about equal' <code>Value</code>\n as <code>~</code> is similar to mathematics <code>≃</code>,</li>\n<li>it lacks typographical distinction,\n i.e. it lacks distinction from <code>-</code> in certain fonts, \n ex. <code>K ~ V</code> might be interpreted as <code>K - V</code>, consider <code>#{ K - 1 ~ 2 - V }</code>,</li>\n</ul>\n\n<p>and hence this is in violation of rule #1 from <em>What do we expect from our syntax?</em>.\nThe interpretation of this syntax is ambiguous.</p>\n\n<p>Two two-character delimiter suggestions are <code>#{ Key := Value }</code> and\n<code>#{ Key =&gt; Value}</code>, where <code>:=</code> is a common denominator for assignment and <code>=&gt;</code>\nshould be read as <em>maps to</em>. A two-character delimiter should be avoided if at\nall possible since it increases the syntax footprint of the source code.</p>\n\n<p>The assignment delimiter reads well for just assignment but suffers from the\nsame reversed logic flaw as records when it comes to pattern matching. The match\n<code>#{ key := Value } = M</code> reads <em>match M to the map pattern where Value is equal\nto key</em>. That does not read well unless we call the assignment delimiter <code>:=</code>\nfor something that its not meant to be.</p>\n\n<p>However, <code>:=</code> is also similar to <code>=:=</code> which means \"is exactly equal\",\ni.e. matches. This is a valuable meaning since we have a difference\nbetween <code>==</code> and <code>=:=</code> when dealing with numbers and thus <code>:=</code> could be a more\ncorrect delimiter for matching syntax.</p>\n\n<p>The delimiter <code>-&gt;</code> would be suitable choice if it weren't for the fact that it\nwould overload the function clause meaning.</p>\n\n<p>Both <code>-&gt;</code> and <code>=&gt;</code> might be confusing when dealing with binaries.\nConsider <code>#{ &lt;&lt;\"key\"&gt;&gt; -&gt; &lt;&lt;\"value\"&gt;&gt; }</code> and <code>#{ &lt;&lt;\"key\"&gt;&gt; =&gt; &lt;&lt;\"value\"&gt;&gt; }</code>,\nwhere <code>=&gt;</code> appears to be slightly more confusing than <code>-&gt;</code>.</p>\n\n<p>Listing of delimiters from above perceived desirability: </p>\n\n<ol>\n<li><code>#{ K =&gt; V }</code> - No ambiguity, no overloading, reads as an association</li>\n<li><code>#{ K := V }</code> - No ambiguity, no overloading, reads as an assignment or exact match</li>\n<li><code>#{ K ~ V }</code>  - Typographical ambiguity, no overloading, no clear meaning</li>\n<li><code>#{ K -&gt; V }</code> - Overloads function clause head and body separator, reads as an association</li>\n<li><code>#{ K = V }</code>  - Overloads match operator, reads as a match or an assignment</li>\n</ol>\n\n<p>Using <code>:=</code> assignment for existing keys seems as a good choice. The choice for\nset-or-update is between <code>=&gt;</code> and <code>~</code>.</p>\n\n<h3>The case for two set-or-update semantics and its syntax</h3>\n\n<p>A case for two different ways to update values in a Map is proposed.</p>\n\n<p>One syntax if, and only if, we want to update a value for an already <em>existing</em>\nkey and another if we want to update the Map with any key.</p>\n\n<ul>\n<li>Use <code>M#{ K =&gt; V }</code> to declare new key value pairs <em>or</em> update already existing keys</li>\n<li>Use <code>M#{ K := V }</code> to update already existing keys.</li>\n<li>Use <code>#{ K := V } = M</code> to match maps.</li>\n</ul>\n\n<p>Example 1:</p>\n\n<pre><code>foo() -&gt;\n    M = #{ key1 =&gt; 1, key2 =&gt; 2 }, % M is declared with keys 'key1' and 'key2'\n    bar(M).\n\nbar(M) -&gt;\n    M#{\n        key1 := \"1\",  %% 'key1' will be set to \"1\"\n        key2 := \"2\",  %% 'key2' will be set to \"2\"\n        key3 := \"3\"   %% this causes an exception since 'key3' does not exist in M\n    }.\n\n&gt; foo().\n** exception error: no match of 'key3' in map\n</code></pre>\n\n<p>Example 2:</p>\n\n<pre><code>foo() -&gt;\n    M = #{ key1 =&gt; 1, key2 =&gt; 2 }, % M is declared with keys 'key1' and 'key2'\n    bar(M).\n\nbar(M) -&gt;\n    M#{\n        key1 =&gt; \"1\",  %% 'key1' will be set to \"1\"\n        key2 =&gt; \"2\",  %% 'key2' will be set to \"2\"\n        key3 =&gt; \"3\"   %% 'key3' will be set to \"3\"\n    }.\n\n&gt; foo().\n#{ key1 =&gt; 1, key2 =&gt; \"2\", key3 =&gt; \"3\" }\n</code></pre>\n\n<h2>Impact of syntax footprint</h2>\n\n<p>We must lessen the syntax footprint impact on the source code and the language.</p>\n\n<p>Currently the two normal ways of sending options to a functions are either via\nrecords or property lists. Both have some drawbacks. Records are compile time\ndependent and syntactic sugar for tuples. Property lists are generic but\nproduces a lot of texts when defining them and operating on them.</p>\n\n<p>Consider this example when parsing a list of arguments:</p>\n\n<pre><code>args(Args) -&gt; \n     args(Args, [{analyze, false}, {suppression, false}, {target, none}]).\n\nargs([\"-r\" | Args], Opts) -&gt; \n    args(Args, [{analyze, true}     | proplists:delete(analyze, Opts)]);\nargs([\"-s=\"++File | Args], Opts) -&gt; \n    args(Args, [{suppression, File} | proplists:delete(suppression, Opts)]);\nargs([Target], Opts) -&gt; \n    [{target, Target} | proplists:delete(target, Opts)].\n</code></pre>\n\n<p>The textual impact, the number of characters, is quite heavy when operating on \nproperty lists.</p>\n\n<p>If we instead use some kind of map with syntax, how would that look?</p>\n\n<pre><code>args(Args) -&gt; \n    args(Args, #{ analyze =&gt; false, suppression =&gt; false, target =&gt; none}).\n\nargs([\"-r\" | Args], Opts)        -&gt; args(Args, Opts#{ analyze := true });\nargs([\"-s=\"++File | Args], Opts) -&gt; args(Args, Opts#{ suppression := File});\nargs([Target], Opts)             -&gt; Opts#{ target := Target }.\n</code></pre>\n\n<p>This looks cleaner in my opinion but that is a very subjective view. To use some\ndata we can count the characters, and we see that the property lists example has\n390 characters versus the map examples 306. Property lists uses almost 30% more\ncharacters in this example.</p>\n\n<h2>Semantics and API-functions</h2>\n\n<h3>List conversions</h3>\n\n<p>Perhaps the most sane <code>maps:from_list/1</code> semantics would be to have the key-value\nsignificance order in left to right, meaning the first association is used and\nthe latter values with matching keys are ignored.</p>\n\n<p>This differs from the <code>dict:from_list/1</code> behavior.</p>\n\n<p>Consider the following <code>dict</code> example:</p>\n\n<pre><code>[{a,2}] = dict:to_list(dict:from_list([{a,1}, {a,2}])).\n</code></pre>\n\n<p>By letting the leftmost be the most significant key we could simplify conversion\nfrom and to lists. </p>\n\n<p>Current suggestion has the following semantics:</p>\n\n<pre><code>Ls = [{a,old}],\n#{ a := old } = maps:from_list([{a,new}|Ls]).\n</code></pre>\n\n<p>The reversal would be:</p>\n\n<pre><code>Ls = [{a,old}],\n#{ a := new } = maps:from_list([{a,new}|Ls]).\n</code></pre>\n\n<h2>Equality and Ordering</h2>\n\n<p>A restriction set on the implementation by the Erlang specification is that\norder is total, i.e. satisfies <em>antisymmetry</em>, <em>transitivity</em> and <em>totality</em>.</p>\n\n<ul>\n<li>If <code>M1 =&lt; M2</code> and <code>M2 =&lt; M1</code> then <code>M1 == M2</code>,</li>\n<li>If <code>M1 =&lt; M2</code> and <code>M2 =&lt; M3</code> then <code>M1 =&lt; M3</code>,</li>\n<li>If <code>M1 =&lt; M2</code> or <code>M2 =&lt; M1</code> (always comparable)\nwhere <code>M1</code>, <code>M2</code> and <code>M3</code> are any Map term.</li>\n</ul>\n\n<p>This only holds true in Erlang if we treat floats and integers as union of types,\nnamely numbers. In the case of a Maps, <code>true = #{ 1.0 =&gt; V } == #{ 1 =&gt; V}</code>.</p>\n\n<ul>\n<li>The need for order arises in a few cases.\n<ul>\n<li>comparison, for example sorting, <code>lists:sort([M1, .., Mn])</code></li>\n<li>introspection, for example when printed.</li>\n</ul></li>\n<li>Ordered maps impose restrictions on the underlying implementation and a\nhashing approach will be nearly impossible.</li>\n<li>The underlying structure does not need to be sorted, an order could be\nproduced when needed,\n<ul>\n<li><code>M1</code> &lt; <code>M2</code>, would result in an internal sort but would cost\nO( <em>N1</em> * lg <em>N1</em> + <em>N2</em> * lg <em>N2</em> ), where\n<code>N1 = maps:size(M1) and N2 = maps:size(M2)</code></li>\n</ul></li>\n</ul>\n\n<h2>Accessing a single value</h2>\n\n<p>Do we need to have single access or is matching sufficient?</p>\n\n<p>Consider the following,</p>\n\n<pre><code>V = M#{ K }\n</code></pre>\n\n<p>is shorter than</p>\n\n<pre><code>#{ K := V } = M\n</code></pre>\n\n<p>It also allows for easy access of associated values in deep structures.</p>\n\n<p>The syntax for single value access is the least developed (and contemplated)\nfeature in this proposal and certainly could use some input.</p>\n\n<p>More over, the dot syntax must be abolished. Currently it is used for records\nbut it will not be used for maps. Dot represents end of expression list in last\nclause, or end of attribute.</p>\n\n<p>It cannot be used to distinguish between floats or associations.</p>\n\n<p>Example:</p>\n\n<pre><code>1&gt; M = #{ 1.1 =&gt; a, 1 =&gt; #{ 1 =&gt; b } }.\n#{ 1 =&gt; #{ 1 =&gt; b }, 1.1 =&gt; a }.\n\n2&gt; #M.1.1.\na | b ?\n</code></pre>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Erlang code written with Maps will only be parseable, loadable and executable \non Erlang/OTP R17A and later releases of Erlang/OTP but not on previous\nreleases.</p>\n\n<p>Erlang code written before Erlang/OTP R17A will be perfectly compatible, i.e.\nparseable, loadable and executable with these Maps changes.</p>\n\n<p>Distribution will not be backwards compatible.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}