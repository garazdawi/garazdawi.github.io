{"pageProps":{"index":{"id":"0004","content":"<pre><code>Author: Per Gustafsson &lt;pergu(at)it(dot)uu(dot)se&gt;\nStatus: Final/R12B-0 Proposal is implemented in OTP release R12B-0\nType: Standards Track\nCreated: 10-Aug-2007\nErlang-Version: R12B-0\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 4: <a href=\"eep-0004.md\" title=\"EEP Source\"> New BIFs for bit-level binaries (bit strings)</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP describes the introduction of bit level binaries to the\nErlang programming language. They can be constructed and manipulated\nusing the bit syntax and  a new set of BIFs which operate on bit-level\nbinaries. These new BIFs are introduced in order to not alter the semantics of\nexisting BIFs which operate on binaries, but instead implement similar\noperations for bit level binaries using new BIFs.</p>\n\n<h1>Definitions</h1>\n\n<p>A bit-level binary in this document called a <em>bit string</em> is a sequence of\nbits of any length. A <em>binary</em> on the other hand is a sequence of bits\nwhere the number of bits is evenly divisible by eight. These\ndefinitions implies that any binary is also a bit string.</p>\n\n<h1>Manipulating bit strings using the bit syntax</h1>\n\n<p>A bit syntax expression: </p>\n\n<p><code>&lt;&lt;Seg1,...,SegN&gt;&gt;</code> </p>\n\n<p>Evaluates to a bit string, if the sum of the sizes of all segments in the\nexpression is divisible by eight the result is also a\nbinary. Previously such expression could only evaluate to binaries and\na runtime error was raised if this was not the case.</p>\n\n<p>With this extension the expression <code>Bin = &lt;&lt;1:9&gt;&gt;</code> which previously caused a\nruntime error now creates a 9-bit binary. To be able to use this\nbit string to build a new bigger bit string we can write: </p>\n\n<p><code>&lt;&lt;Bin/bitstring, 0:1&gt;&gt;</code></p>\n\n<p>Note the use of bitstring as the type. This expands to binary-unit:1 where as\nthe binary type would have expanded to binary-unit:8. Since bitstring is a long\nword to write in a binary pattern there is an alias <em>bits</em> which is used in the\nrest of this proposal, similarily for binary there is a shorthand <em>bytes</em>.</p>\n\n<p>To match out a bit-level binary we also use the bit string type as in ::</p>\n\n<pre><code>case Bin of\n  &lt;&lt;1:1,Rest/bits&gt;&gt; -&gt; Rest;\n  &lt;&lt;0:1,_/bits&gt;&gt; -&gt; 0\nend\n</code></pre>\n\n<p>This allows us to avoid situations were we would have to calculate\npadding.        </p>\n\n<h1>Specifications</h1>\n\n<p><code>bitsize/1::bitstring() -&gt; integer()</code></p>\n\n<p>Returns the size of a bit string in bits. This BIF is allowed in guards.</p>\n\n<p><code>list_to_bitstring/1::bitstring_list() -&gt; bitstr()</code></p>\n\n<p><code>bitstring_list = cons(char() | bitstring()| bitstring_list(), bitstring() | bitstring_list) | nil()</code></p>\n\n<p>Concatenates the bit strings and chars in the bitstring_list to create a bit\nstring, each char becomes an 8-bit bit string.</p>\n\n<p><code>is_bitstring/1::any() -&gt; bool()</code></p>\n\n<p>Returns true if the argument is a bit string, otherwise it returns\nfalse. This BIF is allowed in guards.</p>\n\n<p><code>bitstring_to_list/1::bitstring() -&gt; [char()|bitstring()]</code></p>\n\n<p>Turns a bit string into a list of characters and if the number of bits\nin the bit string is not evenly divisible by eight the last element in\nthe list is a bit string consisting of the last 1-7 bits of the original\nbit string.</p>\n\n<h1>Rationale</h1>\n\n<p>The current definition of binaries makes it complicated to use the bit\nsyntax for decoding when the format is not byte oriented, because the\nprogrammer is always forced to pad the binaries that he is using to\nbecome a sequence of bytes. Allowing bit-level binaries alleviates\nthis problem.</p>\n\n<p>The new BIFs proposed here are intended to give programmers the same\ntools to manipulate bit-level binaries as they are used to when\nmanipulating binaries without changing the semantics of already\nexisting BIFs and maintain properties such as if this statement:</p>\n\n<p><code>is_binary(X) andalso size(X) =:= 0</code></p>\n\n<p>evaluates to true then that implies that <code>X = &lt;&lt;&gt;&gt;</code>.</p>\n\n<h1>Implementation</h1>\n\n<p>The extensions described in this document are either already\nimplemented in R11B-4, but protected by a compiler switched or can be\neasily implemented.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>This change will not be entirely backward compatible for example:\n<code>N=9, &lt;&lt;1:N&gt;&gt;</code> would cause an error in the old system and now it would\nevaluate to a bit string. </p>\n\n<p>The new BIFs are intended to give the same expressiveness for handling\nbit-level binaries as we have for ordinary binaries without changing\nthe semantics of the BIFs for binaries such as size/1,\nbinary<em>to</em>list/1, list<em>to</em>binary/1 etc.. This means that all such BIFs\nwill throw an exception if their arguments contains bit strings.</p>\n"}},"__N_SSG":true}