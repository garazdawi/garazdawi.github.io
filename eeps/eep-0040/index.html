<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-version: R15B02
Created: 19-Oct-2012
Post-History: 19-Oct-2012
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 40: <a href="eep-0040.md" title="EEP Source"> A proposal for Unicode variable and atom names in Erlang</a></h2>

<h1>Abstract</h1>

<p>This EEP proposes how to extend variable and atom names in Erlang
to contain Unicode characters in a backwards compatible way.</p>

<h1>Forces</h1>

<ol>
<li>Support for Unicode continues to increase, with
minimal source code support about to arrive.</li>
<li>Unicode variable names and unquoted atoms are not
here yet, so now is the time to settle on a design.</li>
<li>They will need to come.  There may be legal or
institutional reasons why unicode-capable languages
are required.  Some people just want to use their
own language and script.  Erlang's strength in
network applications means that being able to
represent Internationalized Domain Names as unquoted
atoms would be just as much of a convenience as
being able to represent ASCII domain names like
www.example.com (which needs no quotes in Erlang) is.</li>
<li>There is a framework for Unicode identifiers in <a href="http://www.unicode.org/reports/tr31/" title="Unicode Standard Annex 31">UAX#31</a>,
used by several programming languages, including Ada, Java,
C++, C, C#, Javascript, and Python (section 2.3 of <a href="http://docs.python.org/release/3.1.5/reference/lexical_analysis.html" title="Python Lexical Analysis">Python Lexical</a>,
and see also <a href="http://www.python.org/dev/peps/pep-3131/" title="Python Enhancement Proposal 3131">PEP 3131</a>).</li>
<li>Existing Erlang identifiers should remain valid,
including ones containing "@" and ".".</li>
<li>Existing Erlang support features, such as ignoring
variables that start with underscore when reporting
singleton variables, should not be broken.</li>
<li>We should not "steal" any characters to use as "magic
markers" for variables because they might be needed for
other purposes.  A good (bad) example of this is "?", which
could be used for several things if it were not used for macros.</li>
<li>Character sequences in Latin-1 that are not legal variable or
atom names now should not be made into such by this specification.</li>
</ol>

<h1>Reference</h1>

<p>Names of sets of characters, XID_Start, XID_Continue, Lu, Lt, Lo, Pc,
Other_Id_Start, are drawn from <a href="http://www.unicode.org/versions/Unicode6.2.0/" title="The Unicode Standard version 6.2.0">Unicode</a> and <a href="http://www.unicode.org/reports/tr31/" title="Unicode Standard Annex 31">UAX#31</a>.</p>

<pre><code>    Lu = upper case letters
    Lt = title case letters
    Ll = lower case letters
    Lo = non-case letters (Arabic, Chinese, and so on)
    Pc = connector punctuators, including the low line (_) and
         a number of other characters like undertie (‿).
    Other_Id_Start = script capital p, estimated symbol,
         katakana-hiragana voiced sound mark, and
         katakana-hiragana semi-voiced sound mark.
</code></pre>

<h1>Specification</h1>

<h2>Variables</h2>

<pre><code>variable ::= var_start var_continue*

var_start ::= (XID_Start ∩ (Lu ∪ Lt ∪ Other_Id_Start)) ∪ Pc

var_continue ::= XID_Continue ∪ "@" \ "ªº"
</code></pre>

<p>The choice of XID here follows Python.  It ensures that the normalisation
of a variable is still a variable.  In fact Unicode variables should be
normalised.  Unicode has enough look-alike characters that we cannot hope
for "look the same &lt;=> are the same" to be true, but we should go <em>some</em>
way in that direction.</p>

<p>Variables in scripts that do not distinguish letter case have to
begin with <em>some</em> special character to ensure that they are not
mistaken for unquoted atoms.  There are 10 Pc characters in the Basic
Multilingual Plane.  The Erlang parser treats a variable beginning
with an underscore specially: there will be no complaint if it is a
singleton.  One approach would be to say that this special treatment
does not apply to the other 9 Pc characters.
Using that approach, ‿ would not be a wild-card,
_隠者 should be a singleton, and ‿隠者  should not.</p>

<p>Of course, someone might be using fonts
that do include say Arabic letters but not say the undertie.  We can
deal with that by revising the underscore rule, which I recommend:</p>

<pre><code>    Variable does not begin with a Pc character =&gt;
             should not be a singleton.

    Variable is just a Pc character and nothing else =&gt;
             is a wild card.

    Variable begins with a Pc character followed by an
    Lu or Lt or Pc character =&gt;
             may be a singleton.

    Variable begins with a Pc character followed by
    a legal character other than an Lu or Lt or Pc character =&gt;
             should not be a singleton.
</code></pre>

<p>Thus ‿ is a wild-card, 隠者 is an atom, _隠者 should not be
a singleton, but __隠者 <em>may</em> be a singleton.  This rule is a
consistent generalisation of the existing rule.</p>

<h2>Unquoted atoms</h2>

<pre><code>    unquoted_atom ::= "."? atom_start atom_continue*

    atom_start ::= XID_Start \ (Lu ∪ Lt ∪ "ªº")

    atom_continue ::= XID_Continue ∪ "@" \ "ªº"
                   |  "." atom_start
</code></pre>

<p>Again the choice of XID follows Python, and ensures that the
normalisation of an unquoted atom is still an unquoted atom.
Unquoted atoms should be normalised.</p>

<p>The details of Erlang unquoted atoms are somewhat subtle; I have
checked my understanding experimentally.  An initial dot is allowed,
but is always discarded.  That's odd, but it's the way it is now.</p>

<h2>Keywords</h2>

<p>Keywords have the form of unquoted atoms.  No new keywords are
introduced.</p>

<h3>Specifics</h3>

<ul>
<li><p>Any Python identifier or keyword is
an Erlang variable or unquoted atom or keyword
unless it contains "ª" or "º".</p></li>
<li><p>@ signs may occur freely in variables and unquoted atoms except as the
first character, as now.</p></li>
<li><p>Although they are in the Ll set, and so are technically lower case
letters,  "ª" and "º" are not allowed in variable names or
unquoted atoms in this proposal because they are not allowed in
Erlang now.</p></li>
<li><p>dots may not be followed by capital letters, digits, or underscores,
as now.</p></li>
<li><p>I am not sure whether modifier letters should be allowed after a dot.</p></li>
<li><p>I am not sure what to do with the Other_ID_Start characters.
Script capital p <em>looks</em> like a capital p and even has "capital" in
its name.  All other "* SCRIPT CAPITAL *" characters are upper case
letters.  Surely it should be allowed to start a variable.
The estimated sign looks like an enlarged lower case e; other symbols
that look like letters are classified as letters.  You'd expect this
to begin an atom.  As for the Katakana-Hiragana voicing marks, I have
no intuition whatever.  Assigning the whole group to atoms seems
safest.</p></li>
<li><p>All existing variable names and unquoted atoms remain legal, and no
new variable or atom forms using only Latin-1 characters have been
introduced.</p></li>
</ul>

<h1>Rationale</h1>

<p>While Erlang files meant to be shared with a wide audience should
still be written in English, if people are working in a group fluent
in some language on requirements also written in that language, it
is desirable that they should be able to stay close to the terminology
of the requirements lest they introduce translation errors.</p>

<p>The whole design flows in the direction "if someone wants to use their
own script in an Erlang file, they should be able to do so comfortably
in a way that is generally consistent with other programming
languages."</p>

<p>This <em>does</em> mean that there will be Erlang source files that a skilled
Erlang programmer is unable to decipher because of the unfamiliarity
of the script.  With over 110,000 characters in Unicode 6, this is
just going to happen no matter what we do.  Once Unicode strings are
available, can quoted Unicode atoms be far behind?  And once they are
possible, refusing unquoted Unicode atoms does not salvage universal
readability.  All it would accomplish is to annoy people by requiring
single quotation marks to be used liberally.  Old Algol programmers
will recall only too clearly how much of an impairment to readability
a hailstorm of single quotation marks was.  And if you can use
γαμμα as an atom, does it make any sense to refuse Γαμμα?</p>

<p>One of the goals for this EEP is that if an Erlang text contains only
Latin-1 characters, then it should be legal under the new rules if and
only if it is legal under the old rules, and should have the same
meaning in either context.  During the transition period, there will
be people writing Erlang code for systems following the new rules, and
giving it to people using Latin-1 or at any rate old-rules systems.
They should not <em>accidentally</em> introduce incompatibilities.  This is
why we have to ban  "ª" and "º" for now.  Later we may lift that ban.</p>

<p>There are three ways we have to customize the UAX 31 definition.</p>

<pre><code>    - We have to continue to support "@" in variables and
      "@" and "." in unquoted atoms for backwards compatibility.

    - We have to continue to forbid unquoted atoms containing
      the Latin-1 masculine and feminine ordinal indicators.

    - We have to distinguish between variables and unquoted atoms.
</code></pre>

<p>There is a fourth way we <em>might</em> customize it.  Ken Whistler of
Unicode advises that he "doesn't see much point" in allowing Pc
characters other than LOW LINE and FULLWIDTH LOW LINE, unless there
are legacy reasons why something else has to be supported.  It seems
like a good idea that if s is a legal ASCII identifier, the full width
version of s should also be a legal identifier, so FULLWIDTH LOW LINE
definitely ought to be allowed.  I find using UNDERTIE cool, but it's
an editor's mark really.  If we reject the other Pc characters now, we
can always allow them later if we find a need; if we allow them now,
it will be hard to reject them later.  Making this change <em>clearly</em> in
the definitions will take a little thought, so that's for the next revision.</p>

<p>Dmitry Belyaev has raised the issue of localising keywords.  That is
outside the scope of this EEP, which is concerned with which character
sequences are variables and which are keywords-or-unquoted-atoms.
This has to be got right first before we can consider localised keywords.</p>

<p>The leading underscore rule was revised on the 5th of November on
the advice of Ulrich Neumerkel to avoid the problem that _Œuvre
would not have been accepted as a singleton.  Now it will.  This was
ironic, as Māori variables like _Āporo would have been misclassified.</p>

<h2>Trouble spot</h2>

<p>It is highly desirable that a legal Erlang text should remain legal
even as Unicode is revised.  <a href="http://www.unicode.org/reports/tr31/" title="Unicode Standard Annex 31">UAX#31</a> and <a href="http://www.unicode.org/policies/stability_policy.html" title="Unicode Character Encoding Stability Policy">Stability</a> very nearly
give us what we need.  The one problem that seems to be technically
possible is that an upper or lower case letter without an opposite
case counterpart might change its General Category (while being given
the Other_ID_Start property if it ceased to be a letter at all),
so an identifier beginning with such a cased orphan might switch from
variable to unquoted atom or vice versa.  Some cased orphans do exist,
like LATIN LETTER SMALL CAPITAL M, but what would a capital capital M
be?</p>

<p>One possibility is to raise the issue with the Unicode consortium and
leave this unresolved until they reply.  The issue <em>has</em> been raised,
and the tentative reply "you may not be able to rely on any given
standard property for special purposes.  Especially if that property is not
formally stable." given.  The next step may well be to seek a revision
to UAX#31, because Erlang is not alone in wanting a case distinction.</p>

<p>Another possibility would be to say that an Lu character may only
begin a variable if it has a lower-case counterpart, and an Ll
character may only begin an unquoted atom if it has an upper-case
counterpart.  Since "ß" and "ÿ" have upper-case counterparts in
Unicode, Latin-1 unquoted atoms would not be affected by such a rule.
The great mass of Lo characters would also be unaffected.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0040","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-version: R15B02\nCreated: 19-Oct-2012\nPost-History: 19-Oct-2012\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 40: \u003ca href=\"eep-0040.md\" title=\"EEP Source\"\u003e A proposal for Unicode variable and atom names in Erlang\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes how to extend variable and atom names in Erlang\nto contain Unicode characters in a backwards compatible way.\u003c/p\u003e\n\n\u003ch1\u003eForces\u003c/h1\u003e\n\n\u003col\u003e\n\u003cli\u003eSupport for Unicode continues to increase, with\nminimal source code support about to arrive.\u003c/li\u003e\n\u003cli\u003eUnicode variable names and unquoted atoms are not\nhere yet, so now is the time to settle on a design.\u003c/li\u003e\n\u003cli\u003eThey will need to come.  There may be legal or\ninstitutional reasons why unicode-capable languages\nare required.  Some people just want to use their\nown language and script.  Erlang's strength in\nnetwork applications means that being able to\nrepresent Internationalized Domain Names as unquoted\natoms would be just as much of a convenience as\nbeing able to represent ASCII domain names like\nwww.example.com (which needs no quotes in Erlang) is.\u003c/li\u003e\n\u003cli\u003eThere is a framework for Unicode identifiers in \u003ca href=\"http://www.unicode.org/reports/tr31/\" title=\"Unicode Standard Annex 31\"\u003eUAX#31\u003c/a\u003e,\nused by several programming languages, including Ada, Java,\nC++, C, C#, Javascript, and Python (section 2.3 of \u003ca href=\"http://docs.python.org/release/3.1.5/reference/lexical_analysis.html\" title=\"Python Lexical Analysis\"\u003ePython Lexical\u003c/a\u003e,\nand see also \u003ca href=\"http://www.python.org/dev/peps/pep-3131/\" title=\"Python Enhancement Proposal 3131\"\u003ePEP 3131\u003c/a\u003e).\u003c/li\u003e\n\u003cli\u003eExisting Erlang identifiers should remain valid,\nincluding ones containing \"@\" and \".\".\u003c/li\u003e\n\u003cli\u003eExisting Erlang support features, such as ignoring\nvariables that start with underscore when reporting\nsingleton variables, should not be broken.\u003c/li\u003e\n\u003cli\u003eWe should not \"steal\" any characters to use as \"magic\nmarkers\" for variables because they might be needed for\nother purposes.  A good (bad) example of this is \"?\", which\ncould be used for several things if it were not used for macros.\u003c/li\u003e\n\u003cli\u003eCharacter sequences in Latin-1 that are not legal variable or\natom names now should not be made into such by this specification.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1\u003eReference\u003c/h1\u003e\n\n\u003cp\u003eNames of sets of characters, XID_Start, XID_Continue, Lu, Lt, Lo, Pc,\nOther_Id_Start, are drawn from \u003ca href=\"http://www.unicode.org/versions/Unicode6.2.0/\" title=\"The Unicode Standard version 6.2.0\"\u003eUnicode\u003c/a\u003e and \u003ca href=\"http://www.unicode.org/reports/tr31/\" title=\"Unicode Standard Annex 31\"\u003eUAX#31\u003c/a\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    Lu = upper case letters\n    Lt = title case letters\n    Ll = lower case letters\n    Lo = non-case letters (Arabic, Chinese, and so on)\n    Pc = connector punctuators, including the low line (_) and\n         a number of other characters like undertie (‿).\n    Other_Id_Start = script capital p, estimated symbol,\n         katakana-hiragana voiced sound mark, and\n         katakana-hiragana semi-voiced sound mark.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003ch2\u003eVariables\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003evariable ::= var_start var_continue*\n\nvar_start ::= (XID_Start ∩ (Lu ∪ Lt ∪ Other_Id_Start)) ∪ Pc\n\nvar_continue ::= XID_Continue ∪ \"@\" \\ \"ªº\"\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe choice of XID here follows Python.  It ensures that the normalisation\nof a variable is still a variable.  In fact Unicode variables should be\nnormalised.  Unicode has enough look-alike characters that we cannot hope\nfor \"look the same \u0026lt;=\u003e are the same\" to be true, but we should go \u003cem\u003esome\u003c/em\u003e\nway in that direction.\u003c/p\u003e\n\n\u003cp\u003eVariables in scripts that do not distinguish letter case have to\nbegin with \u003cem\u003esome\u003c/em\u003e special character to ensure that they are not\nmistaken for unquoted atoms.  There are 10 Pc characters in the Basic\nMultilingual Plane.  The Erlang parser treats a variable beginning\nwith an underscore specially: there will be no complaint if it is a\nsingleton.  One approach would be to say that this special treatment\ndoes not apply to the other 9 Pc characters.\nUsing that approach, ‿ would not be a wild-card,\n_隠者 should be a singleton, and ‿隠者  should not.\u003c/p\u003e\n\n\u003cp\u003eOf course, someone might be using fonts\nthat do include say Arabic letters but not say the undertie.  We can\ndeal with that by revising the underscore rule, which I recommend:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    Variable does not begin with a Pc character =\u0026gt;\n             should not be a singleton.\n\n    Variable is just a Pc character and nothing else =\u0026gt;\n             is a wild card.\n\n    Variable begins with a Pc character followed by an\n    Lu or Lt or Pc character =\u0026gt;\n             may be a singleton.\n\n    Variable begins with a Pc character followed by\n    a legal character other than an Lu or Lt or Pc character =\u0026gt;\n             should not be a singleton.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThus ‿ is a wild-card, 隠者 is an atom, _隠者 should not be\na singleton, but __隠者 \u003cem\u003emay\u003c/em\u003e be a singleton.  This rule is a\nconsistent generalisation of the existing rule.\u003c/p\u003e\n\n\u003ch2\u003eUnquoted atoms\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e    unquoted_atom ::= \".\"? atom_start atom_continue*\n\n    atom_start ::= XID_Start \\ (Lu ∪ Lt ∪ \"ªº\")\n\n    atom_continue ::= XID_Continue ∪ \"@\" \\ \"ªº\"\n                   |  \".\" atom_start\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAgain the choice of XID follows Python, and ensures that the\nnormalisation of an unquoted atom is still an unquoted atom.\nUnquoted atoms should be normalised.\u003c/p\u003e\n\n\u003cp\u003eThe details of Erlang unquoted atoms are somewhat subtle; I have\nchecked my understanding experimentally.  An initial dot is allowed,\nbut is always discarded.  That's odd, but it's the way it is now.\u003c/p\u003e\n\n\u003ch2\u003eKeywords\u003c/h2\u003e\n\n\u003cp\u003eKeywords have the form of unquoted atoms.  No new keywords are\nintroduced.\u003c/p\u003e\n\n\u003ch3\u003eSpecifics\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eAny Python identifier or keyword is\nan Erlang variable or unquoted atom or keyword\nunless it contains \"ª\" or \"º\".\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e@ signs may occur freely in variables and unquoted atoms except as the\nfirst character, as now.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAlthough they are in the Ll set, and so are technically lower case\nletters,  \"ª\" and \"º\" are not allowed in variable names or\nunquoted atoms in this proposal because they are not allowed in\nErlang now.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003edots may not be followed by capital letters, digits, or underscores,\nas now.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eI am not sure whether modifier letters should be allowed after a dot.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eI am not sure what to do with the Other_ID_Start characters.\nScript capital p \u003cem\u003elooks\u003c/em\u003e like a capital p and even has \"capital\" in\nits name.  All other \"* SCRIPT CAPITAL *\" characters are upper case\nletters.  Surely it should be allowed to start a variable.\nThe estimated sign looks like an enlarged lower case e; other symbols\nthat look like letters are classified as letters.  You'd expect this\nto begin an atom.  As for the Katakana-Hiragana voicing marks, I have\nno intuition whatever.  Assigning the whole group to atoms seems\nsafest.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAll existing variable names and unquoted atoms remain legal, and no\nnew variable or atom forms using only Latin-1 characters have been\nintroduced.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eWhile Erlang files meant to be shared with a wide audience should\nstill be written in English, if people are working in a group fluent\nin some language on requirements also written in that language, it\nis desirable that they should be able to stay close to the terminology\nof the requirements lest they introduce translation errors.\u003c/p\u003e\n\n\u003cp\u003eThe whole design flows in the direction \"if someone wants to use their\nown script in an Erlang file, they should be able to do so comfortably\nin a way that is generally consistent with other programming\nlanguages.\"\u003c/p\u003e\n\n\u003cp\u003eThis \u003cem\u003edoes\u003c/em\u003e mean that there will be Erlang source files that a skilled\nErlang programmer is unable to decipher because of the unfamiliarity\nof the script.  With over 110,000 characters in Unicode 6, this is\njust going to happen no matter what we do.  Once Unicode strings are\navailable, can quoted Unicode atoms be far behind?  And once they are\npossible, refusing unquoted Unicode atoms does not salvage universal\nreadability.  All it would accomplish is to annoy people by requiring\nsingle quotation marks to be used liberally.  Old Algol programmers\nwill recall only too clearly how much of an impairment to readability\na hailstorm of single quotation marks was.  And if you can use\nγαμμα as an atom, does it make any sense to refuse Γαμμα?\u003c/p\u003e\n\n\u003cp\u003eOne of the goals for this EEP is that if an Erlang text contains only\nLatin-1 characters, then it should be legal under the new rules if and\nonly if it is legal under the old rules, and should have the same\nmeaning in either context.  During the transition period, there will\nbe people writing Erlang code for systems following the new rules, and\ngiving it to people using Latin-1 or at any rate old-rules systems.\nThey should not \u003cem\u003eaccidentally\u003c/em\u003e introduce incompatibilities.  This is\nwhy we have to ban  \"ª\" and \"º\" for now.  Later we may lift that ban.\u003c/p\u003e\n\n\u003cp\u003eThere are three ways we have to customize the UAX 31 definition.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    - We have to continue to support \"@\" in variables and\n      \"@\" and \".\" in unquoted atoms for backwards compatibility.\n\n    - We have to continue to forbid unquoted atoms containing\n      the Latin-1 masculine and feminine ordinal indicators.\n\n    - We have to distinguish between variables and unquoted atoms.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere is a fourth way we \u003cem\u003emight\u003c/em\u003e customize it.  Ken Whistler of\nUnicode advises that he \"doesn't see much point\" in allowing Pc\ncharacters other than LOW LINE and FULLWIDTH LOW LINE, unless there\nare legacy reasons why something else has to be supported.  It seems\nlike a good idea that if s is a legal ASCII identifier, the full width\nversion of s should also be a legal identifier, so FULLWIDTH LOW LINE\ndefinitely ought to be allowed.  I find using UNDERTIE cool, but it's\nan editor's mark really.  If we reject the other Pc characters now, we\ncan always allow them later if we find a need; if we allow them now,\nit will be hard to reject them later.  Making this change \u003cem\u003eclearly\u003c/em\u003e in\nthe definitions will take a little thought, so that's for the next revision.\u003c/p\u003e\n\n\u003cp\u003eDmitry Belyaev has raised the issue of localising keywords.  That is\noutside the scope of this EEP, which is concerned with which character\nsequences are variables and which are keywords-or-unquoted-atoms.\nThis has to be got right first before we can consider localised keywords.\u003c/p\u003e\n\n\u003cp\u003eThe leading underscore rule was revised on the 5th of November on\nthe advice of Ulrich Neumerkel to avoid the problem that _Œuvre\nwould not have been accepted as a singleton.  Now it will.  This was\nironic, as Māori variables like _Āporo would have been misclassified.\u003c/p\u003e\n\n\u003ch2\u003eTrouble spot\u003c/h2\u003e\n\n\u003cp\u003eIt is highly desirable that a legal Erlang text should remain legal\neven as Unicode is revised.  \u003ca href=\"http://www.unicode.org/reports/tr31/\" title=\"Unicode Standard Annex 31\"\u003eUAX#31\u003c/a\u003e and \u003ca href=\"http://www.unicode.org/policies/stability_policy.html\" title=\"Unicode Character Encoding Stability Policy\"\u003eStability\u003c/a\u003e very nearly\ngive us what we need.  The one problem that seems to be technically\npossible is that an upper or lower case letter without an opposite\ncase counterpart might change its General Category (while being given\nthe Other_ID_Start property if it ceased to be a letter at all),\nso an identifier beginning with such a cased orphan might switch from\nvariable to unquoted atom or vice versa.  Some cased orphans do exist,\nlike LATIN LETTER SMALL CAPITAL M, but what would a capital capital M\nbe?\u003c/p\u003e\n\n\u003cp\u003eOne possibility is to raise the issue with the Unicode consortium and\nleave this unresolved until they reply.  The issue \u003cem\u003ehas\u003c/em\u003e been raised,\nand the tentative reply \"you may not be able to rely on any given\nstandard property for special purposes.  Especially if that property is not\nformally stable.\" given.  The next step may well be to seek a revision\nto UAX#31, because Erlang is not alone in wanting a case distinction.\u003c/p\u003e\n\n\u003cp\u003eAnother possibility would be to say that an Lu character may only\nbegin a variable if it has a lower-case counterpart, and an Ll\ncharacter may only begin an unquoted atom if it has an upper-case\ncounterpart.  Since \"ß\" and \"ÿ\" have upper-case counterparts in\nUnicode, Latin-1 unquoted atoms would not be affected by such a rule.\nThe great mass of Lo characters would also be unaffected.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0040"},"buildId":"LNcThF2jK_Vf0EYibERT7","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/LNcThF2jK_Vf0EYibERT7/_buildManifest.js" async=""></script><script src="/_next/static/LNcThF2jK_Vf0EYibERT7/_ssgManifest.js" async=""></script></body></html>