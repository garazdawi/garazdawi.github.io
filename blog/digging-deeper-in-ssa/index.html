<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/digging-deeper-in-ssa/">Digging deeper in SSA</a></h3><p><em>Thursday, 20 September 2018<!-- --> - <!-- -->Björn Gustavsson</em></p><p>This blog post continues the exploration of the <a href="https://github.com/erlang/otp/pull/1935">new SSA-based
intermediate representation</a> through multiple examples. Make
sure to read the <a href="http://blog.erlang.org/introducing-ssa/">Introduction to SSA</a> if you missed it.</p><h2>Calling a BIF that may fail</h2><p>The first example calls a guard BIF that may fail with
an exception:</p><pre><code class="language-erlang">element_body(T) -&gt;
    element(2, T).</code></pre><p>The (optimized) SSA code looks like this:</p><pre><code>function blog:element_body(_0) {
0:
  %% blog.erl:5
  _1 = bif:element literal 2, _0
  @ssa_bool = succeeded _1
  br @ssa_bool, label 3, label 1

3:
  ret _1

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}</code></pre><p>Let&#x27;s go through the code a few lines at a time:</p><pre><code>  %% blog.erl:5
  _1 = bif:element literal 2, _0
  @ssa_bool = succeeded _1</code></pre><p>The <code>bif:element</code> instruction calls the guard BIF <code>element/2</code>, assigning
the value to the variable <code>_1</code> if the call is successful.</p><p>What if the call is not successful?</p><p>The <code>succeeded _1</code> instruction tests whether the previous instruction
assigning to <code>_1</code> was successful. <code>true</code> will be assigned to <code>@ssa_bool</code>
if the second element of the tuple was successfully fetched from the tuple,
and <code>false</code> will be assigned otherwise.</p><pre><code>  br @ssa_bool, label 3, label 1</code></pre><p>The <code>br</code> instruction tests whether <code>@ssa_bool</code> is <code>true</code>. If <code>true</code>, execution
continues at block 3, which returns the value of the second element from the
tuple. If <code>false</code>, execution continues at block 1.</p><p>It was mentioned in the <a href="http://blog.erlang.org/introducing-ssa/">previous blog post</a> that block 1 is a
special block that the SSA code generator always emits. In the
previous examples, it was never referenced and therefore removed by
one of the optimization passes.</p><p>In this example, it is used as the target when the call to <code>element/2</code> fails.</p><p>The BEAM code generator treats references to block 1 specially. Here follows the
BEAM code for the function. As usual, I have omitted the function header.</p><pre><code>  %% Block 0.
  {line,[{location,&quot;blog.erl&quot;,5}]}.
  {bif,element,{f,0},[{integer,2},{x,0}],{x,0}}.
  return.</code></pre><p>Note that no code has been generated for block 1.</p><p>The <code>line</code> instructions gives the file name and line number of the source file.
It will be used in the stack backtrace if the following instruction fails.</p><p>The <code>bif</code> instruction calls the given guard BIF, <code>element/2</code> in this case.
The <code>{f,0}</code> operand gives the action to take if the <code>element/2</code> fails. The number
<code>0</code> is a special case, meaning that a <code>badarg</code> exception should be raised if the
call of <code>element/2</code> fails.</p><h2>A failing BIF call in a guard</h2><p>In the next example, <code>element/2</code> is called in a guard:</p><pre><code class="language-erlang">element_guard(T) when element(2, T) =:= true -&gt;
    ok;
element_guard(_) -&gt;
    error.</code></pre><p>The SSA code looks like this:</p><pre><code>function blog:element_guard(_0) {
0:
  %% blog.erl:7
  _1 = bif:element literal 2, _0
  @ssa_bool = succeeded _1
  br @ssa_bool, label 4, label 3

4:
  @ssa_bool:5 = bif:&#x27;=:=&#x27; _1, literal true
  br @ssa_bool:5, label 6, label 3

6:
  ret literal ok

3:
  ret literal error
}</code></pre><p>The first two instructions in block 0 are the same as in the previous
example.  The <code>br</code> instruction has different labels, though. The
failure label refers to block 3, which returns the value <code>error</code>. The
success label continues execution at block 4.</p><pre><code>4:
  @ssa_bool:5 = bif:&#x27;=:=&#x27; _1, literal true
  br @ssa_bool:5, label 6, label 3</code></pre><p>Block 4 is the translation of <code>=:= true</code> part of the Erlang code.
If the second element in the tuple is equal to <code>true</code>, execution
continues at block 6, which returns the value <code>ok</code>. Otherwise
execution continues at block 3, which returns the value <code>error</code>.</p><p>Here is the BEAM code:</p><pre><code>  {bif,element,{f,5},[{integer,2},{x,0}],{x,0}}.
  {test,is_eq_exact,{f,5},[{x,0},{atom,true}]}.
  {move,{atom,ok},{x,0}}.
  return.
{label,5}.
  {move,{atom,error},{x,0}}.
  return.</code></pre><p>In the <code>bif</code> instruction, <code>{f,5}</code> means that execution should
continue at label 5 if the <code>element/2</code> call fails. Otherwise
execution will continue at the next instruction.</p><h2>Our first case</h2><p>Here is the next example:</p><pre><code class="language-erlang">case1(X) -&gt;
    case X of
        1 -&gt; a;
        2 -&gt; b;
        _ -&gt; c
    end.</code></pre><p>Translated to SSA code:</p><pre><code>function blog:case1(_0) {
0:
  switch _0, label 3, [ { literal 2, label 5 }, { literal 1, label 4 } ]

4:
  ret literal a

5:
  ret literal b

3:
  ret literal c
}</code></pre><p>The <code>switch</code> instruction is a multi-way branch to one of any number of
other blocks, based on the value of a variable. In this example, it
branches based on the value of the variable <code>_0</code>. If <code>_0</code> is equal
to 2, execution continues at block 5. If <code>_0</code> is equal to 1,
execution continues at block 4. If the value is not equal to any
of the values in the switch list, execution continues at the block
referred to by the failure label, in this example block 3.</p><p>The BEAM code looks like this:</p><pre><code>  {select_val,{x,0},{f,10},{list,[{integer,2},{f,9},{integer,1},{f,8}]}}.
{label,8}.
  {move,{atom,a},{x,0}}.
  return.
{label,9}.
  {move,{atom,b},{x,0}}.
  return.
{label,10}.
  {move,{atom,c},{x,0}}.
  return.</code></pre><h2>Terminators</h2><p>As mentioned in the <a href="http://blog.erlang.org/introducing-ssa/">previous blog post</a>, the last instruction in a block is
called a <em>terminator</em>. A terminator either returns from the function or transfers
control to another block. With the introduction of <code>switch</code>, the terminator story
is complete. To summarize, a block can end in one of the following terminators:</p><ul><li><p><code>ret</code> to return a value from the function.</p></li><li><p><code>br</code> to either branch to another block (one-way branch), or branch to one
of two possible other blocks based on a variable (two-way branch).</p></li><li><p><code>switch</code> to branch to one of any number of other blocks.</p></li></ul><h2>Another case</h2><p>Here is a slightly different example:</p><pre><code class="language-erlang">case2(X) -&gt;
    case X of
        1 -&gt; a;
        2 -&gt; b;
        3 -&gt; c
    end.</code></pre><p>In this case, <code>X</code> must be one of the integers 1, 2, or 3. Otherwise, there will
be a <code>{case_clause,X}</code> exception. Here is the SSA code:</p><pre><code>function blog:case2(_0) {
0:
  switch _0, label 3, [ { literal 3, label 6 }, { literal 2, label 5 }, { literal 1, label 4 } ]

4:
  ret literal a

5:
  ret literal b

6:
  ret literal c

3:
  _2 = put_tuple literal case_clause, _0

  %% blog.erl:20
  @ssa_ret:7 = call remote (literal erlang):(literal error)/1, _2
  ret @ssa_ret:7
}</code></pre><p>The failure label for the <code>switch</code> is 3. Block 3 builds the <code>{case_clause,X}</code>
tuple and calls <code>erlang:error/1</code>.</p><p>Here is the BEAM code:</p><pre><code>  {select_val,{x,0},
              {f,16},
              {list,[{integer,3},
                     {f,15},
                     {integer,2},
                     {f,14},
                     {integer,1},
                     {f,13}]}}.
{label,13}.
  {move,{atom,a},{x,0}}.
  return.
{label,14}.
  {move,{atom,b},{x,0}}.
  return.
{label,15}.
  {move,{atom,c},{x,0}}.
  return.
{label,16}.
  {line,[{location,&quot;blog.erl&quot;,20}]}.
  {case_end,{x,0}}.</code></pre><p>The <code>case_end</code> instruction is an optimization to save space. It is shorter than
the equivalent:</p><pre><code>  {test_heap,3,1}.
  {put_tuple2,{x,0},{list,[{atom,case_clause},{x,0}]}}.
  {line,[{location,&quot;blog.erl&quot;,20}]}.
  {call_ext_only,1,{extfunc,erlang,error,1}}.</code></pre><p>(The <code>put_tuple2</code> instruction was introduced in
<a href="https://github.com/erlang/otp/pull/1947">#1947: Introduce a put_tuple2 instruction</a>, which was recently merged
to <code>master</code>.)</p><h2>Our final case</h2><p>It&#x27;s time to address the kind of <code>case</code> similar to what was teased at the
end of the previous blog post.</p><p>In this example, the variable <code>Y</code> will be assigned different values in
each clause of the <code>case</code>:</p><pre><code class="language-erlang">case3a(X) -&gt;
    case X of
        zero -&gt;
            Y = 0;
        something -&gt;
            Y = X;
        _ -&gt;
            Y = no_idea
    end,
    {ok,Y}.</code></pre><p>Perhaps a more common way to write this <code>case</code> would be:</p><pre><code class="language-erlang">case3b(X) -&gt;
    Y = case X of
            zero -&gt; 0;
            something -&gt; X;
            _ -&gt; no_idea
        end,
    {ok,Y}.</code></pre><p>In either case, the problem remains. Static Single Assignment means that each
variable can only be given a value once. So how can this example be translated
to SSA code?</p><p>Here follows the SSA code for <code>case3a/1</code>. The SSA code for <code>case3b/1</code> is almost
identical except for variable naming.</p><pre><code>function blog:case3a(_0) {
0:
  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]

5:
  br label 3

6:
  br label 3

4:
  br label 3

3:
  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }
  _7 = put_tuple literal ok, Y
  ret _7
}</code></pre><p>Let&#x27;s jump right to the interesting (and confusing) part of the code:</p><pre><code>3:
  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }</code></pre><p>Clearly, <code>Y</code> is only given a value once, so the SSA property is
preserved.</p><p>That&#x27;s good, but exactly what is the value that is being assigned?</p><p>The name of the instruction is <code>phi</code>, which is the name of the
Greek letter <a href="https://en.wikipedia.org/wiki/Phi">φ</a>. Having an unusual name, the instruction
deserves to have unusual operands, too. Each operand is a pair, the
first element in the pair being a value and the second element a block
number of a predecessor block. The value of the <code>phi</code> node will be one
of the values from one the pairs. But from which pair? That depends on
the number of the previous block that branched to the <code>phi</code> instruction.</p><p>To make that somewhat clearer, let&#x27;s look at all operands:</p><ul><li><p><code>{ literal no_idea, 4 }</code>: If the number of block that executed <code>br label 3</code>
was 4, the value of the <code>phi</code> instruction will be the value in this pair,
that is, the atom <code>no_idea</code>. The failure label for the <code>switch</code> instruction
is 4, so this pair will be chosen when <code>_0</code> does not match any of the values
in the switch list.</p></li><li><p><code>{ literal 0, 5 }</code>: If the number of block that executed <code>br label 3</code>
was 5, the value of the <code>phi</code> instruction will be the integer 0. The
<code>switch</code> instruction will transfer control to block 5 if the value of
<code>_0</code> is the atom <code>zero</code>.</p></li><li><p><code>{ _0, 6 }</code>: Finally, if <code>_0</code> is the atom <code>something</code>, the <code>switch</code>
will transfer control to block 6, which will transfer control to
block 3. The value of the <code>phi</code> instruction will be the value of the
variable <code>_0</code>.</p></li></ul><p>The concept of <code>phi</code> instructions probably feels a bit strange at
first sight (and at second sight), and one might also think they
must be terribly inefficient.</p><p>Leaving the strangeness aside, let&#x27;s talk about the efficiency. <code>phi</code>
instructions is a fiction convenient for representing and optimizing
the code. When translating to BEAM code, the <code>phi</code> instructions are
eliminated.</p><p>Here follows an example that is <strong>not</strong> SSA code, because it assigns
the variable <code>Y</code> three times, but gives an idea how the <code>phi</code>
instruction is eliminated:</p><pre><code>%% Not SSA code!
function blog:case3a(_0) {
0:
  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]

5:
  Y := literal 0
  br label 3

6:
  Y := _0
  br label 3

4:
  Y := no_idea
  br label 3

3:
  _7 = put_tuple literal ok, Y
  ret _7
}</code></pre><p>The BEAM code generator (<code>beam_ssa_codegen</code>) does a similar rewrite
during code generation.</p><p>Here is the unoptimized BEAM code, slightly edited for clarity:</p><pre><code>%% Block 0.
{select_val,{x,0},
            {f,53},
            {list,[{atom,something},{f,55},{atom,zero},{f,57}]}}.

%% Block 5.
{label,57}.
  {move,{integer,0},{x,0}}.
  {jump,{f,59}}.

%% Block 6.
{label,55}.
  %% The result is already in {x,0}.
  {jump,{f,59}}.

%% Block 4.
{label,53}.
  {move,{atom,no_idea},{x,0}}.
  {jump,{f,59}}.

%% Block 3.
{label,59}.
   {test_heap,3,1}.
   {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.
   return.</code></pre><p>Here is the final BEAM code after some more optimizations:</p><pre><code>{label,18}.
  {select_val,{x,0},
              {f,20},
              {list,[{atom,something},{f,21},{atom,zero},{f,19}]}}.
{label,19}.
  {move,{integer,0},{x,0}}.
  {jump,{f,21}}.
{label,20}.
  {move,{atom,no_idea},{x,0}}.
{label,21}.
  {test_heap,3,1}.
  {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.
  return.</code></pre><h2>The cold case</h2><p>Here is the example from the end of the previous blog post:</p><pre><code class="language-erlang">bar(X) -&gt;
    case X of
        none -&gt;
            Y = 0;
        _ -&gt;
            Y = X
    end,
    Y + 1.</code></pre><p>And here is the SSA code:</p><pre><code>function blog:bar(_0) {
0:
  @ssa_bool = bif:&#x27;=:=&#x27; _0, literal none
  br @ssa_bool, label 5, label 4

5:
  br label 3

4:
  br label 3

3:
  Y = phi { _0, 4 }, { literal 0, 5 }

  %% blog.erl:52
  _6 = bif:&#x27;+&#x27; Y, literal 1
  @ssa_bool:6 = succeeded _6
  br @ssa_bool:6, label 7, label 1

7:
  ret _6

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}</code></pre><p>It is left as an exercise to the reader to read and understand the code.</p><p>Here is the BEAM code:</p><pre><code>{label,28}.
  {test,is_eq_exact,{f,29},[{x,0},{atom,none}]}.
  {move,{integer,0},{x,0}}.
{label,29}.
  {line,[{location,&quot;blog.erl&quot;,52}]}.
  {gc_bif,&#x27;+&#x27;,{f,0},1,[{x,0},{integer,1}],{x,0}}.
  return.</code></pre><p>The <code>gc_bif</code> instruction calls a guard BIF that might need to do a
garbage collection. Since integers can be of essentially unlimited
size in Erlang, the result of <code>+</code> might not fit in a word. The
<code>1</code> following <code>{f,0}</code> is the number of registers that must be
preserved; in this case, only <code>{x,0}</code>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"digging-deeper-in-ssa","title":"Digging deeper in SSA","author":"Björn Gustavsson","excerpt":"\nThis blog post continues the exploration of the [new SSA-based\nintermediate representation][pr1935] through multiple examples. Make\nsure to read the [Introduction to SSA][prev] if you missed it.\n\n[prev]: http://blog.erlang.org/introducing-ssa/,\n[pr1935]: https://github.com/erlang/otp/pull/1935,\n[pr1947]: https://github.com/erlang/otp/pull/1947,\n[phi]: https://en.wikipedia.org/wiki/Phi","article_date":1537401600000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Digging deeper in SSA","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post continues the exploration of the [new SSA-based\nintermediate representation][pr1935] through multiple examples. Make\nsure to read the [Introduction to SSA][prev] if you missed it.\n\n## Calling a BIF that may fail\n\nThe first example calls a guard BIF that may fail with\nan exception:\n\n```erlang\nelement_body(T) -\u003e\n    element(2, T).\n```\n\nThe (optimized) SSA code looks like this:\n\n```\nfunction blog:element_body(_0) {\n0:\n  %% blog.erl:5\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n  br @ssa_bool, label 3, label 1\n\n3:\n  ret _1\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\nLet's go through the code a few lines at a time:\n\n```\n  %% blog.erl:5\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n```\n\nThe `bif:element` instruction calls the guard BIF `element/2`, assigning\nthe value to the variable `_1` if the call is successful.\n\nWhat if the call is not successful?\n\nThe `succeeded _1` instruction tests whether the previous instruction\nassigning to `_1` was successful. `true` will be assigned to `@ssa_bool`\nif the second element of the tuple was successfully fetched from the tuple,\nand `false` will be assigned otherwise.\n\n```\n  br @ssa_bool, label 3, label 1\n```\n\nThe `br` instruction tests whether `@ssa_bool` is `true`. If `true`, execution\ncontinues at block 3, which returns the value of the second element from the\ntuple. If `false`, execution continues at block 1.\n\nIt was mentioned in the [previous blog post][prev] that block 1 is a\nspecial block that the SSA code generator always emits. In the\nprevious examples, it was never referenced and therefore removed by\none of the optimization passes.\n\nIn this example, it is used as the target when the call to `element/2` fails.\n\nThe BEAM code generator treats references to block 1 specially. Here follows the\nBEAM code for the function. As usual, I have omitted the function header.\n\n      %% Block 0.\n      {line,[{location,\"blog.erl\",5}]}.\n      {bif,element,{f,0},[{integer,2},{x,0}],{x,0}}.\n      return.\n\nNote that no code has been generated for block 1.\n\nThe `line` instructions gives the file name and line number of the source file.\nIt will be used in the stack backtrace if the following instruction fails.\n\nThe `bif` instruction calls the given guard BIF, `element/2` in this case.\nThe `{f,0}` operand gives the action to take if the `element/2` fails. The number\n`0` is a special case, meaning that a `badarg` exception should be raised if the\ncall of `element/2` fails.\n\n## A failing BIF call in a guard\n\nIn the next example, `element/2` is called in a guard:\n\n```erlang\nelement_guard(T) when element(2, T) =:= true -\u003e\n    ok;\nelement_guard(_) -\u003e\n    error.\n```\n\nThe SSA code looks like this:\n\n```\nfunction blog:element_guard(_0) {\n0:\n  %% blog.erl:7\n  _1 = bif:element literal 2, _0\n  @ssa_bool = succeeded _1\n  br @ssa_bool, label 4, label 3\n\n4:\n  @ssa_bool:5 = bif:'=:=' _1, literal true\n  br @ssa_bool:5, label 6, label 3\n\n6:\n  ret literal ok\n\n3:\n  ret literal error\n}\n```\n\nThe first two instructions in block 0 are the same as in the previous\nexample.  The `br` instruction has different labels, though. The\nfailure label refers to block 3, which returns the value `error`. The\nsuccess label continues execution at block 4.\n\n```\n4:\n  @ssa_bool:5 = bif:'=:=' _1, literal true\n  br @ssa_bool:5, label 6, label 3\n```\n\nBlock 4 is the translation of `=:= true` part of the Erlang code.\nIf the second element in the tuple is equal to `true`, execution\ncontinues at block 6, which returns the value `ok`. Otherwise\nexecution continues at block 3, which returns the value `error`.\n\nHere is the BEAM code:\n\n      {bif,element,{f,5},[{integer,2},{x,0}],{x,0}}.\n      {test,is_eq_exact,{f,5},[{x,0},{atom,true}]}.\n      {move,{atom,ok},{x,0}}.\n      return.\n    {label,5}.\n      {move,{atom,error},{x,0}}.\n      return.\n\nIn the `bif` instruction, `{f,5}` means that execution should\ncontinue at label 5 if the `element/2` call fails. Otherwise\nexecution will continue at the next instruction.\n\n## Our first case\n\nHere is the next example:\n\n```erlang\ncase1(X) -\u003e\n    case X of\n        1 -\u003e a;\n        2 -\u003e b;\n        _ -\u003e c\n    end.\n```\n\nTranslated to SSA code:\n\n```\nfunction blog:case1(_0) {\n0:\n  switch _0, label 3, [ { literal 2, label 5 }, { literal 1, label 4 } ]\n\n4:\n  ret literal a\n\n5:\n  ret literal b\n\n3:\n  ret literal c\n}\n```\n\nThe `switch` instruction is a multi-way branch to one of any number of\nother blocks, based on the value of a variable. In this example, it\nbranches based on the value of the variable `_0`. If `_0` is equal\nto 2, execution continues at block 5. If `_0` is equal to 1,\nexecution continues at block 4. If the value is not equal to any\nof the values in the switch list, execution continues at the block\nreferred to by the failure label, in this example block 3.\n\nThe BEAM code looks like this:\n\n      {select_val,{x,0},{f,10},{list,[{integer,2},{f,9},{integer,1},{f,8}]}}.\n    {label,8}.\n      {move,{atom,a},{x,0}}.\n      return.\n    {label,9}.\n      {move,{atom,b},{x,0}}.\n      return.\n    {label,10}.\n      {move,{atom,c},{x,0}}.\n      return.\n\n## Terminators\n\nAs mentioned in the [previous blog post][prev], the last instruction in a block is\ncalled a *terminator*. A terminator either returns from the function or transfers\ncontrol to another block. With the introduction of `switch`, the terminator story\nis complete. To summarize, a block can end in one of the following terminators:\n\n* `ret` to return a value from the function.\n\n* `br` to either branch to another block (one-way branch), or branch to one\nof two possible other blocks based on a variable (two-way branch).\n\n* `switch` to branch to one of any number of other blocks.\n\n## Another case\n\nHere is a slightly different example:\n\n```erlang\ncase2(X) -\u003e\n    case X of\n        1 -\u003e a;\n        2 -\u003e b;\n        3 -\u003e c\n    end.\n```\n\nIn this case, `X` must be one of the integers 1, 2, or 3. Otherwise, there will\nbe a `{case_clause,X}` exception. Here is the SSA code:\n\n```\nfunction blog:case2(_0) {\n0:\n  switch _0, label 3, [ { literal 3, label 6 }, { literal 2, label 5 }, { literal 1, label 4 } ]\n\n4:\n  ret literal a\n\n5:\n  ret literal b\n\n6:\n  ret literal c\n\n3:\n  _2 = put_tuple literal case_clause, _0\n\n  %% blog.erl:20\n  @ssa_ret:7 = call remote (literal erlang):(literal error)/1, _2\n  ret @ssa_ret:7\n}\n```\n\nThe failure label for the `switch` is 3. Block 3 builds the `{case_clause,X}`\ntuple and calls `erlang:error/1`.\n\nHere is the BEAM code:\n\n      {select_val,{x,0},\n                  {f,16},\n                  {list,[{integer,3},\n                         {f,15},\n                         {integer,2},\n                         {f,14},\n                         {integer,1},\n                         {f,13}]}}.\n    {label,13}.\n      {move,{atom,a},{x,0}}.\n      return.\n    {label,14}.\n      {move,{atom,b},{x,0}}.\n      return.\n    {label,15}.\n      {move,{atom,c},{x,0}}.\n      return.\n    {label,16}.\n      {line,[{location,\"blog.erl\",20}]}.\n      {case_end,{x,0}}.\n\nThe `case_end` instruction is an optimization to save space. It is shorter than\nthe equivalent:\n\n      {test_heap,3,1}.\n      {put_tuple2,{x,0},{list,[{atom,case_clause},{x,0}]}}.\n      {line,[{location,\"blog.erl\",20}]}.\n      {call_ext_only,1,{extfunc,erlang,error,1}}.\n\n(The `put_tuple2` instruction was introduced in\n[#1947: Introduce a put_tuple2 instruction][pr1947], which was recently merged\nto `master`.)\n\n## Our final case\n\nIt's time to address the kind of `case` similar to what was teased at the\nend of the previous blog post.\n\nIn this example, the variable `Y` will be assigned different values in\neach clause of the `case`:\n\n```erlang\ncase3a(X) -\u003e\n    case X of\n        zero -\u003e\n            Y = 0;\n        something -\u003e\n            Y = X;\n        _ -\u003e\n            Y = no_idea\n    end,\n    {ok,Y}.\n```\n\nPerhaps a more common way to write this `case` would be:\n\n```erlang\ncase3b(X) -\u003e\n    Y = case X of\n            zero -\u003e 0;\n            something -\u003e X;\n            _ -\u003e no_idea\n        end,\n    {ok,Y}.\n```\n\nIn either case, the problem remains. Static Single Assignment means that each\nvariable can only be given a value once. So how can this example be translated\nto SSA code?\n\nHere follows the SSA code for `case3a/1`. The SSA code for `case3b/1` is almost\nidentical except for variable naming.\n\n```\nfunction blog:case3a(_0) {\n0:\n  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]\n\n5:\n  br label 3\n\n6:\n  br label 3\n\n4:\n  br label 3\n\n3:\n  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }\n  _7 = put_tuple literal ok, Y\n  ret _7\n}\n```\n\nLet's jump right to the interesting (and confusing) part of the code:\n\n```\n3:\n  Y = phi { literal no_idea, 4 }, { literal 0, 5 }, { _0, 6 }\n```\n\nClearly, `Y` is only given a value once, so the SSA property is\npreserved.\n\nThat's good, but exactly what is the value that is being assigned?\n\nThe name of the instruction is `phi`, which is the name of the\nGreek letter [\u0026phi;][phi]. Having an unusual name, the instruction\ndeserves to have unusual operands, too. Each operand is a pair, the\nfirst element in the pair being a value and the second element a block\nnumber of a predecessor block. The value of the `phi` node will be one\nof the values from one the pairs. But from which pair? That depends on\nthe number of the previous block that branched to the `phi` instruction.\n\nTo make that somewhat clearer, let's look at all operands:\n\n* `{ literal no_idea, 4 }`: If the number of block that executed `br label 3`\nwas 4, the value of the `phi` instruction will be the value in this pair,\nthat is, the atom `no_idea`. The failure label for the `switch` instruction\nis 4, so this pair will be chosen when `_0` does not match any of the values\nin the switch list.\n\n* `{ literal 0, 5 }`: If the number of block that executed `br label 3`\nwas 5, the value of the `phi` instruction will be the integer 0. The\n`switch` instruction will transfer control to block 5 if the value of\n`_0` is the atom `zero`.\n\n* `{ _0, 6 }`: Finally, if `_0` is the atom `something`, the `switch`\nwill transfer control to block 6, which will transfer control to\nblock 3. The value of the `phi` instruction will be the value of the\nvariable `_0`.\n\nThe concept of `phi` instructions probably feels a bit strange at\nfirst sight (and at second sight), and one might also think they\nmust be terribly inefficient.\n\nLeaving the strangeness aside, let's talk about the efficiency. `phi`\ninstructions is a fiction convenient for representing and optimizing\nthe code. When translating to BEAM code, the `phi` instructions are\neliminated.\n\nHere follows an example that is **not** SSA code, because it assigns\nthe variable `Y` three times, but gives an idea how the `phi`\ninstruction is eliminated:\n\n```\n%% Not SSA code!\nfunction blog:case3a(_0) {\n0:\n  switch _0, label 4, [ { literal something, label 6 }, { literal zero, label 5 } ]\n\n5:\n  Y := literal 0\n  br label 3\n\n6:\n  Y := _0\n  br label 3\n\n4:\n  Y := no_idea\n  br label 3\n\n3:\n  _7 = put_tuple literal ok, Y\n  ret _7\n}\n```\n\nThe BEAM code generator (`beam_ssa_codegen`) does a similar rewrite\nduring code generation.\n\nHere is the unoptimized BEAM code, slightly edited for clarity:\n\n    %% Block 0.\n    {select_val,{x,0},\n                {f,53},\n                {list,[{atom,something},{f,55},{atom,zero},{f,57}]}}.\n\n    %% Block 5.\n    {label,57}.\n      {move,{integer,0},{x,0}}.\n      {jump,{f,59}}.\n\n    %% Block 6.\n    {label,55}.\n      %% The result is already in {x,0}.\n      {jump,{f,59}}.\n\n    %% Block 4.\n    {label,53}.\n      {move,{atom,no_idea},{x,0}}.\n      {jump,{f,59}}.\n\n    %% Block 3.\n    {label,59}.\n       {test_heap,3,1}.\n       {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n       return.\n\nHere is the final BEAM code after some more optimizations:\n\n    {label,18}.\n      {select_val,{x,0},\n                  {f,20},\n                  {list,[{atom,something},{f,21},{atom,zero},{f,19}]}}.\n    {label,19}.\n      {move,{integer,0},{x,0}}.\n      {jump,{f,21}}.\n    {label,20}.\n      {move,{atom,no_idea},{x,0}}.\n    {label,21}.\n      {test_heap,3,1}.\n      {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n      return.\n\n## The cold case\n\nHere is the example from the end of the previous blog post:\n\n```erlang\nbar(X) -\u003e\n    case X of\n        none -\u003e\n            Y = 0;\n        _ -\u003e\n            Y = X\n    end,\n    Y + 1.\n```\n\nAnd here is the SSA code:\n\n```\nfunction blog:bar(_0) {\n0:\n  @ssa_bool = bif:'=:=' _0, literal none\n  br @ssa_bool, label 5, label 4\n\n5:\n  br label 3\n\n4:\n  br label 3\n\n3:\n  Y = phi { _0, 4 }, { literal 0, 5 }\n\n  %% blog.erl:52\n  _6 = bif:'+' Y, literal 1\n  @ssa_bool:6 = succeeded _6\n  br @ssa_bool:6, label 7, label 1\n\n7:\n  ret _6\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\nIt is left as an exercise to the reader to read and understand the code.\n\nHere is the BEAM code:\n\n    {label,28}.\n      {test,is_eq_exact,{f,29},[{x,0},{atom,none}]}.\n      {move,{integer,0},{x,0}}.\n    {label,29}.\n      {line,[{location,\"blog.erl\",52}]}.\n      {gc_bif,'+',{f,0},1,[{x,0},{integer,1}],{x,0}}.\n      return.\n\nThe `gc_bif` instruction calls a guard BIF that might need to do a\ngarbage collection. Since integers can be of essentially unlimited\nsize in Erlang, the result of `+` might not fit in a word. The\n`1` following `{f,0}` is the number of registers that must be\npreserved; in this case, only `{x,0}`.\n\n[prev]: http://blog.erlang.org/introducing-ssa/\n[pr1935]: https://github.com/erlang/otp/pull/1935\n[pr1947]: https://github.com/erlang/otp/pull/1947\n[phi]: https://en.wikipedia.org/wiki/Phi\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"digging-deeper-in-ssa"},"buildId":"L68tPJnB-kPxrFxsY9AoN","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_buildManifest.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_ssgManifest.js" async=""></script></body></html>