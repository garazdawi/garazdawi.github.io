<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 27-Aug-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 22: <a href="eep-0022.md" title="EEP Source"> Range checking for binaries</a></h2>

<h1>Abstract</h1>

<p>A module may request that bit fields be range checked.</p>

<h1>Specification</h1>

<p>A new directive is added.</p>

<pre><code>-bit_range_check(Wanted).
</code></pre>

<p>where Wanted is 'false' or 'true'.</p>

<p>Recall that a segment of a bit string (or binary) has the form</p>

<pre><code>Value [':' Size] ['/' Type_Specifier_List]
</code></pre>

<p>where <code>Type_Specifier_List</code> includes such things as 'integer',
'signed', and 'unsigned'.  Currently the documentation states
that</p>

<pre><code>"Signedness ... Only matters for matching and when the type
 is integer.  The default is unsigned."
</code></pre>

<p>Combining the <code>Size</code> with the <code>Unit</code> gives a <code>Size_In_Bits</code>.
The on-line Erlang manual does not state in section 6.16 that
in constructing a bit string the bottom <code>Size_In_Bits</code> bits of
an integer are used with the rest quietly ignored, but it is so.</p>

<p>The directive <code>-bit_range_check(false)</code> makes explicit the
programmer's intention that this C-like truncation should happen.</p>

<p>The directive <code>-bit_range_check(true)</code> says that it is a checked
run-time error in</p>

<pre><code>Value:Size/unsigned-integer-unit:1
</code></pre>

<p>or constructions otherwise equivalent to it if Value does not
lie in the range <code>0 &lt;= Value &lt; 2**Size</code>, and it is a checked
run-time error in</p>

<pre><code>Value:Size/signed-integer-unit:1
</code></pre>

<p>or constructions otherwise equivalent to it if Value does not
lie in the range <code>-(2**(Size-1)) &lt;= Value &lt; 2**(Size-1)</code>.</p>

<p>The error that is raised is like the error that would be raised
for <code>(1//0):Size/Type_Specifier_List</code> except for using 'badrange'
instead of 'badarith'.</p>

<p>The behaviour of integer bit syntax segments in the absence of
a <code>-bit_range_check</code> directive is implementation defined and
subject to change.</p>

<p>The BEAM system is extended with a new instruction or instructions
similar to the existing instruction or instructions for integer
segments but checking the range.  The compiler is extended to
generate them for <code>&lt;&lt;...&gt;&gt;</code> expressions in the range of a
<code>-bit_range_check(true)</code> directive.</p>

<p>A <code>-bit_range_check</code> directive may not appear after a bit syntax
pattern or expression or after another <code>-bit_range_check</code> directive.</p>

<h1>Motivation</h1>

<p>It keeps on coming as an unpleasant surprise to Erlang programmers
that this truncation happens.  Quiet destruction of information is
otherwise alien to Erlang:  integer arithmetic is unbounded, not
wrapped as in some (but not all) C systems; element/2 doesn't take
indices modulo tuple size but raises an exception if the index is
out of range, and so on.</p>

<p>In any case where the truncation is wanted, an Erlang programmer
can already write</p>

<pre><code>(Value rem 256):unsigned-integer
</code></pre>

<p>and the Erlang compiler could notice this and optimise the 'rem'
operation away, so the truncation is not only unusual in Erlang,
it is also unexpected in this particular case.</p>

<p>It is not only unexpected, it removes a chance to find mistakes,
so it would seem to be undesirable.</p>

<p>Edwin Fine asked "How difficult could it be to add optional run-
time checking to detect this condition without a serious risk of
adverse effects on the correctness of Erlang run-time execution?"</p>

<p>Björn Gustavsson replied "it would be better to add optional
support in the compiler to turn on checks (either for an entire
module, or for individual segments of a binary).  If someone
writes an EEP, we will consider implementing it."</p>

<p>This is that EEP.</p>

<h1>Rationale</h1>

<p>The Erlang/OTP team regard the old behaviour as a feature,
and wish to retain it.  In particular, they wish modules that
were written expecting the old behaviour to continue to work
(for now) without modification.</p>

<p>One alternative would be to add new syntax, such as having a
new 'checked' specifier, so that</p>

<pre><code>Value/checked-unsigned-integer
</code></pre>

<p>would require a value in the range 0..255.
But many Erlang programmers will want to use this as the normal
case, and will not like the safe version being so much more effort
to write than the unsafe version.</p>

<p>It appears that "truncation wanted/not wanted" is not a matter
of this expression or that, but of this programmer or that,
and we can expect that each module will be written by someone
expecting only one behaviour or expecting only the other.</p>

<p>Adding a</p>

<pre><code>-bit_range_check(true).
</code></pre>

<p>directive to a module is more work than doing nothing at all,
but programmers who want this behaviour should be able to set up
their editing environment to have this line in their template for
creating new Erlang modules.</p>

<p>There are several questions:</p>

<ul>
<li>Should this apply to bit strings as well as integers?</li>
<li>What should the name of the directive be?</li>
<li>What should the argument(s) of the directive be?</li>
<li>Should multiple instances of the directive be allowed in
a module?</li>
</ul>

<p>Bit strings:  <code>Assume X = &lt;&lt;5:3/unsigned-integer-unit:1&gt;&gt;</code>.
Currently, <code>&lt;&lt;X:2/bits&gt;&gt;</code> quietly truncates <code>X</code>.  This drops bits
from the right of <code>X</code>, giving <code>&lt;&lt;2:2&gt;&gt;</code>.  If this worked the same
as integers, you would expect <code>&lt;&lt;1:2&gt;&gt;</code>.  This is certainly
very odd.  Since we get truncation on the left and padding on
the left for integers, we naturally expect padding on the
right for bit strings to go with truncation on the right.
But <code>&lt;&lt;X:4/bits&gt;&gt;</code> isn't <code>&lt;&lt;10:4&gt;&gt;</code>, it's a runtime exception.
All very odd indeed.  It would certainly be desirable to have
an easy way for the programmer to indicate whether they wanted
truncation on the left or the right and padding on the left or
the right.  Perhaps a new built in function</p>

<pre><code>set_bit_size(Bit_String, Desired_Width,
             Truncation, Padding, Fill)

Bit_String : a bit string
Desired_Width : a non-negative integer, the width wanted
Truncation: 'left' | 'right' | 'error';
    if bit_size(Bit_String) &gt; Desired_Width
        truncate on the left/truncate on the right/
        report an error
Padding: 'left' | 'right' | 'error';
    if bit_size(Bit_String) &lt; Desired_Width
        pad on the left/pad on the right/report an error
Fill: 0 | 1 | 'copy';
    pad with 0/pad with 1/pad with a copy of the
    last bit at the end where padding is done.
</code></pre>

<p>However, that idea is only partly baked, and is not part of the
current proposal.  As things currently stand, using the bit
syntax and relying on implicit truncation is the simplest way
to extract the leading bits of a bit string.</p>

<p>As long as the name of the directive is intention-revealing,
it doesn't matter very much what it is.
I proposed <code>bit_range_check</code> because it is all about checking,
ranges in bit syntax, but since in this draft it does NOT apply
to bit string segments, perhaps <code>bit_integer_range_check</code> would
be better.</p>

<p>The arguments false and true seem clear enough.
Alternatives would be something like</p>

<pre><code>-bit_integer_range(check).
-bit_integer_range(no_check).
</code></pre>

<p>That would be fine too.</p>

<p>Classical Pascal compilers let you do things like</p>

<pre><code>{$I-}   (* disable index checks *)
(* code with no index checks *)
{$I+}   (* re-enable index checks *)
</code></pre>

<p>Allowing multiple <code>-bit_range_check</code> directives in a module could
let you use code written for the old approach inside a module
that otherwise uses the new approach.  I don't believe that we
want to encourage that sort of thing:  it is MUCH easier when
reading a module if all of it follows the same rule.</p>

<p>It is also easier for an Erlang compiler that expects to be able
to process function definitions in any order.  The compiler can
check for one of these directives anywhere in a module before it
handles any bit syntax forms anywhere.  However, it is easier for
people reading a module if, when they first see a <code>&lt;&lt;...&gt;&gt;</code>
construction, they have already seen any directive that might
affect what it means.</p>

<p>The restrictions on the number and placement of these directives
can always be relaxed later if necessary.</p>

<h1>Backwards Compatibility</h1>

<p>All existing Erlang code remains acceptable with unchanged semantics.</p>

<h1>Reference Implementation</h1>

<p>None, because I still can't find my way around the compiler.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0022","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 27-Aug-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 22: \u003ca href=\"eep-0022.md\" title=\"EEP Source\"\u003e Range checking for binaries\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eA module may request that bit fields be range checked.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eA new directive is added.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-bit_range_check(Wanted).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere Wanted is 'false' or 'true'.\u003c/p\u003e\n\n\u003cp\u003eRecall that a segment of a bit string (or binary) has the form\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eValue [':' Size] ['/' Type_Specifier_List]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eType_Specifier_List\u003c/code\u003e includes such things as 'integer',\n'signed', and 'unsigned'.  Currently the documentation states\nthat\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\"Signedness ... Only matters for matching and when the type\n is integer.  The default is unsigned.\"\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCombining the \u003ccode\u003eSize\u003c/code\u003e with the \u003ccode\u003eUnit\u003c/code\u003e gives a \u003ccode\u003eSize_In_Bits\u003c/code\u003e.\nThe on-line Erlang manual does not state in section 6.16 that\nin constructing a bit string the bottom \u003ccode\u003eSize_In_Bits\u003c/code\u003e bits of\nan integer are used with the rest quietly ignored, but it is so.\u003c/p\u003e\n\n\u003cp\u003eThe directive \u003ccode\u003e-bit_range_check(false)\u003c/code\u003e makes explicit the\nprogrammer's intention that this C-like truncation should happen.\u003c/p\u003e\n\n\u003cp\u003eThe directive \u003ccode\u003e-bit_range_check(true)\u003c/code\u003e says that it is a checked\nrun-time error in\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eValue:Size/unsigned-integer-unit:1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor constructions otherwise equivalent to it if Value does not\nlie in the range \u003ccode\u003e0 \u0026lt;= Value \u0026lt; 2**Size\u003c/code\u003e, and it is a checked\nrun-time error in\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eValue:Size/signed-integer-unit:1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor constructions otherwise equivalent to it if Value does not\nlie in the range \u003ccode\u003e-(2**(Size-1)) \u0026lt;= Value \u0026lt; 2**(Size-1)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe error that is raised is like the error that would be raised\nfor \u003ccode\u003e(1//0):Size/Type_Specifier_List\u003c/code\u003e except for using 'badrange'\ninstead of 'badarith'.\u003c/p\u003e\n\n\u003cp\u003eThe behaviour of integer bit syntax segments in the absence of\na \u003ccode\u003e-bit_range_check\u003c/code\u003e directive is implementation defined and\nsubject to change.\u003c/p\u003e\n\n\u003cp\u003eThe BEAM system is extended with a new instruction or instructions\nsimilar to the existing instruction or instructions for integer\nsegments but checking the range.  The compiler is extended to\ngenerate them for \u003ccode\u003e\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u003c/code\u003e expressions in the range of a\n\u003ccode\u003e-bit_range_check(true)\u003c/code\u003e directive.\u003c/p\u003e\n\n\u003cp\u003eA \u003ccode\u003e-bit_range_check\u003c/code\u003e directive may not appear after a bit syntax\npattern or expression or after another \u003ccode\u003e-bit_range_check\u003c/code\u003e directive.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eIt keeps on coming as an unpleasant surprise to Erlang programmers\nthat this truncation happens.  Quiet destruction of information is\notherwise alien to Erlang:  integer arithmetic is unbounded, not\nwrapped as in some (but not all) C systems; element/2 doesn't take\nindices modulo tuple size but raises an exception if the index is\nout of range, and so on.\u003c/p\u003e\n\n\u003cp\u003eIn any case where the truncation is wanted, an Erlang programmer\ncan already write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(Value rem 256):unsigned-integer\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand the Erlang compiler could notice this and optimise the 'rem'\noperation away, so the truncation is not only unusual in Erlang,\nit is also unexpected in this particular case.\u003c/p\u003e\n\n\u003cp\u003eIt is not only unexpected, it removes a chance to find mistakes,\nso it would seem to be undesirable.\u003c/p\u003e\n\n\u003cp\u003eEdwin Fine asked \"How difficult could it be to add optional run-\ntime checking to detect this condition without a serious risk of\nadverse effects on the correctness of Erlang run-time execution?\"\u003c/p\u003e\n\n\u003cp\u003eBjörn Gustavsson replied \"it would be better to add optional\nsupport in the compiler to turn on checks (either for an entire\nmodule, or for individual segments of a binary).  If someone\nwrites an EEP, we will consider implementing it.\"\u003c/p\u003e\n\n\u003cp\u003eThis is that EEP.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe Erlang/OTP team regard the old behaviour as a feature,\nand wish to retain it.  In particular, they wish modules that\nwere written expecting the old behaviour to continue to work\n(for now) without modification.\u003c/p\u003e\n\n\u003cp\u003eOne alternative would be to add new syntax, such as having a\nnew 'checked' specifier, so that\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eValue/checked-unsigned-integer\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewould require a value in the range 0..255.\nBut many Erlang programmers will want to use this as the normal\ncase, and will not like the safe version being so much more effort\nto write than the unsafe version.\u003c/p\u003e\n\n\u003cp\u003eIt appears that \"truncation wanted/not wanted\" is not a matter\nof this expression or that, but of this programmer or that,\nand we can expect that each module will be written by someone\nexpecting only one behaviour or expecting only the other.\u003c/p\u003e\n\n\u003cp\u003eAdding a\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-bit_range_check(true).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003edirective to a module is more work than doing nothing at all,\nbut programmers who want this behaviour should be able to set up\ntheir editing environment to have this line in their template for\ncreating new Erlang modules.\u003c/p\u003e\n\n\u003cp\u003eThere are several questions:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eShould this apply to bit strings as well as integers?\u003c/li\u003e\n\u003cli\u003eWhat should the name of the directive be?\u003c/li\u003e\n\u003cli\u003eWhat should the argument(s) of the directive be?\u003c/li\u003e\n\u003cli\u003eShould multiple instances of the directive be allowed in\na module?\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBit strings:  \u003ccode\u003eAssume X = \u0026lt;\u0026lt;5:3/unsigned-integer-unit:1\u0026gt;\u0026gt;\u003c/code\u003e.\nCurrently, \u003ccode\u003e\u0026lt;\u0026lt;X:2/bits\u0026gt;\u0026gt;\u003c/code\u003e quietly truncates \u003ccode\u003eX\u003c/code\u003e.  This drops bits\nfrom the right of \u003ccode\u003eX\u003c/code\u003e, giving \u003ccode\u003e\u0026lt;\u0026lt;2:2\u0026gt;\u0026gt;\u003c/code\u003e.  If this worked the same\nas integers, you would expect \u003ccode\u003e\u0026lt;\u0026lt;1:2\u0026gt;\u0026gt;\u003c/code\u003e.  This is certainly\nvery odd.  Since we get truncation on the left and padding on\nthe left for integers, we naturally expect padding on the\nright for bit strings to go with truncation on the right.\nBut \u003ccode\u003e\u0026lt;\u0026lt;X:4/bits\u0026gt;\u0026gt;\u003c/code\u003e isn't \u003ccode\u003e\u0026lt;\u0026lt;10:4\u0026gt;\u0026gt;\u003c/code\u003e, it's a runtime exception.\nAll very odd indeed.  It would certainly be desirable to have\nan easy way for the programmer to indicate whether they wanted\ntruncation on the left or the right and padding on the left or\nthe right.  Perhaps a new built in function\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eset_bit_size(Bit_String, Desired_Width,\n             Truncation, Padding, Fill)\n\nBit_String : a bit string\nDesired_Width : a non-negative integer, the width wanted\nTruncation: 'left' | 'right' | 'error';\n    if bit_size(Bit_String) \u0026gt; Desired_Width\n        truncate on the left/truncate on the right/\n        report an error\nPadding: 'left' | 'right' | 'error';\n    if bit_size(Bit_String) \u0026lt; Desired_Width\n        pad on the left/pad on the right/report an error\nFill: 0 | 1 | 'copy';\n    pad with 0/pad with 1/pad with a copy of the\n    last bit at the end where padding is done.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHowever, that idea is only partly baked, and is not part of the\ncurrent proposal.  As things currently stand, using the bit\nsyntax and relying on implicit truncation is the simplest way\nto extract the leading bits of a bit string.\u003c/p\u003e\n\n\u003cp\u003eAs long as the name of the directive is intention-revealing,\nit doesn't matter very much what it is.\nI proposed \u003ccode\u003ebit_range_check\u003c/code\u003e because it is all about checking,\nranges in bit syntax, but since in this draft it does NOT apply\nto bit string segments, perhaps \u003ccode\u003ebit_integer_range_check\u003c/code\u003e would\nbe better.\u003c/p\u003e\n\n\u003cp\u003eThe arguments false and true seem clear enough.\nAlternatives would be something like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-bit_integer_range(check).\n-bit_integer_range(no_check).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat would be fine too.\u003c/p\u003e\n\n\u003cp\u003eClassical Pascal compilers let you do things like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{$I-}   (* disable index checks *)\n(* code with no index checks *)\n{$I+}   (* re-enable index checks *)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAllowing multiple \u003ccode\u003e-bit_range_check\u003c/code\u003e directives in a module could\nlet you use code written for the old approach inside a module\nthat otherwise uses the new approach.  I don't believe that we\nwant to encourage that sort of thing:  it is MUCH easier when\nreading a module if all of it follows the same rule.\u003c/p\u003e\n\n\u003cp\u003eIt is also easier for an Erlang compiler that expects to be able\nto process function definitions in any order.  The compiler can\ncheck for one of these directives anywhere in a module before it\nhandles any bit syntax forms anywhere.  However, it is easier for\npeople reading a module if, when they first see a \u003ccode\u003e\u0026lt;\u0026lt;...\u0026gt;\u0026gt;\u003c/code\u003e\nconstruction, they have already seen any directive that might\naffect what it means.\u003c/p\u003e\n\n\u003cp\u003eThe restrictions on the number and placement of these directives\ncan always be relaxed later if necessary.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eAll existing Erlang code remains acceptable with unchanged semantics.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone, because I still can't find my way around the compiler.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0022"},"buildId":"In61zFhZNXGgIV-idPSaW","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/In61zFhZNXGgIV-idPSaW/_buildManifest.js" async=""></script><script src="/_next/static/In61zFhZNXGgIV-idPSaW/_ssgManifest.js" async=""></script></body></html>