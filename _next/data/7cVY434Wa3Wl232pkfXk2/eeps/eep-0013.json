{"pageProps":{"index":{"id":"0013","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 09-Jul-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 13: <a href=\"eep-0013.md\" title=\"EEP Source\"> -enum declarations</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Erlang programs often need to process data streams using data\nformats devised without reference to Erlang.  For this reason\nOTP supports ASN.1 and CORBA, amongst other interface techniques.\nBinary data streams often contain \"symbolic\" values that are\nrepresented in the original description by some kind of\nenumeration declaration, often literally a C \"enum\" declaration.</p>\n\n<p>This EEP proposes an \"<code>-enum</code>\" declaration for Erlang for\nconvenient mapping between atoms on one side of an interface and\nintegers on the other, especially in the bit syntax.</p>\n\n<p>This replaces some uses of the preprocessor with something that\npermits the clearer expression of the programmer's intent.</p>\n\n<h1>Specification</h1>\n\n<p>A new form of declaration is added, four new guard BIFs, and a\nnew type specifier for bit syntax.</p>\n\n<h2>Declaration</h2>\n\n<pre><code>'-' 'enum' '(' identifier-and-size ',' '{' enum-binding\n    {',' enum-binding}* ')' '.'\n</code></pre>\n\n<p>where identifier-and-size is</p>\n\n<pre><code>identifier\n</code></pre>\n\n<p>or</p>\n\n<pre><code>identifier : size\n</code></pre>\n\n<p>or</p>\n\n<pre><code>identifier / type-specifier-list\n</code></pre>\n\n<p>or</p>\n\n<pre><code>identifier : size / type-specifier-list\n</code></pre>\n\n<p>and enum-binding is</p>\n\n<pre><code>identifier '=' constant-integer-expression\n</code></pre>\n\n<p>or</p>\n\n<pre><code>identifier\n</code></pre>\n\n<p>size and type-specifier-list are as in the bit syntax,\nexcept that the type-specifier-list may not include a Type.\nIf the size is missing, it will be the first of [8,16,32,64]\nthat is compatible with the integer values, as described later.\nIf the size is present, it must be an integer that is compatible \nwith the integer values.  Signedness, if present, must agree\nwith the integer values.</p>\n\n<h2>Example</h2>\n\n<pre><code>-enum(colour, {red,orange,yellow,green,blue}).\n-enum(fruit:32,  {quandong,lime,banana,orange,apple}).\n</code></pre>\n\n<p>The identifier following the left parenthesis is called the\n\"enumeration identifier\" and the identifiers bound by the\nbindings are called \"enumerals\".</p>\n\n<p>After <code>-include</code> and <code>-if</code> processing, there should be at most one\nenum declaration for any identifier.  The identifier must not\nbe one of</p>\n\n<pre><code>integer | float | binary | bytes | bitstring | bits\n</code></pre>\n\n<p>Such a declaration only has significance within the constructs\ndefined in this EEP; the only existing notation which is affected\nis the bit syntax.</p>\n\n<p>Within a single enum declaration, an enumeral may not be bound in\ntwo or more bindings.</p>\n\n<p>If the first binding does not have an integer-constant-expression,\nit is as if \"= 0\" appeared.  If a later binding does not have an\ninteger-constant-expression, it is as if \"= N\" appeared, where N\nis one more than the integer value of the previous binding.</p>\n\n<p>Within a single enum declaration, an integer value may not be used\nin two or more bindings, whether implicitly or explicitly.</p>\n\n<h2>Built-in functions</h2>\n\n<h3><code>is_enum_atom(Atom, Enumeration_Identifier)</code></h3>\n\n<ul>\n<li><code>true</code> when Enumeration_Identifier is an atom that is declared\nas an enumeration identifier and Atom is one of the enumerals\nin that declaration,</li>\n<li><code>false</code> otherwise.</li>\n</ul>\n\n<p>May be used as a guard test provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.</p>\n\n<h3><code>is_enum_integer(Integer, Enumeration_Identifier)</code></h3>\n\n<ul>\n<li><code>true</code> when Enumeration_Identifier is an atom that is declared\nas an enumeration identifier and Integer is an integer that\nis used as the value in one of the bindings in that\ndeclaration,</li>\n<li><code>false</code> otherwise.</li>\n</ul>\n\n<p>May be used as a guard test provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.</p>\n\n<h3><code>enum_to_atom(Integer, Enumeration_Identifier)</code></h3>\n\n<ul>\n<li>when <code>is_enum_integer(Integer, Enumeration_Identifier)</code> -> <br />\nthe enumeral bound to Integer in the\ndeclaration of Enumeration_Identifier</li>\n<li>otherwise exits with <code>badarg</code>.</li>\n</ul>\n\n<p>May be used in a guard expression provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.</p>\n\n<h3><code>enum_to_integer(Atom, Enumeration_Identifier)</code></h3>\n\n<ul>\n<li>when <code>is_enum_atom(Atom, Enumeration_Identifier)</code> -> <br />\nthe integer value that Atom is bound to in the\ndeclaration of Enumeration_Identifier</li>\n<li>otherwise exits with <code>badarg</code>.</li>\n</ul>\n\n<p>May be used in a guard expression provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.</p>\n\n<p>All four of these functions are expected to take O(1) time\nand to allocate no storage at run time.</p>\n\n<h2>Bit syntax extension</h2>\n\n<p>The Type in a segment of the bit syntax may additionally be\nan Enumeration_Identifier, and the corresponding Value will\nthen be an atom.  The value in the bit string that is being\nmatched or constructed is or will be the integer bound to\nthe atom; as such the Size, Endianness, Signedness, and Unit\nare interpreted as for the <code>integer</code> Type.</p>\n\n<p>In constructing a bit string,</p>\n\n<pre><code>    V / Enumeration_Identifier ...\nor  V : Size / Enumeration_Identifier ...\n</code></pre>\n\n<p>acts as if</p>\n\n<pre><code>    enum_to_integer(V, Enumeration_Identifier) / integer ...\nor  enum_to_integer(V, Enumeration_Identifier) : Size / integer ...\n</code></pre>\n\n<p>had been written, with one exception, which is now described.</p>\n\n<p>If all the integer values in an enum declaration are non-negative,\nlet k be the smallest integer such that 2^k is greater than all\nof them. If some are negative, let k be the smallest integer such\nthat 2^(k-1) is greater than all of them and -(2^(k-1)) is less\nthan or equal to all of them. The size of a segment for an\nenumeration value must then be at least k bits, whatever the\nactual value. A programmer who finds a need to bypass this can\ndo the enumeral&lt;->integer conversion manually; what this limit\ndoes is to prevent accidental mis-specification. The size given\nin the enum declaration must be at least k. If no size is given\nin the bit syntax, the size given (or defaulted) in the enum\ndeclaration will be used.</p>\n\n<p>When such a segment is used in pattern matching, it is as if</p>\n\n<ul>\n<li>first an integer is extracted as if the Type had been <code>integer</code>,</li>\n<li>then the value is converted to an atom as if by <code>enum_to_atom</code>,</li>\n<li>and finally the atom is matched to whatever pattern appeared.</li>\n</ul>\n\n<p>One expects that cases where the value V is an explicit atom\nwill be translated completely at compile time, therefore having\nno overhead compared with using macros and <code>/integer</code>.</p>\n\n<h1>Motivation</h1>\n\n<p>This was inspired by thinking about PADS and other data\ndescription languages.  Imagine a C program doing something like</p>\n\n<pre><code>enum seriousness {\n    not_serious = 'N',\n    hospitalised = 'H',\n    life_threatening = 'L',\n    congenital_abnormality = 'C',\n    persisting_disability = 'P',\n    intervention_required = 'I',\n    death = 'D'\n};\nstruct Message {\n    char tag;                       /* a seriousness */\n    union {\n        int   number_of_days;       /* H */\n        float extent_of_disability; /* C or P */\n        char  procedure_code[5];    /* I */\n    } supplement;\n};\n</code></pre>\n\n<p>(The Message structure has been considerably simplified.) <br />\nNow imagine matching it.</p>\n\n<pre><code>-define(NOT_SERIOUS, $N).\n-define(HOSPITALISED, $H).\n-define(LIFE_THREATENING, $L).\n-define(CONGENITAL_ABNORMALITY, $C).\n-define(PERSISTING_DISABILITY, $P).\n-define(INTERVENTION_REQUIRED, $I).\n-define(DEATH, $D).\n\ndecode_message(B0) -&gt;\n    case B0\n      of &lt;&lt;?NOT_SERIOUS, B1/binary&gt;&gt; -&gt;\n            {{not_serious}, B1}\n       ; &lt;&lt;?HOSPITALISED, NDays:32, B1/binary&gt;&gt; -&gt;\n            {{hospitalised,NDays}, B1}\n       ; &lt;&lt;?LIFE_THREATENING, B1/binary&gt;&gt; -&gt;\n            {{life_threatening}, B1}\n       ; &lt;&lt;?CONGENITAL_ABNORMALITY, Extent/float, B1/binary&gt;&gt; -&gt;\n            {{congenital_abnormality,Extent}, B1}\n       ; &lt;&lt;?PERSISTING_DISABILITY, Extent/float, B1/binary&gt;&gt; -&gt;\n            {{persisting_abnormality,Extent}, B1}\n       ; &lt;&lt;?INTERVENTION_REQUIRED, Code:5/bytes, B1/binary&gt;&gt; -&gt;\n            {{intervention_required,Code}, B1}\n       ; &lt;&lt;?DEATH, B1/binary&gt;&gt; -&gt;\n            {{death}, B1}\n    end.\n</code></pre>\n\n<p>There are a number of problems with this.</p>\n\n<ul>\n<li>You have to use macros; functions are not allowed in patterns.</li>\n<li>There is nothing to link these macros together as a group.</li>\n<li>So there is no help checking that you are using the right ones.</li>\n<li>There is no word to relate them back to the original enum.</li>\n<li>If the size isn't 8, it must be repeated in each pattern.</li>\n<li>If the Endianness isn't <code>big</code>, it must be repeated in each\npattern. </li>\n<li>If the size is wrong, too bad.</li>\n<li>If a macro from the wrong list is used, too bad.</li>\n<li>You cannot use the same enumeral name for more than one\nenumeration, unless it happens to have the same value in both.</li>\n<li>If you pass the macros around in a computation, they look\njust like numbers to tracers and debuggers; they have no\nrun-time symbolic value.</li>\n</ul>\n\n<p>Now here's the version using <code>-enum</code>.</p>\n\n<pre><code>-enum(seriousness : 8, {\n    not_serious = $N,\n    hospitalised = $H\n    life_threatening = $L,\n    congenital_abnormality = $C,\n    persisting_disability = $P,\n    intervention_required = $I,\n    death = $D\n}).\n\ndecode_message(B0) -&gt;\n    case B0\n      of &lt;&lt;not_serious/seriousness,\n          B1/binary&gt;&gt; -&gt;\n            {{not_serious}, B1}\n       ; &lt;&lt;hospitalised/seriousness,\n           NDays:32, B1/binary&gt;&gt; -&gt;\n            {{hospitalised,NDays}, B1}\n       ; &lt;&lt;life_threatening/seriousness,\n           B1/binary&gt;&gt; -&gt;\n            {{life_threatening}, B1}\n       ; &lt;&lt;congenital_abnormality/seriousness,\n           Extent/float, B1/binary&gt;&gt; -&gt;\n            {{congenital_abnormality,Extent}, B1}\n       ; &lt;&lt;persisting_disability/seriousness,\n            Extent/float, B1/binary&gt;&gt; -&gt;\n            {{persisting_abnormality,Extent}, B1}\n       ; &lt;&lt;intervention_required/seriousness,\n            Code:5/bytes, B1/binary&gt;&gt; -&gt;\n            {{intervention_required,Code}, B1}\n       ; &lt;&lt;death/seriousness,\n           B1/binary&gt;&gt; -&gt;\n            {{death}, B1}\n    end.\n</code></pre>\n\n<p>Rather fortuitously, this feature also provides a way of\naccepting any of a set of atoms or integers with a single\nguard test.  Let's restructure the previous example to\nfirst extract the seriousness and then match the body, but\nthis time, have just one body of each shape.</p>\n\n<pre><code>-enum(seriousness, {\n    not_serious = $N,\n    hospitalised = $H\n    life_threatening = $L,\n    congenital_abnormality = $C,\n    persisting_disability = $P,\n    intervention_required = $I,\n    death = $D\n}).\n-enum(no_more_info, {\n    not_serious = $N,\n    life_threatening = $L,\n    death = $D\n}).\n-enum(extent_of_impairment, {\n    congenital_abnormality = $C,\n    persisting_disability = $P\n}).\n\ndecode_message(&lt;&lt;Seriousness/seriousness, B0/binary&gt;&gt;) -&gt;\n    if is_enum_atom(Seriousness, no_more_info) -&gt;\n       {{Seriousness}, B0}\n     ; is_enum_atom(Seriousness, extent_of_impairment) -&gt;\n       &lt;&lt;Extent/float, B1/binary&gt;&gt; = B0,\n       {{Seriousness,Extent}, B1}\n     ; Seriousness =:= hospitalised -&gt;\n       &lt;&lt;NDays:32, B1/binary&gt;&gt; = B0,\n       {{Seriousness,NDays}, B1}\n     ; Seriousness =:= intervention_required -&gt;\n       &lt;&lt;Code:5/bytes, B1/binary&gt;&gt; = B0,\n       {{Seriousness,Code}, B1}\n    end.\n</code></pre>\n\n<h1>Rationale</h1>\n\n<p>Since this is supposed to make it easy to convert descriptions <br />\nfrom C or PADS or similar forms, an enum declaration looks like\na C enum declaration.</p>\n\n<p>Since size, signedness, and endianness may be needed in multiple\nplaces, it makes sense to put them all in the declaration so that\nthey don't have to be repeated (and therefore cannot be repeated\nincorrectly).</p>\n\n<p>The order of the arguments in the new BIFs is chosen to match\nthe order of the arguments in <code>is_record/2</code>, so as to be familiar\nto Erlang programmers.</p>\n\n<p>The new BIFs are needed to explain the extended bit syntax.\nThe only abbreviation in their names is <code>enum</code>, which exactly\nmatches the keyword in the declaration.</p>\n\n<p>The new BIFs can also be used to implement the extended bit\nsyntax by source-to-source transformation; no actual change to\nthe bit syntax machinery is required.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Code that uses any of the four new BIFs will be affected.\nThe nearest that the Erlang/OTP sources come to mentioning\nany of those atoms is <code>enum_to_int</code>, which is used.\nCode that does use any of these BIFs can be found using\ncross-reference tools.</p>\n\n<p>A simple approach would be to say that the BIFs <code>is_enum_atom/2</code>,\n<code>is_enum_integer/2</code>, <code>enum_to_atom/2</code>, <code>and enum_to_integer/2</code>\nare in scope in a module if and only if there is an <code>-enum</code>\ndeclaration in that module, in which case existing code would\nbe entirely unaffected.</p>\n\n<p>The effect on the bit syntax is that previously illegal\nforms (where Type is not one of the existing numeric or bit\nstring types or Value is an atom) become legal, but only if\nlicensed by appropriate <code>-enum</code> declarations.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>There is none.  However, we can sketch one.\nThe four new BIFs are all simple table lookups of the kind that\nthe Erlang compiler already has to be able to generate for\nindexed clause selection.  As such, they are safe to call in\nguards.  Since the Type in the bit syntax may only be an\nenumeration name when it is a literal atom known to the compiler\nas an enumeration name, the constructor</p>\n\n<pre><code>&lt;&lt;... V : S / T X ...&gt;&gt;\n</code></pre>\n\n<p>can be translated as</p>\n\n<pre><code>( V1 = enum_to_integer(V, X), &lt;&lt;... V1 : S / integer X ...&gt;&gt;)\n</code></pre>\n\n<p>and the pattern</p>\n\n<pre><code>&lt;&lt;... V : S / T X ...&gt;&gt;\n</code></pre>\n\n<p>can be translated to</p>\n\n<pre><code>&lt;&lt;... V' : S / integer X ...&gt;&gt;\n</code></pre>\n\n<p>by adding</p>\n\n<pre><code>V =:= enum_to_atom(V', T)\n</code></pre>\n\n<p>to the guard if V occurs elsewhere in the pattern or will be\nbound in the context, or</p>\n\n<pre><code>   V = enum_to_atom(V', T)\nif V would not otherwise become bound.\n</code></pre>\n\n<p>Binding like this should be allowed in guards anyway,\nbut in this case it is perfectly safe because it is O(1) and\ndoes not require any dynamic storage allocation (unlike, say,\narithmetic).</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}