{"pageProps":{"index":{"id":"0005","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;,\n        Per Gustafsson &lt;pergu(at)it(dot)uu(dot)se&gt;\nStatus: Draft\nType: Standards Track\nCreated: 10-Aug-2007\nErlang-Version: R12B-0\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 5: <a href=\"eep-0005.md\" title=\"EEP Source\"> More Versatile Encapsulation with <code>export_to</code></a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP describes a new directive called <code>export_to</code> which allows a\nmodule to specify exactly which other modules that can call a function\ndefined in the module. This provides a very fine grained primitive for\nencapsulation. Allowing the programmer to control more directly how\nhis code should be used.</p>\n\n<p>This is an idea originally proposed by Richard O'Keefe. </p>\n\n<h1>Specification</h1>\n\n<p>This is the syntax for the <code>-export_to</code> directive:</p>\n\n<pre><code>-export_to([m,...], [f/a,...]).\n</code></pre>\n\n<p>where <code>[m,...]</code> is a list of module names and ``[f/a,...]''\nis a list of function name/arity pairs.</p>\n\n<p>This means that the function <code>f/a</code> can be called from the module\n<code>m</code>. Whether the call is a static call, a dynamic call,\nor an apply should not matter.</p>\n\n<p>Except for the restriction to a specified set of modules,\nthese functions should act like functions exported to the\nworld using <code>-export</code>, <em>i</em>.<em>e</em>., calls to these functions\nshould always invoke the latest version of the function.</p>\n\n<p>When a list has only one element, it may be abbreviated to just\nthat element, so</p>\n\n<pre><code>-export_to(m, [f/a,...]).\n-export_to(m, f/a).\n-export_to([m,...], f/a).\n</code></pre>\n\n<p>are allowed abbreviations.</p>\n\n<p>A function may be explicitly exported to any number of modules.\nAn Erlang compiler should allow a function to be both explicitly\nexported to one or more modules with <code>-export_to</code> and also\nexported to the world with <code>-export</code>, in order to ease the\ntransition, but should by default warn about this.\nThe existing <code>export_all</code> flag should also be compatible with\nexplicit exports.</p>\n\n<h1>Motivation</h1>\n\n<p>Modules in Erlang have several roles.\nA module is the unit of compilation and code reloading.\nIt is also the unit of encapsulation, because the\nonly way to hide a function from being called by any other function is\nto make it a local function in a module.  A module also defines a\nseparate namespace for functions.  This wealth of roles for the module\nmakes it difficult to structure Erlang applications in a way that\nmakes them well encapsulated while keeping modules small and focused.</p>\n\n<p>Most applications written in Erlang consist of several smaller\nmodules, and though the application has a public API which is a subset\nof the exported functions of the modules, exactly which functions\nare part of the public API can only be specified in comments or\ndocumentation since functions are either exported so that anyone can\ncall them, or not exported meaning that they can only be called inside\nthe module, but sometimes we want to have more control than\nthis, <em>e</em>.<em>g</em>., this function should only be called from other modules\nin this application,\nor this function should only be called from the shell.</p>\n\n<p>The <code>-export_to</code> directive lets the programmer\nexpress such restrictions, which the runtime system then enforces,\nso that readers can trust them.\nThe <code>-export_to</code> directive is <strong>not</strong> meant to replace\nthe <code>-export</code> directive, but to be an alternative when the\nprogrammer knows all intended collaborators.</p>\n\n<p>This feature was originally inspired by the way the programming\nlanguage Eiffel controls the visibility of a class's features\nto other classes, so Bertrand Meyer deserves the credit.  This\nmeans, of course, that the idea is \"proven technology\".</p>\n\n<h1>Rationale </h1>\n\n<p>There are some choices in designing the <code>-export_to</code> syntax,\nfor example should m be allowed to be a list of modules or\nshould we have an <code>export_to</code> list where each entry is a module,\nfunction/arity pair.\nOne reason to use the suggested syntax is that it reads pretty easily as:</p>\n\n<p>export to module <code>m</code> this list of functions <code>[f/a]</code></p>\n\n<p>One way to think about this is that there is an \"export\" matrix\nwhere the rows are indexed by modules and the columns are indexed\nby local functions.  Sometimes it is convenient to slice it by\nrows (<em>this</em> behaviour module may call <em>these</em> callbacks) and\nsometimes it is convenient to slice it by columns (<em>this</em> utility\nfunction may be called by all <em>these</em> modules in my application).\nThe original design focus was on callbacks so that they could be\nexported to a behaviour without exporting them to the world.\nSince then it has become clear that exporting to an application\nis also a convenient thing.  So let us allow programmers to write\nthe matrix whatever way most clearly expresses their intentions.</p>\n\n<p>Another issue is whether we should have some syntactic sugar for\nspecifying common export patterns such as exporting a set of functions\nto all the modules in an application or exporting a function in order\nto make it possible to apply the function or to make it possible to\nupdate the code of the function.</p>\n\n<p>In fact exporting to an application is already easy with this\nproposal.  When you develop an application <em>foo</em>, create a\nfile <em>foo</em><code>_modules.hrl</code> with the contents:</p>\n\n<pre><code>-define(_FOO_`_MODULES`,\n        [ mod1\n        , mod2\n        ...\n        ]).\n</code></pre>\n\n<p>Then within a file you may write</p>\n\n<pre><code>-include('_foo_`_modules.hrl').\n-export_to(_FOO_`_MODULES`, [f/a,...]).\n</code></pre>\n\n<p>Further additions to this proposal may be worth discussing once\nwe have some experience with this basic building block.</p>\n\n<p>One issue which perhaps deserves comment is that <em>calling</em> a\nrestricted-export function is just like any other remote call.\nThese seems to be no reason to make it different.  In particular,\nif module A initially exports a function to the world, and\nmodule B calls it, and then the author of module A decides to\nrestrict it to B, B should not change.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Adding an <code>-export_to</code> directive should be totally backwards\ncompatible, because since it is not a legal attribute, it currently\ncauses a syntax error.</p>\n\n<h1>Implementation</h1>\n\n<p>This feature has not been implemented yet, but here are some goals\nthat we think the implementation should fulfill:</p>\n\n<ul>\n<li><p>Ordinary static calls to an <code>-export_to</code> function should cost the\nsame as calls to other <code>-export_to</code> functions.</p></li>\n<li><p>The performance of other calls should not be affected by the\nintroduction of <code>-export_to</code> calls.</p></li>\n<li><p>The space cost should be O(1) per (m,f,a) matrix entry.</p></li>\n</ul>\n\n<p>These can be archived by putting most of the machinery to handle this\nfeature in the loader and only using dynamic checks for dynamic\ncalls.</p>\n"}},"__N_SSG":true}