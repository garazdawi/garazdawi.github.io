<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
Status: Final/21.0 Proposal is to be included in OTP release 21.0
Type: Standards Track
Created: 23-Nov-2017
Erlang-Version: 21
Post-History: 24-Nov-2017, 30-Nov-2017
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 47: <a href="eep-0047.md" title="EEP Source"> Add syntax in try/catch to retrieve the stacktrace directly</a></h2>

<h1>Abstract</h1>

<p>This EEP proposes an extension to the <code>try/catch</code> statement to allow
the call stack back-trace (<strong>stacktrace</strong>) to be retrieved without
calling <code>erlang:get_stacktrace/0</code>.</p>

<h1>Specification</h1>

<p>We will introduce new syntax to retrieve the call stack back-trace
(hereafter called <strong>stacktrace</strong>).  Currently,
<code>erlang:get_stacktrace/0</code> can be called at any time to retrieve the
stacktrace from the last exception that occurred in the current
process.</p>

<p>The current syntax for <code>try/catch</code> is:</p>

<pre><code>try
  Exprs
catch
    [Class1:]ExceptionPattern1 [when ExceptionGuardSeq1] -&gt;
        ExceptionBody1;
    [ClassN:]ExceptionPatternN [when ExceptionGuardSeqN] -&gt;
        ExceptionBodyN
end
</code></pre>

<p>We propose the following extension of the syntax for exception clause
heads:</p>

<pre><code>Class:ExceptionPattern:Stacktrace [when ExceptionGuardSeq] -&gt;
</code></pre>

<p><code>Stacktrace</code> must be a variable name, not a pattern.  Furthermore,
<code>Stacktrace</code> must not be previously bound and it must not be
referenced in <code>ExceptionGuardSeq</code>.</p>

<p>Here is an example:</p>

<pre><code>try
  Exprs
catch
  something_was_thrown -&gt;
    %% The default class is 'throw'.
    .
    .
    .
  throw:something_else_was_thrown -&gt;
    .
    .
    .
  throw:thrown_with_interesting_stacktrace:Stk -&gt;
    %% The class 'throw' must be explicitly given when
    %% the stacktrace is to be retrieved.
    .
    .
    .
  error:undef -&gt;
    %% Handle an undefined function specially.
    .
    .
    .
  C:E:Stk -&gt;
    %% Log any other exception and rethrow it.
    log_exception(C, E, Stk),
    raise(C, E, Stk)
end.
</code></pre>

<h1>Motivation</h1>

<p>The main motivation for this feature is to be able to deprecate
(and ultimately remove) <code>erlang:get_stacktrace/0</code>.</p>

<p>The problem with <code>erlang:get_stacktrace/0</code> is that it forces the
stacktrace from the latest exception in a process to be retained
until another exception occurs or the process terminates.  The
stacktrace often includes the arguments for the last function
call, BIF call, or (in OTP 21) operator that failed.  The arguments
can be of any size.</p>

<p>Here is an example:</p>

<pre><code>1&gt; catch abs(lists:seq(1, 1000)).
{'EXIT',{badarg,
      [{erlang,abs,
                 [[1,2,3,4,5,6,7,8,9,10,11,12,13,
                   14,15,16,17,18,19,20|...]],
                 []},
          {erl_eval,do_apply,6,[{file,"erl_eval.erl"},{line,674}]},
          {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,431}]},
          {shell,exprs,7,[{file,"shell.erl"},{line,687}]},
          {shell,eval_exprs,7,[{file,"shell.erl"},{line,642}]},
          {shell,eval_loop,3,[{file,"shell.erl"},{line,627}]}]}}
2&gt;
</code></pre>

<p>The list containing the integers from 1 through 1000 will be kept
in the process that caused the exception until another exception
occurs in the same process.</p>

<p>In a future release, where <code>erlang:get_stacktrace/0</code> has either been
changed to always return <code>[]</code> or been removed, it is no longer
necessary to keep the stacktrace in the process indefinitely.</p>

<p>Another motivation is that pitfalls such as the one in the following
example are impossible:</p>

<pre><code>try
  Expr
catch
  C:E -&gt;
    do_something(),
    log_exception(C, E, erlang:get_stacktrace())
end
</code></pre>

<p>If <code>do_something()</code> generates and catches an exception, the call
to <code>erlang:get_stacktrace/0</code> will retrieve the wrong stacktrace.</p>

<h1>Rationale</h1>

<h2>The Syntax</h2>

<p>Regarding the syntax, we did consider using another token instead of
colon before the stacktrace variable.  That would continue to allow
making the class <code>throw</code> implicit even when retrieving the stacktrace.
That is, you could write an exception pattern, followed by some
special token, followed by the name of the stacktrace variable, and
the class <code>throw</code> would be implicitly understood.</p>

<p>We rejected that for two reasons:</p>

<ul>
<li><p>We could not find a suitable separator token.  Our best suggestion
was <code>@</code>, and that will not work because <code>@</code> is allowed in atoms.
Tokens like <code>/</code> could confuse at least the parser (and possibly human
readers) because patterns are allowed to contain constant expressions.
A double colon (<code>::</code>) would not cause any ambiguitiy issues, but
everyone immediately associated it with a type declaration.</p></li>
<li><p>In practice, when catching an exception of class <code>throw</code>, one is
almost never interested in the stacktrace.</p></li>
</ul>

<h2>Why Not Allow Matching On The Stacktrace?</h2>

<p><code>Stacktrace</code> must be a variable, not a pattern.  There are two
reasons:</p>

<ul>
<li><p>In general, pattern matching on the stacktrace is discouraged.  The
intention is that it should be inspected by a human to aid in
debugging.</p></li>
<li><p>Allowing pattern matching on the stacktrace would be expensive.
When an exception occurs, a raw stacktrace is saved.  The raw
stacktrace contains a limited number of continuation pointers
(by default 8) collected from the stack and possibly the arguments
for the function call or BIF call that failed.  To convert the
raw stacktrace to the symbolic form that can be matched or shown is
quite expensive; by only allowing a variable, that conversion will
only happen when a clause has matched and its body is about to
be executed.</p></li>
</ul>

<h2>Limiting The Scope Of erlang:get_stacktrace/0 Instead?</h2>

<p>In OTP 20, we introduced a new warning in the documentation for
<code>erlang:get_stacktrace/0</code>:</p>

<blockquote>
  <p><code>erlang:get_stacktrace/0</code> is only guaranteed to return a stacktrace if
  called (directly or indirectly) from within the scope of a try
  expression.</p>
</blockquote>

<p>Our intention was that by limiting the scope, the stacktrace could be
cleared when exiting the scope.  For example, the following code would
continue to work, but the stacktrace would be cleared when leaving
<code>try/catch</code>:</p>

<pre><code>try Expr
catch
  C:R -&gt;
   {C,R,helper()}
end

helper() -&gt;
  erlang:get_stacktrace().
</code></pre>

<p>Unfortunately, the following slightly different example would force
a hard choice upon us:</p>

<pre><code>try Expr
catch
  C:R -&gt;
   helper(C, R)
end

helper(C, R) -&gt;
  {C,R,erlang:get_stacktrace()}.
</code></pre>

<p>The call to <code>helper/2</code> is tail-recursive.  If we are to keep the call
tail-recursive, we cannot clear the stacktrace.  Conversely, if we are
to clear the stacktrace, the call can no longer be tail-recursive.</p>

<p>Another problem is that the compiler cannot warn for all instances of
calls to <code>erlang:get_stacktrace/0</code> that would not return a stacktrace.
All it can do is to warn for obvious calls that will not work such as
in the following example:</p>

<pre><code>try Expr
catch
  C:R -&gt;
    .
    .
    .
end,
Stk = erlang:get_stacktrace(),
.
.
.
</code></pre>

<p>That is, the compiler can only warn if there is a use of <code>try/catch</code>
or <code>catch</code> followed by a call to <code>erlang:get_stacktrace/0</code> in the same
function.</p>

<p>We could limit the useful scope of <code>erlang:get_stacktrace/0</code> to
just the syntactic scope of the clause within the <code>try/catch</code>.
For example:</p>

<pre><code>try
  Expr
catch
  C:E -&gt;
    Stk = erlang:get_stacktrace(),
    log_exception(C, E, Stk)
end
</code></pre>

<p>It does not seem to be any advantage of that solution compared
to introducing the new syntax.  Developers would still have to
update their programs (eliminating calls to <code>erlang:get_stacktrace/0</code>
from helper functions and moving them into the syntactic scope of
the <code>try/catch</code>).</p>

<h1>Backwards Compatibility</h1>

<p>Since the new syntax would cause a compilation error in OTP 20
and previous releases, no existing source code can be affected.</p>

<p>The abstract format already includes a variable (with the name <code>_</code>)
for the stacktrace in exception clauses.  That means that many
tools that manipulate the abstract Erlang code will continue to
work without any change.</p>

<p>The <code>erlang:get_stacktrace/0</code> BIF can be deprecated in several
stages to minimize the impact of the change.</p>

<p>For example:</p>

<ul>
<li><p>In OTP 21, there will be a compiler warning that
<code>erlang:get_stacktrace/0</code> is deprecated.</p></li>
<li><p>In OTP 23 (or possibly OTP 22), <code>erlang:get_stacktrace/0</code> will start
returning <code>[]</code>.  Many programs that have not been updated will
continue to work, except that if an exception is raised no stacktrace
will be available to aid in debugging.</p></li>
<li><p>In some future release (OTP 42?), <code>erlang:get_stacktrace/0</code> can be
removed.</p></li>
</ul>

<h1>Implementation</h1>

<p>The implementation can be found in <a href="https://github.com/erlang/otp/pull/1634" title="#1634: Add syntax in try/catch to retrieve the stacktrace directly">PR #1634</a>.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0047","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Bj√∂rn Gustavsson \u0026lt;bjorn(at)erlang(dot)org\u0026gt;\nStatus: Final/21.0 Proposal is to be included in OTP release 21.0\nType: Standards Track\nCreated: 23-Nov-2017\nErlang-Version: 21\nPost-History: 24-Nov-2017, 30-Nov-2017\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 47: \u003ca href=\"eep-0047.md\" title=\"EEP Source\"\u003e Add syntax in try/catch to retrieve the stacktrace directly\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes an extension to the \u003ccode\u003etry/catch\u003c/code\u003e statement to allow\nthe call stack back-trace (\u003cstrong\u003estacktrace\u003c/strong\u003e) to be retrieved without\ncalling \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eWe will introduce new syntax to retrieve the call stack back-trace\n(hereafter called \u003cstrong\u003estacktrace\u003c/strong\u003e).  Currently,\n\u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e can be called at any time to retrieve the\nstacktrace from the last exception that occurred in the current\nprocess.\u003c/p\u003e\n\n\u003cp\u003eThe current syntax for \u003ccode\u003etry/catch\u003c/code\u003e is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry\n  Exprs\ncatch\n    [Class1:]ExceptionPattern1 [when ExceptionGuardSeq1] -\u0026gt;\n        ExceptionBody1;\n    [ClassN:]ExceptionPatternN [when ExceptionGuardSeqN] -\u0026gt;\n        ExceptionBodyN\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe propose the following extension of the syntax for exception clause\nheads:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eClass:ExceptionPattern:Stacktrace [when ExceptionGuardSeq] -\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eStacktrace\u003c/code\u003e must be a variable name, not a pattern.  Furthermore,\n\u003ccode\u003eStacktrace\u003c/code\u003e must not be previously bound and it must not be\nreferenced in \u003ccode\u003eExceptionGuardSeq\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere is an example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry\n  Exprs\ncatch\n  something_was_thrown -\u0026gt;\n    %% The default class is 'throw'.\n    .\n    .\n    .\n  throw:something_else_was_thrown -\u0026gt;\n    .\n    .\n    .\n  throw:thrown_with_interesting_stacktrace:Stk -\u0026gt;\n    %% The class 'throw' must be explicitly given when\n    %% the stacktrace is to be retrieved.\n    .\n    .\n    .\n  error:undef -\u0026gt;\n    %% Handle an undefined function specially.\n    .\n    .\n    .\n  C:E:Stk -\u0026gt;\n    %% Log any other exception and rethrow it.\n    log_exception(C, E, Stk),\n    raise(C, E, Stk)\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThe main motivation for this feature is to be able to deprecate\n(and ultimately remove) \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe problem with \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e is that it forces the\nstacktrace from the latest exception in a process to be retained\nuntil another exception occurs or the process terminates.  The\nstacktrace often includes the arguments for the last function\ncall, BIF call, or (in OTP 21) operator that failed.  The arguments\ncan be of any size.\u003c/p\u003e\n\n\u003cp\u003eHere is an example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; catch abs(lists:seq(1, 1000)).\n{'EXIT',{badarg,\n      [{erlang,abs,\n                 [[1,2,3,4,5,6,7,8,9,10,11,12,13,\n                   14,15,16,17,18,19,20|...]],\n                 []},\n          {erl_eval,do_apply,6,[{file,\"erl_eval.erl\"},{line,674}]},\n          {erl_eval,expr,5,[{file,\"erl_eval.erl\"},{line,431}]},\n          {shell,exprs,7,[{file,\"shell.erl\"},{line,687}]},\n          {shell,eval_exprs,7,[{file,\"shell.erl\"},{line,642}]},\n          {shell,eval_loop,3,[{file,\"shell.erl\"},{line,627}]}]}}\n2\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe list containing the integers from 1 through 1000 will be kept\nin the process that caused the exception until another exception\noccurs in the same process.\u003c/p\u003e\n\n\u003cp\u003eIn a future release, where \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e has either been\nchanged to always return \u003ccode\u003e[]\u003c/code\u003e or been removed, it is no longer\nnecessary to keep the stacktrace in the process indefinitely.\u003c/p\u003e\n\n\u003cp\u003eAnother motivation is that pitfalls such as the one in the following\nexample are impossible:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry\n  Expr\ncatch\n  C:E -\u0026gt;\n    do_something(),\n    log_exception(C, E, erlang:get_stacktrace())\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf \u003ccode\u003edo_something()\u003c/code\u003e generates and catches an exception, the call\nto \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e will retrieve the wrong stacktrace.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003ch2\u003eThe Syntax\u003c/h2\u003e\n\n\u003cp\u003eRegarding the syntax, we did consider using another token instead of\ncolon before the stacktrace variable.  That would continue to allow\nmaking the class \u003ccode\u003ethrow\u003c/code\u003e implicit even when retrieving the stacktrace.\nThat is, you could write an exception pattern, followed by some\nspecial token, followed by the name of the stacktrace variable, and\nthe class \u003ccode\u003ethrow\u003c/code\u003e would be implicitly understood.\u003c/p\u003e\n\n\u003cp\u003eWe rejected that for two reasons:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eWe could not find a suitable separator token.  Our best suggestion\nwas \u003ccode\u003e@\u003c/code\u003e, and that will not work because \u003ccode\u003e@\u003c/code\u003e is allowed in atoms.\nTokens like \u003ccode\u003e/\u003c/code\u003e could confuse at least the parser (and possibly human\nreaders) because patterns are allowed to contain constant expressions.\nA double colon (\u003ccode\u003e::\u003c/code\u003e) would not cause any ambiguitiy issues, but\neveryone immediately associated it with a type declaration.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIn practice, when catching an exception of class \u003ccode\u003ethrow\u003c/code\u003e, one is\nalmost never interested in the stacktrace.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eWhy Not Allow Matching On The Stacktrace?\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003eStacktrace\u003c/code\u003e must be a variable, not a pattern.  There are two\nreasons:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIn general, pattern matching on the stacktrace is discouraged.  The\nintention is that it should be inspected by a human to aid in\ndebugging.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAllowing pattern matching on the stacktrace would be expensive.\nWhen an exception occurs, a raw stacktrace is saved.  The raw\nstacktrace contains a limited number of continuation pointers\n(by default 8) collected from the stack and possibly the arguments\nfor the function call or BIF call that failed.  To convert the\nraw stacktrace to the symbolic form that can be matched or shown is\nquite expensive; by only allowing a variable, that conversion will\nonly happen when a clause has matched and its body is about to\nbe executed.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eLimiting The Scope Of erlang:get_stacktrace/0 Instead?\u003c/h2\u003e\n\n\u003cp\u003eIn OTP 20, we introduced a new warning in the documentation for\n\u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e is only guaranteed to return a stacktrace if\n  called (directly or indirectly) from within the scope of a try\n  expression.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eOur intention was that by limiting the scope, the stacktrace could be\ncleared when exiting the scope.  For example, the following code would\ncontinue to work, but the stacktrace would be cleared when leaving\n\u003ccode\u003etry/catch\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry Expr\ncatch\n  C:R -\u0026gt;\n   {C,R,helper()}\nend\n\nhelper() -\u0026gt;\n  erlang:get_stacktrace().\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUnfortunately, the following slightly different example would force\na hard choice upon us:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry Expr\ncatch\n  C:R -\u0026gt;\n   helper(C, R)\nend\n\nhelper(C, R) -\u0026gt;\n  {C,R,erlang:get_stacktrace()}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe call to \u003ccode\u003ehelper/2\u003c/code\u003e is tail-recursive.  If we are to keep the call\ntail-recursive, we cannot clear the stacktrace.  Conversely, if we are\nto clear the stacktrace, the call can no longer be tail-recursive.\u003c/p\u003e\n\n\u003cp\u003eAnother problem is that the compiler cannot warn for all instances of\ncalls to \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e that would not return a stacktrace.\nAll it can do is to warn for obvious calls that will not work such as\nin the following example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry Expr\ncatch\n  C:R -\u0026gt;\n    .\n    .\n    .\nend,\nStk = erlang:get_stacktrace(),\n.\n.\n.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat is, the compiler can only warn if there is a use of \u003ccode\u003etry/catch\u003c/code\u003e\nor \u003ccode\u003ecatch\u003c/code\u003e followed by a call to \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e in the same\nfunction.\u003c/p\u003e\n\n\u003cp\u003eWe could limit the useful scope of \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e to\njust the syntactic scope of the clause within the \u003ccode\u003etry/catch\u003c/code\u003e.\nFor example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry\n  Expr\ncatch\n  C:E -\u0026gt;\n    Stk = erlang:get_stacktrace(),\n    log_exception(C, E, Stk)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt does not seem to be any advantage of that solution compared\nto introducing the new syntax.  Developers would still have to\nupdate their programs (eliminating calls to \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e\nfrom helper functions and moving them into the syntactic scope of\nthe \u003ccode\u003etry/catch\u003c/code\u003e).\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eSince the new syntax would cause a compilation error in OTP 20\nand previous releases, no existing source code can be affected.\u003c/p\u003e\n\n\u003cp\u003eThe abstract format already includes a variable (with the name \u003ccode\u003e_\u003c/code\u003e)\nfor the stacktrace in exception clauses.  That means that many\ntools that manipulate the abstract Erlang code will continue to\nwork without any change.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e BIF can be deprecated in several\nstages to minimize the impact of the change.\u003c/p\u003e\n\n\u003cp\u003eFor example:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIn OTP 21, there will be a compiler warning that\n\u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e is deprecated.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIn OTP 23 (or possibly OTP 22), \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e will start\nreturning \u003ccode\u003e[]\u003c/code\u003e.  Many programs that have not been updated will\ncontinue to work, except that if an exception is raised no stacktrace\nwill be available to aid in debugging.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIn some future release (OTP 42?), \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e can be\nremoved.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003eImplementation\u003c/h1\u003e\n\n\u003cp\u003eThe implementation can be found in \u003ca href=\"https://github.com/erlang/otp/pull/1634\" title=\"#1634: Add syntax in try/catch to retrieve the stacktrace directly\"\u003ePR #1634\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0047"},"buildId":"Ouo7gQeKiYSKAal9g8wsl","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/Ouo7gQeKiYSKAal9g8wsl/_buildManifest.js" async=""></script><script src="/_next/static/Ouo7gQeKiYSKAal9g8wsl/_ssgManifest.js" async=""></script></body></html>