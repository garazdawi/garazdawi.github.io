{"pageProps":{"index":{"id":"0015","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 15-Jul-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 15: <a href=\"eep-0015.md\" title=\"EEP Source\"> Portable funs</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Current Erlang has two kinds of funs.  An \"external\" fun,\nModule:Name/Arity, is just a name and can be used freely.\nA \"local\" fun contains code that is bound to the module it\nwas defined in.  This means that you cannot save internal\nfuns in data bases or send them to remote systems and expect them to\nwork.</p>\n\n<p>I propose a \"portable fun\", which is a syntactically restricted\nkind of fun.  The restriction ensures that a programmer knows\n(and the run time can discover) exactly what modules are/will be\nrequired.  These funs can be safely sent to remote nodes, and \ncan safely be stored in data bases, retrieved at a later time,\nand executed.  Nor need a process holding a reference to such a\nfun be killed when the module it came from is unloaded.</p>\n\n<p>A new way of implementing these funs is required for best speed,\nso this is quite a large change.  However, a prototype that\ninterpreted portable functions would be possible.</p>\n\n<h1>Specification</h1>\n\n<p>Currently, Erlang has</p>\n\n<pre><code>fun_expr -&gt; 'fun' fun_clauses 'end' : ...\n</code></pre>\n\n<p>We add</p>\n\n<pre><code>fun_expr -&gt; 'fun' '!' fun_clauses 'end' : ...\n</code></pre>\n\n<p>and make the following restrictions:</p>\n\n<ol>\n<li>A portable fun may not contain plain funs.</li>\n<li>A portable fun may not contain a call f(...)\nwithout a module prefix unless f is a built-in function.</li>\n<li>A portable fun may not contain any call of the\nform M:f(...) or m:F(...) or M:F(...).</li>\n<li>A portable fun may not contain any call of the\nform F(...) unless F is bound in its head.</li>\n<li>In a system where abstract patterns are available,\nthey are restricted the same way as function calls.</li>\n</ol>\n\n<p>The intent of these restrictions is to ensure that\nevery call is to a built in function, a known export\nof a known module, or to some kind of fun received as\na parameter.</p>\n\n<p>The built-in function erlang:fun_info/1 is extended in\nthe following ways:</p>\n\n<ol>\n<li>In a {type,Type} item, Type may be 'portable'.</li>\n<li>In a {module,Module} item for a portable fun, the Module\nwill be present, but there will in fact be no other\nconnection between a portable fun and any module by that name.</li>\n<li>In a {name,Name} item for a portable fun,\nName will always be [].</li>\n<li>None of the items specified for 'local' funs will be\nreturned for 'portable' funs.</li>\n<li>{calls,List} will be returned for a portable fun,\nwhere List is a list of {Module,Imports} pairs, where\neach Module that is used in a remote call in the fun is\nlisted once, and the Imports are a list of {Name,Arity}\npairs as reported in *:module_info/0.  This permits the\nreceiver of a portable fun to determine which modules\nneed loading and which functions they are expected to export.</li>\n<li>For consistency,\nerlang:fun_info(fun M:F/A, calls)\n=> [{M,[{F,A}]}]</li>\n</ol>\n\n<p>The built-in function erlang:fun_info/2 is extended similarly.\nAn additional key 'source' is provided for this function.</p>\n\n<h3>fun_info(Fun, source)</h3>\n\n<ul>\n<li>for a local fun, the result is 'undefined'.</li>\n<li>for an external fun, the result is the abstract syntax\ntree the parser returns for fun M:F/A.</li>\n<li>for a portable fun, the result is the abstract syntax\ntree the parser returned for the fun!..... end form\nit came from.</li>\n</ul>\n\n<p>The built-in functions-and-guard-predicates\nerlang:is<em>function(Term) and erlang:is</em>function(Term, Arity)\naccept portable funs as well as external and local ones.</p>\n\n<p>Two new built-in functions-and-guard-predicates\nerlang:is<em>portable</em>function(Term) and\nerlang:is<em>portable</em>function(Term, Arity)\nare provided, which recognise 'portable' and 'external' functions. <br />\n(This proposal will definitely need to be revised to make the\nnames clearer.)</p>\n\n<h1>Motivation</h1>\n\n<p>Imagine that you have an Erlang node reporting events to clients\non other nodes.  Clients wish to receive only a few of the events.\nOne approach is for the reporter to send all events to all clients\nand let the clients do the filtering.  A better approach lets the\nclients tell the reporter which events they want, and for it to\nsend just the interesting events.  But how do the clients tell the\nreporter which events they are interested in?</p>\n\n<p>One approach is to simply have a fixed set of event classes.\nThat is too coarse.</p>\n\n<p>Another approach would be to define an event description language,\nperhaps based in some way on match specifications.\nThat is better, but there is currently no way to compile match\nspecifications (that's another thing this is for!) so matching is\nslow, and it is still limited; the reporter might want to provide\nsummary functions that the filters can use.</p>\n\n<p>Another approach would be to send a fun, which is really the\nobvious way to do it.  Unfortunately, this currently will not work,\nand there are reasons why it shouldn't.  (For example, the body of\na local function may have been subject to inline expansion of\nfunctions whose definitions on the receiving node are different.)</p>\n\n<p>Another approach would be to send an entire module as a binary.\nThis gets a bit heavyweight.  It also creates a problem of managing\npossibly large numbers of modules in the reporter.  It is also\ninsecure unless the reporter does a lot of work to verify the code\nfor safety.  Long term, it will also create version skew problems\nif the client and reporter are not using exactly the same BEAM\n(or other VM).</p>\n\n<p>For another example, consider storing functions in a data base.\nSince a local fun is tied to a specific version of a specific\nmodule, if you save a function one month, upgrade your system,\nand restore the module next month, you cannot expect it to work.\nThis means that, for example, you cannot store a binary together\nwith a function that knows how to decode it.</p>\n\n<p>For another example, consider something like a data base that\ndynamically receive matchspecs (or something like matchspecs)\nand wishes to apply such a thing to millions of records.  It\nis easy enough to transform a matchspec to Erlang code, and\neven to compile the result, but now you have a module to manage,\nnot a simple thing that can be cleaned up by a garbage collector.</p>\n\n<p>Basically, the aim of this proposal is to move Erlang one step\nfurther along the \"functions are data\" functional programming way.</p>\n\n<p>However, it is necessary to do this in such a way that a process\nreceiving a portable fun does not have to place total trust in\nthe source.  The receiver must be able to inspect a portable fun\nas well as just call it.</p>\n\n<h1>Rationale</h1>\n\n<p>It would not be a good idea to just add the portability\nrestrictions on top of existing fun syntax.  That would break\nmost programs that use funs.</p>\n\n<p>Perhaps the obvious thing would be to use #fun...end, as the\nsharp seems to be Erlang's \"oops, we didn't think of that in the\nGood Old Days\" marker, much as it is in Common Lisp.  However, we\nwant that notation for anonymous abstract patterns, and in any\ncase, there is nothing iconic about the sharp in this context.</p>\n\n<p>The bang is used to suggest that this is a kind of fun that you\nmight want to send, which indeed it is.  As for where it is\nplaced, the bang is to be thought of as post-modifying the 'fun'\nkeyword, not as pre-modifying the argument list, so that</p>\n\n<pre><code>fun!({a,X}) -&gt; ...\n   ;({b,Y}) -&gt; ...\nend\n</code></pre>\n\n<p>does not have a repeated bang.</p>\n\n<p>What do you send when you send a portable fun?</p>\n\n<ul>\n<li>the environment, of course</li>\n<li>some sort of header, of course</li>\n<li>but what does the CODE look like?</li>\n</ul>\n\n<p>If it is native code, you can't send a fun from a SPARC to a Mac.\nIf it is BEAM code, you can't send a fun to another system unless\nit has exactly the same version of BEAM.\nIn either case, you have made life extremely hard for a wary\nreceiver that wants to inspect the code.\nIf it is the source code, then</p>\n\n<ul>\n<li>it can be (lazily!) compiled to BEAM (or some other VM) </li>\n<li>it can be interpreted</li>\n<li>it can be debugged</li>\n<li>it can be inspected</li>\n<li>we don't have to worry about how the compiler deals with\ncomprehensions -- sadly, the current compiler generates\nrecursive auxiliary functions, which complicates things,\nand better approaches are possible</li>\n</ul>\n\n<p>Accordingly, the binary format for a portable fun would include\nthe source tree, possibly compressed as in Kistler's Juice.\nThe native representation would include a pointer to a block of\nBEAM code and optionally a pointer to a block of native code,\nbut these would be filled in on first call.</p>\n\n<p>The possibility of interpretation means that there is a cheap way\nto implement a prototype of this EEP: always interpret.  This too\nargues against any change to existing funs; we don't want to slow\nthem down.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>\"fun!\" is currently a syntax error,\nso no existing code can be affected by that.</p>\n\n<p>As I read the documentation for erlang:fun_info/[1,2],\nprogrammers should always have treated these functions as\nopen-ended.  Nothing promised by the existing manual is\nremoved or altered, only new values provided.</p>\n\n<p>Any existing program that called\nerlang:is<em>portable</em>function/[1,2]\ndidn't work anyway, there being no such functions.\nIf a module defined is<em>portable</em>function/1 or /2,\nit would not have been allowed in a guard, but would have\nbeen allowed elsewhere; such a module could be affected.\nIf the compiler discovers a definition of either function\nin a module, it should print a warning message, and use only\nthe module's version.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None.</p>\n\n<p>Long term, this needs at least two things:</p>\n\n<ol>\n<li><p>a fun representation that holds instructions in a binary\nthat is not part of any module, not unlike the classic\nInterlisp-D implementation, so that such funs can be\nindividually garbage collected.  This is desirable anyway.</p></li>\n<li><p>a compilation strategy for comprehensions that, like the\nclassic Pop-2 system, generates in-line loops instead of\ncalls to out-of-line auxiliary functions.  This is\ndesirable anyway; it should be noticeably faster.</p></li>\n</ol>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}