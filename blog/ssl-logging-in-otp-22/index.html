<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/ssl-logging-in-otp-22/">TLS logging improvements in OTP 22</a></h3><p><em>Friday, 5 October 2018<!-- --> - <!-- -->Péter Dimitrov</em></p><p>Erlang/OTP 22 will be an important release for the <code>ssl</code> application. We are working on
several new features and improvements such as support for TLS 1.3, some of those are already
on the master branch. This blog post presents the new ssl debug logging built on the new
logger API.</p><h2>Usage</h2><p>As the <code>ssl</code> application undergoes a lot of changes the release of the new logger API
presented the opportunity to level up its debug logging capabilities to be on par with
OpenSSL.</p><p>We have introduced a new option <code>log_level</code> that specifies the log level for the <code>ssl</code>
application. It can take the following values (ordered by increasing verbosity level):
<code>emergency</code>, <code>alert</code>, <code>critical</code>, <code>error</code>, <code>warning</code>, <code>notice</code>,
<code>info</code> and <code>debug</code>. At verbosity level <code>notice</code> and above error reports are
displayed in TLS. The level <code>debug</code> triggers verbose logging of TLS protocol messages
in a similar style as in OpenSSL.</p><p>The verbose debug logging can be turned on by two simple steps: the <code>log_level</code> shall
be set to <code>debug</code> and the logger shall be configured to enable <code>debug</code> logging
for the ssl application. The following code snippet is a sample module with a simple TLS server
and client:</p><pre><code class="language-erlang">-module(ssltest).

-compile(export_all).

-define(PORT, 11000).

server() -&gt;
    application:load(ssl),
    logger:set_application_level(ssl, debug),
    {ok, _} = application:ensure_all_started(ssl),
    Port = ?PORT,
    LOpts = [{certfile, &quot;server.pem&quot;},
             {keyfile, &quot;server.key&quot;},
             {versions, [&#x27;tlsv1.2&#x27;]},
             {log_level, debug}
            ],
    {ok, LSock} = ssl:listen(Port, LOpts),
    {ok, CSock} = ssl:transport_accept(LSock),
    {ok, _} = ssl:handshake(CSock).

client() -&gt;
    application:load(ssl),
    logger:set_application_level(ssl, debug),
    {ok, _} = application:ensure_all_started(ssl),
    Port = ?PORT,
    COpts = [{verify, verify_peer},
             {cacertfile, &quot;ca.pem&quot;},
             {versions, [&#x27;tlsv1.2&#x27;]},
             {log_level, debug}
            ],
    {ok, Sock} = ssl:connect(&quot;localhost&quot;, Port, COpts).
</code></pre><p>Starting the server and client in their respective erlang shells produces the following
verbose logging of TLS protocol messages:</p><pre><code>1&gt; ssltest:server().
reading (238 bytes) TLS 1.2 Record Protocol, handshake
0000 - 16 03 03 00 e9 01 00 00  e5 03 03 5b ab 42 7a ee    ...........[.Bz.
0010 - 91 23 df 70 30 fb 41 b9  c5 14 79 d7 02 48 74 c9    .#.p0.A...y..Ht.
0020 - b9 a9 8f e0 e9 04 1a f9  a8 21 49 00 00 4a 00 ff    .........!I..J..
0030 - c0 2c c0 30 c0 24 c0 28  c0 2e c0 32 c0 26 c0 2a    .,.0.$.(...2.&amp;.*
0040 - 00 9f 00 a3 00 6b 00 6a  c0 2b c0 2f c0 23 c0 27    .....k.j.+./.#.&#x27;
0050 - c0 2d c0 31 c0 25 c0 29  00 9e 00 a2 00 67 00 40    .-.1.%.).....g.@
0060 - c0 0a c0 14 00 39 00 38  c0 05 c0 0f c0 09 c0 13    .....9.8........
0070 - 00 33 00 32 c0 04 c0 0e  01 00 00 72 00 00 00 0e    .3.2.......r....
0080 - 00 0c 00 00 09 6c 6f 63  61 6c 68 6f 73 74 00 0a    .....localhost..
0090 - 00 3a 00 38 00 0e 00 0d  00 19 00 1c 00 0b 00 0c    .:.8............
00a0 - 00 1b 00 18 00 09 00 0a  00 1a 00 16 00 17 00 08    ................
00b0 - 00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13    ................
00c0 - 00 01 00 02 00 03 00 0f  00 10 00 11 00 0b 00 02    ................
00d0 - 01 00 00 0d 00 18 00 16  06 03 06 01 05 03 05 01    ................
00e0 - 04 03 04 01 03 03 03 01  02 03 02 01 02 02          ..............
&lt;&lt;&lt; TLS 1.2 Handshake, ClientHello
[{client_version,{3,3}},
 {random,
     &lt;&lt;91,171,66,122,238,145,35,223,112,48,251,65,185,197,20,121,215,2,72,116,
       201,185,169,143,224,233,4,26,249,168,33,73&gt;&gt;},
 {session_id,&lt;&lt;&gt;&gt;},
 {cipher_suites,
     [&lt;&lt;0,255&gt;&gt;,
      &lt;&lt;&quot;À,&quot;&gt;&gt;,&lt;&lt;&quot;À0&quot;&gt;&gt;,&lt;&lt;&quot;À$&quot;&gt;&gt;,&lt;&lt;&quot;À(&quot;&gt;&gt;,&lt;&lt;&quot;À.&quot;&gt;&gt;,&lt;&lt;&quot;À2&quot;&gt;&gt;,&lt;&lt;&quot;À&amp;&quot;&gt;&gt;,&lt;&lt;&quot;À*&quot;&gt;&gt;,
      &lt;&lt;0,159&gt;&gt;,
      &lt;&lt;0,163&gt;&gt;,
      &lt;&lt;0,107&gt;&gt;,
      &lt;&lt;0,106&gt;&gt;,
      &lt;&lt;&quot;À+&quot;&gt;&gt;,&lt;&lt;&quot;À/&quot;&gt;&gt;,&lt;&lt;&quot;À#&quot;&gt;&gt;,&lt;&lt;&quot;À&#x27;&quot;&gt;&gt;,&lt;&lt;&quot;À-&quot;&gt;&gt;,&lt;&lt;&quot;À1&quot;&gt;&gt;,&lt;&lt;&quot;À%&quot;&gt;&gt;,&lt;&lt;&quot;À)&quot;&gt;&gt;,
      &lt;&lt;0,158&gt;&gt;,
      &lt;&lt;0,162&gt;&gt;,
      &lt;&lt;0,103&gt;&gt;,
      &lt;&lt;0,64&gt;&gt;,
      &lt;&lt;&quot;À\n&quot;&gt;&gt;,
      &lt;&lt;192,20&gt;&gt;,
      &lt;&lt;0,57&gt;&gt;,
      &lt;&lt;0,56&gt;&gt;,
      &lt;&lt;192,5&gt;&gt;,
      &lt;&lt;192,15&gt;&gt;,
      &lt;&lt;&quot;À\t&quot;&gt;&gt;,
      &lt;&lt;192,19&gt;&gt;,
      &lt;&lt;0,51&gt;&gt;,
      &lt;&lt;0,50&gt;&gt;,
      &lt;&lt;192,4&gt;&gt;,
      &lt;&lt;192,14&gt;&gt;]},
 {compression_methods,[0]},
...
[Truncated for brevity]</code></pre><p>This is not the final format as there are many ways to further improve the representation
of the handshake protocol messages such as converting the cipher suites to a human-readable
erlang representation.</p><p>As a comparison this is the debug output from an OpenSSL server when the same erlang client
connects to it:</p><pre><code>$ /usr/bin/openssl s_server -accept 11000 -tls1_2 -cert server.pem -key server.key -msg -debug
Using default temp DH parameters
ACCEPT
read from 0x16f0040 [0x16f56b3] (5 bytes =&gt; 5 (0x5))
0000 - 16 03 03 00 a1                                    .....
&lt;&lt;&lt; ??? [length 0005]
    16 03 03 00 a1
read from 0x16f0040 [0x16f56b8] (161 bytes =&gt; 161 (0xA1))
0000 - 01 00 00 9d 03 03 5b ac-a1 cc 20 4c 4d 52 d0 d4   ......[... LMR..
0010 - c8 fc dd 95 b0 fa 65 97-57 9e 44 aa dd 0e 46 10   ......e.W.D...F.
0020 - 6c 14 57 9c ce a0 00 00-04 00 ff c0 14 01 00 00   l.W.............
0030 - 70 00 2b 00 06 00 04 03-04 03 03 00 00 00 0e 00   p.+.............
0040 - 0c 00 00 09 6c 6f 63 61-6c 68 6f 73 74 00 0a 00   ....localhost...
0050 - 3a 00 38 00 0e 00 0d 00-19 00 1c 00 0b 00 0c 00   :.8.............
0060 - 1b 00 18 00 09 00 0a 00-1a 00 16 00 17 00 08 00   ................
0070 - 06 00 07 00 14 00 15 00-04 00 05 00 12 00 13 00   ................
0080 - 01 00 02 00 03 00 0f 00-10 00 11 00 0b 00 02 01   ................
0090 - 00 00 32 00 04 00 02 02-03 00 0d 00 04 00 02 02   ..2.............
00a0 - 01                                                .
&lt;&lt;&lt; TLS 1.2 Handshake [length 00a1], ClientHello
    01 00 00 9d 03 03 5b ac a1 cc 20 4c 4d 52 d0 d4
    c8 fc dd 95 b0 fa 65 97 57 9e 44 aa dd 0e 46 10
    6c 14 57 9c ce a0 00 00 04 00 ff c0 14 01 00 00
    70 00 2b 00 06 00 04 03 04 03 03 00 00 00 0e 00
    0c 00 00 09 6c 6f 63 61 6c 68 6f 73 74 00 0a 00
    3a 00 38 00 0e 00 0d 00 19 00 1c 00 0b 00 0c 00
    1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00
    06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00
    01 00 02 00 03 00 0f 00 10 00 11 00 0b 00 02 01
    00 00 32 00 04 00 02 02 03 00 0d 00 04 00 02 02
    01
...
[Truncated for brevity]</code></pre><p>The verbose debug logging proved to be especially useful during the development of new
extensions as previously we had to use wireshark captures to validate TLS protocol
messages.</p><h2>Implementation</h2><p>In the <code>ssl</code> application, we needed a way to handle two types of protocol
messages, tls_record and handshake, each with a custom formatter.</p><p>The most straightforward solution was to add a new handler instance to the logger with a
special formatter function that filters out all the &quot;noise&quot; coming from other
modules of the system.</p><p>The handler itself could reuse the standard handler for logger, <code>logger_std_h</code>, as it
could print logs to <code>standard_io</code>. You can add multiple standard handler instances to
logger if your application requires it.</p><pre><code class="language-erlang">logger:add_handler(ssl_handler, logger_std_h, Config),</code></pre><p>The new ssl_handler is configured with a formatter that is implemented by the <code>ssl_logger</code>
module.</p><pre><code class="language-erlang">Config = #{level =&gt; debug,
           filter_default =&gt; stop,
           formatter =&gt; {ssl_logger, #{}}},</code></pre><p>Handler filter level is set to <code>debug</code> with <code>stop</code> as the default filter action. We also
need a filter that lets the log events pass to the formatter if the source of the log event is the
ssl application. In other words, we need a domain filter with the action <code>log</code> on all sub-domains
matching <code>[otp,ssl]</code>.</p><pre><code class="language-erlang">Filter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},</code></pre><p>Putting it all together we get the following function.</p><pre><code class="language-erlang">start_logger() -&gt;
    Config = #{level =&gt; debug,
               filter_default =&gt; stop,
               formatter =&gt; {ssl_logger, #{}}},
    Filter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},
    logger:add_handler(ssl_handler, logger_std_h, Config),
    logger:add_handler_filter(ssl_handler, filter_non_ssl, Filter).</code></pre><p>The function <code>format</code> is called in ssl_logger when an event gets through all the filters:</p><pre><code class="language-erlang">format(#{level:= _Level, msg:= {report, Msg}, meta:= _Meta},
       _Config0) -&gt;
     #{direction := Direction,
       protocol := Protocol,
       message := BinMsg0} = Msg,
    case Protocol of
        &#x27;tls_record&#x27; -&gt;
            BinMsg = lists:flatten(BinMsg0),
            format_tls_record(Direction, BinMsg);
        &#x27;handshake&#x27; -&gt;
            format_handshake(Direction, BinMsg0);
        _Other -&gt;
            []
    end.</code></pre><p>There are two more helper functions that wrap around the logging macros. They were added in order
to be able to set logging level per TLS session.</p><pre><code class="language-erlang">debug(Level, Report, Meta) -&gt;
    case logger:compare_levels(Level, debug) of
        lt -&gt;
            ?LOG_DEBUG(Report, Meta);
        eq -&gt;
            ?LOG_DEBUG(Report, Meta);
        _ -&gt;
            ok
    end.

notice(Level, Report) -&gt;
    case logger:compare_levels(Level, notice) of
        lt -&gt;
            ?LOG_NOTICE(Report);
        eq -&gt;
            ?LOG_NOTICE(Report);
        _ -&gt;
            ok
    end.</code></pre><p>To print a log event, the above functions are called with the configured ssl log level and
the domain parameter.</p><pre><code class="language-erlang">ssl_logger:debug(Opts#ssl_options.log_level,
	         Report,
		 #{domain =&gt; [otp,ssl,handshake]}),</code></pre><p>Those who are interested in the current state of development can already play with the
<code>&#x27;tlsv1.3&#x27;</code> atom in the <code>versions</code> option.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"ssl-logging-in-otp-22","title":"TLS logging improvements in OTP 22","author":"Péter Dimitrov","excerpt":"Erlang/OTP 22 will be an important release for the ```ssl``` application. We are working on\nseveral new features and improvements such as support for TLS 1.3, some of those are already\non the master branch. This blog post presents the new ssl debug logging built on the new\nlogger API.","article_date":1538697600000,"tags":["ssl","logger"],"frontmatter":{"layout":"post","title":"TLS logging improvements in OTP 22","tags":"ssl logger","author":"Péter Dimitrov"},"content":"Erlang/OTP 22 will be an important release for the ```ssl``` application. We are working on\nseveral new features and improvements such as support for TLS 1.3, some of those are already\non the master branch. This blog post presents the new ssl debug logging built on the new\nlogger API.\n\n## Usage\n\nAs the ```ssl``` application undergoes a lot of changes the release of the new logger API\npresented the opportunity to level up its debug logging capabilities to be on par with\nOpenSSL.\n\nWe have introduced a new option ```log_level``` that specifies the log level for the ```ssl```\napplication. It can take the following values (ordered by increasing verbosity level):\n```emergency```, ```alert```, ```critical```, ```error```, ```warning```, ```notice```,\n```info``` and ```debug```. At verbosity level ```notice``` and above error reports are\ndisplayed in TLS. The level ```debug``` triggers verbose logging of TLS protocol messages\nin a similar style as in OpenSSL.\n\nThe verbose debug logging can be turned on by two simple steps: the ```log_level``` shall\nbe set to ```debug``` and the logger shall be configured to enable ```debug``` logging\nfor the ssl application. The following code snippet is a sample module with a simple TLS server\nand client:\n\n```erlang\n-module(ssltest).\n\n-compile(export_all).\n\n-define(PORT, 11000).\n\nserver() -\u003e\n    application:load(ssl),\n    logger:set_application_level(ssl, debug),\n    {ok, _} = application:ensure_all_started(ssl),\n    Port = ?PORT,\n    LOpts = [{certfile, \"server.pem\"},\n             {keyfile, \"server.key\"},\n             {versions, ['tlsv1.2']},\n             {log_level, debug}\n            ],\n    {ok, LSock} = ssl:listen(Port, LOpts),\n    {ok, CSock} = ssl:transport_accept(LSock),\n    {ok, _} = ssl:handshake(CSock).\n\nclient() -\u003e\n    application:load(ssl),\n    logger:set_application_level(ssl, debug),\n    {ok, _} = application:ensure_all_started(ssl),\n    Port = ?PORT,\n    COpts = [{verify, verify_peer},\n             {cacertfile, \"ca.pem\"},\n             {versions, ['tlsv1.2']},\n             {log_level, debug}\n            ],\n    {ok, Sock} = ssl:connect(\"localhost\", Port, COpts).\n\n```\n\nStarting the server and client in their respective erlang shells produces the following\nverbose logging of TLS protocol messages:\n\n\n```\n1\u003e ssltest:server().\nreading (238 bytes) TLS 1.2 Record Protocol, handshake\n0000 - 16 03 03 00 e9 01 00 00  e5 03 03 5b ab 42 7a ee    ...........[.Bz.\n0010 - 91 23 df 70 30 fb 41 b9  c5 14 79 d7 02 48 74 c9    .#.p0.A...y..Ht.\n0020 - b9 a9 8f e0 e9 04 1a f9  a8 21 49 00 00 4a 00 ff    .........!I..J..\n0030 - c0 2c c0 30 c0 24 c0 28  c0 2e c0 32 c0 26 c0 2a    .,.0.$.(...2.\u0026.*\n0040 - 00 9f 00 a3 00 6b 00 6a  c0 2b c0 2f c0 23 c0 27    .....k.j.+./.#.'\n0050 - c0 2d c0 31 c0 25 c0 29  00 9e 00 a2 00 67 00 40    .-.1.%.).....g.@\n0060 - c0 0a c0 14 00 39 00 38  c0 05 c0 0f c0 09 c0 13    .....9.8........\n0070 - 00 33 00 32 c0 04 c0 0e  01 00 00 72 00 00 00 0e    .3.2.......r....\n0080 - 00 0c 00 00 09 6c 6f 63  61 6c 68 6f 73 74 00 0a    .....localhost..\n0090 - 00 3a 00 38 00 0e 00 0d  00 19 00 1c 00 0b 00 0c    .:.8............\n00a0 - 00 1b 00 18 00 09 00 0a  00 1a 00 16 00 17 00 08    ................\n00b0 - 00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13    ................\n00c0 - 00 01 00 02 00 03 00 0f  00 10 00 11 00 0b 00 02    ................\n00d0 - 01 00 00 0d 00 18 00 16  06 03 06 01 05 03 05 01    ................\n00e0 - 04 03 04 01 03 03 03 01  02 03 02 01 02 02          ..............\n\u003c\u003c\u003c TLS 1.2 Handshake, ClientHello\n[{client_version,{3,3}},\n {random,\n     \u003c\u003c91,171,66,122,238,145,35,223,112,48,251,65,185,197,20,121,215,2,72,116,\n       201,185,169,143,224,233,4,26,249,168,33,73\u003e\u003e},\n {session_id,\u003c\u003c\u003e\u003e},\n {cipher_suites,\n     [\u003c\u003c0,255\u003e\u003e,\n      \u003c\u003c\"À,\"\u003e\u003e,\u003c\u003c\"À0\"\u003e\u003e,\u003c\u003c\"À$\"\u003e\u003e,\u003c\u003c\"À(\"\u003e\u003e,\u003c\u003c\"À.\"\u003e\u003e,\u003c\u003c\"À2\"\u003e\u003e,\u003c\u003c\"À\u0026\"\u003e\u003e,\u003c\u003c\"À*\"\u003e\u003e,\n      \u003c\u003c0,159\u003e\u003e,\n      \u003c\u003c0,163\u003e\u003e,\n      \u003c\u003c0,107\u003e\u003e,\n      \u003c\u003c0,106\u003e\u003e,\n      \u003c\u003c\"À+\"\u003e\u003e,\u003c\u003c\"À/\"\u003e\u003e,\u003c\u003c\"À#\"\u003e\u003e,\u003c\u003c\"À'\"\u003e\u003e,\u003c\u003c\"À-\"\u003e\u003e,\u003c\u003c\"À1\"\u003e\u003e,\u003c\u003c\"À%\"\u003e\u003e,\u003c\u003c\"À)\"\u003e\u003e,\n      \u003c\u003c0,158\u003e\u003e,\n      \u003c\u003c0,162\u003e\u003e,\n      \u003c\u003c0,103\u003e\u003e,\n      \u003c\u003c0,64\u003e\u003e,\n      \u003c\u003c\"À\\n\"\u003e\u003e,\n      \u003c\u003c192,20\u003e\u003e,\n      \u003c\u003c0,57\u003e\u003e,\n      \u003c\u003c0,56\u003e\u003e,\n      \u003c\u003c192,5\u003e\u003e,\n      \u003c\u003c192,15\u003e\u003e,\n      \u003c\u003c\"À\\t\"\u003e\u003e,\n      \u003c\u003c192,19\u003e\u003e,\n      \u003c\u003c0,51\u003e\u003e,\n      \u003c\u003c0,50\u003e\u003e,\n      \u003c\u003c192,4\u003e\u003e,\n      \u003c\u003c192,14\u003e\u003e]},\n {compression_methods,[0]},\n...\n[Truncated for brevity]\n```\n\nThis is not the final format as there are many ways to further improve the representation\nof the handshake protocol messages such as converting the cipher suites to a human-readable\nerlang representation.\n\nAs a comparison this is the debug output from an OpenSSL server when the same erlang client\nconnects to it:\n\n\n```\n$ /usr/bin/openssl s_server -accept 11000 -tls1_2 -cert server.pem -key server.key -msg -debug\nUsing default temp DH parameters\nACCEPT\nread from 0x16f0040 [0x16f56b3] (5 bytes =\u003e 5 (0x5))\n0000 - 16 03 03 00 a1                                    .....\n\u003c\u003c\u003c ??? [length 0005]\n    16 03 03 00 a1\nread from 0x16f0040 [0x16f56b8] (161 bytes =\u003e 161 (0xA1))\n0000 - 01 00 00 9d 03 03 5b ac-a1 cc 20 4c 4d 52 d0 d4   ......[... LMR..\n0010 - c8 fc dd 95 b0 fa 65 97-57 9e 44 aa dd 0e 46 10   ......e.W.D...F.\n0020 - 6c 14 57 9c ce a0 00 00-04 00 ff c0 14 01 00 00   l.W.............\n0030 - 70 00 2b 00 06 00 04 03-04 03 03 00 00 00 0e 00   p.+.............\n0040 - 0c 00 00 09 6c 6f 63 61-6c 68 6f 73 74 00 0a 00   ....localhost...\n0050 - 3a 00 38 00 0e 00 0d 00-19 00 1c 00 0b 00 0c 00   :.8.............\n0060 - 1b 00 18 00 09 00 0a 00-1a 00 16 00 17 00 08 00   ................\n0070 - 06 00 07 00 14 00 15 00-04 00 05 00 12 00 13 00   ................\n0080 - 01 00 02 00 03 00 0f 00-10 00 11 00 0b 00 02 01   ................\n0090 - 00 00 32 00 04 00 02 02-03 00 0d 00 04 00 02 02   ..2.............\n00a0 - 01                                                .\n\u003c\u003c\u003c TLS 1.2 Handshake [length 00a1], ClientHello\n    01 00 00 9d 03 03 5b ac a1 cc 20 4c 4d 52 d0 d4\n    c8 fc dd 95 b0 fa 65 97 57 9e 44 aa dd 0e 46 10\n    6c 14 57 9c ce a0 00 00 04 00 ff c0 14 01 00 00\n    70 00 2b 00 06 00 04 03 04 03 03 00 00 00 0e 00\n    0c 00 00 09 6c 6f 63 61 6c 68 6f 73 74 00 0a 00\n    3a 00 38 00 0e 00 0d 00 19 00 1c 00 0b 00 0c 00\n    1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00\n    06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00\n    01 00 02 00 03 00 0f 00 10 00 11 00 0b 00 02 01\n    00 00 32 00 04 00 02 02 03 00 0d 00 04 00 02 02\n    01\n...\n[Truncated for brevity]\n```\n\nThe verbose debug logging proved to be especially useful during the development of new\nextensions as previously we had to use wireshark captures to validate TLS protocol\nmessages.\n\n## Implementation\n\nIn the ```ssl``` application, we needed a way to handle two types of protocol\nmessages, tls_record and handshake, each with a custom formatter.\n\nThe most straightforward solution was to add a new handler instance to the logger with a\nspecial formatter function that filters out all the \"noise\" coming from other\nmodules of the system.\n\nThe handler itself could reuse the standard handler for logger, ```logger_std_h```, as it\ncould print logs to ```standard_io```. You can add multiple standard handler instances to\nlogger if your application requires it.\n\n```erlang\nlogger:add_handler(ssl_handler, logger_std_h, Config),\n```\n\nThe new ssl_handler is configured with a formatter that is implemented by the ```ssl_logger```\nmodule.\n\n```erlang\nConfig = #{level =\u003e debug,\n           filter_default =\u003e stop,\n           formatter =\u003e {ssl_logger, #{}}},\n```\n\nHandler filter level is set to ```debug``` with ```stop``` as the default filter action. We also\nneed a filter that lets the log events pass to the formatter if the source of the log event is the\nssl application. In other words, we need a domain filter with the action ```log``` on all sub-domains\nmatching ```[otp,ssl]```.\n\n```erlang\nFilter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},\n```\n\nPutting it all together we get the following function.\n\n```erlang\nstart_logger() -\u003e\n    Config = #{level =\u003e debug,\n               filter_default =\u003e stop,\n               formatter =\u003e {ssl_logger, #{}}},\n    Filter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},\n    logger:add_handler(ssl_handler, logger_std_h, Config),\n    logger:add_handler_filter(ssl_handler, filter_non_ssl, Filter).\n```\n\nThe function ```format``` is called in ssl_logger when an event gets through all the filters:\n\n```erlang\nformat(#{level:= _Level, msg:= {report, Msg}, meta:= _Meta},\n       _Config0) -\u003e\n     #{direction := Direction,\n       protocol := Protocol,\n       message := BinMsg0} = Msg,\n    case Protocol of\n        'tls_record' -\u003e\n            BinMsg = lists:flatten(BinMsg0),\n            format_tls_record(Direction, BinMsg);\n        'handshake' -\u003e\n            format_handshake(Direction, BinMsg0);\n        _Other -\u003e\n            []\n    end.\n```\n\nThere are two more helper functions that wrap around the logging macros. They were added in order\nto be able to set logging level per TLS session.\n\n```erlang\ndebug(Level, Report, Meta) -\u003e\n    case logger:compare_levels(Level, debug) of\n        lt -\u003e\n            ?LOG_DEBUG(Report, Meta);\n        eq -\u003e\n            ?LOG_DEBUG(Report, Meta);\n        _ -\u003e\n            ok\n    end.\n\nnotice(Level, Report) -\u003e\n    case logger:compare_levels(Level, notice) of\n        lt -\u003e\n            ?LOG_NOTICE(Report);\n        eq -\u003e\n            ?LOG_NOTICE(Report);\n        _ -\u003e\n            ok\n    end.\n```\n\nTo print a log event, the above functions are called with the configured ssl log level and\nthe domain parameter.\n\n```erlang\nssl_logger:debug(Opts#ssl_options.log_level,\n\t         Report,\n\t\t #{domain =\u003e [otp,ssl,handshake]}),\n```\n\nThose who are interested in the current state of development can already play with the\n```'tlsv1.3'``` atom in the ```versions``` option.\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"ssl-logging-in-otp-22"},"buildId":"L68tPJnB-kPxrFxsY9AoN","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_buildManifest.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_ssgManifest.js" async=""></script></body></html>