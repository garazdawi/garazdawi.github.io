<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 10-Jul-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 14: <a href="eep-0014.md" title="EEP Source"> Guard clarification and extension</a></h2>

<h1>Abstract</h1>

<p>Allow Pattern = Guard_Expression as a simple guard test.
Make obviously silly guards syntax errors.</p>

<h1>Specification</h1>

<p>Replace the opening text of section 6.24 "Guard Sequences"
as follows.</p>

<pre><code>&lt;guard&gt; ::= &lt;OR guard&gt;
&lt;OR guard&gt; ::= &lt;AND guard&gt; {';' &lt;AND guard&gt;}*
</code></pre>

<p>An <code>&lt;OR guard&gt;</code> is a sequence of <code>&lt;AND guards&gt;</code> separated by
semicolons.  Here, as elsewhere in Erlang, semicolon means
sequential OR:  an <code>&lt;OR guard&gt;</code> evaluates its <code>&lt;AND guards&gt;</code>
one at a time from left to right, until one succeeds or
until all have failed.</p>

<pre><code>&lt;AND guard&gt; ::= &lt;guard test&gt; {',' &lt;guard test&gt;}*
</code></pre>

<p>An <code>&lt;AND guard&gt;</code> is a sequence of <code>&lt;guard tests&gt;</code> separated by
semicolons.  Here, as is often the case in Erlang, comma
means sequential AND:  an <code>&lt;AND guard&gt;</code> evaluates its
<code>&lt;guard tests&gt;</code> one at a time from left to right, until all
have succeeded or one has failed.</p>

<pre><code>&lt;guard test&gt; ::= &lt;guard match&gt;
              | &lt;Boolean expression&gt;

&lt;guard match&gt; ::= &lt;pattern&gt; '=' &lt;guard expr&gt;
               |  &lt;pattern&gt; '=' &lt;guard match&gt;
</code></pre>

<p>A <code>&lt;guard test&gt;</code> is either a match or a Boolean expression.
In a guard, a match suceeds if and only if the <code>&lt;guard expr&gt;</code>
can be evaluated without exception, and the result can be
matched with the <code>&lt;pattern&gt;</code>, possibly binding some variables.</p>

<p>If a variable is bound in one <code>&lt;guard test&gt;</code>, it may be used in
later <code>&lt;guard test&gt;</code>s of the same <code>&lt;AND guard&gt;</code>.  If a variable
is bound in all of the <code>&lt;AND guard&gt;</code>s of an <code>&lt;OR guard&gt;</code> it may
be used in the guarded code, so</p>

<pre><code>if  X = 1, is_atom(element(X, Tup))
 ;  X = 2, is_atom(element(X, Tup))
 -&gt; ... uses X ...
</code></pre>

<p>is OK.  If a variable is bound in one of the <code>&lt;AND guard&gt;</code>s of
an <code>&lt;OR guard&gt;</code> but not all of them it may not be used in the
guarded code, so</p>

<pre><code>if  X = a
 ;  Y = b
 -&gt; ... uses X ...
</code></pre>

<p>is not allowed.</p>

<p>A <code>&lt;Boolean expression&gt;</code> in a guard consists of a number
of subexpressions
    constant 'false'
    constant 'true'
    variable (must be bound to 'false' or 'true')
    term comparison with <code>&lt;guard expr&gt;</code> operands
    calls to type test BIFs with <code>&lt;guard expr&gt;</code> operands
    <code>&lt;Boolean expression&gt;</code>s in parentheses
combined using the operators 'not', 'and', 'or',
'andalso', and 'orelse'.  Thus</p>

<pre><code>X+1 == Y
</code></pre>

<p>is a <code>&lt;Boolean expression&gt;</code> that can be used as a <code>&lt;guard test&gt;</code>
but</p>

<pre><code>X+1
</code></pre>

<p>is not.  You are advised never to use the 'and' and 'or' operators
and to avoid 'andalso' and 'orelse' whenever ',' and ';' will do
what you need.</p>

<p>The set of <code>&lt;guard expr&gt;</code>s is a subset of the set of valid Erlang
expressions.  The reason for restricting the set of valid
expressions is that evaluation of a guard expression must be
guaranteed to be free of side effects and to terminate.</p>

<p>A <code>&lt;guard expr&gt;</code> consists of a number of subexpressions</p>

<ul>
<li>constants</li>
<li>variables</li>
<li>calls to "other BIFs Allowed in Guard Expressions"
(see table) with <code>&lt;guard expr&gt;</code> arguments</li>
<li>record field selections</li>
<li><code>&lt;guard expr&gt;</code>s in parentheses</li>
</ul>

<p>combined using the built in arithmetic and bitwise operators.</p>

<h1>Motivation</h1>

<p>There are two parts to this EEP.  It was originally going to
be just about allowing matches in guards.  Then it was going
to be two, because the current situation is just too messy,
but then it became one again for brevity.</p>

<p>Consider this case.  A function is given a tuple and an index.
If the element at that index is in the range 0..127, it
should be returned.  Otherwise some other clause should apply.
Currently, we have to write</p>

<pre><code>f(Tuple, Index)
    when is_integer(element(Tuple, Index)),
     0 =&lt; element(Tuple, Index),
     element(Tuple, Index) =&lt; 127
      -&gt; element(Tuple, Index);
...
</code></pre>

<p>or something else which is even clumsier.  Why can't we write</p>

<pre><code>f(Tuple, Index)
    when X = element(Tuple, Index),
         is_integer(X), 0 =&lt; X, X =&lt; 127
      -&gt; X;
...
</code></pre>

<p>In trying to explain how to add this to the language, I found
that the current description of guards in the Erlang reference
manual is remarkably fuzzy.  Dismayingly, this is matched
by an equally fuzzy implementation.  The description mixes
up things that can be used as arguments of guard BIFs
(guard expressions) with simple guards.</p>

<p>Consider the example</p>

<pre><code>X = 1,
if X+1 -&gt; true
 ; X-1 -&gt; false
end.
</code></pre>

<p>This clearly makes no sense at all, and should be rejected
as bad syntax.  According to the current reference manual,
it is legal; X+1 and X-1 are legal "guard expressions".</p>

<p>In the shell, this exampel crashes, which indeed makes
a lot of sense.  But 'erlc' says:</p>

<pre><code>{X+1} Warning: the guard for this clause evaluates to 'false'
{X-1} Warning: the guard for this clause evaluates to 'false'
</code></pre>

<p>It is good that there is a warning, but bad that the text of
the warning is wrong.  These things DON'T evaluate to 'false',
they evaluate to numbers.  Then, despite having given a warning,
you get a run-time error.</p>

<pre><code>exited: {if_clause,[{a,f,0},{shell,exprs,6},{shell,eval_loop,3}]}
</code></pre>

<p>What happened in this example, of course, was that all of the
clauses of the 'if' were eliminated because all of them were
malformed.  More realistic examples would simply quietly do the
wrong thing at run time.</p>

<h1>Rationale</h1>

<p>The syntax for allowing matches in guards is obvious;
no other syntax would be tolerable.  The only real question
is whether they can be embedded inside 'andalso' and 'orelse'
or not, and in order to avoid questions of backtracking, I
have said "no".  This is really the simplest extension of
guards to allow matches that I can think of.</p>

<p>The rest of the EEP is concerned with trying to rule out
obviously silly guard tests at compile time.  Precisely how
this is done is debateable.  That it should be done surely
isn't.  What benefit do we currently obtain (other than
unwarranted simplicity in the compiler) from allowing "27"
and "X+5" as guards?</p>

<h1>Backwards Compatibility</h1>

<p>Matches are currently not allowed in guards, so no existing
application code can be broken by adding them.  Obviously,
anything that works with Erlang parse trees will need to be
extended.</p>

<p>Cleaning up what's allowed in guards may affect existing code.
However, in most cases the compiler would already have warned
about this, and the compatibility issue amounts to turning a
warning message into an error message.</p>

<h1>Reference Implementation</h1>

<p>None.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0014","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 10-Jul-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 14: \u003ca href=\"eep-0014.md\" title=\"EEP Source\"\u003e Guard clarification and extension\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eAllow Pattern = Guard_Expression as a simple guard test.\nMake obviously silly guards syntax errors.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eReplace the opening text of section 6.24 \"Guard Sequences\"\nas follows.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;guard\u0026gt; ::= \u0026lt;OR guard\u0026gt;\n\u0026lt;OR guard\u0026gt; ::= \u0026lt;AND guard\u0026gt; {';' \u0026lt;AND guard\u0026gt;}*\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn \u003ccode\u003e\u0026lt;OR guard\u0026gt;\u003c/code\u003e is a sequence of \u003ccode\u003e\u0026lt;AND guards\u0026gt;\u003c/code\u003e separated by\nsemicolons.  Here, as elsewhere in Erlang, semicolon means\nsequential OR:  an \u003ccode\u003e\u0026lt;OR guard\u0026gt;\u003c/code\u003e evaluates its \u003ccode\u003e\u0026lt;AND guards\u0026gt;\u003c/code\u003e\none at a time from left to right, until one succeeds or\nuntil all have failed.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;AND guard\u0026gt; ::= \u0026lt;guard test\u0026gt; {',' \u0026lt;guard test\u0026gt;}*\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn \u003ccode\u003e\u0026lt;AND guard\u0026gt;\u003c/code\u003e is a sequence of \u003ccode\u003e\u0026lt;guard tests\u0026gt;\u003c/code\u003e separated by\nsemicolons.  Here, as is often the case in Erlang, comma\nmeans sequential AND:  an \u003ccode\u003e\u0026lt;AND guard\u0026gt;\u003c/code\u003e evaluates its\n\u003ccode\u003e\u0026lt;guard tests\u0026gt;\u003c/code\u003e one at a time from left to right, until all\nhave succeeded or one has failed.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;guard test\u0026gt; ::= \u0026lt;guard match\u0026gt;\n              | \u0026lt;Boolean expression\u0026gt;\n\n\u0026lt;guard match\u0026gt; ::= \u0026lt;pattern\u0026gt; '=' \u0026lt;guard expr\u0026gt;\n               |  \u0026lt;pattern\u0026gt; '=' \u0026lt;guard match\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA \u003ccode\u003e\u0026lt;guard test\u0026gt;\u003c/code\u003e is either a match or a Boolean expression.\nIn a guard, a match suceeds if and only if the \u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003e\ncan be evaluated without exception, and the result can be\nmatched with the \u003ccode\u003e\u0026lt;pattern\u0026gt;\u003c/code\u003e, possibly binding some variables.\u003c/p\u003e\n\n\u003cp\u003eIf a variable is bound in one \u003ccode\u003e\u0026lt;guard test\u0026gt;\u003c/code\u003e, it may be used in\nlater \u003ccode\u003e\u0026lt;guard test\u0026gt;\u003c/code\u003es of the same \u003ccode\u003e\u0026lt;AND guard\u0026gt;\u003c/code\u003e.  If a variable\nis bound in all of the \u003ccode\u003e\u0026lt;AND guard\u0026gt;\u003c/code\u003es of an \u003ccode\u003e\u0026lt;OR guard\u0026gt;\u003c/code\u003e it may\nbe used in the guarded code, so\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eif  X = 1, is_atom(element(X, Tup))\n ;  X = 2, is_atom(element(X, Tup))\n -\u0026gt; ... uses X ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis OK.  If a variable is bound in one of the \u003ccode\u003e\u0026lt;AND guard\u0026gt;\u003c/code\u003es of\nan \u003ccode\u003e\u0026lt;OR guard\u0026gt;\u003c/code\u003e but not all of them it may not be used in the\nguarded code, so\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eif  X = a\n ;  Y = b\n -\u0026gt; ... uses X ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis not allowed.\u003c/p\u003e\n\n\u003cp\u003eA \u003ccode\u003e\u0026lt;Boolean expression\u0026gt;\u003c/code\u003e in a guard consists of a number\nof subexpressions\n    constant 'false'\n    constant 'true'\n    variable (must be bound to 'false' or 'true')\n    term comparison with \u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003e operands\n    calls to type test BIFs with \u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003e operands\n    \u003ccode\u003e\u0026lt;Boolean expression\u0026gt;\u003c/code\u003es in parentheses\ncombined using the operators 'not', 'and', 'or',\n'andalso', and 'orelse'.  Thus\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eX+1 == Y\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis a \u003ccode\u003e\u0026lt;Boolean expression\u0026gt;\u003c/code\u003e that can be used as a \u003ccode\u003e\u0026lt;guard test\u0026gt;\u003c/code\u003e\nbut\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eX+1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis not.  You are advised never to use the 'and' and 'or' operators\nand to avoid 'andalso' and 'orelse' whenever ',' and ';' will do\nwhat you need.\u003c/p\u003e\n\n\u003cp\u003eThe set of \u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003es is a subset of the set of valid Erlang\nexpressions.  The reason for restricting the set of valid\nexpressions is that evaluation of a guard expression must be\nguaranteed to be free of side effects and to terminate.\u003c/p\u003e\n\n\u003cp\u003eA \u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003e consists of a number of subexpressions\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003econstants\u003c/li\u003e\n\u003cli\u003evariables\u003c/li\u003e\n\u003cli\u003ecalls to \"other BIFs Allowed in Guard Expressions\"\n(see table) with \u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003e arguments\u003c/li\u003e\n\u003cli\u003erecord field selections\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;guard expr\u0026gt;\u003c/code\u003es in parentheses\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ecombined using the built in arithmetic and bitwise operators.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThere are two parts to this EEP.  It was originally going to\nbe just about allowing matches in guards.  Then it was going\nto be two, because the current situation is just too messy,\nbut then it became one again for brevity.\u003c/p\u003e\n\n\u003cp\u003eConsider this case.  A function is given a tuple and an index.\nIf the element at that index is in the range 0..127, it\nshould be returned.  Otherwise some other clause should apply.\nCurrently, we have to write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(Tuple, Index)\n    when is_integer(element(Tuple, Index)),\n     0 =\u0026lt; element(Tuple, Index),\n     element(Tuple, Index) =\u0026lt; 127\n      -\u0026gt; element(Tuple, Index);\n...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor something else which is even clumsier.  Why can't we write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(Tuple, Index)\n    when X = element(Tuple, Index),\n         is_integer(X), 0 =\u0026lt; X, X =\u0026lt; 127\n      -\u0026gt; X;\n...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn trying to explain how to add this to the language, I found\nthat the current description of guards in the Erlang reference\nmanual is remarkably fuzzy.  Dismayingly, this is matched\nby an equally fuzzy implementation.  The description mixes\nup things that can be used as arguments of guard BIFs\n(guard expressions) with simple guards.\u003c/p\u003e\n\n\u003cp\u003eConsider the example\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eX = 1,\nif X+1 -\u0026gt; true\n ; X-1 -\u0026gt; false\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis clearly makes no sense at all, and should be rejected\nas bad syntax.  According to the current reference manual,\nit is legal; X+1 and X-1 are legal \"guard expressions\".\u003c/p\u003e\n\n\u003cp\u003eIn the shell, this exampel crashes, which indeed makes\na lot of sense.  But 'erlc' says:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{X+1} Warning: the guard for this clause evaluates to 'false'\n{X-1} Warning: the guard for this clause evaluates to 'false'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt is good that there is a warning, but bad that the text of\nthe warning is wrong.  These things DON'T evaluate to 'false',\nthey evaluate to numbers.  Then, despite having given a warning,\nyou get a run-time error.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexited: {if_clause,[{a,f,0},{shell,exprs,6},{shell,eval_loop,3}]}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhat happened in this example, of course, was that all of the\nclauses of the 'if' were eliminated because all of them were\nmalformed.  More realistic examples would simply quietly do the\nwrong thing at run time.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe syntax for allowing matches in guards is obvious;\nno other syntax would be tolerable.  The only real question\nis whether they can be embedded inside 'andalso' and 'orelse'\nor not, and in order to avoid questions of backtracking, I\nhave said \"no\".  This is really the simplest extension of\nguards to allow matches that I can think of.\u003c/p\u003e\n\n\u003cp\u003eThe rest of the EEP is concerned with trying to rule out\nobviously silly guard tests at compile time.  Precisely how\nthis is done is debateable.  That it should be done surely\nisn't.  What benefit do we currently obtain (other than\nunwarranted simplicity in the compiler) from allowing \"27\"\nand \"X+5\" as guards?\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eMatches are currently not allowed in guards, so no existing\napplication code can be broken by adding them.  Obviously,\nanything that works with Erlang parse trees will need to be\nextended.\u003c/p\u003e\n\n\u003cp\u003eCleaning up what's allowed in guards may affect existing code.\nHowever, in most cases the compiler would already have warned\nabout this, and the compatibility issue amounts to turning a\nwarning message into an error message.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0014"},"buildId":"ob9V3f7Iet6syJeg0QYgd","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_buildManifest.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_ssgManifest.js" async=""></script></body></html>