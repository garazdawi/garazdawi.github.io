{"pageProps":{"index":{"id":"0046","content":"<pre><code>Author: Walter Weinmann &lt;walter.weinmann@gmail.com&gt;\nStatus: Draft\nType: Standards Track\nCreated: 06-Dec-2016\nErlang-Version: OTP 20.0\nPost-History: 6-Dec-2016\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 46: <a href=\"eep-0046.md\" title=\"EEP Source\"> B-trees: balanced search trees of order n</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP proposes the creation of a new module named b_trees for the \nadministration of b-trees.  Both the optional persistence and the sort \norder should be implemented by pluggable functionality.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n\n<h1>Specification</h1>\n\n<h2>Data Structure</h2>\n\n<pre><code>{MinimumSubtrees, \n MaximumKeys, \n SizeKeyValues, \n SortFunction/2, \n State, \n Tree}\n</code></pre>\n\n<p><code>Tree</code> is composed of nodes of the form </p>\n\n<pre><code>{KeyNumber, \n SubtreeNumber, \n [{Key, Value}], \n [Tree]}\n</code></pre>\n\n<p>and the \"empty b-tree\" node </p>\n\n<pre><code>nil\n</code></pre>\n\n<p><code>State</code> is a tuple composed of the following parameters: </p>\n\n<pre><code>{StateTarget, \n DeleteFunction/3, \n InsertFunction/3, \n LookupFunction/3}\n</code></pre>\n\n<p>Since the b-trees are always balanced, there is no need for a balance \noperation.</p>\n\n<h2>DATA TYPES</h2>\n\n<pre><code>b_tree() = {pos_integer(), \n            pos_integer(), \n            non_neg_integer(), \n            sort_function(), \n            state(), \n            tree()}\n</code></pre>\n\n<p>A general balanced tree.</p>\n\n<pre><code>iterator() = [{key_values(), subtrees()}]\n</code></pre>\n\n<p>A general balanced tree iterator.</p>\n\n<h2>EXPORTS</h2>\n\n<h3>copy(Tree1, Tree2) -> Tree3</h3>\n\n<p>Types:</p>\n\n<pre><code>Tree1 = Tree2 = Tree3 = b_tree() | gb_trees:tree()\n</code></pre>\n\n<p>Copies tree Tree1 to an empty tree Tree2. Both trees may be either \nof type b-tree or binary tree (gb_trees). Returns the new tree \nTree3 of the same type as tree Tree2.</p>\n\n<h3>delete(Key, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Removes the node with key Key from b-tree B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, \ncrashes otherwise.</p>\n\n<h3>delete_any (Key, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Removes the node with key Key from b-tree B-Tree1 if key Key is present \nin b-tree B-Tree1, otherwise does nothing.  Returns the new b-tree B-Tree2.</p>\n\n<h3>empty (Order) -> B-Tree</h3>\n\n<p>Types:</p>\n\n<pre><code>Order = pos_integer()\nB-Tree = b_tree()\n</code></pre>\n\n<p>Returns a new empty b-tree.  The order is defined as the maximum number \nof children nodes a non-leaf node may hold.</p>\n\n<h3>enter (Key, Value, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nValue = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Inserts key Key with value Value into b-tree B-Tree1 if key Key is not \npresent in b-tree B-Tree1, otherwise updates the current value of key Key \nto value Value in b-tree B-Tree1.  Returns a new b-tree B-Tree2.</p>\n\n<h3>from_dict (B-Tree1, List) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree1 = B-Tree2 = b_tree()\nList = [{Key, Value}]\n</code></pre>\n\n<p>Turns an ordered list List of key value tuples into a b-tree.  The given \nb-tree B-Tree1 must be empty.  The list must not contain duplicate keys.</p>\n\n<h3>get (Key, B-Tree) -> Value</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree = b_tree()\nValue = any()\n</code></pre>\n\n<p>Retrieves the value stored with key Key in b-tree B-Tree.  Assumes that \nkey Key is present in b-tree B-Tree, crashes otherwise.</p>\n\n<h3>height (B-Tree) -> integer() >= 0</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\n</code></pre>\n\n<p>Returns the height of b-tree B-Tree as an integer.  Assumes that b-tree \nB-Tree is non-empty.</p>\n\n<h3>insert (Key, Value, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nValue = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Inserts key Key with value Value into b-tree  B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is <strong>not</strong> present in b-tree B-Tree1, \ncrashes otherwise.</p>\n\n<h3>is_defined (Key, B-Tree) -> boolean()</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree = b_tree()\n</code></pre>\n\n<p>Returns <code>true</code> if key Key is present in b-tree B-Tree, otherwise <code>false</code>.</p>\n\n<h3>is_empty (B-Tree) -> boolean()</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\n</code></pre>\n\n<p>Returns <code>true</code> if b-tree B-Tree is an empty b-tree, otherwise <code>false</code>.</p>\n\n<h3>iterator (B-Tree) -> Iterator</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\nIterator = iterator()\n</code></pre>\n\n<p>Returns iterator Iterator that can be used for traversing the entries \nof b-tree B-Tree; see <code>next/1</code>.  The implementation of this iterator is \nvery efficient; traversing the whole b-tree using <code>next/1</code> is only slightly\nslower than getting the list of all key-value pairs using <code>to_list/1</code> \nand traversing that.  The main advantage of the iterator approach is that \nit does not require the complete list of all key-value pairs to be built \nin memory at one time.</p>\n\n<h3>iterator_from (Key, B-Tree) -> Iterator</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any(9\nB-Tree = b_tree()\nIterator = iterator()\n</code></pre>\n\n<p>Returns iterator Iterator that can be used for traversing the entries \nof b-tree B-Tree; see <code>next/1</code>.  The difference, as compared to the \niterator returned by iterator/1, is that the first key greater than \nor equal to key Key is returned.</p>\n\n<h3>keys (B-Tree) -> [Key]</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\nKey = any()\n</code></pre>\n\n<p>Returns the keys in b-tree B-Tree as an ordered list.</p>\n\n<h3>largest (B-Tree) -> {Key, Value}</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\nKey = any()\nValue = any()\n</code></pre>\n\n<p>Returns a tuple {Key, Value}, where Key is the largest key in b-tree \nB-Tree, and Value is the value associated with this key.  Assumes that \nb-tree B-Tree is not empty.</p>\n\n<h3>lookup (Key, B-Tree) -> none | {value, Value}</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree = b_tree()\nValue = any()\n</code></pre>\n\n<p>Looks up key Key in b-tree B-Tree. Returns {value, Value}, or none if \nkey Key is not present.</p>\n\n<h3>map (Function, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Function = fun((Key, Value1) -&gt; Value2)\nB-Tree1 = B-Tree2 = b_tree()\nKey = any()\nValue1 = Value2 = any()\n</code></pre>\n\n<p>Maps function Function(Key, Value1) -> Value2 to all key value pairs of \nb-tree B-Tree1.  Returns the new b-tree B-Tree2 with the same set of \nkeys as b-tree B-Tree1 and the new set of values.</p>\n\n<h3>next (Iterator1) -> 'none' | {Key, Value, Iterator2}</h3>\n\n<p>Types:</p>\n\n<pre><code>Iterator1 = Iterator2 = iterator()\nKey = any()\nValue = any()\n</code></pre>\n\n<p>Returns the tuple {Key, Value, Iterator2}, where Key is the smallest \nkey referred to by iterator Iterator1, and iterator Iterator2 is the \nnew iterator to be used for traversing the remaining nodes, or the \natom '<strong>none</strong>' if no nodes remain.</p>\n\n<h3>set_parameter (B-Tree1, Name, Value) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree1 = B-Tree2 = b_tree()\nName : Value = sort  : Function = fun((Key1, Key2) -&gt; equal | \n                                                      greater | \n                                                      less)\n             | state : {StateTarget, \n                        Function = fun(StateTarget, delete, Key) \n                                 -&gt; true,\n                        Function = fun(StateTarget, insert, Subtrees) \n                                 -&gt; Key,\n                        Function = fun(StateTarget, lookup, Key) \n                                 -&gt; Subtrees}\n</code></pre>\n\n<p>Sets the parameter Name to value Value in the empty b-tree B-Tree1 and \nreturns the new b-tree B-Tree2.  This function can only be used in \nconjunction with an empty b-tree.</p>\n\n<h3>size_key_values (B-Tree) -> integer() >= 0</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\n</code></pre>\n\n<p>Returns the number of key value pairs in b-tree B-Tree as an integer. <br />\nReturns 0 (zero) if b-tree B-Tree is empty.</p>\n\n<h3>size_nodes (B-Tree) -> {integer() >= 0, integer() >= 0}</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\n</code></pre>\n\n<p>Returns the number of total nodes and the number of leaf nodes in b-tree \nB-Tree as a tuple of two integers.  Returns {0, 0} (zero) if b-tree B-Tree \nis empty.</p>\n\n<h3>smallest (B-Tree) -> {Key, Value}</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\nKey = any()\nValue = any()\n</code></pre>\n\n<p>Returns tuple {Key, Value}, where Key is the smallest key in b-tree \nB-Tree, and Value is the value associated with this key.  Assumes that \nb-tree B-Tree is not empty.</p>\n\n<h3>sort_ascending (Key1, Key2) -> 'equal' | 'greater' | 'less'</h3>\n\n<p>Types:</p>\n\n<pre><code>Key1 = Key2  = any()\nequal = greater = less = atom()\n</code></pre>\n\n<p>Returns the atom '<strong>greater</strong>' if Key1 > Key2, the atom '<strong>less</strong>' \nif Key1 &lt; Key2 and otherwise the atom '<strong>equal</strong>'.</p>\n\n<h3>sort_descending (Key1, Key2) -> 'equal' | 'greater' | 'less'</h3>\n\n<p>Types:</p>\n\n<pre><code>Key1 = Key2  = any()\nequal = greater = less = atom()\n</code></pre>\n\n<p>Returns the atom '<strong>less</strong>' if Key1 > Key2, the atom '<strong>greater</strong>' \nif Key1 &lt; Key2 and otherwise the atom '<strong>equal</strong>'.</p>\n\n<h3>take(Key, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Removes the node with key Key from b-tree B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, \ncrashes otherwise.</p>\n\n<h3>delete_any (Key, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Removes the node with key Key from b-tree B-Tree1 if key Key is present \nin b-tree B-Tree1, otherwise does nothing. Returns the new b-tree B-Tree2.</p>\n\n<h3>take_largest (B-Tree1) -> {Key, Value, B-Tree2}</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree1 = B-Tree2 = b_tree()\nKey = any()\nValue = any()\n</code></pre>\n\n<p>Returns tuple {Key, Value, B-Tree2}, where Key is the largest key in \nb-tree B-Tree1, Value is the value associated with this key, and b-tree \nB-Tree2 is this b-tree with the corresponding key value pair deleted. <br />\nAssumes that b-tree B-Tree1 is not empty.</p>\n\n<h3>take_smallest (B-Tree1) -> {Key, Value, B-Tree2}</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree1 = B-Tree2 = b_tree()\nKey = any()\nValue = any()\n</code></pre>\n\n<p>Returns tuple {Key, Value, B-Tree2}, where Key is the smallest key in \nb-tree B-Tree1, Value is the value associated with this key, and b-tree \nB-Tree2 is this b-tree with the corresponding key value pair deleted. <br />\nAssumes that b-tree B-Tree1 is not empty.</p>\n\n<h3>to_list (B-Tree) -> [{Key, Value}]</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\nKey = any()\nValue = any()\n</code></pre>\n\n<p>Converts b-tree B-Tree into an ordered list of key value tuples.</p>\n\n<h3>update (Key, Value, B-Tree1) -> B-Tree2</h3>\n\n<p>Types:</p>\n\n<pre><code>Key = any()\nValue = any()\nB-Tree1 = B-Tree2 = b_tree()\n</code></pre>\n\n<p>Updates key Key to value Value in b-tree B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1.</p>\n\n<h3>values (B-Tree) -> [Value]</h3>\n\n<p>Types:</p>\n\n<pre><code>B-Tree = b_tree()\nValue = any()\n</code></pre>\n\n<p>Returns the values in b-tree B-Tree as an ordered list, sorted by their \ncorresponding keys.  Duplicates are not removed.</p>\n\n<h2>Pluggable Persistence Functionality</h2>\n\n<h3>Format:</h3>\n\n<pre><code>{StateTarget, DeleteFunction, InsertFunction, LookupFunction}\n\nStateTarget = any()\n\nDeleteFunction(StateTarget, delete, Key) -&gt; true\n\nInsertFunction(StateTarget, insert, Subtrees) -&gt; Key\n\nLookupFunction(StateTarget, lookup, Key) -&gt; Subtrees\n</code></pre>\n\n<p>Examples for state targets are a Dets table or a Mnesia table.  The delete \nfunction takes a state target, the atom <code>delete</code> and a key as arguments \nand returns the atom <code>true</code> if successful.  The insert function takes a \nstate target, the atom <code>insert</code> and a subtrees data structure as arguments \nand returns a key if successful.  The lookup function takes a state target, \nthe atom <code>lookup</code> and a key as arguments and returns a subtrees data \nstructure if successful.</p>\n\n<h3>Example functions:</h3>\n\n<p>The following examples are based on Mnesia.</p>\n\n<pre><code>persistence_by_mnesia(_, delete, SubtreesKey) \n                     when is_list(SubtreesKey) -&gt;\n    true;\npersistence_by_mnesia(StateTarget, delete, SubtreesKey) -&gt;\n    F = fun() -&gt;\n        ok = mnesia:delete({StateTarget, SubtreesKey}),\n        true\n    end,\n    mnesia:activity(transaction, F);\n\npersistence_by_mnesia(_, insert, []) -&gt;\n    [];\npersistence_by_mnesia(StateTarget, insert, \n                      [{_, _, [{Key, _} | _], _} | _] = Subtrees) -&gt;\n    SubtreesKey = list_to_binary(Key),\n    F = fun() -&gt;\n        ok = mnesia:write(StateTarget, \n                          #subtrees{subtreesKey = SubtreesKey, \n                          subtrees = Subtrees}, write),\n        SubtreesKey\n    end,\n    mnesia:activity(transaction, F);\n\npersistence_by_mnesia(_, lookup, SubtreesKey) \n                     when is_list(SubtreesKey) -&gt;\n    SubtreesKey;\npersistence_by_mnesia(StateTarget, lookup, SubtreesKey) -&gt;\n    F = fun() -&gt;\n        [{subtrees, SubtreesKey, Subtrees}] = mnesia:read(StateTarget, \n                                                          SubtreesKey),\n        Subtrees\n    end,\nmnesia:activity(transaction, F).\n</code></pre>\n\n<h3>Example usage:</h3>\n\n<p>Creating the Mnesia table:</p>\n\n<pre><code>-record(subtrees, {subtreesKey, subtrees}).\n\n{atomic, ok} = mnesia:create_table(StateTargetName, [{record_name, \n                                                      subtrees}]),\n</code></pre>\n\n<p>Creating the b-tree:</p>\n\n<pre><code>BTree1 = b_trees:empty(500),\nBTree2 = b_trees:set_parameter(BTree1, state, \n                               {StateTargetName, \n                                fun persistence_by_mnesia/3, \n                                fun persistence_by_mnesia/3, \n                                fun persistence_by_mnesia/3}),\n</code></pre>\n\n<h2>Pluggable Sort Functionality</h2>\n\n<h3>Format:</h3>\n\n<pre><code>FunctionName(Key1, Key2) -&gt; equal | greater | less\n\nKey1 = Key2 = any()\n</code></pre>\n\n<p>The sort function takes two keys as arguments and returns the atom <code>less</code> \nif Key1 &lt; Key2, the atom <code>greater</code> if Key1 > Key2 and otherwise the \natom <code>equal</code>.</p>\n\n<h3>Example function:</h3>\n\n<pre><code>-spec sort_descending(key(), key()) -&gt; sort_result().\n\nsort_descending(Key_1, Key_2) -&gt;\nif\n    Key_1 &lt; Key_2 -&gt; greater;\n    Key_1 &gt; Key_2 -&gt; less;\n    true -&gt; equal\nend.\n</code></pre>\n\n<h3>Example usage:</h3>\n\n<pre><code>BTree1 = b_trees:empty(500),\nBTree2 = b_trees:set_parameter(BTree1, sort, fun sort_descending/2),\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>B-trees are self-balancing tree data structures that keep data sorted \nand allow searches, sequential access, insertions, and deletions in \nlogarithmic time.  B-trees are a generalization of a binary search \ntrees in that a node can have more than two children.  Unlike self-balancing \nbinary search trees, the b-tree is optimized for systems that read and \nwrite large blocks of data.  B-trees are a good example of a data structure \nfor external memory.</p>\n\n<h1>Rationale</h1>\n\n<p>The functional design of the module b_trees is based on the module gb_trees:  </p>\n\n<pre><code> b_trees          | gb_trees\n------------------|---------\n n/a              | balance/1\n copy/2           | n/a\n delete/2         | delete/2\n delete_any/2     | delete_any/2\n empty/1          | empty/0\n enter/3          | enter/3\n from_dict/2      | from_orddict/1\n get/2            | get/2\n height/1         | n/a\n insert/3         | insert/3\n is_defined/2     | is_defined/2\n is_empty/1       | is_empty/1\n iterator/1       | iterator/1\n iterator_from/2  | iterator_from/2\n keys/1           | keys/1\n largest/1        | largest/1\n lookup/2         | lookup/2\n map/2            | map/2\n next/1           | next/1\n set_parameter/3  | n/a\n size_key_values/1| size/1\n size_nodes/1     | n/a\n smallest/1       | smallest/1\n sort_ascending/2 | n/a\n sort_descending/2| n/a\n take/2           | take/2\n take_any/2       | take_any/2\n take_largest/1   | take_largest/1\n take_smallest/1  | take_smallest/1\n to_list/1        | to_list/1\n update/3         | update/3\n values/1         | values/1\n</code></pre>\n\n<p>The functions <code>delete/2</code> and <code>insert/3</code> are implementations of the algorithms \nof Cormen, Thomas; Leiserson, Charles; Rivest, Ronald; Stein, Clifford (2009), \nIntroduction to Algorithms (Third ed.), MIT Press and McGraw-Hill, pp. 484-504, \nISBN 0-262-03384-4. Chapter 18: B-Trees.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>No issues - except module name collisions.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>The reference implementation can be fetched from Github:</p>\n\n<pre><code>https://github.com/walter-weinmann/b_trees\n</code></pre>\n"}},"__N_SSG":true}