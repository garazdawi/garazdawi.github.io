<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Tobias Lindahl &lt;tobias(dot)lindahl(at)it(dot)uu(dot)se&gt;,
        Kostis Sagonas &lt;kostis(at)it(dot)uu(dot)se&gt;
Status: Draft
Type: Standards Track
Created: 2-Dec-2007
Erlang-Version: R12B
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 8: <a href="eep-0008.md" title="EEP Source"> Types and function specifications</a></h2>

<h1>Abstract</h1>

<p>This EEP describes an extension to the Erlang language for
declaring sets of Erlang terms to form a particular type, effectively
forming a specific subtype of the set of all Erlang terms.
Subsequently, these types can be used to specify types of record
fields and argument and return values of functions.</p>

<h1>Rationale</h1>

<p>Type information can be used to document function interfaces, provide
more information for bug detection tools such as Dialyzer, and can be
exploited by documentation tools such as Edoc for generating program
documentation of various forms. It is expected that the type language
described in this document will supersede and eventually replace the
purely comment-based @type and @spec declarations used by Edoc.</p>

<h1>Specification</h1>

<h2>Types and their syntax</h2>

<p>Types describe sets of Erlang terms. Types consist and are built from
a set of predefined types (e.g. <code>integer()</code>, <code>atom()</code>, <code>pid()</code>, ...)
described below. Predefined types represent a typically infinite set
of Erlang terms which belong to this type. For example, the type
<code>atom()</code> stands for the set of all Erlang atoms.</p>

<p>For integers and atoms, we allow for singleton types (e.g. the
integers <code>-1</code> and <code>42</code> or the atoms <code>'foo'</code> and <code>'bar'</code>).</p>

<p>All other types are built using unions of either predefined types or
singleton types. In a type union between a type and one of its
subtypes the subtype is absorbed by the supertype and the union is
subsequently treated as if the subtype was not a constituent of the
union. For example, the type union::</p>

<pre><code>atom() | 'bar' | integer() | 42
</code></pre>

<p>describes the same set of terms as the type union::</p>

<p>atom() | integer()</p>

<p>Because of subtype relations that exist between types, types form a
lattice where the topmost element, <code>any()</code>, denotes the set of all Erlang
terms and the bottommost element, <code>none()</code>, denotes the empty set of terms.</p>

<p>The set of predefined types and the syntax for types is given below::</p>

<pre><code>Type :: any()            %% The top type, the set of all Erlang terms.
      | none()           %% The bottom type, contains no terms.
      | pid()
      | port()
      | ref()
      | []               %% nil
      | Atom
      | Binary
      | float()
      | Fun
      | Integer
      | List
      | Tuple
      | Union
      | UserDefined      %% described in Section 2

Union :: Type1 | Type2

Atom :: atom()
      | Erlang_Atom      %% 'foo', 'bar', ...

Binary :: binary()                        %% &lt;&lt;_:_ * 8&gt;&gt;
        | &lt;&lt;&gt;&gt;
        | &lt;&lt;_:Erlang_Integer&gt;&gt;            %% Base size
        | &lt;&lt;_:_*Erlang_Integer&gt;&gt;          %% Unit size
        | &lt;&lt;_:Erlang_Integer, _:_*Erlang_Integer&gt;&gt;

Fun :: fun()                              %% any function
     | fun((...) -&gt; Type)                 %% any arity, returning Type
     | fun(() -&gt; Type)
     | fun((TList) -&gt; Type)

Integer :: integer()
         | Erlang_Integer                 %% ..., -1, 0, 1, ... 42 ...
         | Erlang_Integer..Erlang_Integer %% specifies an integer range

List :: list(Type)                        %% Proper list ([]-terminated)
      | improper_list(Type1, Type2)       %% Type1=contents, Type2=termination
      | maybe_improper_list(Type1, Type2) %% Type1 and Type2 as above

Tuple :: tuple()                          %% stands for a tuple of any size
       | {}
       | {TList}

TList :: Type
       | Type, TList
</code></pre>

<p>Because lists are commonly used, they have shorthand type notations.
The type <code>list(T)</code> has the shorthand <code>[T]</code>. The shorthand <code>[T,...]</code>
stands for the set of non-empty proper lists whose elements are of type <code>T</code>.
The only difference between the two shorthands is that <code>[T]</code> may be an
empty list but <code>[T,...]</code> may not.</p>

<p>Notice that the shorthand for <code>list()</code>, i.e. the list of elements of
unknown type, is <code>[_]</code> (or <code>[any()]</code>), not <code>[]</code>. The notation <code>[]</code>
specifies the singleton type for the empty list.</p>

<p>For convenience, the following types are also built-in. They can be
thought as predefined aliases for the type unions also shown in the
table. (Some type unions below slightly abuse the syntax of types.)</p>

<pre><code>==========================  =====================================
      Built-in type                   Stands for
==========================  =====================================
``term()``                  ``any()``
``bool()``                  ``'false' | 'true'``
``byte()``                  ``0..255``
``char()``                  ``0..16#10ffff``
``non_neg_integer()``       ``0..``
``pos_integer()``           ``1..``
``neg_integer()``           ``..-1``
``number()``                ``integer() | float()``
``list()``                  ``[any()]``
``maybe_improper_list()``   ``maybe_improper_list(any(), any())``
``maybe_improper_list(T)``  ``maybe_improper_list(T, any())``
``string()``                ``[char()]``
``nonempty_string()``       ``[char(),...]``
``iolist()``                ``maybe_improper_list(``
                                ``char() | binary() |``
                                ``iolist(), binary() | [])``
``module()``                ``atom()``
``mfa()``                   ``{atom(),atom(),byte()}``
``node()``                  ``atom()``
``timeout()``               ``'infinity' | non_neg_integer()``
``no_return()``             ``none()``
==========================  =====================================
</code></pre>

<p>Users are not allowed to define types with the same names as the
predefined or built-in ones. This is checked by the compiler and its
violation results in a compilation error. (For bootstrapping purposes,
it can also result to just a warning if this involves a built-in type
which has just been introduced.)</p>

<p><strong>NOTE</strong>: The following built-in list types also exist, but they are
expected to be rarely used. Hence, they have long names:</p>

<pre><code>nonempty_maybe_improper_list(Type) :: nonempty_maybe_improper_list(Type, any())
nonempty_maybe_improper_list() :: nonempty_maybe_improper_list(any())
</code></pre>

<p>where the following two types</p>

<pre><code>nonempty_improper_list(Type1, Type2)
nonempty_maybe_improper_list(Type1, Type2)
</code></pre>

<p>define the set of Erlang terms one would expect.</p>

<p>Also for convenience, we allow for record notation to be used. Records
are just shorthands for the corresponding tuples:</p>

<pre><code>Record :: #Erlang_Atom{}
        | #Erlang_Atom{Fields}
</code></pre>

<p>Records have been extended to possibly contain type information. This
is described in Section 3 below.</p>

<h2>Type declarations of user-defined types</h2>

<p>As seen, the basic syntax of a type is an atom followed by closed
parentheses. New types are declared using <code>'type'</code> compiler attributes
as in the following:</p>

<pre><code>-type my_type() :: Type.
</code></pre>

<p>where the type name is an atom (<code>'my_type'</code> in the above) followed by
parenthesis. Type is a type as defined in the previous section. A
current restriction is that Type can contain only predefined types or
user-defined types which have been previously defined. This
restriction is enforced by the compiler and results in a compilation
error. (A similar restriction currently exists for records).</p>

<p>This means that general recursive types cannot be defined. Lifting
this restriction is future work.</p>

<p>Type declarations can also be parametrized by including type variables
between the parentheses. The syntax of type variables is the same as
Erlang variables (starts with an upper case letter). Naturally, these
variables can - and should - appear on the RHS of the definition.
A concrete example appears below:</p>

<pre><code>-type orddict(Key, Val) :: [{Key, Val}].
</code></pre>

<h2>Type information in record declarations</h2>

<p>The types of record fields can be specified in the declaration of the
record. The syntax for this is:</p>

<pre><code>-record(rec, {field1 :: Type1, field2, field3 :: Type3}).
</code></pre>

<p>For fields without type annotations, their type defaults to <code>any()</code>.
I.e., the above is a shorthand for:</p>

<pre><code>-record(rec, {field1 :: Type1, field2 :: any(), field3 :: Type3}).
</code></pre>

<p>In the presence of initial values for fields, the type must be
declared after the initialisation as in the following:</p>

<pre><code>-record(rec, {field1 = [] :: Type1, field2, field3 = 42 :: Type3}).
</code></pre>

<p>Naturally, the initial values for fields should be compatible with
(i.e. a member of) the corresponding types. This is checked by the
compiler and results in a compilation error if a violation is
detected. For fields without initial values, the singleton type
<code>'undefined'</code> is added to all declared types. In other words, the
following two record declarations have identical effects:</p>

<pre><code>-record(rec, {f1 = 42 :: integer(),
              f2      :: float(),
              f3      :: 'a' | 'b').

-record(rec, {f1 = 42 :: integer(),
              f2      :: 'undefined' | float(),
              f3      :: 'undefined' | 'a' | 'b').
</code></pre>

<p>For this reason, it is recommended that records contain initializers,
whenever possible.</p>

<p>Any record, containing type information or not, once defined, can be
used as a type using the syntax:</p>

<pre><code>#rec{}
</code></pre>

<p>In addition, the record fields can be further specified when using a
record type by adding type information about the field in the
following manner:</p>

<pre><code>#rec{some_field :: Type}
</code></pre>

<p>Any unspecified fields are assumed to have the type in the original
record declaration.</p>

<h2>Specifications (contracts) for functions</h2>

<p>A contract (or specification) for a function is given using the new
compiler attribute <code>'spec'</code>. The basic format is as follows:</p>

<pre><code>-spec Module:Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.
</code></pre>

<p>The arity of the function has to match the number of arguments, or
else a compilation error occurs.</p>

<p>This form can also be used in header files (.hrl) to declare type
information for exported functions. Then these header files can be
included in files that (implicitly or explicitly) import these
functions.</p>

<p>For most uses within a given module, the following shorthand is allowed:</p>

<pre><code>-spec Function(ArgType1, ..., ArgTypeN) -&gt; ReturnType.
</code></pre>

<p>Also, for documentation purposes, argument names can be given:</p>

<pre><code>-spec Function(ArgName1 :: Type1, ..., ArgNameN :: TypeN) -&gt; RT.
</code></pre>

<p>A function specification can be overloaded. That is, it can have
several types, separated by a semicolon (;):</p>

<pre><code>-spec foo(T1, T2) -&gt; T3
       ; (T4, T5) -&gt; T6.
</code></pre>

<p>A current restriction, which currently results in a warning (<em>OBS</em>: not
an error) by the compiler, is that the domains of the argument types
cannot be overlapping. For example, the following specification
results in a warning:</p>

<pre><code>-spec foo(pos_integer()) -&gt; pos_integer()
       ; (integer()) -&gt; integer().
</code></pre>

<p>Type variables can be used in specifications to specify relations for
the input and output arguments of a function. For example, the
following specification defines the type of a polymorphic identity
function:</p>

<pre><code>-spec id(X) -&gt; X.
</code></pre>

<p>However, note that the above specification does not restrict the input
and output type in any way. We can constrain these types by guard-like
subtype constraints:</p>

<pre><code>-spec id(X) -&gt; X when is_subtype(X, tuple()).
</code></pre>

<p>and provide bounded quantification. Currently, the <code>is_subtype/2</code> guard
is the only guard which can be used in a <code>'spec'</code> attribute.</p>

<p>The scope of an <code>is_subtype/2</code> constraint is the <code>(...) -&gt; RetType</code>
specification after which it appears. To avoid confusion, we suggest
that different variables are used in different constituents of an
overloaded contract as in the example below:</p>

<pre><code>-spec foo({X, integer()}) -&gt; X when is_subtype(X, atom())
       ; ([Y]) -&gt; Y when is_subtype(Y, number()).
</code></pre>

<p>Some functions in Erlang are not meant to return; either because they
define servers or because they are used to throw exceptions as the
function below::</p>

<pre><code>my_error(Err) -&gt; erlang:throw({error, Err}).
</code></pre>

<p>For such functions we recommend the use of the special <code>no_return()</code>
type for their "return", via a contract of the form::</p>

<pre><code>-spec my_error(term()) -&gt; no_return().
</code></pre>

<h2>Current limitations</h2>

<p>The main limitation is the inability to define recursive types.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0008","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Tobias Lindahl \u0026lt;tobias(dot)lindahl(at)it(dot)uu(dot)se\u0026gt;,\n        Kostis Sagonas \u0026lt;kostis(at)it(dot)uu(dot)se\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 2-Dec-2007\nErlang-Version: R12B\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 8: \u003ca href=\"eep-0008.md\" title=\"EEP Source\"\u003e Types and function specifications\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP describes an extension to the Erlang language for\ndeclaring sets of Erlang terms to form a particular type, effectively\nforming a specific subtype of the set of all Erlang terms.\nSubsequently, these types can be used to specify types of record\nfields and argument and return values of functions.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eType information can be used to document function interfaces, provide\nmore information for bug detection tools such as Dialyzer, and can be\nexploited by documentation tools such as Edoc for generating program\ndocumentation of various forms. It is expected that the type language\ndescribed in this document will supersede and eventually replace the\npurely comment-based @type and @spec declarations used by Edoc.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003ch2\u003eTypes and their syntax\u003c/h2\u003e\n\n\u003cp\u003eTypes describe sets of Erlang terms. Types consist and are built from\na set of predefined types (e.g. \u003ccode\u003einteger()\u003c/code\u003e, \u003ccode\u003eatom()\u003c/code\u003e, \u003ccode\u003epid()\u003c/code\u003e, ...)\ndescribed below. Predefined types represent a typically infinite set\nof Erlang terms which belong to this type. For example, the type\n\u003ccode\u003eatom()\u003c/code\u003e stands for the set of all Erlang atoms.\u003c/p\u003e\n\n\u003cp\u003eFor integers and atoms, we allow for singleton types (e.g. the\nintegers \u003ccode\u003e-1\u003c/code\u003e and \u003ccode\u003e42\u003c/code\u003e or the atoms \u003ccode\u003e'foo'\u003c/code\u003e and \u003ccode\u003e'bar'\u003c/code\u003e).\u003c/p\u003e\n\n\u003cp\u003eAll other types are built using unions of either predefined types or\nsingleton types. In a type union between a type and one of its\nsubtypes the subtype is absorbed by the supertype and the union is\nsubsequently treated as if the subtype was not a constituent of the\nunion. For example, the type union::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eatom() | 'bar' | integer() | 42\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003edescribes the same set of terms as the type union::\u003c/p\u003e\n\n\u003cp\u003eatom() | integer()\u003c/p\u003e\n\n\u003cp\u003eBecause of subtype relations that exist between types, types form a\nlattice where the topmost element, \u003ccode\u003eany()\u003c/code\u003e, denotes the set of all Erlang\nterms and the bottommost element, \u003ccode\u003enone()\u003c/code\u003e, denotes the empty set of terms.\u003c/p\u003e\n\n\u003cp\u003eThe set of predefined types and the syntax for types is given below::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eType :: any()            %% The top type, the set of all Erlang terms.\n      | none()           %% The bottom type, contains no terms.\n      | pid()\n      | port()\n      | ref()\n      | []               %% nil\n      | Atom\n      | Binary\n      | float()\n      | Fun\n      | Integer\n      | List\n      | Tuple\n      | Union\n      | UserDefined      %% described in Section 2\n\nUnion :: Type1 | Type2\n\nAtom :: atom()\n      | Erlang_Atom      %% 'foo', 'bar', ...\n\nBinary :: binary()                        %% \u0026lt;\u0026lt;_:_ * 8\u0026gt;\u0026gt;\n        | \u0026lt;\u0026lt;\u0026gt;\u0026gt;\n        | \u0026lt;\u0026lt;_:Erlang_Integer\u0026gt;\u0026gt;            %% Base size\n        | \u0026lt;\u0026lt;_:_*Erlang_Integer\u0026gt;\u0026gt;          %% Unit size\n        | \u0026lt;\u0026lt;_:Erlang_Integer, _:_*Erlang_Integer\u0026gt;\u0026gt;\n\nFun :: fun()                              %% any function\n     | fun((...) -\u0026gt; Type)                 %% any arity, returning Type\n     | fun(() -\u0026gt; Type)\n     | fun((TList) -\u0026gt; Type)\n\nInteger :: integer()\n         | Erlang_Integer                 %% ..., -1, 0, 1, ... 42 ...\n         | Erlang_Integer..Erlang_Integer %% specifies an integer range\n\nList :: list(Type)                        %% Proper list ([]-terminated)\n      | improper_list(Type1, Type2)       %% Type1=contents, Type2=termination\n      | maybe_improper_list(Type1, Type2) %% Type1 and Type2 as above\n\nTuple :: tuple()                          %% stands for a tuple of any size\n       | {}\n       | {TList}\n\nTList :: Type\n       | Type, TList\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBecause lists are commonly used, they have shorthand type notations.\nThe type \u003ccode\u003elist(T)\u003c/code\u003e has the shorthand \u003ccode\u003e[T]\u003c/code\u003e. The shorthand \u003ccode\u003e[T,...]\u003c/code\u003e\nstands for the set of non-empty proper lists whose elements are of type \u003ccode\u003eT\u003c/code\u003e.\nThe only difference between the two shorthands is that \u003ccode\u003e[T]\u003c/code\u003e may be an\nempty list but \u003ccode\u003e[T,...]\u003c/code\u003e may not.\u003c/p\u003e\n\n\u003cp\u003eNotice that the shorthand for \u003ccode\u003elist()\u003c/code\u003e, i.e. the list of elements of\nunknown type, is \u003ccode\u003e[_]\u003c/code\u003e (or \u003ccode\u003e[any()]\u003c/code\u003e), not \u003ccode\u003e[]\u003c/code\u003e. The notation \u003ccode\u003e[]\u003c/code\u003e\nspecifies the singleton type for the empty list.\u003c/p\u003e\n\n\u003cp\u003eFor convenience, the following types are also built-in. They can be\nthought as predefined aliases for the type unions also shown in the\ntable. (Some type unions below slightly abuse the syntax of types.)\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e==========================  =====================================\n      Built-in type                   Stands for\n==========================  =====================================\n``term()``                  ``any()``\n``bool()``                  ``'false' | 'true'``\n``byte()``                  ``0..255``\n``char()``                  ``0..16#10ffff``\n``non_neg_integer()``       ``0..``\n``pos_integer()``           ``1..``\n``neg_integer()``           ``..-1``\n``number()``                ``integer() | float()``\n``list()``                  ``[any()]``\n``maybe_improper_list()``   ``maybe_improper_list(any(), any())``\n``maybe_improper_list(T)``  ``maybe_improper_list(T, any())``\n``string()``                ``[char()]``\n``nonempty_string()``       ``[char(),...]``\n``iolist()``                ``maybe_improper_list(``\n                                ``char() | binary() |``\n                                ``iolist(), binary() | [])``\n``module()``                ``atom()``\n``mfa()``                   ``{atom(),atom(),byte()}``\n``node()``                  ``atom()``\n``timeout()``               ``'infinity' | non_neg_integer()``\n``no_return()``             ``none()``\n==========================  =====================================\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUsers are not allowed to define types with the same names as the\npredefined or built-in ones. This is checked by the compiler and its\nviolation results in a compilation error. (For bootstrapping purposes,\nit can also result to just a warning if this involves a built-in type\nwhich has just been introduced.)\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: The following built-in list types also exist, but they are\nexpected to be rarely used. Hence, they have long names:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enonempty_maybe_improper_list(Type) :: nonempty_maybe_improper_list(Type, any())\nnonempty_maybe_improper_list() :: nonempty_maybe_improper_list(any())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere the following two types\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enonempty_improper_list(Type1, Type2)\nnonempty_maybe_improper_list(Type1, Type2)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003edefine the set of Erlang terms one would expect.\u003c/p\u003e\n\n\u003cp\u003eAlso for convenience, we allow for record notation to be used. Records\nare just shorthands for the corresponding tuples:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eRecord :: #Erlang_Atom{}\n        | #Erlang_Atom{Fields}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRecords have been extended to possibly contain type information. This\nis described in Section 3 below.\u003c/p\u003e\n\n\u003ch2\u003eType declarations of user-defined types\u003c/h2\u003e\n\n\u003cp\u003eAs seen, the basic syntax of a type is an atom followed by closed\nparentheses. New types are declared using \u003ccode\u003e'type'\u003c/code\u003e compiler attributes\nas in the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-type my_type() :: Type.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere the type name is an atom (\u003ccode\u003e'my_type'\u003c/code\u003e in the above) followed by\nparenthesis. Type is a type as defined in the previous section. A\ncurrent restriction is that Type can contain only predefined types or\nuser-defined types which have been previously defined. This\nrestriction is enforced by the compiler and results in a compilation\nerror. (A similar restriction currently exists for records).\u003c/p\u003e\n\n\u003cp\u003eThis means that general recursive types cannot be defined. Lifting\nthis restriction is future work.\u003c/p\u003e\n\n\u003cp\u003eType declarations can also be parametrized by including type variables\nbetween the parentheses. The syntax of type variables is the same as\nErlang variables (starts with an upper case letter). Naturally, these\nvariables can - and should - appear on the RHS of the definition.\nA concrete example appears below:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-type orddict(Key, Val) :: [{Key, Val}].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eType information in record declarations\u003c/h2\u003e\n\n\u003cp\u003eThe types of record fields can be specified in the declaration of the\nrecord. The syntax for this is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-record(rec, {field1 :: Type1, field2, field3 :: Type3}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor fields without type annotations, their type defaults to \u003ccode\u003eany()\u003c/code\u003e.\nI.e., the above is a shorthand for:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-record(rec, {field1 :: Type1, field2 :: any(), field3 :: Type3}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn the presence of initial values for fields, the type must be\ndeclared after the initialisation as in the following:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-record(rec, {field1 = [] :: Type1, field2, field3 = 42 :: Type3}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNaturally, the initial values for fields should be compatible with\n(i.e. a member of) the corresponding types. This is checked by the\ncompiler and results in a compilation error if a violation is\ndetected. For fields without initial values, the singleton type\n\u003ccode\u003e'undefined'\u003c/code\u003e is added to all declared types. In other words, the\nfollowing two record declarations have identical effects:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-record(rec, {f1 = 42 :: integer(),\n              f2      :: float(),\n              f3      :: 'a' | 'b').\n\n-record(rec, {f1 = 42 :: integer(),\n              f2      :: 'undefined' | float(),\n              f3      :: 'undefined' | 'a' | 'b').\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor this reason, it is recommended that records contain initializers,\nwhenever possible.\u003c/p\u003e\n\n\u003cp\u003eAny record, containing type information or not, once defined, can be\nused as a type using the syntax:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#rec{}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn addition, the record fields can be further specified when using a\nrecord type by adding type information about the field in the\nfollowing manner:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#rec{some_field :: Type}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAny unspecified fields are assumed to have the type in the original\nrecord declaration.\u003c/p\u003e\n\n\u003ch2\u003eSpecifications (contracts) for functions\u003c/h2\u003e\n\n\u003cp\u003eA contract (or specification) for a function is given using the new\ncompiler attribute \u003ccode\u003e'spec'\u003c/code\u003e. The basic format is as follows:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec Module:Function(ArgType1, ..., ArgTypeN) -\u0026gt; ReturnType.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe arity of the function has to match the number of arguments, or\nelse a compilation error occurs.\u003c/p\u003e\n\n\u003cp\u003eThis form can also be used in header files (.hrl) to declare type\ninformation for exported functions. Then these header files can be\nincluded in files that (implicitly or explicitly) import these\nfunctions.\u003c/p\u003e\n\n\u003cp\u003eFor most uses within a given module, the following shorthand is allowed:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec Function(ArgType1, ..., ArgTypeN) -\u0026gt; ReturnType.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAlso, for documentation purposes, argument names can be given:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec Function(ArgName1 :: Type1, ..., ArgNameN :: TypeN) -\u0026gt; RT.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA function specification can be overloaded. That is, it can have\nseveral types, separated by a semicolon (;):\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec foo(T1, T2) -\u0026gt; T3\n       ; (T4, T5) -\u0026gt; T6.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA current restriction, which currently results in a warning (\u003cem\u003eOBS\u003c/em\u003e: not\nan error) by the compiler, is that the domains of the argument types\ncannot be overlapping. For example, the following specification\nresults in a warning:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec foo(pos_integer()) -\u0026gt; pos_integer()\n       ; (integer()) -\u0026gt; integer().\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eType variables can be used in specifications to specify relations for\nthe input and output arguments of a function. For example, the\nfollowing specification defines the type of a polymorphic identity\nfunction:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec id(X) -\u0026gt; X.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHowever, note that the above specification does not restrict the input\nand output type in any way. We can constrain these types by guard-like\nsubtype constraints:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec id(X) -\u0026gt; X when is_subtype(X, tuple()).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand provide bounded quantification. Currently, the \u003ccode\u003eis_subtype/2\u003c/code\u003e guard\nis the only guard which can be used in a \u003ccode\u003e'spec'\u003c/code\u003e attribute.\u003c/p\u003e\n\n\u003cp\u003eThe scope of an \u003ccode\u003eis_subtype/2\u003c/code\u003e constraint is the \u003ccode\u003e(...) -\u0026gt; RetType\u003c/code\u003e\nspecification after which it appears. To avoid confusion, we suggest\nthat different variables are used in different constituents of an\noverloaded contract as in the example below:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec foo({X, integer()}) -\u0026gt; X when is_subtype(X, atom())\n       ; ([Y]) -\u0026gt; Y when is_subtype(Y, number()).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSome functions in Erlang are not meant to return; either because they\ndefine servers or because they are used to throw exceptions as the\nfunction below::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003emy_error(Err) -\u0026gt; erlang:throw({error, Err}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor such functions we recommend the use of the special \u003ccode\u003eno_return()\u003c/code\u003e\ntype for their \"return\", via a contract of the form::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec my_error(term()) -\u0026gt; no_return().\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eCurrent limitations\u003c/h2\u003e\n\n\u003cp\u003eThe main limitation is the inability to define recursive types.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0008"},"buildId":"NPm6cMGILpqRmaNHZXj9d","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/NPm6cMGILpqRmaNHZXj9d/_buildManifest.js" async=""></script><script src="/_next/static/NPm6cMGILpqRmaNHZXj9d/_ssgManifest.js" async=""></script></body></html>