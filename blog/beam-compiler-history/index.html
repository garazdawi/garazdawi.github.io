<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/beam-compiler-history/">A Brief History of the BEAM Compiler</a></h3><p><em>Monday, 18 June 2018<!-- --> - <!-- -->Bj√∂rn Gustavsson</em></p><p>This blog post is a brief history lesson about the Erlang compiler for
the BEAM machine. To provide some context, there will first be a quick
look at the abstract machines for Erlang.</p><h2>A brief overview of the early Erlang implementations</h2><h3>The Prolog interpreter</h3><p>The first version of Erlang was implemented in
Prolog in 1986. That version of Erlang was used
to find out which features of the languages were
useful and which were not. New languages features
could be added or deleted in a matter of hours
or days.</p><h3>JAM (Joe&#x27;s Abstract Machine)</h3><p>It soon became clear that Erlang needed to be at
least 40 times faster to be useful in real projects.</p><p>In 1989 JAM (Joe&#x27;s Abstract Machine) was first
implemented. <a href="http://www.erlang-factory.com/conference/ErlangUserConference2013/speakers/MikeWilliams">Mike Williams</a> wrote the runtime system
in C, <a href="https://github.com/joearms">Joe Armstrong</a> wrote the compiler, and
<a href="https://github.com/rvirding">Robert Virding</a> wrote the libraries.</p><p>JAM turned out be 70 times faster than the Prolog
interpreter. Success?</p><h3>TEAM (Turbo Erlang Abstract Machine)</h3><p>It soon became clear that Erlang still needed
to be faster to be useful in real projects.</p><p>Therefore Bogumil (&quot;Bogdan&quot;) Hausman created TEAM (Turbo Erlang
Abstract Machine). It compiled the Erlang code to C code, which was
then compiled to native code using GCC.</p><p>It was significantly faster than JAM for small projects.
Unfortunately, compilation was very slow, and the code size of the
compiled code was too big to make it useful for large projects.</p><h3>BEAM (Bogdan&#x27;s Erlang Abstract Machine)</h3><p>Bogumil Hausman next machine was called BEAM
(Bogdan&#x27;s Erlang Abstract Machine). It was a hybrid machine
that could execute both native code and <a href="https://en.wikipedia.org/wiki/Threaded_code">threaded code</a> with
an <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a>. That allowed customers to compile their
time-critial modules to native code and all other modules to
threaded BEAM code. The threaded BEAM in itself was faster
than JAM code.</p><p>Bogdan&#x27;s original compiler for BEAM shared the compiler front end with
JAM. Essentially, the front end at that time did the same thing as the
front end in the current compiler as described in <a href="http://blog.erlang.org/compiler-lost-in-translation">Lost in Translation
(Exploring the Compiler&#x27;s Front End)</a>.</p><p>I don&#x27;t have the source code for Bodgan&#x27;s original compiler,
but as far as I can determine it had three compiler passes that
translated the abstract format to threaded BEAM code.</p><ul><li><p><code>beam_compile</code> - Translated the abstract format to BEAM instructions.</p></li><li><p><code>beam_optimize</code> - Optimized the BEAM instructions. This pass was mandatory,
since it did some necessary transformations of the BEAM instructions.</p></li><li><p><code>beam_asm</code> - Converted the symbolic BEAM assembly format to a binary
BEAM module.</p></li></ul><h3>VEE (Virding&#x27;s Erlang Engine)</h3><p>Here we must mention VEE (Virding&#x27;s Erlang Engine) for reasons that
will soon become clear.</p><p>VEE was an experimental implementation with a different memory model
compared to JAM and BEAM. Instead of JAM&#x27;s and BEAM&#x27;s separate heaps
for each process, VEE used a single shared heap with a real-time
garbage collector.  That made message passing blindlingly fast
compared to JAM and BEAM.</p><p>Overall, though, there was no speed gain compared to JAM. The reason
was probably that the single shared heap decreased the cache hit
rate.</p><h2>The maturation of BEAM</h2><p>The OTP group and Erlang/OTP was created to industrialize Erlang and
make it suitable for huge real-world projects. The first release, OTP
R1B, was released in 1996.</p><p>This is the point where the history lesson may become a little bit
more subjective.</p><p>I joined the Erlang/OTP team at the end of 1996. My first small
code contributions to Erlang/OTP were included in OTP R1D.</p><p>I worked in the ERTS (Erlang Run-Time System) team, which at that time
was lead by Kenneth Lundin. Initially I worked with the Erlang runtime
system for Microsoft Windows. After some time (maybe a year or so),
Kenneth asked me to help stabilizing and improving BEAM. Gradually
BEAM become my main responsibility, and when Bogdan left Ericsson, I
become the main developer responsible for the BEAM <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)">interpreter</a> and
compiler.</p><p>This blog post desperately tries to cover the history of the BEAM
<em>compiler</em>, but I think that some more historical context is needed
before we can approach the compiler.</p><p>The overall goal of the work on BEAM from OTP R1 up to OTP R5
was to make it stable enough and fast enough to be useful in real
projects.</p><p>There were two major obstacles to reaching that goal:</p><ul><li>BEAM/C, that is, native code via C code.</li><li>The huge number of ever-changing BEAM instructions.</li></ul><h3>BEAM/C must die!</h3><p>It soon became obvious that BEAM/C, the compiler passes that
compiled Erlang code to C code, had to die. At the time that
I started working on BEAM, there were three distinct flavors of
BEAM/C: one for GCC on Sparc, one for GCC on non-sparc CPUs (such
as Intel x86), and one for other C compilers that did not support
GCC&#x27;s extension for taking the address of a label. Bugs not only showed
up in the native code, but the mere existence of BEAM/C complicated and
caused bugs in the threaded BEAM interpreter.</p><p>Unfortunately, early in my career of improving BEAM, I made some
optimizations of the size of the C code generated by BEAM/C. That came
back to bite me later when I suggested that we should remove
BEAM/C. The size improvements made it possible to fit more Erlang code
compiled to native code into the system, and the native code was
faster than threaded BEAM code. Our customer at the time (<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.9122&amp;rep=rep1&amp;type=pdf">the AXD 301
project</a>) needed the extra speed improvements that BEAM/C gave
them and did not allow us to remove BEAM/C unless we could improve the
performance of threaded BEAM code to similar or better than BEAM/C
performance.</p><h3>The ever-changing BEAM instructions</h3><p>At that time, the BEAM interpreter had over <a href="http://www.cs-lab.org/historical_beam_instruction_set.html">300
instructions</a>.  While JAM had a very simple loader that
essentially only loaded the JAM files into memory, the loader for BEAM
had to translate every instruction from the byte format in the BEAM
files to the threaded code format in memory.  The BEAM had
hand-written code for the loading of every single instruction.</p><p>To make it worse, the instruction set was constantly evolving. Bug
fixes and performance improvements needed new instructions, and those
instructions had to be implemented in the compiler, threaded code
interpreter (the <code>process_main()</code> function in <code>beam_emu.c</code>), and
the loader. In every minor and major release of Erlang/OTP, the
users of BEAM had to recompile all of their Erlang code
because the instruction set had changed.</p><p>There must be a better way, I thought. I started to write a simple
Perl script to a least automate the mapping from instruction name to
instruction number in the compiler, interpreter, and loader.
<a href="https://github.com/tonyrog">Tony Rogvall</a> suggested that I could be more ambitious and
generate most of the code for for the loader using the Perl script.
He also suggested that operands for many instructions could be packed
into a single word. That would reduce load code size and also improve
the cache hit rate, improving execution speed.</p><p>So I started writing the first version of the <a href="https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md">beam_makeops script</a>
and rewriting the loader. I prefer to work incrementally, making minor changes
to a code base that is always working. But I could not rewrite the loader
incrementally, so I hacked away frantically for two or three days until
I had a bare bones version of the new loader working. I could then relax
a little and somewhat more slowly add more features to <code>beam_makeops</code> and
the loader.</p><p>The new loader took over some tasks formerly done by the compiler.</p><p>For example, the BEAM machine has several specialized <code>move</code>
instructions.  There is one instruction for moving something into an X
register, another for moving an atom into an X register, and so
on. Before the new loader, the compiler knew about all those variants
of <code>move</code> instructions and selected the appropriate one. With the new
loader, there is only one <code>move</code> instruction that the compiler needs
to care about, and the loader will select the appropriate specialized
<code>move</code> instruction to use at load time.</p><p>Another minor optimization done by the compiler was combining of
common instructions sequences. For example, a <code>move</code> instruction
followed by a <code>call</code> instruction would be combined to a <code>move_call</code>
instruction. That optimization was also moved to the loader.</p><p>All those capabilities made it possible to significantly simplify and
reduce the number of instructions known to the compiler. More
importantly, that made it possible to keep the instruction set stable
(while still allowing minor optimizations and performance tuning by
tweaking only the loader and interpreter), avoiding the need to
recompile all Erlang code every time there was a new release.</p><p>If my memory doesn&#x27;t fail me, the new loader was introduced in OTP R4.</p><h2>OTP R5B: The &quot;new&quot; BEAM</h2><p>Moving forward to OTP R5.</p><p>OTP R5 was the last release that supported JAM.</p><p>OTP R5 can also be said to be first release that featured the &quot;new&quot;
BEAM. In that release, the <a href="http://www.erlang.se/~bjorn/beam_file_format.html">modern BEAM file format</a>
was introduced. The same file format is used today. At that time,
there were 78 BEAM instructions; in OTP 20, there are 159 instructions
(actually, 129 active instructions and 30 obsoleted instructions no
longer used). While new instructions have been introduced when needed
and obsolete instructions have been removed, it has always been
possible to load BEAM files compiled from at least two major releases
back.</p><p>Execution of threaded BEAM had become fast enough, so that BEAM/C
could be dropped (already in R4, I think). But strangely enough,
the customers still wanted more speed.</p><p>The BEAM compiler in R5 was still Bogdan&#x27;s original compiler. While
it did more optimizations than the JAM ever did, we knew that more
optimizations were possible.</p><h2>R6B: Enter Kernel Erlang</h2><p>Meanwhile, on the top floor Robert Virding was busy writing a
new compiler for his VEE machine. In that new compiler, Robert
introduced a new intermediate format that he called <em>Kernel Erlang</em>.
The idea was that more optimizations could be applied to the code
in that format before generating code for the actual machine.</p><p>At that time, there was no actual interpreter that could execute the
code emitted by his new compiler (he had not updated the VEE machine
yet). The machine he had in mind was a register machine. It was similar
to BEAM, except that it did stack trimming.</p><p>We wanted the better performance that we could get from Robert&#x27;s compiler,
but the question was: should we implement a new interpreter (or adapt
BEAM) to execute the code from Robert&#x27;s compiler, or should we adapt
Robert&#x27;s compiler to generate BEAM code?</p><p>Because we now for the first time had a stable implementation of BEAM,
we decided not to rock the boat again; thus, we decided that I should
adapt the code generator part of Robert&#x27;s compiler for BEAM.</p><p>For the most part, I used Robert&#x27;s name for instructions. For example,
the instruction to load a term into a register was called <code>M</code> in the
original BEAM, while Robert&#x27;s compiler used the <code>move</code>. The more major
changes was in the handling of the stack.  Robert&#x27;s compiler had stack
trimming, which I had to remove and rewrite to handle BEAM&#x27;s fixed
stack frame. (I reintroduced a limited form of stack trimming later.)</p><p>Since JAM was not supported in OTP R6, all customers that had previously
used JAM had to migrate to BEAM. To minimize the risk of the migration
as much as possible, one of our customers requested that we made the
battle-tested original BEAM compiler available as an option in OTP R6.</p><p>Therefore, we added options to choose which version of the compiler
to use. To use the old compiler, one would write:</p><pre><code>$ erlc +v1 some_module.erl</code></pre><p>Default was Robert&#x27;s new compiler, which was called <code>v2</code>. There
was also an undocumented, unofficial compiler version called <code>v3</code>.</p><p>All compilers shared the front end and the <code>beam_asm</code> pass that
created the final BEAM module.</p><h3>The v1_compiler</h3><p>The <code>v1</code> compiler had the following passes:</p><ul><li>v1_adapt</li><li>v1_compile</li><li>v1_optimize</li><li>v1_cleanup</li></ul><p>The <code>v1_compile</code> and <code>v1_optimize</code> passes were essentially
the <code>beam_compile</code> and <code>beam_optimize</code> passes from Bogdan&#x27;s
compiler.</p><p>There had been some changes to the front end since R5, so
the <code>v1_adapt</code> pass was there to hide those changes for the
<code>v1_compile</code> and <code>v1_optimize</code> passes. The <code>v1_cleanup</code> pass was
an additional minor optimization pass; I think it was present
in OTP R5 as well.</p><h3>The v2_compiler</h3><p>The <code>v2</code> compiler was Robert&#x27;s new compiler. It had the following
passes:</p><ul><li>v2_kernel</li><li>v2_kernopt</li><li>v2_match</li><li>v2_life</li><li>v2_codegen</li></ul><p>The <code>v2_kernel</code> pass translated the abstract format to Kernel Erlang.</p><p><code>v2_kernopt</code> did very basic optimizations of the Kernel Erlang code,
essentially only <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation and constant folding</a>.</p><p><code>v2_match</code> did pattern matching compilation. JAM would match clauses
in function heads or <code>case</code> expressions sequentially. The old BEAM
compiler would do only a little bit better in that it could match
multiple integers or atoms in a single instruction. Robert&#x27;s compiler
was the first Erlang compiler to properly compile pattern matching using
the algorithm described in
<a href="https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/">The Implementation of Functional Programming Languages</a>
by Simon Peyton Jones.</p><p><code>v2_life</code> would calculate life-time information needed by the
<code>v2_codegen</code> pass, and <code>v2_codegen</code> would generate the BEAM
assembly code.</p><h2>R7B: Enter Core Erlang</h2><p>Meanwhile, <a href="https://github.com/richcarl">Richard Carlsson</a> and the <a href="https://www.it.uu.se/research/group/hipe/">HiPE group</a>
at Uppsala University come up with the idea for a new intermediate
format useful as an interchange format for different Erlang
implementations and for optimizing Erlang programs.</p><p>The new format was called <a href="https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf">Core Erlang</a>. Robert liked the idea
and started to implement Core Erlang in the compiler.  The undocumented
implementation of <code>v3</code> compiler in OTP R6 is based on a draft version
of the Core Erlang specification.</p><p>In OTP R7B, the v1 and v2 compilers were removed, and the only
remaining compiler was the <code>v3</code> compiler that used Core Erlang.
It had the following passes:</p><ul><li>v3_core</li><li>v3_core_opt</li><li>v3_kernel</li><li>v3_life</li><li>v3_codegen</li></ul><p>The <code>v3_core</code> pass translated the abstract format to Core Erlang.</p><p>The <code>v3_core_opt</code> pass essentially only called <code>sys_core_fold</code>, which
did <a href="https://en.wikipedia.org/wiki/Constant_folding">constant propagation and constant folding</a>. <code>sys_core_fold</code>
still do those things, and <a href="http://blog.erlang.org/core-erlang-optimizations">more</a>.</p><p>The remaining passes do the same thing as today.</p><p>The <code>v3_kernel</code> pass translates from Core Erlang to Kernel Erlang,
and also does pattern matching compilation (in the same way as in
<code>v2_match</code>). The optimizations in <code>v2_kernopt</code> are now done in
<code>sys_core_fold</code>.</p><p>The <code>v3_life</code> pass (despite its name) no longer calculates life-time
information. The life-time information is instead calculated by
<code>v3_kernel</code> and passed on as annotations.</p><p>The reason that <code>v3_life</code> still exists is that Robert had continued
to work on his own version of <code>codegen</code> that did not have all
my changes in it to work for BEAM. While implementing the Core Erlang
passes, he also did many improvements to <code>codegen</code>.</p><p>When it was time to integrate our different versions of the compiler,
Robert looked in horror at all my changes in <code>codegen</code>. To avoid
having to reintroduce all my adapations and optimizations for BEAM
into his new version of <code>codegen</code>, Robert wrote an adapter pass
that translated from the new Kernel Erlang format to the old format
so that my <code>codegen</code> would work. The adapter pass is called
<code>v3_life</code>.</p><p>Thus, <code>v3_codegen</code> is essentially <code>v2_codegen</code> with a new name.</p><p>In the upcoming OTP 21, <code>v3_life</code> has been combined with <code>v3_codegen</code>.</p><h2>Learning Erlang from Robert</h2><p>In the time period that Robert and I worked together on the compiler,
I usually worked on <code>v3_codegen</code> and the passes below, while Robert
worked on all passes above <code>v3_codegen</code>.</p><p>Occasionally, I would add some optimizations to <code>sys_core_fold</code> and
give them to Robert to incorporate into his latest version of
<code>sys_core_fold</code>.</p><p>I would then look at what Robert had done with my code, and learn.</p><p>Usually Robert had subtly improved my code, made it slightly
cleaner and simpler. But one time I handed Robert an
optimization of <code>case</code> clauses. The code I got back was very different.
Robert had broken apart my optimization into several simpler
optimizations that achieved the same purpose (and more) than my
more complicated optimization.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"beam-compiler-history","title":"A Brief History of the BEAM Compiler","author":"Bj√∂rn Gustavsson","excerpt":"\nThis blog post is a brief history lesson about the Erlang compiler for\nthe BEAM machine. To provide some context, there will first be a quick\nlook at the abstract machines for Erlang.\n\n[mike]: http://www.erlang-factory.com/conference/ErlangUserConference2013/speakers/MikeWilliams,\n[joe]: https://github.com/joearms,\n[robert]: https://github.com/rvirding,\n[threaded code]: https://en.wikipedia.org/wiki/Threaded_code,\n[interpreter]: https://en.wikipedia.org/wiki/Interpreter_(computing),\n[front end]: http://blog.erlang.org/compiler-lost-in-translation,\n[axd301]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.9122\u0026rep=rep1\u0026type=pdf,\n[beam1997]: http://www.cs-lab.org/historical_beam_instruction_set.html,\n[tonyrog]: https://github.com/tonyrog,\n[makeops]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md,\n[beam file format]: http://www.erlang.se/~bjorn/beam_file_format.html,\n[folding]: https://en.wikipedia.org/wiki/Constant_folding,\n[peytonjones]: https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/,\n[hipe]: https://www.it.uu.se/research/group/hipe/,\n[carlsson]: https://github.com/richcarl,\n[core]: https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf,\n[sys_core_fold]: http://blog.erlang.org/core-erlang-optimizations","article_date":1529280000000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"A Brief History of the BEAM Compiler","tags":"compiler BEAM","author":"Bj√∂rn Gustavsson"},"content":"\nThis blog post is a brief history lesson about the Erlang compiler for\nthe BEAM machine. To provide some context, there will first be a quick\nlook at the abstract machines for Erlang.\n\n## A brief overview of the early Erlang implementations\n\n### The Prolog interpreter\n\nThe first version of Erlang was implemented in\nProlog in 1986. That version of Erlang was used\nto find out which features of the languages were\nuseful and which were not. New languages features\ncould be added or deleted in a matter of hours\nor days.\n\n### JAM (Joe's Abstract Machine)\n\nIt soon became clear that Erlang needed to be at\nleast 40 times faster to be useful in real projects.\n\nIn 1989 JAM (Joe's Abstract Machine) was first\nimplemented. [Mike Williams][mike] wrote the runtime system\nin C, [Joe Armstrong][joe] wrote the compiler, and\n[Robert Virding][robert] wrote the libraries.\n\n[mike]: http://www.erlang-factory.com/conference/ErlangUserConference2013/speakers/MikeWilliams\n[joe]: https://github.com/joearms\n[robert]: https://github.com/rvirding\n\nJAM turned out be 70 times faster than the Prolog\ninterpreter. Success?\n\n### TEAM (Turbo Erlang Abstract Machine)\n\nIt soon became clear that Erlang still needed\nto be faster to be useful in real projects.\n\nTherefore Bogumil (\"Bogdan\") Hausman created TEAM (Turbo Erlang\nAbstract Machine). It compiled the Erlang code to C code, which was\nthen compiled to native code using GCC.\n\nIt was significantly faster than JAM for small projects.\nUnfortunately, compilation was very slow, and the code size of the\ncompiled code was too big to make it useful for large projects.\n\n### BEAM (Bogdan's Erlang Abstract Machine)\n\nBogumil Hausman next machine was called BEAM\n(Bogdan's Erlang Abstract Machine). It was a hybrid machine\nthat could execute both native code and [threaded code] with\nan [interpreter]. That allowed customers to compile their\ntime-critial modules to native code and all other modules to\nthreaded BEAM code. The threaded BEAM in itself was faster\nthan JAM code.\n\n[threaded code]: https://en.wikipedia.org/wiki/Threaded_code\n[interpreter]: https://en.wikipedia.org/wiki/Interpreter_(computing)\n\nBogdan's original compiler for BEAM shared the compiler front end with\nJAM. Essentially, the front end at that time did the same thing as the\nfront end in the current compiler as described in [Lost in Translation\n(Exploring the Compiler's Front End)][front end].\n\nI don't have the source code for Bodgan's original compiler,\nbut as far as I can determine it had three compiler passes that\ntranslated the abstract format to threaded BEAM code.\n\n* `beam_compile` - Translated the abstract format to BEAM instructions.\n\n* `beam_optimize` - Optimized the BEAM instructions. This pass was mandatory,\nsince it did some necessary transformations of the BEAM instructions.\n\n* `beam_asm` - Converted the symbolic BEAM assembly format to a binary\nBEAM module.\n\n[front end]: http://blog.erlang.org/compiler-lost-in-translation\n\n### VEE (Virding's Erlang Engine)\n\nHere we must mention VEE (Virding's Erlang Engine) for reasons that\nwill soon become clear.\n\nVEE was an experimental implementation with a different memory model\ncompared to JAM and BEAM. Instead of JAM's and BEAM's separate heaps\nfor each process, VEE used a single shared heap with a real-time\ngarbage collector.  That made message passing blindlingly fast\ncompared to JAM and BEAM.\n\nOverall, though, there was no speed gain compared to JAM. The reason\nwas probably that the single shared heap decreased the cache hit\nrate.\n\n## The maturation of BEAM\n\nThe OTP group and Erlang/OTP was created to industrialize Erlang and\nmake it suitable for huge real-world projects. The first release, OTP\nR1B, was released in 1996.\n\nThis is the point where the history lesson may become a little bit\nmore subjective.\n\nI joined the Erlang/OTP team at the end of 1996. My first small\ncode contributions to Erlang/OTP were included in OTP R1D.\n\nI worked in the ERTS (Erlang Run-Time System) team, which at that time\nwas lead by Kenneth Lundin. Initially I worked with the Erlang runtime\nsystem for Microsoft Windows. After some time (maybe a year or so),\nKenneth asked me to help stabilizing and improving BEAM. Gradually\nBEAM become my main responsibility, and when Bogdan left Ericsson, I\nbecome the main developer responsible for the BEAM [interpreter] and\ncompiler.\n\nThis blog post desperately tries to cover the history of the BEAM\n*compiler*, but I think that some more historical context is needed\nbefore we can approach the compiler.\n\nThe overall goal of the work on BEAM from OTP R1 up to OTP R5\nwas to make it stable enough and fast enough to be useful in real\nprojects.\n\nThere were two major obstacles to reaching that goal:\n\n* BEAM/C, that is, native code via C code.\n* The huge number of ever-changing BEAM instructions.\n\n### BEAM/C must die!\n\nIt soon became obvious that BEAM/C, the compiler passes that\ncompiled Erlang code to C code, had to die. At the time that\nI started working on BEAM, there were three distinct flavors of\nBEAM/C: one for GCC on Sparc, one for GCC on non-sparc CPUs (such\nas Intel x86), and one for other C compilers that did not support\nGCC's extension for taking the address of a label. Bugs not only showed\nup in the native code, but the mere existence of BEAM/C complicated and\ncaused bugs in the threaded BEAM interpreter.\n\nUnfortunately, early in my career of improving BEAM, I made some\noptimizations of the size of the C code generated by BEAM/C. That came\nback to bite me later when I suggested that we should remove\nBEAM/C. The size improvements made it possible to fit more Erlang code\ncompiled to native code into the system, and the native code was\nfaster than threaded BEAM code. Our customer at the time ([the AXD 301\nproject][axd301]) needed the extra speed improvements that BEAM/C gave\nthem and did not allow us to remove BEAM/C unless we could improve the\nperformance of threaded BEAM code to similar or better than BEAM/C\nperformance.\n\n[axd301]: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.140.9122\u0026rep=rep1\u0026type=pdf\n\n### The ever-changing BEAM instructions\n\nAt that time, the BEAM interpreter had over [300\ninstructions][beam1997].  While JAM had a very simple loader that\nessentially only loaded the JAM files into memory, the loader for BEAM\nhad to translate every instruction from the byte format in the BEAM\nfiles to the threaded code format in memory.  The BEAM had\nhand-written code for the loading of every single instruction.\n\nTo make it worse, the instruction set was constantly evolving. Bug\nfixes and performance improvements needed new instructions, and those\ninstructions had to be implemented in the compiler, threaded code\ninterpreter (the `process_main()` function in `beam_emu.c`), and\nthe loader. In every minor and major release of Erlang/OTP, the\nusers of BEAM had to recompile all of their Erlang code\nbecause the instruction set had changed.\n\nThere must be a better way, I thought. I started to write a simple\nPerl script to a least automate the mapping from instruction name to\ninstruction number in the compiler, interpreter, and loader.\n[Tony Rogvall][tonyrog] suggested that I could be more ambitious and\ngenerate most of the code for for the loader using the Perl script.\nHe also suggested that operands for many instructions could be packed\ninto a single word. That would reduce load code size and also improve\nthe cache hit rate, improving execution speed.\n\nSo I started writing the first version of the [beam_makeops script][makeops]\nand rewriting the loader. I prefer to work incrementally, making minor changes\nto a code base that is always working. But I could not rewrite the loader\nincrementally, so I hacked away frantically for two or three days until\nI had a bare bones version of the new loader working. I could then relax\na little and somewhat more slowly add more features to `beam_makeops` and\nthe loader.\n\nThe new loader took over some tasks formerly done by the compiler.\n\nFor example, the BEAM machine has several specialized `move`\ninstructions.  There is one instruction for moving something into an X\nregister, another for moving an atom into an X register, and so\non. Before the new loader, the compiler knew about all those variants\nof `move` instructions and selected the appropriate one. With the new\nloader, there is only one `move` instruction that the compiler needs\nto care about, and the loader will select the appropriate specialized\n`move` instruction to use at load time.\n\nAnother minor optimization done by the compiler was combining of\ncommon instructions sequences. For example, a `move` instruction\nfollowed by a `call` instruction would be combined to a `move_call`\ninstruction. That optimization was also moved to the loader.\n\nAll those capabilities made it possible to significantly simplify and\nreduce the number of instructions known to the compiler. More\nimportantly, that made it possible to keep the instruction set stable\n(while still allowing minor optimizations and performance tuning by\ntweaking only the loader and interpreter), avoiding the need to\nrecompile all Erlang code every time there was a new release.\n\nIf my memory doesn't fail me, the new loader was introduced in OTP R4.\n\n[beam1997]: http://www.cs-lab.org/historical_beam_instruction_set.html\n[tonyrog]: https://github.com/tonyrog\n[makeops]: https://github.com/erlang/otp/blob/OTP-21.0-rc1/erts/emulator/internal_doc/beam_makeops.md\n\n## OTP R5B: The \"new\" BEAM\n\nMoving forward to OTP R5.\n\nOTP R5 was the last release that supported JAM.\n\nOTP R5 can also be said to be first release that featured the \"new\"\nBEAM. In that release, the [modern BEAM file format][beam file format]\nwas introduced. The same file format is used today. At that time,\nthere were 78 BEAM instructions; in OTP 20, there are 159 instructions\n(actually, 129 active instructions and 30 obsoleted instructions no\nlonger used). While new instructions have been introduced when needed\nand obsolete instructions have been removed, it has always been\npossible to load BEAM files compiled from at least two major releases\nback.\n\nExecution of threaded BEAM had become fast enough, so that BEAM/C\ncould be dropped (already in R4, I think). But strangely enough,\nthe customers still wanted more speed.\n\nThe BEAM compiler in R5 was still Bogdan's original compiler. While\nit did more optimizations than the JAM ever did, we knew that more\noptimizations were possible.\n\n[beam file format]: http://www.erlang.se/~bjorn/beam_file_format.html\n\n## R6B: Enter Kernel Erlang\n\nMeanwhile, on the top floor Robert Virding was busy writing a\nnew compiler for his VEE machine. In that new compiler, Robert\nintroduced a new intermediate format that he called *Kernel Erlang*.\nThe idea was that more optimizations could be applied to the code\nin that format before generating code for the actual machine.\n\nAt that time, there was no actual interpreter that could execute the\ncode emitted by his new compiler (he had not updated the VEE machine\nyet). The machine he had in mind was a register machine. It was similar\nto BEAM, except that it did stack trimming.\n\nWe wanted the better performance that we could get from Robert's compiler,\nbut the question was: should we implement a new interpreter (or adapt\nBEAM) to execute the code from Robert's compiler, or should we adapt\nRobert's compiler to generate BEAM code?\n\nBecause we now for the first time had a stable implementation of BEAM,\nwe decided not to rock the boat again; thus, we decided that I should\nadapt the code generator part of Robert's compiler for BEAM.\n\nFor the most part, I used Robert's name for instructions. For example,\nthe instruction to load a term into a register was called `M` in the\noriginal BEAM, while Robert's compiler used the `move`. The more major\nchanges was in the handling of the stack.  Robert's compiler had stack\ntrimming, which I had to remove and rewrite to handle BEAM's fixed\nstack frame. (I reintroduced a limited form of stack trimming later.)\n\nSince JAM was not supported in OTP R6, all customers that had previously\nused JAM had to migrate to BEAM. To minimize the risk of the migration\nas much as possible, one of our customers requested that we made the\nbattle-tested original BEAM compiler available as an option in OTP R6.\n\nTherefore, we added options to choose which version of the compiler\nto use. To use the old compiler, one would write:\n\n```\n$ erlc +v1 some_module.erl\n```\n\nDefault was Robert's new compiler, which was called `v2`. There\nwas also an undocumented, unofficial compiler version called `v3`.\n\nAll compilers shared the front end and the `beam_asm` pass that\ncreated the final BEAM module.\n\n### The v1_compiler\n\nThe `v1` compiler had the following passes:\n\n* v1_adapt\n* v1_compile\n* v1_optimize\n* v1_cleanup\n\nThe `v1_compile` and `v1_optimize` passes were essentially\nthe `beam_compile` and `beam_optimize` passes from Bogdan's\ncompiler.\n\nThere had been some changes to the front end since R5, so\nthe `v1_adapt` pass was there to hide those changes for the\n`v1_compile` and `v1_optimize` passes. The `v1_cleanup` pass was\nan additional minor optimization pass; I think it was present\nin OTP R5 as well.\n\n### The v2_compiler\n\nThe `v2` compiler was Robert's new compiler. It had the following\npasses:\n\n* v2_kernel\n* v2_kernopt\n* v2_match\n* v2_life\n* v2_codegen\n\nThe `v2_kernel` pass translated the abstract format to Kernel Erlang.\n\n`v2_kernopt` did very basic optimizations of the Kernel Erlang code,\nessentially only [constant propagation and constant folding][folding].\n\n`v2_match` did pattern matching compilation. JAM would match clauses\nin function heads or `case` expressions sequentially. The old BEAM\ncompiler would do only a little bit better in that it could match\nmultiple integers or atoms in a single instruction. Robert's compiler\nwas the first Erlang compiler to properly compile pattern matching using\nthe algorithm described in\n[The Implementation of Functional Programming Languages][peytonjones]\nby Simon Peyton Jones.\n\n`v2_life` would calculate life-time information needed by the\n`v2_codegen` pass, and `v2_codegen` would generate the BEAM\nassembly code.\n\n[folding]: https://en.wikipedia.org/wiki/Constant_folding\n[peytonjones]: https://www.microsoft.com/en-us/research/publication/the-implementation-of-functional-programming-languages/\n\n## R7B: Enter Core Erlang\n\nMeanwhile, [Richard Carlsson][carlsson] and the [HiPE group][hipe]\nat Uppsala University come up with the idea for a new intermediate\nformat useful as an interchange format for different Erlang\nimplementations and for optimizing Erlang programs.\n\nThe new format was called [Core Erlang][core]. Robert liked the idea\nand started to implement Core Erlang in the compiler.  The undocumented\nimplementation of `v3` compiler in OTP R6 is based on a draft version\nof the Core Erlang specification.\n\nIn OTP R7B, the v1 and v2 compilers were removed, and the only\nremaining compiler was the `v3` compiler that used Core Erlang.\nIt had the following passes:\n\n* v3_core\n* v3_core_opt\n* v3_kernel\n* v3_life\n* v3_codegen\n\nThe `v3_core` pass translated the abstract format to Core Erlang.\n\nThe `v3_core_opt` pass essentially only called `sys_core_fold`, which\ndid [constant propagation and constant folding][folding]. `sys_core_fold`\nstill do those things, and [more][sys_core_fold].\n\nThe remaining passes do the same thing as today.\n\nThe `v3_kernel` pass translates from Core Erlang to Kernel Erlang,\nand also does pattern matching compilation (in the same way as in\n`v2_match`). The optimizations in `v2_kernopt` are now done in\n`sys_core_fold`.\n\nThe `v3_life` pass (despite its name) no longer calculates life-time\ninformation. The life-time information is instead calculated by\n`v3_kernel` and passed on as annotations.\n\nThe reason that `v3_life` still exists is that Robert had continued\nto work on his own version of `codegen` that did not have all\nmy changes in it to work for BEAM. While implementing the Core Erlang\npasses, he also did many improvements to `codegen`.\n\nWhen it was time to integrate our different versions of the compiler,\nRobert looked in horror at all my changes in `codegen`. To avoid\nhaving to reintroduce all my adapations and optimizations for BEAM\ninto his new version of `codegen`, Robert wrote an adapter pass\nthat translated from the new Kernel Erlang format to the old format\nso that my `codegen` would work. The adapter pass is called\n`v3_life`.\n\nThus, `v3_codegen` is essentially `v2_codegen` with a new name.\n\nIn the upcoming OTP 21, `v3_life` has been combined with `v3_codegen`.\n\n[hipe]: https://www.it.uu.se/research/group/hipe/\n[carlsson]: https://github.com/richcarl\n[core]: https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf\n[sys_core_fold]: http://blog.erlang.org/core-erlang-optimizations\n\n## Learning Erlang from Robert\n\nIn the time period that Robert and I worked together on the compiler,\nI usually worked on `v3_codegen` and the passes below, while Robert\nworked on all passes above `v3_codegen`.\n\nOccasionally, I would add some optimizations to `sys_core_fold` and\ngive them to Robert to incorporate into his latest version of\n`sys_core_fold`.\n\nI would then look at what Robert had done with my code, and learn.\n\nUsually Robert had subtly improved my code, made it slightly\ncleaner and simpler. But one time I handed Robert an\noptimization of `case` clauses. The code I got back was very different.\nRobert had broken apart my optimization into several simpler\noptimizations that achieved the same purpose (and more) than my\nmore complicated optimization.\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"beam-compiler-history"},"buildId":"ob9V3f7Iet6syJeg0QYgd","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_buildManifest.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_ssgManifest.js" async=""></script></body></html>