{"pageProps":{"index":{"id":"0016","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 23-Jul-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 16: <a href=\"eep-0016.md\" title=\"EEP Source\"> is_between/3</a></h2>\n\n<h1>Abstract</h1>\n\n<p>There should be a new built in function for guards,</p>\n\n<pre><code>is_between(Term, Lower_Bound, Upper_Bound)\n</code></pre>\n\n<p>which succeeds when <code>Term</code>, <code>Lower_Bound</code>, and <code>Upper_Bound</code>\nare all integers, and <code>Lower_Bound =&lt; Term =&lt; Upper_Bound</code>.</p>\n\n<h1>Specification</h1>\n\n<p>A new guard BIF is added.</p>\n\n<pre><code>is_between(Term, LB, UB)\n</code></pre>\n\n<p>In expression use, if LB or UB is not an integer,\na badarith exception is thrown, just like an attempt to\ndo remainder or bitwise operations on non-integer arguments.\nIn guard use, that exception becomes failure.</p>\n\n<p>This is a type test which succeeds (or returns true) if\nTerm is an integer and lies between LB and UB inclusive,\nand fails (or returns false) for other values of Term.</p>\n\n<p>As an expression, it has the same effect as</p>\n\n<pre><code>( X = Term, Y = LB, Z = UB,\n  Y bor Z,\n  ( is_integer(X), X &gt;= Y, X =&lt; Z )\n)\n</code></pre>\n\n<p>where X, Y, and Z are new variables that are not exported.</p>\n\n<p>In particular,</p>\n\n<pre><code>is_integer(tom, dick, harry)\n</code></pre>\n\n<p>should raise an exception, not return false, as <code>is_integer(Term)</code>\nis only tested after LB and UB have been found to be integers.</p>\n\n<p>As a guard test, it has the same effect as</p>\n\n<pre><code>( X = Term, Y = LB, Z = UB,\n  is_integer(Y), is_integer(Z), is_integer(X),\n  X &gt;= Y, X =&lt; Z\n)\n</code></pre>\n\n<p>would have, were that allowed.  However, it admits a much\nmore efficient implementation.</p>\n\n<h1>Motivation</h1>\n\n<p>Currently some people test whether a variable is a byte thus:</p>\n\n<pre><code>-define(is_byte(X), (X &gt;= 0 andalso X =&lt; 255)).\n</code></pre>\n\n<p>This is actual current practice.  However, it fails to check\nthat <code>X</code> is an integer, so <code>?is_byte(1.5)</code> succeeds, it may\nevaluate <code>X</code> twice, so <code>?is_byte((Pid ! 0))</code> will send two messages,\nnot the expected one, and the current Erlang compiler generates\nnoticeably worse code in guards for 'andalso' and 'orelse' than\nit does for ',' and ';'.</p>\n\n<p>It is also useful to test whether a subscript is in range,</p>\n\n<pre><code>-define(in_range(X, T), (X &gt;= 1 andalso X =&lt; size(T))).\n</code></pre>\n\n<p>which has similar problems.</p>\n\n<p>Using <code>is_between</code>, we can replace these definitions with</p>\n\n<pre><code>-define(is_byte(X),     is_between(X, 0, 255)).\n-define(in_range(X, T), is_between(X, 1, size(T))).\n</code></pre>\n\n<p>which are free of those problems</p>\n\n<h1>Rationale</h1>\n\n<p>One alternative to this design would be to follow the example\nof Common Lisp (and the even earlier example of the systems\nprogramming language on HP 3000s) and allow</p>\n\n<pre><code>E1 =&lt; E2 =&lt; E3      % (&lt;= E1 E2 E3) in Lisp\n</code></pre>\n\n<p>(and possibly also</p>\n\n<pre><code>E1 =&lt; E2 &lt;  E3\nE1 &lt;  E2 =&lt; E3\nE1 &lt;  E2 &lt;  E3)     % (&lt;  E1 E2 E3) in Lisp\n</code></pre>\n\n<p>as guards and expressions, evaluating each expression exactl\nonce.  I am very fond of this syntax and would be pleased to\nsee it.  This would resolve the double evaluation of <code>E2</code>, the\npossible non-evaluation of <code>E3</code>, and the inefficiency of 'andalso'.\nHowever, it would not address the problem that a byte or an\nindex is not just a NUMBER in a certain range, but an INTEGER.\nIf Erlang had multiple comparison syntax, there would still be\na use for <code>is_between/3</code>.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Code that defines a function named <code>is_between/3</code> will be\naffected.  Since the Erlang compiler parses an entire\nmodule before semantic analysis, it's easy to\n-   check for a definition of <code>is_between/3</code>\n-   warn if one is present\n-   disable the new built-in in such a case.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>There is none.  However, we can sketch one.\nTwo new BEAM instructions are required:</p>\n\n<pre><code>{test,is_between,Lbl,[Src1,Src2,Src3]}\n{bif,is_between,?,[Src1,Src2,Src3],Dst}\n</code></pre>\n\n<p>The test does</p>\n\n<pre><code>if Src2 is not an integer, goto Lbl.\nif Src3 is not an integer, goto Lbl.\nif Src1 is not an integer, goto Lbl.\nif Src1 &lt; Src2, goto Lbl.\nif Src3 &lt; Src1, goto Lbl.\n</code></pre>\n\n<p>The bif does</p>\n\n<pre><code>if Src2 is not an integer, except!\nif Src3 is not an integer, except!\nif Src1 is not an integer\nor Src1 &lt; Src2\nor Src3 &lt; Src1\nthen move 'false' to Dst\nelse move 'true'  to Dst.\n</code></pre>\n\n<p>Nothing here is fundamentally new, and only my unfamiliarity with\nhow to add instructions to the emulator prevents me doing it.  And\nmy total ignorance of how to tell HiPE about them!</p>\n\n<p>There might be some point in having variants of these instructions\nfor use when Src2 and Src3 are integer literals; I would certainly\nexpect HiPE to elide redundant tests here.</p>\n\n<p>The compiler would simply recognise <code>is_between/3</code> and emit the\nappropriate BEAM rather like it recognises <code>is_atom/1</code>.\nMy ignorance of how to extend the emulator is exceeded by my\nignorance of how to extend the compiler.  Certainly we'd need</p>\n\n<pre><code>...\nis_bif(erlang, is_between, 3) -&gt; true;\n...\nis_guard_bif(erlang, is_between, 3) -&gt; true;\n...\nis_pure(erlang, is_between, 3) -&gt; true;\n...\n</code></pre>\n\n<p>(but NOT an <code>is_safe</code> rule) in <code>erl_bifs.erl</code>.  Or would we?  I've\nnot been able to figure out where <code>is_guard_bif/3</code> is called.\nThere will need to be a new entry in genop.tab as well.\nOhhh, <code>erl_internal.erl</code> is in <code>.../stdlib</code>, not <code>.../compiler</code>.\nOK, so a couple of functions in <code>erl_internal.erl</code> need to be patched\nto recognise <code>is_between/3</code>; what needs changing to generate BEAM?\nThe annoying thing is that if I knew my way around the compiler,\nit would be easier to add this than to write it up.</p>\n\n<p>Here's some text to go in the documentation:</p>\n\n<blockquote>\n<pre><code>is_integer(Term, LB, UB) -&gt; bool()\n\nTypes:\n  Term = term()\n  LB = integer()\n  UB = integer()\n</code></pre>\n\n<p>Returns true if Term is an integer lying between LB\nand UB inclusive (LB =&lt; Term, Term =&lt; UB); otherwise\nreturns false.  In an expression, raises an exception\nif LB or UB is not an integer.  Having UB &lt; LB is not\nan error.</p>\n\n<p>Allowed in guard tests.</p>\n</blockquote>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}