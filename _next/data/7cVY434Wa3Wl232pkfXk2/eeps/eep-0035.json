{"pageProps":{"index":{"id":"0035","content":"<pre><code>Author: Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;,\n        Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;\nStatus: Draft\nType: Standards Track\nCreated: 29-Sep-2010\nErlang-Version: R14B\nPost-History:\nReplaces: 9\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 35: <a href=\"eep-0035.md\" title=\"EEP Source\"> Binary string module(s)</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP contains developed suggestions regarding the module <code>binary_string</code>\nfirst suggested in <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>. The module name is now however changed to <code>bstring</code>.</p>\n\n<p><a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a> suggests several modules and is partially superseded by later\nEEP's (i.e. <a href=\"/eeps/eep-0011\" title=\"EEP 11, intresting extensions to EEP 9\">EEP 11</a> and <a href=\"/eeps/eep-0031\" title=\"EEP 31, rewrite of EEP 9, module binary\">EEP 31</a>), while still containing valuable suggestions not\nyet implemented. This last remaining module suggested in <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a> will therefore\nappear in this separate EEP. This is made in agreement with\nthe original author of <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>.</p>\n\n<p>The module <code>bstring</code> is suggested to contain functions for\nconvenient manipulation of textual data stored in binaries,\ni.e. binary strings. It somewhat resembles the <code>string</code> module\n(which is list oriented), but is not to be viewed simply as a\n<code>string</code> module for binaries.</p>\n\n<p>The module suggested handles binary character encoding in both the\nstandard character encodings of Erlang, namely ISO-Latin-1 and UTF-8.</p>\n\n<h1>Motivation</h1>\n\n<p>Text strings are traditionally represented as lists of integers in\nErlang. While this is convenient and more or less built into the\nsyntax of the language (i.e. \"ABC\" is syntactic sugar for [$A,$B,$C]),\na more compact representation is often desired. Also, in some\ncircumstances binaries can be more efficient to manipulate in terms of\nalgorithm complexity than lists are (especially in the fixed character\nwidth case of ISO-Latin-1).</p>\n\n<p>More modules have been added to the standard libraries lately to aid\nthe usage of binaries for text strings, both as representing\nISO-Latin-1 characters and Unicode strings encoded in UTF-8. Most\nnotably the <code>re</code> library, but also the <code>unicode</code> module are fairly\nnew additions to <code>stdlib</code> which will make life easier for the\nprogrammer when it comes to manipulating binary encoded strings. Also\na module for fast searching and replacing in byte oriented binaries is\npresent (the module <code>binary</code>), but no traditional string manipulation module is\nyet in the libraries. To ease use of binary encoded strings, such a module is\nneeded.</p>\n\n<h1>Rationale</h1>\n\n<p>The module <code>string</code> for text oriented operations on lists has been\npresent in the standard libraries for so long that most programmers\ndon't remember a time when it wasn't there. It is said to originally\nbe a merge of two different string modules, written and designed by\ntwo different programmers with possibly slightly different goals and\ndefinitely slightly different views on function naming. While\nsometimes criticized for duplicated functionality and inconsistent\nfunction naming, among other things, the module has remained useful\nthroughout the entire lifespan of Erlang/OTP. The string\nrepresentation used has also withstood the evolution of Unicode.</p>\n\n<p>It is worth to note that the only functions in the <code>string</code> module\nthat actually are language or region dependent are later additions to\nthe module. Those functions (like <code>to_upper</code>, <code>to_lower</code>, <code>to_integer</code> and\n<code>to_float</code>), or their binary equivalence, are not part of the module\ninterface I suggest for <code>bstring</code> for the simple reason that they\nneed language support not yet present in Erlang. A future EEP might\nsuggest such language support (i.e. some kind of \"locale\" support), but\nthat is future work not covered by this EEP.</p>\n\n<p>So, however criticized, the string module is very useful for\nmanipulating lists, and the same functionality for binary strings is\ndesirable. While a lot of the functionality will be similar, there are\nsome major issues to consider when implementing a module for\nmanipulating strings encoded in binaries:</p>\n\n<ul>\n<li><p>Unicode - Binaries can have different encodings. A Character encoded\nas UTF-8 might take more than one (up to four) byte positions, and\neven the same character can have different encodings in ISO-Latin-1\nand UTF-8 (all codepoints from 128 to 255). The functions need to be\ninformed of the character encoding explicitly, The encoding\ninformation is not present in the binaries.</p></li>\n<li><p>Mixed character encodings - As characters can be encoded in\ndifferent ways, two strings in the same program could have different\nencodings. Supplying the functions with non-homogeneous string\nencoding data should be consistently solved throughout the module,\nas should the selection of returned encoding where applicable.</p></li>\n<li><p>Default character encoding - As functions will take extra arguments\nto specify encoding, a consistent default might be useful. Choosing\nthe default is not entirely simple, as the tradition states\nISO-Latin-1, while the future suggests UTF-8.</p></li>\n<li><p>Languages - Erlang has no notion of \"Locale\" or preferred number\nformat. A general string module can not assume neither a specific\nnotion of uppercase or lowercase letters, nor a specific number\nencoding format (especially true for floating point numbers).</p></li>\n<li><p>Word separators - The space character is certainly not the only word\nseparator for textual data (in any language). The notion of words\nseparated by spaces imposes a restriction of the relevant languages.</p></li>\n<li><p>Left to right or right to left - Notions like left or right to\ndenote the beginning or end of a string are certainly not language\nindependent. While strings in a language have a beginning and an end,\nthat beginning and end may be placed both to the left, the right or\neven at the top, bottom or center of the graphical representation. A\nstring manipulation module should not use naming implying a\nleft-to-right script, or any other type of script.</p></li>\n<li><p>Naming and duplicated functionality - The original <code>string</code> module\nhas been accused of having somewhat inconsistent naming and\nfunctionality duplicated. In fact the only duplicated functions are\n<code>substr</code> and <code>sub_string</code>. Some cleanup of the interface might\nbe needed.</p></li>\n<li><p>Byte oriented versus character oriented return values - When dealing\nwith Unicode data, a character may take more than one byte, why\ni.e. counting the number of characters in a string tells you very\nlittle about the actual size of the string in bytes. Furthermore,\nlater processing of a binary might require byte-oriented\nmanipulation of a string rather than character oriented (i.e. you\nwant to manipulate the string using the <code>binary</code> module or with\nbit-syntax), while characters are actually what constitutes a\nstring, not bytes. You would want both.</p></li>\n<li><p>New or replaced functionality - New functionality have been suggested from several sources,\nmost notably <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>. For example the function <code>split</code> suggested in <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a> is very similar to \n<c>string:tokens/2</c>. Should we keep <code>tokens</code> anyway, for example?</p></li>\n</ul>\n\n<p>I'll address the different issues below.</p>\n\n<h2>Unicode</h2>\n\n<p>The interface has to support both ISO-Latin-1 and UTF-8. The <code>unicode</code> module supports even more encodings, but Erlang/OTP uses UTF-8 for all \"internal\" interfaces and UTF-8 is the expected encoding of a binary Unicode string. Even though UTF-8 is compatible with ISO-Latin-1 in the 7bit ASCII range, characters with codepoints between 128 and 255 are encoded differently in the \"plain\" ISO-Latin-1 encoding and in UTF-8. This means that all functions in the <code>bstring</code> module need to have the actual encoding as one or more extra parameters.</p>\n\n<p>One could invent a more abstract binary string format where the data is for example represented as a tuple with the string and the encoding packed together. However no other module supports such a string construct and I don't think that would really add something, neither functionality nor readability. Consider code like:</p>\n\n<pre><code>bstring:tokens(Bin,latin1,[$ ,$\\n])\n</code></pre>\n\n<p>compared to:</p>\n\n<pre><code>bstring:tokens({Bin,latin1}, [$ ,$\\n]).\n</code></pre>\n\n<p>or even:</p>\n\n<pre><code>bstring:tokens(#bstring{data = Bin, encoding = latin1}, [$ ,$\\n]).\n</code></pre>\n\n<p>In many cases the extra information needs to be added in connection to the call, making the code no more readable or simple to write than with the separate extra argument. Consider if we had a default value for encoding. The code:</p>\n\n<pre><code>f(Data) -&gt;\n       bstring:tokens(Data,[$ ,$\\n]).\n</code></pre>\n\n<p>would not in any way indicate if <code>Data</code> was supposed to be a binary with the default encoding or some kind of complex data structure indicating both the actual string and it's encoding. </p>\n\n<p>I think the extra argument for the encoding is straight forward and simple, and it makes programming easier when using the binary string in other modules as well (i.e. <code>re</code>, <code>binary</code>, <code>file</code> etc). I think we should simply not have a special string datatype for this module, character encoding should be supplied as a separate argument.</p>\n\n<h2>Mixed character encodings</h2>\n\n<p>To ease transition between character encodings, I think the interface should accept different encodings for both different parameters and the return value. This makes it possible to convert on the fly and for the functions to decide on the most efficient character conversion path for the supplied arguments and the return value. </p>\n\n<p>The downside of this approach is that some functions will take a lot of parameters telling different character encodings, for example a string concatenation routine could look like:</p>\n\n<pre><code>  concat(BString1, Encoding1, BString2, Encoding2, Encoding3) -&gt; BString3\n</code></pre>\n\n<p>being called like:</p>\n\n<pre><code>  US = bstring:concat(SA,latin1, SB, latin1, unicode),\n</code></pre>\n\n<p>which might look a little awkward to write. On the other hand, conversion is made on the fly and you will not need to explicitly call the <code>unicode</code> module to convert the result. </p>\n\n<p>I think implicit conversion is so useful that it is worth the extra arguments. For example a <code>concat</code> function would be more or less useless without it, the bit syntax would be much easier to use if no conversion should be allowed.</p>\n\n<h2>Default character encoding</h2>\n\n<p>Choosing a default character encoding is not obvious. While ISO-Latin-1 is the default in Erlang (i.e. &lt;&lt;\"korvsmörgås\">> gives a ISO-Latin-1 encoded binary string), UTF-8 usage is expected to grow in the future. </p>\n\n<p>Although its tempting to select UTF-8 as the default encoding, I think we should stick to ISO-Latin-1 as the default even for this module. There are several reasons:</p>\n\n<ul>\n<li><p>We need not, as a rule, impose new standards in every module we add\nto the standard library. Consistence certainly adds value, and both\nthe bit-syntax, the source code encoding and things like the\nio:format routine has ISO-Latin-1 as default. Lets not make this\nmodule inconsistent with the others.</p></li>\n<li><p>The <code>string</code> module is often used to manipulate arbitrary lists\nof integers, not always actually representing textual data. In the\nsame way can <code>bstring</code> probably be used to manipulate arbitrary\nblobs of bytes if ISO-latin-1 versions are used. ISO-Latin-1 is\nactually the raw bytes uninterpreted, why any binary data can be\nworked on in a ISO-Latin-1 oriented routine. Using UTF-8 encoding as\ndefault would narrow the use for the default functions to only work\non real text data.</p></li>\n<li><p>The pure ISO-Latin-1 implementations of the functions will be the\nmost efficient ones as no data checking at all is needed. Any byte\nvalue is acceptable in any version. Some functions are usable on\nUTF-8 strings even though they expect ISO-Latin-1 data. The\ndifference between the ISO-Latin-1 version and the UTF-8 version\nbeing only indata control. If the data given to, for example\n<code>bstring:concat</code> is already checked for correct UTF-8, the simpler\nISO-Latin-1 version of the function is both more efficient and\nguaranteed to give as correct output as the input:</p>\n\n<pre><code>    CorrectUtf8_1 = give_me_good_string(),\n    CorrectUtf8_2 = give_me_another_good_string(),\n    CorrectUtf8_3 = bstring:concat(CorrectUtf8_1, latin1, CorrectUtf8_2, latin1, latin1),\n    ...\n</code></pre>\n\n<p>Simply put, ISO-Latin-1 versions of the functions are more generally\nuseful than pure UTF-8 versions and are also more efficient.</p></li>\n<li><p>A wrapper module providing pure UTF-8 interfaces can easily be\nwritten. The overhead of going via a wrapper would be relatively\nlower for an UTF-8 wrapper than for an ISO-Latin-1 ditto, as the\noverhead of character decoding/encoding of UTF-8 strings in the\nmodule would be quite high. Simply put, a wrapper would cost very\nlittle compared to the cost of checking the data for UTF-8\ncorrectness.</p>\n\n<p>I actually suggest a module <code>ubstring</code> that has the part of the\n<code>bstring</code> interface where a default encoding is implied, but with\nthe difference that UTF-8 is expected. For example, a function\n<code>ubstring:tokens/2</code> would look like this:</p>\n\n<pre><code>tokens(S,L) -&gt; bstring:tokens(S,unicode,L).\n</code></pre>\n\n<p>Quite simple.</p></li>\n</ul>\n\n<p>To conclude, I think all functions should exist in a version where no\nencoding is supplied and ISO-Latin-1 encoded data is expected.</p>\n\n<h2>Languages</h2>\n\n<p>Even though Unicode characters can be used to express text in most\nknown, living and dead scripts, language and region knowledge is a\ncompletely different thing. String interfaces often impose language\nspecific properties of the string, like left-to-right writing\ndirection, the notion of words built up by space separated groups of\ncharacters, ways of representing numbers and decimal points etc. As\nErlang does not (yet) have a way of specifying such language-, or\nregion-specific properties of a string, the interface should not\ncontain language-dependent functionality. The <code>string</code> module did not\noriginally contain such functions (except that character alignment\nfunctions were named <code>left</code> and <code>right</code>), but unfortunately\nfunctions like <code>to_float</code> and <code>to_upper</code> have been added.</p>\n\n<p>I think that having language-dependent functions in the <code>string</code>\nmodule was a mistake and I do not want to make that mistake\nagain. Hence I have not included such functions or names in\n<code>bstring</code>.</p>\n\n<p>I rather suggest \"Locale\" functionality as a subject of a future\nEEP. For those who consider that simple, try to write a correct\n<code>to_upper</code> function for just all European languages, make sure it\nworks on all platforms that can run Erlang... Maybe not rocket science, but a\n<em>lot</em> of metadata is required. Data that is not always available in\nthe underlying OS, but probably needs to be distributed with Erlang/OTP for\nconsistent functionality. Definitely worth it's own EEP.</p>\n\n<h2>Word separators</h2>\n\n<p>In connection with language independence, I think we should drop the\nnotion of <em>words</em> as a group of characters separated by space. The word\n\"token\" is more general and does not in the same way indicate language\nconstructs. The <code>string</code> module has the ASCII space character as a\ndefault for word separation, which I think should be dropped in\n<code>bstring</code>. Whatever should separate tokens should be supplied,\npossibly as alternatives. I therefore suggest the functions\n<code>bstring:num_tokens</code> and <code>bstring:nth_token</code> to fulfill the\nfunctionality of <code>string:words</code> and <code>string:sub_word</code>.</p>\n\n<p>As in <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>, I suggest a new function <code>split</code> to handle the case\nof multi-character separators for tokens. A compilation of <code>split</code>\nand <code>join</code> makes a convenient <code>replace</code> function too.</p>\n\n<h2>Left-to-right or Right-to-left</h2>\n\n<p>As mentioned earlier, I don't think direction of the graphical\nrepresentation should be implied in the interface, why I suggest using\nnotions like leading and trailing (meaning leading and trailing\ncharacters in the binary) rather than any directional notions. I also\nthink aligning strings (like in <code>strings:right</code> etc.) could be solved\nin one function <code>align</code>, taking one of the atoms <code>leading</code>,\n<code>trailing</code> or <code>center</code> as a parameter, if it should at all be\nimplemented.</p>\n\n<h2>Naming and duplicated functionality</h2>\n\n<p>I definitely do not think we should have all interfaces from\n<code>string</code> duplicated to <code>bstring</code>. Especially interfaces that are\naliases should not be carried along to the <code>bstring</code> module. Most\nfunctions in the <code>string</code> module however have short and fairly\ndescribing names, often similar to names found in other languages. I\nthink using a <code>r</code> prefix for functionality working from the end of\nthe string towards the beginning is a good choice, as is <code>c</code> for\ncomplement.</p>\n\n<h2>Byte oriented versus character oriented return values</h2>\n\n<p>Some functions in <code>string</code>, that are certainly useful, return numbers\ndenoting character positions. The same functions should definitely be\npresent in the <code>bstring</code> module and the return values should\ndefinitely be character oriented. However byte offsets are definitely\nuseful, for example if we use a function like <code>span</code> to find the\nfirst character not in a set of characters, we might want the byte\noffset of that first character too.</p>\n\n<p>I suggest adding some interfaces returning byte offsets, or <em>part()'s</em>\nlike the ones used in the <code>binary</code> module and by <code>re</code>, to cope\nwith the need for byte offsets and lengths in some circumstances. A\n<code>b</code> suffix to the function name could denote such functionality, so\nthat <code>bstring:span</code> returns a character position while\n<code>bstring:spanb</code> returns a byte position and <code>btring:str</code> returns a\ncharacter position and <code>bstring:strb</code> returns a <em>part()</em>. Although\nthis will in the end give rise to more functions in the interface,\nhaving return-type-changing options in an option list is not the way\nto go (I know, I have them in <code>re</code>, but it's still not generally a\ngood idea...).</p>\n\n<h2>New or replaced functionality</h2>\n\n<p>When writing a general string module, there is no end to the new, more\nor less esoteric, functionality one could add. I think we, at least\nin an initial implementation, should stick to the functionality\noutlined in <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>, namely extending <code>str</code> and friends to\noptionally take a list of alternative strings to search for, add a\nfunction <code>split</code> to take care of multi-character separators (as\nopposed to single character separators in the function <code>tokens</code>) and\na substitution function, which I think should be named <code>replace</code> as\nin other modules.</p>\n\n<p>The use of pre-compiled matches from the <code>binary</code> module is however\nnot a good idea, as the <code>binary</code> module has no notion of character\nencoding. Search strings need to be given in defined character\nencodings and both the \"haystacks\" and the \"needles\" encoding need to\nbe known when doing an efficient search. So - no pre-compiled search\nexpressions.</p>\n\n<h2>Excerpt of a suggested manual page</h2>\n\n<p>As made obvious above, I prefer the name <code>bstring</code> for a binary\nstring module in favor of the more verbose name <code>binary_string</code>\noriginally suggested. In that module <code>bstring</code>, I suggest the\nfollowing interfaces, expressed as in a manual page of OTP.</p>\n\n<h2>DATA TYPES</h2>\n\n<pre><code>    encoding() = latin1 | unicode | utf8\n      - The encoding of characters in the binary data, both input and output\n    bstring() \n      - Binary with characters encoded either in ISO-Latin-1 or UTF-8\n    unicode_char() = non_negative_integer() \n      - An integer representing a valid unicode codepoint\n    non_negative_integer()\n      - An integer &gt;= 0\n</code></pre>\n\n<h2>EXPORTS</h2>\n\n<h3><code>align(BString, Alignment, Number, Char) -&gt; Result</code></h3>\n\n<h3><code>align(BString, Encoding, Alignment, Number, Char) -&gt; Result</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = Result = bstring()\nEncoding = encoding()\nAlignment = leading | trailing | center\nNumber = non_negative_integer()\nChar = unicode_char()\n</code></pre>\n\n<p>Aligns the characters in <code>BString</code> in a <code>Result</code> of <code>Number</code> characters according to the <code>Alignment</code> parameter. Alignment is done by inserting the character <code>Char</code> in the beginning or end (or both) of the binary string. </p>\n\n<p>The resulting binary string will contain exactly <code>Number</code> characters, the string is truncated if it contains more characters than <code>Number</code> - either at the end if <code>Alignment</code> is <code>leading</code>, or at the beginning if <code>Alignment</code> is <code>trailing</code>, or at both ends if <code>Alignment</code> is <code>center</code> . If <code>Encoding</code> is <code>unicode</code>, the <code>Result</code> may well contain more bytes than <code>Number</code>, as one character may require several bytes. </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:align(&lt;&lt;\"Hello\"&gt;&gt;, latin1, center, 10, $.).\n&lt;&lt;\"..Hello...\"&gt;&gt;\n</code></pre>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, <code>Encoding</code> or <code>Alignment</code> has an invalid value, the character <code>Char</code> cannot be encoded in the character encoding given as <code>Encoding</code> or any of the parameters are of the wrong type. </p>\n\n<h3><code>chr(BString, Character) -&gt; Position</code></h3>\n\n<h3><code>chr(BString, Encoding, Character) -&gt; Position</code></h3>\n\n<h3><code>rchr(BString, Character) -&gt; Position</code></h3>\n\n<h3><code>rchr(BString, Encoding, Character) -&gt; Position</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = encoding()\nCharacter = unicode_char()\nPosition = integer()\n</code></pre>\n\n<p>Returns the (zero-based) character position of the first/last occurrence of <code>Character</code> in <code>BString</code> . <code>-1</code> is returned if <code>Character</code> does not occur. </p>\n\n<p>Note that the character position is not the same as the byte position. Use the <code>chrb</code> and <code>rchrb</code> functions to get the byte positions. </p>\n\n<p>If <code>Character</code> cannot be represented in the encoding, it is not an error, you are just certain to get <code>-1</code> as a return value. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>chrb(BString, Character) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<h3><code>chrb(BString, Encoding, Character) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<h3><code>rchrb(BString, Character) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<h3><code>rchrb(BString, Encoding, Character) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = encoding()\nCharacter = unicode_char()\nBytePosition = integer()\nByteLength = non_negative_integer()\n</code></pre>\n\n<p>Works as <code>chr</code> and <code>rchr</code> respectively, but returns the byte position and byte length of the character. </p>\n\n<p>If the character is not found, <code>{-1,0}</code> is returned. </p>\n\n<h3><code>concat(BString1, BString2) -&gt; BString3</code></h3>\n\n<h3><code>concat(BString1, Encoding1, BString2, Encoding2, Encoding3) -&gt; BString3</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString1 = BString2 = BString3 = bstring()\nEncoding1 = Encoding2 = Encoding3 = encoding()\n</code></pre>\n\n<p>Concatenates two binary strings to form a new string. Returns the new binary string in the encoding given by Encoding3. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if <code>BString1</code> or <code>Bstring2</code> does not contain characters encoded according to the <code>Encoding1</code> and <code>Encoding2</code> parameters, the encoding parameters has an invalid value, the codepoints in the in-parameters cannot be represented in the output encoding or any of the parameters are of the wrong type. </p>\n\n<h3><code>equal(BString1, BString2) -&gt; bool()</code></h3>\n\n<h3><code>equal(BString1, Encoding1, BString2, Encoding2) -&gt; bool()</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString1 = BString2 = bstring()\nEncoding1 = Encoding2 = encoding()\n</code></pre>\n\n<p>Tests whether two binary strings are equal. Returns <code>true</code> if they are, otherwise <code>false</code> . </p>\n\n<p><code>Encoding1</code> is the encoding of <code>BString1</code> and <code>Encoding2</code> is the encoding of <code>BString2</code> . </p>\n\n<p>Note that the strings can have different encoding and that it is the character values encoded in the strings that are compared. The binary strings are scanned as long as they are equal, meaning that if the function returns <code>true</code>, both strings are correctly encoded, while a return value of <code>false</code> does not guarantee correct encoding in both binary strings. An exception is raised if faulty encoding is determined while comparing the strings, not if parts of the string not inspected contain encoding errors. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if wrongly encoded characters, according to the encoding parameters, are encountered during comparison, the encoding parameters has an invalid value or any of the parameters are of the wrong type. </p>\n\n<h3><code>join(BStringList, Separator) -&gt; Result</code></h3>\n\n<h3><code>join(BStringList, BStringListEncoding, Separator, SeparatorEncoding, ResultEncoding) -&gt; Result</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BStringList = [bstring()]\nBStringListEncoding = SeparatorEncoding = ResultEncoding = encoding()\nSeparator = bstring()\nResult = bstring()\n</code></pre>\n\n<p>Returns a binary string with the elements of <code>BStringList</code> separated by the binary string in <code>Seperator</code> . </p>\n\n<p>All the binary strings in <code>BStringList</code> should have the same encoding (given as <code>BStringListEncoding</code> . The <code>Separator</code> can however have a different encoding (given as <code>SeparatorEncoding</code> ), as can the <code>Result</code> (given as <code>ResultEncoding</code> ). </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:join([&lt;&lt;\"one\"&gt;&gt;, &lt;&lt;\"two\"&gt;&gt;, &lt;&lt;\"three\"&gt;&gt;], latin1, &lt;&lt;\", \"&gt;&gt;, latin1, latin1).\n&lt;&lt;\"one, two, three\"&gt;&gt;\n</code></pre>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if binary strings in <code>BStringList</code> or the <code>Separator</code> do not contain characters encoded according to the <code>BStringListEncoding</code> and <code>SeparatorEncoding</code> parameters respectively, the encoding parameters has an invalid value, the codepoints in the in-parameters cannot be represented in the output encoding <code>ResultEncoding</code> or any of the parameters are of the wrong type. </p>\n\n<h3><code>len(BString) -&gt; Length</code></h3>\n\n<h3><code>len(BString, Encoding) -&gt; Length</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = encoding()\nLength = non_negative_integer()\n</code></pre>\n\n<p>Returns the number of characters in the binary string. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value or any of the parameters are of the wrong type. </p>\n\n<h3><code>nth_token(BString, N, CharList) -&gt; Result</code></h3>\n\n<h3><code>nth_token(BString, Encoding, N, CharList) -&gt; Result</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = Result = bstring()\nEncoding = encoding()\nCharList = [ unicode_char() ]\nN = non_negative_integer()\n</code></pre>\n\n<p>Returns the token number <code>N</code> of <code>BString</code> (zero-based). Tokens are separated by the characters in <code>CharList</code> . </p>\n\n<p>The returned token will have the same encoding as <code>BString</code> . </p>\n\n<p>For example: </p>\n\n<pre><code>&gt; bstring:nth_token(&lt;&lt;\" Hello old boy !\"&gt;&gt;,latin1,3,[$o, $ ]).\n&lt;&lt;\"ld b\"&gt;&gt;\n</code></pre>\n\n<p><code>CharList</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>CharList</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>\n\n<p>Values of <code>N</code> >= number of tokens in <code>BString</code> will result in the empty binary string <code>&lt;&lt;&gt;&gt;</code> being returned. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>num_tokens(BString, CharList) -&gt; Count</code></h3>\n\n<h3><code>num_tokens(BString, Encoding, CharList) -&gt; Count</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = encoding()\nCharList = [ unicode_char() ]\nCount = non_negative_integer()\n</code></pre>\n\n<p>Returns the number of tokens in <code>String</code>, separated by the characters in <code>CharList</code> . </p>\n\n<p>The result is the same as for length(bstring:tokens(BString,Encoding,CharList)), but avoids building the result. </p>\n\n<p>For example: </p>\n\n<pre><code>&gt; num_tokens(&lt;&lt;\" Hello old boy!\"&gt;&gt;, latin1, [$o, $ ]).\n4\n</code></pre>\n\n<p><code>CharList</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>CharList</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>span(BString, Chars) -&gt; Length</code></h3>\n\n<h3><code>span(BString, Encoding, Chars) -&gt; Length</code></h3>\n\n<h3><code>rspan(BString, Chars) -&gt; Length</code></h3>\n\n<h3><code>rspan(BString, Encoding, Chars) -&gt; Length</code></h3>\n\n<h3><code>cspan(BString, Chars) -&gt; Length</code></h3>\n\n<h3><code>cspan(BString, Encoding, Chars) -&gt; Length</code></h3>\n\n<h3><code>rcspan(BString, Chars) -&gt; Length</code></h3>\n\n<h3><code>rcspan(BString, Encoding, Chars) -&gt; Length</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = encoding()\nChars = [ integer() ]\nLength = non_negative_integer()\n</code></pre>\n\n<p>Returns the length (in characters) of the maximum initial (span and cspan) or trailing (rspan and rcspan) segment of BString, which consists entirely of characters from (span and rspan), or not from (cspan and rcspan) Chars. </p>\n\n<p><code>Chars</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>Char</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>\n\n<p>For example: </p>\n\n<pre><code>&gt; bstring:span(&lt;&lt;\"\\t    abcdef\"&gt;&gt;,latin1,\" \\t\").\n5\n&gt; bstring:cspan((&lt;&lt;\"\\t    abcdef\"&gt;&gt;,latin1, \" \\t\").\n0\n</code></pre>\n\n<p>Codepoints in <code>Chars</code> that can not be represented by <code>Encoding</code> is not considered an error. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>spanb(BString, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>spanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>rspanb(BString, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>rspanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>cspanb(BString, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>cspanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>rcspanb(BString, Chars) -&gt; ByteLength</code></h3>\n\n<h3><code>rcspanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = encoding()\nChars = [ integer() ]\nByteLength = non_negative_integer()\n</code></pre>\n\n<p>Work exactly as the functions <code>span</code>, <code>rspan</code>, <code>cspan</code> and <code>rcspan</code> respectively, but returns the number of bytes rather than the number of characters. </p>\n\n<h3><code>split(BString, Separators, Where) -&gt; Tokens</code></h3>\n\n<h3><code>split(BString, Encoding, Separators, SepEncoding, Where, ReturnEncoding) -&gt; Tokens</code></h3>\n\n<p>Types:</p>\n\n<pre><code>String = bstring()\nEncoding = SepEncoding = ReturnEncoding = encoding()\nSeparators = [ bstring() ]\nWhere = first | last | all\nTokens = [bstring()]\n</code></pre>\n\n<p>Returns a list of tokens in <code>BString</code>, separated by the binary strings in <code>Separators</code> . </p>\n\n<p>The <code>Tokens</code> returned are encoded according to <code>ReturnEncoding</code> . </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:split(&lt;&lt;\"abc defxxghix jkl\"&gt;&gt;, latin1, [&lt;&lt;\"x\"&gt;&gt;,&lt;&lt;\" \"&gt;&gt;],all,latin1).\n[&lt;&lt;\"abc\"&gt;&gt;, &lt;&lt;\"def\"&gt;&gt;, &lt;&lt;\"ghi\"&gt;&gt;, &lt;&lt;\"jkl\"&gt;&gt;]\n</code></pre>\n\n<p><code>Separators</code> is to be viewed as a <em>set</em> of binary strings, order is not significant. Codepoints given in <code>Separators</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>\n\n<p>The <code>Where</code> parameter specifies at which occurrence of any of the <code>Separators</code> the binary string is to be split, either at the <code>first</code> occurrence, the <code>last</code> occurrence or at <code>all</code> occurrences, in which case the <code>Tokens</code> may be an arbitrary long list. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if <code>BString</code> or <code>Separators</code> does not contain characters encoded according to the <code>Encoding</code> and <code>SepEncoding</code> parameters respectively, the resulting tokens cannot be encoded in the <code>ReturnEncoding</code>, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>str(BString, SubBStrings) -&gt; Position</code></h3>\n\n<h3><code>str(BString, Encoding, SubBStrings, SubEnc) -&gt; Position</code></h3>\n\n<h3><code>rstr(BString, SubBStrings) -&gt; Position</code></h3>\n\n<h3><code>rstr(BString, Encoding, SubBStrings, SubEnc) -&gt; Position</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nSubBString = bstring() | [ bstring() ]\nEncoding = SubEnc = encoding()\nPosition = integer()\n</code></pre>\n\n<p>Returns the (zero-based) character position where the first/last occurrence of any of the <code>SubBStrings</code> begins in <code>BString</code> . <code>-1</code> is returned if <code>SubBString</code> does not exist in <code>BString</code> . </p>\n\n<p>Note that the <code>Character</code> position is not the same as the byte position. Use the <code>strb</code> and <code>rstrb</code> functions to get the byte positions. </p>\n\n<p>The encoding need not be the same for <code>BString</code> and <code>SubBStrings</code>, however all strings in SubBStrings need to have the same encoding. </p>\n\n<p>If the codepoints in SubBString can not be represented in the encoding of BString, that is not an error, but will always result in the return value -1. </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:str(&lt;&lt;\" Hello Hello World World \"&gt;&gt;,latin1,&lt;&lt;\"Hello World\"&gt;&gt;,latin1).\n7\n</code></pre>\n\n<p>Note that if both encodings are the same and repeated searches with the same <code>SubBStrings</code> are to be performed, it is more efficient to use the <code>binary:match/{2,3}</code> functions with a precompiled pattern on the raw binary data. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> or <code>SubBString</code> does not contain characters encoded according to the <code>Encoding</code> and <code>SubEnc</code> parameters, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>strb(BString, SubBStrings) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<h3><code>strb(BString, Encoding, SubBStrings, SubEnc) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<h3><code>rstrb(BString, SubBStrings) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<h3><code>rstrb(BString, Encoding, SubBStrings, SubEnc) -&gt; {BytePosition, ByteLength}</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nSubBString = bstring() | [ bstring() ]\nEncoding = SubEnc = encoding()\nBytePosition = integer()\nByteLength = non_negative_integer()\n</code></pre>\n\n<p>Works as <code>str</code> and <code>rstr</code> respectively, but returns the byte position and byte length of the found substring. </p>\n\n<p>Note that <code>ByteLength</code> is the length the found substring has in <code>BString</code>, regardless of the encoding in <code>SubBStrings</code>, so that <code>ByteLength</code> may be both larger and smaller than <code>byte_size(SubBString)</code> depending on the binary string's encoding. </p>\n\n<p>If the substring is not found, <code>{-1,0}</code> is returned. </p>\n\n<h3><code>strip(BString, Which, CharList) -&gt; Result</code></h3>\n\n<h3><code>strip(BString, Encoding, Which, CharList) -&gt; Result</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = Result = bstring()\nEncoding = encoding()\nWhich = leading | trailing | both\nCharList = [ unicode_char() ]\n</code></pre>\n\n<p>Removes leading (<code>Which</code> = <code>leading</code>), trailing (<code>Which</code> = <code>trailing</code>) or both leading and trailing (<code>Which</code> = <code>both</code>) characters belonging to the set indicated by <code>CharList</code> from the binary string <code>BString</code> . </p>\n\n<p>This is essentially the same as using <code>spanb</code> and/or <code>rspanb</code> in combination with bit syntax to remove the characters. </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:strip(&lt;&lt;\"...He.llo.....\"&gt;&gt;, latin1, both, [$.]).\n&lt;&lt;\"He.llo\"&gt;&gt;\n</code></pre>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if scanned part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, <code>Encoding</code> or <code>Which</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>replace(BString, Separators, Replacement, Where) -&gt; Result</code></h3>\n\n<h3><code>replace(BString, Encoding, Separators, SeparatorsEncoding, Replacement, ReplacementEncoding, Where, ResultEncoding) -&gt; Result</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = bstring()\nEncoding = SeparatorsEncoding = ReplacementEncoding, ResultEncoding = encoding()\nSeparators = [ bstring() ]\nReplacement = bstring()\nWhere = first | last | all\nResult = bstring()\n</code></pre>\n\n<p>Produces the same result as </p>\n\n<pre><code>bstring:join(bstring:split(BString,Encoding,Separators,SeparatorsEncoding,Where,\n                           unicode),\n             unicode,Replacement,ReplacementEncoding,ResultEncoding)\n</code></pre>\n\n<p>but with less overhead. </p>\n\n<h3><code>substr(BString, Start, Length) -&gt; SubBString</code></h3>\n\n<h3><code>substr(BString, Encoding, Start, Length) -&gt; SubBString</code></h3>\n\n<p>Types:</p>\n\n<pre><code>BString = SubBString = bstring()\nEncoding = bstring()\nStart = integer()\nLength = non_negative_integer() | infinity\n</code></pre>\n\n<p>Returns a substring of <code>String</code>, starting at the zero-based character position <code>Start</code>, and ending at the end of the binary string (if <code>Length</code> is <code>infinity</code> or up to, but not including, the character position <code>Start+Length</code> (if <code>Length</code> is a non negative integer). </p>\n\n<p>The returned <code>SubBString</code> will have the same encoding as <code>BString</code> . </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:substr(&lt;&lt;\"Hello World\"&gt;&gt;, latin1, 3, 5).\n&lt;&lt;\"lo Wo\"&gt;&gt;\n</code></pre>\n\n<p>A negative value of <code>Start</code> denotes <code>abs(Start)</code> characters from the <em>end</em> of <code>BString</code>, so that <code>-1</code> is the last character position in the binary string. </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:substr(&lt;&lt;\"Hello World\"&gt;&gt;, latin1, -1, 3).\n&lt;&lt;\"rld\"&gt;&gt;\n</code></pre>\n\n<p>As the true length of an UTF-8 encoded binary string is quite costly to determine ( <code>O(N)</code>, where <code>N</code> is the number of bytes in the binary), the function is very forgiving about positions given outside of the string, both <code>Start</code> s and <code>Length</code> s. Character positions outside of the string in either direction are collapsed to the empty binary string. </p>\n\n<p>Examples: </p>\n\n<pre><code>&gt; bstring:substr(&lt;&lt;\"01234\"&gt;&gt;, latin1, 5, 5).\n&lt;&lt;&gt;&gt;\n&gt; bstring:substr(&lt;&lt;\"01234\"&gt;&gt;, latin1, 4, 5).\n&lt;&lt;\"4\"&gt;&gt;\n&gt; bstring:substr(&lt;&lt;\"01234\"&gt;&gt;, latin1, -5, 100).\n&lt;&lt;\"01234\"&gt;&gt;\n&gt; bstring:substr(&lt;&lt;\"01234\"&gt;&gt;, latin1, -6, 1).\n&lt;&lt;&gt;&gt;    \n&gt; bstring:substr(&lt;&lt;\"01234\"&gt;&gt;, latin1, -6, 2).\n&lt;&lt;\"0\"&gt;&gt;\n</code></pre>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h3><code>tokens(BString, SeparatorList) -&gt; Tokens</code></h3>\n\n<h3><code>tokens(BString, Encoding, SeparatorList) -&gt; Tokens</code></h3>\n\n<p>Types:</p>\n\n<pre><code>String = bstring()\nEncoding = encoding\nSeparatorList = [ non_negative_integer() ]\nTokens = [bstring()]\n</code></pre>\n\n<p>Returns a list of tokens in <code>BString</code>, separated by the characters in <code>SeparatorList</code> . </p>\n\n<p>The <code>Tokens</code> returned are encoded in the same character encoding as the <code>BString</code> . </p>\n\n<p>Example: </p>\n\n<pre><code>&gt; bstring:tokens(&lt;&lt;\"abc defxxghix jkl\"&gt;&gt;, latin1, [$x,$ ]).\n[&lt;&lt;\"abc\"&gt;&gt;, &lt;&lt;\"def\"&gt;&gt;, &lt;&lt;\"ghi\"&gt;&gt;, &lt;&lt;\"jkl\"&gt;&gt;]\n</code></pre>\n\n<p><code>SeparatorList</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>SeparatorList</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>\n\n<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>\n\n<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>\n\n<h1>Performance</h1>\n\n<p>This module can, and probably should, be implemented entirely in\nErlang, no BIF's or NIF's are needed.  Both the <code>binary</code> and\n<code>unicode</code> modules can be utilized to speed up conversion and indata\nchecking. The Unicode versions will definitely be slower than the\nISO-Latin-1 versions, as character encoding, decoding and checking is\nbound to produce overhead.</p>\n\n<p>The suggested wrapper <code>ubstring</code> should not impose any significant\ncost compared to calling <code>bstring</code> with all encoding arguments set\nto <code>unicode</code>.</p>\n\n<p>The idea is to make string manipulation using binaries convenient as\nit has a great positive impact on systems memory-wise. Increased speed\ncompared to list-oriented strings is not the goal, although it may\nwell be a side-effect.</p>\n\n<h1>Reference implementation</h1>\n\n<p>No specific reference implementation is made, the code will however be made available \non GitHub during any development. </p>\n\n<h1>Copyright</h1>\n\n<p>This document is licensed under the <a href=\"http://creativecommons.org/licenses/by/3.0/\" title=\"Creative Commons Attribution 3.0 License\">Creative Commons license</a>.</p>\n"}},"__N_SSG":true}