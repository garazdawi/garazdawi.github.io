<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/a-brief-BEAM-primer/">A brief introduction to BEAM</a></h3><p><em>Tuesday, 20 October 2020<!-- --> - <!-- -->John HÃ¶gberg</em></p><p>This post is a brief primer on BEAM, the virtual machine that executes user
code in the Erlang Runtime System (ERTS). It&#x27;s intended to help those new to
BEAM follow an upcoming series of posts about the JIT in OTP 24, leaving
implementation details for later.</p><p>BEAM is often confused with ERTS and it&#x27;s important to distinguish between the
two; BEAM is just the virtual machine and it has no notion of processes, ports,
ETS tables, and so on. It merely executes instructions and while ERTS has
influenced their design, it doesn&#x27;t affect what they do when the code is
running, so you don&#x27;t need to understand ERTS to understand BEAM.</p><p>BEAM is a register machine, where all instructions operate on named registers.
Each register can contain any Erlang term such as an integer or a tuple, and it
helps to think of them as simple variables. The two most important kinds of
registers are:</p><ul><li><code>X</code>: these are used for temporary data and passing data between functions.
They don&#x27;t require a stack frame and can be freely used in any function, but
there are certain limitations which we&#x27;ll expand on later.</li><li><code>Y</code>: these are local to each stack frame and have no special
limitations beyond needing a stack frame.</li></ul><p>Control flow is handled by instructions that test a certain condition and
either move on to the next instruction or branch to its <em>fail label</em>, noted by
<code>{f,Index}</code>. For example <code>{test,is_integer,{f,7},[{x,0}]}.</code> checks if <code>{x,0}</code>
contains an integer and jumps to label 7 if it doesn&#x27;t.</p><p>Function arguments are passed from left to right in <code>X</code> registers, starting at
<code>{x,0}</code>, and the result is returned in <code>{x,0}</code>.</p><p>It&#x27;s easier to explain how this fits together through example, so let&#x27;s walk
through a few:</p><pre><code class="language-erlang">sum_tail(List) -&gt;
    sum_tail(List, 0).

sum_tail([Head | Tail], Acc) -&gt;
    sum_tail(Tail, Head + Acc);
sum_tail([], Acc) -&gt;
    Acc.</code></pre><p>Let&#x27;s use <code>erlc -S</code> to look at the instructions one by one:</p>&lt;pre class=&quot;highlight&quot;&gt;
&lt;em&gt;%% sum_tail/1, entry label is 2&lt;/em&gt;
{function, sum_tail, 1, 2}.

  &lt;em&gt;%% Marks a jump target with the label 1.&lt;/em&gt;
  {label,1}.

    &lt;em&gt;%% Special instruction that raises a function_clause
    %% exception. Unused in this function.&lt;/em&gt;
    {func_info,{atom,primer},{atom,sum_tail},1}.

  {label,2}.
    &lt;em&gt;%% The meat of the function starts here.
    %%
    %% Our only argument - &lt;b&gt;List&lt;/b&gt; - is in &lt;b&gt;{x,0}&lt;/b&gt; and
    %% since sum_tail/2 expects it to be the first
    %% argument we can leave it be. We&#x27;ll pass the
    %% integer 0 as the second argument in &lt;b&gt;{x,1}&lt;/b&gt;.&lt;/em&gt;
    {move,{integer,0},{x,1}}.

    &lt;em&gt;%% Tail call sum_tail/2, whose entry label is 4.&lt;/em&gt;
    {call_only,2,{f,4}}.

&lt;em&gt;%% sum_tail/2, entry label is 4&lt;/em&gt;
{function, sum_tail, 2, 4}.
  {label,3}.
    {func_info,{atom,primer},{atom,sum_tail},2}.
  {label,4}.

    &lt;em&gt;%% Test whether we have a non-empty list, and jump to
    %% the base case at label 5 if we don&#x27;t.&lt;/em&gt;
    {test,is_nonempty_list,{f,5},[{x,0}]}.

    &lt;em&gt;%% Unpack the list in the first argument, placing the
    %% head in &lt;b&gt;{x,2}&lt;/b&gt; and the tail in &lt;b&gt;{x,0}&lt;/b&gt;.&lt;/em&gt;
    {get_list,{x,0},{x,2},{x,0}}.

    &lt;em&gt;%% Add the head and our accumulator (remember that the
    %% second function argument is in &lt;b&gt;{x,1}&lt;/b&gt;), and place
    %% the result in &lt;b&gt;{x,1}&lt;/b&gt;.
    %%
    %% A fail label of 0 means that we want the
    %% instruction to throw an exception on error, rather
    %% than jump to a given label.&lt;/em&gt;
    {gc_bif,&#x27;+&#x27;,{f,0},3,[{x,2},{x,1}],{x,1}}.

    &lt;em&gt;%% Tail-call ourselves to handle the rest of the list,
    %% the arguments are already in the right registers.&lt;/em&gt;
    {call_only,2,{f,4}}.

  {label,5}.
    &lt;em&gt;%% Test whether our argument was the empty list. If
    %% not, we jump to label 3 to raise a function_clause
    %% exception.&lt;/em&gt;
    {test,is_nil,{f,3},[{x,0}]}.

    &lt;em&gt;%% Return our accumulator.&lt;/em&gt;
    {move,{x,1},{x,0}}.
    return.
&lt;/pre&gt;<p>Simple enough, isn&#x27;t it?</p><p>I glossed over one little detail though; the mysterious number <code>3</code> in the
addition instruction. This number tells us how many <code>X</code> registers hold live
data in case we need more memory, so they can be preserved while the rest are
discarded as garbage. As a consequence, it&#x27;s unsafe to refer to higher <code>X</code>
registers after this instruction as their contents may be invalid (in this case
<code>{x,3}</code> and above).</p><p>Function calls are similar; we may schedule ourselves out whenever we call or
return from a function, and we&#x27;ll only preserve the function arguments/return
value when we do so. This means that all <code>X</code> registers except for <code>{x,0}</code> are
invalid after a call even if you knew for certain that the called function
didn&#x27;t touch a certain register.</p><p>This is where <code>Y</code> registers enter the picture. Let&#x27;s take the previous example
and make it body-recursive instead:</p><pre><code class="language-erlang">sum_body([Head | Tail]) -&gt;
    Head + sum_body(Tail);
sum_body([]) -&gt;
    0.</code></pre><p>.</p>&lt;pre class=&quot;highlight&quot;&gt;
{function, sum_body, 1, 7}.
  {label,6}.
    {func_info,{atom,primer},{atom,sum_body},1}.
  {label,7}.
    {test,is_nonempty_list,{f,8},[{x,0}]}.

    &lt;em&gt;%% Allocate a stack frame with a single Y register.
    %% Since this instruction may need more memory, we
    %% tell the garbage collector that we currently have
    %% one live X register (our list argument in &lt;b&gt;{x,0}&lt;/b&gt;).&lt;/em&gt;
    {allocate,1,1}.

    &lt;em&gt;%% Unpack the list, placing the head in &lt;b&gt;{y,0}&lt;/b&gt; and
    %% the tail in &lt;b&gt;{x,0}&lt;/b&gt;.&lt;/em&gt;
    {get_list,{x,0},{y,0},{x,0}}.

    &lt;em&gt;%% Body-call ourselves. Note that while this kills all
    %% X registers, it leaves Y registers alone so our
    %% head is still valid.&lt;/em&gt;
    {call,1,{f,7}}.

    &lt;em&gt;%% Add the head to our return value and store the
    %% result in &lt;b&gt;{x,0}&lt;/b&gt;.&lt;/em&gt;
    {gc_bif,&#x27;+&#x27;,{f,0},1,[{y,0},{x,0}],{x,0}}.

    &lt;em&gt;%% Deallocate our stack frame and return.&lt;/em&gt;
    {deallocate,1}.
    return.

  {label,8}.
    {test,is_nil,{f,6},[{x,0}]}.

    &lt;em&gt;%% Return the integer 0.&lt;/em&gt;
    {move,{integer,0},{x,0}}.
    return.
&lt;/pre&gt;<p>Notice how the call instruction changed now that we&#x27;re in a stack frame? There
are three different call instructions:</p><ul><li><code>call</code>: ordinary call as in the example. Control flow will resume at
the next instruction when the called function returns.</li><li><code>call_last</code>: tail call when there is a stack frame. The current frame will
be deallocated before the call.</li><li><code>call_only</code>: tail call when there is no stack frame.</li></ul><p>Each of these have a variant for calling functions in other modules (e.g.
<code>call_ext</code>), but they&#x27;re otherwise identical.</p><p>So far we&#x27;ve only looked at using terms, but what about creating them? Let&#x27;s
have a look:</p><pre><code class="language-erlang">create_tuple(Term) -&gt;
    {hello, Term}.</code></pre><p>.</p>&lt;pre class=&quot;highlight&quot;&gt;
{function, create_tuple, 1, 10}.
  {label,9}.
    {func_info,{atom,primer},{atom,create_tuple},1}.
  {label,10}.
    &lt;em&gt;%% Allocate the three words needed for a 2-tuple, with
    %% a liveness annotation of 1 indicating that &lt;b&gt;{x,0}&lt;/b&gt;
    %% is alive in case we need to GC.&lt;/em&gt;
    {test_heap,3,1}.

    &lt;em&gt;%% Create the tuple and place the result in &lt;b&gt;{x,0}&lt;/b&gt;&lt;/em&gt;
    {put_tuple2,{x,0},{list,[{atom,hello},{x,0}]}}.
  
    return.
&lt;/pre&gt;<p>This is a bit magical in the sense that there&#x27;s an unseen register for memory
allocations, but allocation is rarely far apart from use and it&#x27;s usually
pretty easy to follow. The same principle applies for lists (<a href="https://en.wikipedia.org/wiki/Cons">consing</a>),
floats, and funs as well following <a href="https://github.com/erlang/otp/pull/2765">PR 2765</a>.</p><p>More complicated types like maps, big integers, references, and so on are
created by special instructions that may GC on their own (or allocate outside
the heap in a &quot;heap fragment&quot;) as their size can&#x27;t be statically determined in
advance.</p><p>Now let&#x27;s look at something more uncommon: exceptions.</p><pre><code class="language-erlang">exception() -&gt;
    try
        external:call()
    catch
        throw:example -&gt; hello
    end.</code></pre><p>.</p>&lt;pre class=&quot;highlight&quot;&gt;
{function, exception, 0, 12}.
  {label,11}.
    {func_info,{atom,primer},{atom,exception},0}.
  {label,12}.
    {allocate,1,0}.
  
    &lt;em&gt;%% Place a catch tag in &lt;b&gt;{y,0}&lt;/b&gt;. If an exception is
    %% raised while this tag is the most current one,
    %% the control flow will resume at &lt;b&gt;{f,13}&lt;/b&gt; in this
    %% stack frame.&lt;/em&gt;
    {&#x27;try&#x27;,{y,0},{f,13}}.

    {call_ext,0,{extfunc,external,call,0}}.

    &lt;em&gt;%% Deactivate the catch tag before returning with the
    %% result from the call.&lt;/em&gt;
    {try_end,{y,0}}.

    {deallocate,1}.
    return.

  {label,13}.
    &lt;em&gt;%% Uh oh, we&#x27;ve got an exception. Kill the catch tag
    %% and place the exception class in &lt;b&gt;{x,0}&lt;/b&gt;, the error
    %% reason/thrown value in &lt;b&gt;{x,1}&lt;/b&gt;, and the stack trace
    %% in &lt;b&gt;{x,2}&lt;/b&gt;.&lt;/em&gt;
    {try_case,{y,0}}.

    &lt;em&gt;%% Return &#x27;hello&#x27; if the user threw &#x27;example&#x27;&lt;/em&gt;
    {test,is_eq_exact,{f,14},[{x,0},{atom,throw}]}.
    {test,is_eq_exact,{f,14},[{x,1},{atom,example}]}.
    {move,{atom,hello},{x,0}}.
    {deallocate,1}.
    return.

  {label,14}.
    &lt;em&gt;%% Otherwise, rethrow the exception since no catch
    %% clause matched.&lt;/em&gt;
    {bif,raise,{f,0},[{x,2},{x,1}],{x,0}}.
&lt;/pre&gt;<p>By now you&#x27;ve probably noticed how the control flow only moves forward; just
like Erlang itself the only way to loop is through recursion. The one exception
to this is the receive construct, which may loop until a matching message has
been received:</p><pre><code class="language-erlang">selective_receive(Ref) -&gt;
    receive
        {Ref, Result} -&gt; Result
    end.</code></pre><p>.</p>&lt;pre class=&quot;highlight&quot;&gt;
{function, selective_receive, 1, 16}.
  {label,15}.
    {func_info,{atom,primer},{atom,selective_receive},1}.
  {label,16}.
    {allocate,1,1}.

    &lt;em&gt;%% We may be scheduled out while waiting for a
    %% message, so we&#x27;ll preserve our &lt;b&gt;Ref&lt;/b&gt; in &lt;b&gt;{y,0}&lt;/b&gt;.&lt;/em&gt;
    {move,{x,0},{y,0}}.

  {label,17}.
    &lt;em&gt;%% Pick the next message from the process&#x27; message box
    %% and place it in &lt;b&gt;{x,0}&lt;/b&gt;, jumping to label 19 if the
    %% message box is empty.&lt;/em&gt;
    {loop_rec,{f,19},{x,0}}.
  
    &lt;em&gt;%% Does it match our pattern? If not, jump to label 18
    %% and try the next message.&lt;/em&gt;
    {test,is_tuple,{f,18},[{x,0}]}.
    {test,test_arity,{f,18},[{x,0},2]}.
    {get_tuple_element,{x,0},0,{x,1}}.
    {test,is_eq_exact,{f,18},[{x,1},{y,0}]}.

    &lt;em&gt;%% We&#x27;ve got a match, extract the result and remove
    %% the message from the mailbox.&lt;/em&gt;
    {get_tuple_element,{x,0},1,{x,0}}.
    remove_message.
    {deallocate,1}.
    return.

  {label,18}.
    &lt;em&gt;%% The message didn&#x27;t match, loop back to handle our
    %% next message. Note that the current message remains
    %% in the inbox since a different receive may be
    %% interested in it.&lt;/em&gt;
    {loop_rec_end,{f,17}}.

  {label,19}.
    &lt;em&gt;%% Wait until the next message arrives, returning to
    %% the start of the loop when it does. If there&#x27;s a
    %% timeout involved, it will be handled here.&lt;/em&gt;
    {wait,{f,17}}.
&lt;/pre&gt;<p>There&#x27;s not much more to it, and if you feel comfortable following the examples
above you should have no problems with the JIT series.</p><p>If you&#x27;re curious about which instructions there are, you can find a brief
description of every instruction in <a href="https://github.com/erlang/otp/blob/master/lib/compiler/src/genop.tab">genop.tab</a>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"a-brief-BEAM-primer","title":"A brief introduction to BEAM","author":"John HÃ¶gberg","excerpt":"\nThis post is a brief primer on BEAM, the virtual machine that executes user\ncode in the Erlang Runtime System (ERTS). It's intended to help those new to\nBEAM follow an upcoming series of posts about the JIT in OTP 24, leaving\nimplementation details for later.\n\n[genop.tab]: https://github.com/erlang/otp/blob/master/lib/compiler/src/genop.tab,\n[consing]: https://en.wikipedia.org/wiki/Cons,\n[PR 2765]: https://github.com/erlang/otp/pull/2765","article_date":1603152000000,"tags":["BEAM","compiler","erts"],"frontmatter":{"layout":"post","title":"A brief introduction to BEAM","tags":"BEAM compiler erts","author":"John HÃ¶gberg"},"content":"\nThis post is a brief primer on BEAM, the virtual machine that executes user\ncode in the Erlang Runtime System (ERTS). It's intended to help those new to\nBEAM follow an upcoming series of posts about the JIT in OTP 24, leaving\nimplementation details for later.\n\nBEAM is often confused with ERTS and it's important to distinguish between the\ntwo; BEAM is just the virtual machine and it has no notion of processes, ports,\nETS tables, and so on. It merely executes instructions and while ERTS has\ninfluenced their design, it doesn't affect what they do when the code is\nrunning, so you don't need to understand ERTS to understand BEAM.\n\nBEAM is a register machine, where all instructions operate on named registers.\nEach register can contain any Erlang term such as an integer or a tuple, and it\nhelps to think of them as simple variables. The two most important kinds of\nregisters are:\n\n- `X`: these are used for temporary data and passing data between functions.\n  They don't require a stack frame and can be freely used in any function, but\n  there are certain limitations which we'll expand on later.\n- `Y`: these are local to each stack frame and have no special\n  limitations beyond needing a stack frame.\n\nControl flow is handled by instructions that test a certain condition and\neither move on to the next instruction or branch to its _fail label_, noted by\n`{f,Index}`. For example `{test,is_integer,{f,7},[{x,0}]}.` checks if `{x,0}`\ncontains an integer and jumps to label 7 if it doesn't.\n\nFunction arguments are passed from left to right in `X` registers, starting at\n`{x,0}`, and the result is returned in `{x,0}`.\n\nIt's easier to explain how this fits together through example, so let's walk\nthrough a few:\n\n```erlang\nsum_tail(List) -\u003e\n    sum_tail(List, 0).\n\nsum_tail([Head | Tail], Acc) -\u003e\n    sum_tail(Tail, Head + Acc);\nsum_tail([], Acc) -\u003e\n    Acc.\n```\n\nLet's use `erlc -S` to look at the instructions one by one:\n\n\u003cpre class=\"highlight\"\u003e\n\u003cem\u003e%% sum_tail/1, entry label is 2\u003c/em\u003e\n{function, sum_tail, 1, 2}.\n\n  \u003cem\u003e%% Marks a jump target with the label 1.\u003c/em\u003e\n  {label,1}.\n\n    \u003cem\u003e%% Special instruction that raises a function_clause\n    %% exception. Unused in this function.\u003c/em\u003e\n    {func_info,{atom,primer},{atom,sum_tail},1}.\n\n  {label,2}.\n    \u003cem\u003e%% The meat of the function starts here.\n    %%\n    %% Our only argument - \u003cb\u003eList\u003c/b\u003e - is in \u003cb\u003e{x,0}\u003c/b\u003e and\n    %% since sum_tail/2 expects it to be the first\n    %% argument we can leave it be. We'll pass the\n    %% integer 0 as the second argument in \u003cb\u003e{x,1}\u003c/b\u003e.\u003c/em\u003e\n    {move,{integer,0},{x,1}}.\n\n    \u003cem\u003e%% Tail call sum_tail/2, whose entry label is 4.\u003c/em\u003e\n    {call_only,2,{f,4}}.\n\n\u003cem\u003e%% sum_tail/2, entry label is 4\u003c/em\u003e\n{function, sum_tail, 2, 4}.\n  {label,3}.\n    {func_info,{atom,primer},{atom,sum_tail},2}.\n  {label,4}.\n\n    \u003cem\u003e%% Test whether we have a non-empty list, and jump to\n    %% the base case at label 5 if we don't.\u003c/em\u003e\n    {test,is_nonempty_list,{f,5},[{x,0}]}.\n\n    \u003cem\u003e%% Unpack the list in the first argument, placing the\n    %% head in \u003cb\u003e{x,2}\u003c/b\u003e and the tail in \u003cb\u003e{x,0}\u003c/b\u003e.\u003c/em\u003e\n    {get_list,{x,0},{x,2},{x,0}}.\n\n    \u003cem\u003e%% Add the head and our accumulator (remember that the\n    %% second function argument is in \u003cb\u003e{x,1}\u003c/b\u003e), and place\n    %% the result in \u003cb\u003e{x,1}\u003c/b\u003e.\n    %%\n    %% A fail label of 0 means that we want the\n    %% instruction to throw an exception on error, rather\n    %% than jump to a given label.\u003c/em\u003e\n    {gc_bif,'+',{f,0},3,[{x,2},{x,1}],{x,1}}.\n\n    \u003cem\u003e%% Tail-call ourselves to handle the rest of the list,\n    %% the arguments are already in the right registers.\u003c/em\u003e\n    {call_only,2,{f,4}}.\n\n  {label,5}.\n    \u003cem\u003e%% Test whether our argument was the empty list. If\n    %% not, we jump to label 3 to raise a function_clause\n    %% exception.\u003c/em\u003e\n    {test,is_nil,{f,3},[{x,0}]}.\n\n    \u003cem\u003e%% Return our accumulator.\u003c/em\u003e\n    {move,{x,1},{x,0}}.\n    return.\n\u003c/pre\u003e\n\nSimple enough, isn't it?\n\nI glossed over one little detail though; the mysterious number `3` in the\naddition instruction. This number tells us how many `X` registers hold live\ndata in case we need more memory, so they can be preserved while the rest are\ndiscarded as garbage. As a consequence, it's unsafe to refer to higher `X`\nregisters after this instruction as their contents may be invalid (in this case\n`{x,3}` and above).\n\nFunction calls are similar; we may schedule ourselves out whenever we call or\nreturn from a function, and we'll only preserve the function arguments/return\nvalue when we do so. This means that all `X` registers except for `{x,0}` are\ninvalid after a call even if you knew for certain that the called function\ndidn't touch a certain register.\n\nThis is where `Y` registers enter the picture. Let's take the previous example\nand make it body-recursive instead:\n\n```erlang\nsum_body([Head | Tail]) -\u003e\n    Head + sum_body(Tail);\nsum_body([]) -\u003e\n    0.\n```\n.\n\u003cpre class=\"highlight\"\u003e\n{function, sum_body, 1, 7}.\n  {label,6}.\n    {func_info,{atom,primer},{atom,sum_body},1}.\n  {label,7}.\n    {test,is_nonempty_list,{f,8},[{x,0}]}.\n\n    \u003cem\u003e%% Allocate a stack frame with a single Y register.\n    %% Since this instruction may need more memory, we\n    %% tell the garbage collector that we currently have\n    %% one live X register (our list argument in \u003cb\u003e{x,0}\u003c/b\u003e).\u003c/em\u003e\n    {allocate,1,1}.\n\n    \u003cem\u003e%% Unpack the list, placing the head in \u003cb\u003e{y,0}\u003c/b\u003e and\n    %% the tail in \u003cb\u003e{x,0}\u003c/b\u003e.\u003c/em\u003e\n    {get_list,{x,0},{y,0},{x,0}}.\n\n    \u003cem\u003e%% Body-call ourselves. Note that while this kills all\n    %% X registers, it leaves Y registers alone so our\n    %% head is still valid.\u003c/em\u003e\n    {call,1,{f,7}}.\n\n    \u003cem\u003e%% Add the head to our return value and store the\n    %% result in \u003cb\u003e{x,0}\u003c/b\u003e.\u003c/em\u003e\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\n    \u003cem\u003e%% Deallocate our stack frame and return.\u003c/em\u003e\n    {deallocate,1}.\n    return.\n\n  {label,8}.\n    {test,is_nil,{f,6},[{x,0}]}.\n\n    \u003cem\u003e%% Return the integer 0.\u003c/em\u003e\n    {move,{integer,0},{x,0}}.\n    return.\n\u003c/pre\u003e\n\nNotice how the call instruction changed now that we're in a stack frame? There\nare three different call instructions:\n\n- `call`: ordinary call as in the example. Control flow will resume at\n  the next instruction when the called function returns.\n- `call_last`: tail call when there is a stack frame. The current frame will\n  be deallocated before the call.\n- `call_only`: tail call when there is no stack frame.\n\nEach of these have a variant for calling functions in other modules (e.g.\n`call_ext`), but they're otherwise identical.\n\nSo far we've only looked at using terms, but what about creating them? Let's\nhave a look:\n\n```erlang\ncreate_tuple(Term) -\u003e\n    {hello, Term}.\n```\n.\n\u003cpre class=\"highlight\"\u003e\n{function, create_tuple, 1, 10}.\n  {label,9}.\n    {func_info,{atom,primer},{atom,create_tuple},1}.\n  {label,10}.\n    \u003cem\u003e%% Allocate the three words needed for a 2-tuple, with\n    %% a liveness annotation of 1 indicating that \u003cb\u003e{x,0}\u003c/b\u003e\n    %% is alive in case we need to GC.\u003c/em\u003e\n    {test_heap,3,1}.\n\n    \u003cem\u003e%% Create the tuple and place the result in \u003cb\u003e{x,0}\u003c/b\u003e\u003c/em\u003e\n    {put_tuple2,{x,0},{list,[{atom,hello},{x,0}]}}.\n  \n    return.\n\u003c/pre\u003e\n\nThis is a bit magical in the sense that there's an unseen register for memory\nallocations, but allocation is rarely far apart from use and it's usually\npretty easy to follow. The same principle applies for lists ([consing]),\nfloats, and funs as well following [PR 2765].\n\nMore complicated types like maps, big integers, references, and so on are\ncreated by special instructions that may GC on their own (or allocate outside\nthe heap in a \"heap fragment\") as their size can't be statically determined in\nadvance.\n\nNow let's look at something more uncommon: exceptions.\n\n```erlang\nexception() -\u003e\n    try\n        external:call()\n    catch\n        throw:example -\u003e hello\n    end.\n```\n.\n\u003cpre class=\"highlight\"\u003e\n{function, exception, 0, 12}.\n  {label,11}.\n    {func_info,{atom,primer},{atom,exception},0}.\n  {label,12}.\n    {allocate,1,0}.\n  \n    \u003cem\u003e%% Place a catch tag in \u003cb\u003e{y,0}\u003c/b\u003e. If an exception is\n    %% raised while this tag is the most current one,\n    %% the control flow will resume at \u003cb\u003e{f,13}\u003c/b\u003e in this\n    %% stack frame.\u003c/em\u003e\n    {'try',{y,0},{f,13}}.\n\n    {call_ext,0,{extfunc,external,call,0}}.\n\n    \u003cem\u003e%% Deactivate the catch tag before returning with the\n    %% result from the call.\u003c/em\u003e\n    {try_end,{y,0}}.\n\n    {deallocate,1}.\n    return.\n\n  {label,13}.\n    \u003cem\u003e%% Uh oh, we've got an exception. Kill the catch tag\n    %% and place the exception class in \u003cb\u003e{x,0}\u003c/b\u003e, the error\n    %% reason/thrown value in \u003cb\u003e{x,1}\u003c/b\u003e, and the stack trace\n    %% in \u003cb\u003e{x,2}\u003c/b\u003e.\u003c/em\u003e\n    {try_case,{y,0}}.\n\n    \u003cem\u003e%% Return 'hello' if the user threw 'example'\u003c/em\u003e\n    {test,is_eq_exact,{f,14},[{x,0},{atom,throw}]}.\n    {test,is_eq_exact,{f,14},[{x,1},{atom,example}]}.\n    {move,{atom,hello},{x,0}}.\n    {deallocate,1}.\n    return.\n\n  {label,14}.\n    \u003cem\u003e%% Otherwise, rethrow the exception since no catch\n    %% clause matched.\u003c/em\u003e\n    {bif,raise,{f,0},[{x,2},{x,1}],{x,0}}.\n\u003c/pre\u003e\n\nBy now you've probably noticed how the control flow only moves forward; just\nlike Erlang itself the only way to loop is through recursion. The one exception\nto this is the receive construct, which may loop until a matching message has\nbeen received:\n\n```erlang\nselective_receive(Ref) -\u003e\n    receive\n        {Ref, Result} -\u003e Result\n    end.\n```\n.\n\u003cpre class=\"highlight\"\u003e\n{function, selective_receive, 1, 16}.\n  {label,15}.\n    {func_info,{atom,primer},{atom,selective_receive},1}.\n  {label,16}.\n    {allocate,1,1}.\n\n    \u003cem\u003e%% We may be scheduled out while waiting for a\n    %% message, so we'll preserve our \u003cb\u003eRef\u003c/b\u003e in \u003cb\u003e{y,0}\u003c/b\u003e.\u003c/em\u003e\n    {move,{x,0},{y,0}}.\n\n  {label,17}.\n    \u003cem\u003e%% Pick the next message from the process' message box\n    %% and place it in \u003cb\u003e{x,0}\u003c/b\u003e, jumping to label 19 if the\n    %% message box is empty.\u003c/em\u003e\n    {loop_rec,{f,19},{x,0}}.\n  \n    \u003cem\u003e%% Does it match our pattern? If not, jump to label 18\n    %% and try the next message.\u003c/em\u003e\n    {test,is_tuple,{f,18},[{x,0}]}.\n    {test,test_arity,{f,18},[{x,0},2]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {test,is_eq_exact,{f,18},[{x,1},{y,0}]}.\n\n    \u003cem\u003e%% We've got a match, extract the result and remove\n    %% the message from the mailbox.\u003c/em\u003e\n    {get_tuple_element,{x,0},1,{x,0}}.\n    remove_message.\n    {deallocate,1}.\n    return.\n\n  {label,18}.\n    \u003cem\u003e%% The message didn't match, loop back to handle our\n    %% next message. Note that the current message remains\n    %% in the inbox since a different receive may be\n    %% interested in it.\u003c/em\u003e\n    {loop_rec_end,{f,17}}.\n\n  {label,19}.\n    \u003cem\u003e%% Wait until the next message arrives, returning to\n    %% the start of the loop when it does. If there's a\n    %% timeout involved, it will be handled here.\u003c/em\u003e\n    {wait,{f,17}}.\n\u003c/pre\u003e\n\nThere's not much more to it, and if you feel comfortable following the examples\nabove you should have no problems with the JIT series.\n\nIf you're curious about which instructions there are, you can find a brief\ndescription of every instruction in [genop.tab].\n\n[genop.tab]: https://github.com/erlang/otp/blob/master/lib/compiler/src/genop.tab\n[consing]: https://en.wikipedia.org/wiki/Cons\n[PR 2765]: https://github.com/erlang/otp/pull/2765\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"a-brief-BEAM-primer"},"buildId":"In61zFhZNXGgIV-idPSaW","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/In61zFhZNXGgIV-idPSaW/_buildManifest.js" async=""></script><script src="/_next/static/In61zFhZNXGgIV-idPSaW/_ssgManifest.js" async=""></script></body></html>