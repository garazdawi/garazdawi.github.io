{"pageProps":{"item":{"id":"persistent_term","title":"Clever use of persistent_term","author":"Lukas Larsson","excerpt":"\nThis blog post will go through three different uses of [persistent_term](http://erlang.org/doc/man/persistent_term.html)\nthat I have used since its release and explain a bit why they work so well with\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html).","article_date":1567987200000,"tags":["persistent_term literal"],"frontmatter":{"layout":"post","title":"Clever use of persistent_term","tags":"persistent_term literal","author":"Lukas Larsson"},"content":"\nThis blog post will go through three different uses of [persistent_term](http://erlang.org/doc/man/persistent_term.html)\nthat I have used since its release and explain a bit why they work so well with\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html).\n\n# Global counters\n\nLet's say you want to have some global counters in your system. For example the number\nof times an http request has been made. If the system is very busy that counter\nwill be incremented many many times per second by many different processes. Before\nOTP-22 the best way that I know of to get the best performance is by using a striped\nets tables. i.e. something like the code below:\n\n{% raw %}\n```erlang\nincr(Counter) ->\n  ets:update_counter(?MODULE,{Counter,erlang:system_info(scheduler_id)},1).\n\nread(Counter) ->\n  lists:sum(ets:select(?MODULE,[{{{Counter,'_'},'$1'},[],['$1']}])).\n```\n{% endraw %}\n\nThe code above would make sure that there is very little contention on the ets table\nas each scheduler will get a separate slot in the table to update. This comes at the\ncost of more memory usage and that when reading the value you may not get an exact\nvalue.\n\nIn OTP-22 the same can be achieved by using [counters](http://erlang.org/doc/man/counters.html).\n[Counters](http://erlang.org/doc/man/counters.html) have built-in\nsupport for striping by using the `write_concurrency` option, so we don't have\nto write our own implementation for that. They are also faster and use less memory\nthan ets tables, so lots of wins.\n\nThe remaining problem then is finding the reference to the counter. We could put it\ninto ets and then do an [ets:lookup\\_element/3](http://erlang.org/doc/man/ets.html#lookup_element-3)\nwhen updating a counter.\n\n```erlang\ncnt_incr(Counter) ->\n    counters:add(ets:lookup_element(?MODULE,Counter,2),1,1).\n\ncnt_read(Counter) ->\n    counters:get(ets:lookup_element(?MODULE,Counter,2),1).\n```\n\nThis gives a performance degradation of about 20%, so not really what we want.\nHowever, if we place the counter in [persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nlike the code below we get a performance increase by about 140%, which is much\nmore in line with what we wanted.\n\n```erlang\ncnt_pt_incr(Counter) ->\n    counters:add(persistent_term:get({?MODULE,Counter}),1,1).\n\ncnt_pt_read(Counter) ->\n    counters:get(persistent_term:get({?MODULE,Counter}),1).\n```\n\nThe reason for this huge difference is because when the [counters](http://erlang.org/doc/man/counters.html)\nare placed into [persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nthey are placed there as literals which means that at each increment we not longer\nhave to make a copy of the [counters](http://erlang.org/doc/man/counters.html) reference.\nThis is good for two reasons:\n\n1) The amount of garbage will decrease. In my benchmarks the amount of garbage generated\nby `cnt_incr` is 6 words while both `ets_incr` and `cnt_pt_incr` create 3 words.\n\n2) No reference counts have to be modified. What I mean by this is that the\n[counters](http://erlang.org/doc/man/counters.html) reference\nis what is called a magic reference or nif resource. These references work much in the same\nway as reference counted binaries in that they are not copied when sent to different\nprocesses. Instead only a reference count is incremented at copy and then decremented later\nby the GC. This means that for `cnt_incr` we actually have 3 counters that are modified for\neach call. First we increment the reference count on the counter when copying from ets, then\nwe update the actual counter and then eventually we decrement the reference counter. If we\nuse [persistent\\_term](http://erlang.org/doc/man/persistent_term.html), the term is never\ncopied so we don't have to update any reference counters, instead we just have to update the\nactual counter.\n\nHowever, placing the counter in [persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nis not trouble free. In order to delete or replace the counter reference in\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html) we have to do a global\nGC which depending on the system could be very very expensive.\n\nSo this method is best to only be used by global persistent counters that will never be deleted.\n\nYou can find the code for all the above examples and the benchmark I ran\n[here](https://gist.github.com/garazdawi/17cdb5914b950f0acae21d9fcf7e8d41).\n\n# Logger level check\n\nIn [logger](http://erlang.org/doc/man/logger.html) there is a primary logging\nlevel that is the first test to be done for each potential log message to be generated.\nThis check can be done many times per second and needs to be very quick. At the\nmoment of writing (OTP-22) logger uses an ets table to keep all its configuration which\nincludes the primary logging level.\n\nThis is not really ideal as doing a lookup from the ets table means that we have to take\na read-lock to protect against parallel writes to the value. Taking such a read lock is not\nterribly expensive, but when done thousands of times per second it adds up.\n\nSo in [this PR](https://github.com/erlang/otp/pull/2356) I've used\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html) as\na cache for the primary logging level. Now when reading the value from the hot path\nlogger will instead use [persistent\\_term](http://erlang.org/doc/man/persistent_term.html).\nThis removes all locks from the hot path and we only need to do a lookup in the\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html) hash table.\n\nBut what if we need to update the primary logger level? Don't we force a global GC then?\nNo, because the small integer representing the primary logger level is an immediate.\nThis means that the value fits in one machine word and is always copied in its\nentirety to the calling process. Which in turn means that we don't have to do a global\nGC when replacing the value.\n\nWhen doing this we have to be very careful so that the value does not become a heap value\nas the cost of doing an update would explode. However, it works great for logger and\nhas reduced the overhead of a ?LOG_INFO call by about 65% when no logging should be done.\n\n# Large constant data\n\nWe use an internal tool here at the OTP-team called the \"ticket tool\". It basically\nmanages all of the OTP-XYZ tickets that you see in the release notes that comes with\neach release of Erlang/OTP. It is an ancient tool from late 90's or early 00's that\nno one really wants to touch.\n\nOne part of it is a server that contains a cache of all the 17000 or so tickets that\nhave been created through the years. In that server there is a single process that\nhas each ticket and its state in order to speed up searching in the tickets. The state\nof this process is quite large and when it is doing a GC it takes somewhere around 10\nseconds for it to finish. This means that about every 10 minutes the server freezes for\n10 seconds and we get to experience the joy of being Java programmers for a while.\n\nBeing a VM developer I've always thought the solution to this problem is to implement\neither an incremental GC or at least a mark and sweep GC for large heaps. However, the\nticket tool server has never been of high enough priority to make me spend a year or two\nrewriting the GC.\n\nSo, two weeks ago I decided to take a look and instead I used\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nto move the data from the heap into the literal area instead. This was possible to do because\nI know that the majority of tickets are only searched and never changed, so they will\nremain in the literal area forever, while the tickets that do get edited move onto the\nheap of the ticket server. Basically my code change was this:\n\n```erlang\nhandle_info(timeout, State) ->\n  persistent_term:put(?MODULE,State),\n  erlang:start_timer(60 * 60 * 1000, self(), timeout),\n  {noreply,persistent_term:get(?MODULE)}.\n```\n\nThis small change puts the entire gen_server state into the literal area and then\nany changes done to it will pull the data into the heap. This dropped the GC pauses\ndown to be non-noticeable and took considerable less time to implement than a new GC\nalgorithm.\n"}},"__N_SSG":true}