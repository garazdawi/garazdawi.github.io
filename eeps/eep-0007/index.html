<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Alceste Scalas &lt;alceste(at)crs4(dot)it&gt;
Status: Draft
Type: Standards Track
Created: 3-Sep-2007
Erlang-Version: R12B
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 7: <a href="eep-0007.md" title="EEP Source"> Foreign Function Interface (FFI)</a></h2>

<h1>Abstract</h1>

<p>This EEP describes a Foreign Function Interface (FFI) for Erlang/OTP,
that allows to easily perform direct calls of external C functions.
It introduces three new BIFs (<code>ffi:raw_call/3</code>,
<code>erl_ddll:load_library/3</code> and <code>ffi:raw_call/2</code>) that accomplish the main
FFI tasks: loading generic C libraries, making external function calls
and performing automatic Erlang-to-C and C-to-Erlang type conversions.</p>

<p>It also introduces two auxiliary BIFs for converting C buffers/strings
into binaries (<code>ffi:raw_buffer_to_binary/2</code> and
<code>ffi:raw_cstring_to_binary/1</code>), a new <code>ffi</code> Erlang module that
provides a higher-level API with stricter type checking, and some
utility macros.  Finally, it extends <code>erl_ddll:info/2</code> with FFI
information.</p>

<h1>Motivation</h1>

<p>The current Erlang extension mechanisms can be divided in two main
categories:</p>

<ol>
<li><p>absolute stability at the price of speed (C nodes, pipe drivers);</p></li>
<li><p>more speed at the (potential) price of stability (linked-in
drivers).</p></li>
</ol>

<p>Linked-in drivers have thus become the standard way for creating
library bindings when efficiency is an issue.  In both cases, however,
the Erlang driver interface implies the development of relevant
amounts of glue code, mostly because the communication between Erlang
and C always requires data parsing and (de)serialization.  Several
tools have been created in order to autogenerate (at least part of)
that glue: from the (now unmaintained) <a href="http://www1.erlang.org/documentation/doc-4.8.2/lib/ig-1.8/doc/index.html" title="IG: the Erlang Interface Generator, Törnquist and Lundell">IG driver generation tool</a>
to the newer <a href="http://www.erlang.se/workshop/2002/Fritchie.pdf" title="The Evolution of Erlang Drivers and the Erlang Driver Toolkit, Fritchie">Erlang Driver Toolkit (EDTK)</a> and <a href="http://dryverl.objectweb.org/" title="The Dryverl Erlang/C binding compiler">Dryverl</a>.</p>

<p>But, even with the help of these tools, developing an Erlang driver is
a difficult and time-consuming task (especially when interfacing
external libraries with tens or hundreds of functions), and the glue
code itself increases the possibility to introduce bugs --- that, in
the case of linked-in drivers, usually mean VM crashes.  For all these
reasons, the lack of libraries and the difficulty of interfacing them
from other languages is one of the negative aspects that are usually
associated with Erlang.</p>

<p>The same problems also arise when a developer needs to replace
performance-critical portions of his/her Erlang code with optimized C
functions.  In this case, also the data serialization/deserialization
overhead may be a significant issue.</p>

<p>An easier method for interfacing Erlang and C code could drastically
extend the Erlang capabilities and open new usage scenarios.</p>

<h1>Rationale</h1>

<p>This EEP proposes a Foreign Function Interface (FFI) extension that
would allow to easily perform direct C function calls.  This concept
is implemented in almost every language, with two main (non-exclusive)
approaches:</p>

<ol>
<li><p>automatic type conversions between the host and the foreign
language (examples: <a href="http://python.net/crew/theller/ctypes/" title="The CPython package">Python</a>, <a href="http://www.cse.unsw.edu.au/~chak/haskell/ffi/" title="The Haskell 98 Foreign Function Interface">Haskell</a>);</p></li>
<li><p>documented C interface for handling host language types from the
foreign language (examples: <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jni/" title="The Java Native Interface">Java</a>, <a href="http://docs.python.org/ext/ext.html" title="Extending and Embedding the Python Interpreter">Python</a> <a href="http://docs.python.org/api/api.html" title="Python/C API Reference Manual">(API)</a>).</p></li>
</ol>

<p>This EEP follows the first approach, but (when possible) also reuses
part of the existing C Driver API (and, thus, allows to manage
<code>ErlDrvBinary</code> and <code>ErlIOVec</code> pointers in the external C
functions).</p>

<p>The FFI has been designed <em>not</em> to require language changes or
introduce incompatibilities.</p>

<p>The BIFs and functions proposed in this EEP don't give any access to
the Erlang VM internals --- but the called C functions could leak
memory and/or cause the Erlang VM to crash.  The FFI is, thus, not
intended for "casual" Erlang developers: this is a tool designed for
library bindings developers (that should take care of hiding FFI calls
from final users), and advanced programmers looking for an easy (and
efficient) way to call C code from Erlang.</p>

<h1>Overview</h1>

<p>In order to call a C function, the FFI needs a port opened towards the
required C code.  Thus, with the current driver loading mechanism, a
developer would be required to:</p>

<ol>
<li><p>create a C file with a void <code>ErlDrvEntry</code> structure and driver
init function;</p></li>
<li><p>compile it and possibly link it against the required C libraries,
thus obtaining a void Erlang driver;</p></li>
<li><p>load the driver in the Erlang VM, by using <code>erl_ddll:load/2</code>.</p></li>
</ol>

<p>In order to simplify this procedure, this EEP proposes the
<code>erl_ddll:load_library/3</code> function, that allows to load a generic
library in the Erlang VM --- even if it lacks the structure of an
Erlang linked-in driver.</p>

<p><code>erl_ddll:load_library/3</code> also offers an option to preload a list of C
function symbols and signatures, thus precompiling the internal
structures needed for performing dynamic function calls.  Information
about preloaded data can be retrieved with <code>erl_ddll:info/2</code>.</p>

<p>Once a library or driver has been loaded, <code>erlang:open_port/2</code> or
<code>erlang:open_port/1</code> could be used to get a port for the FFI
functions, and perform calls either through the low-level or the
high-level APIs.</p>

<h2>Low-level API</h2>

<p>The low-level FFI methods are denoted by the <code>raw_</code> prefix.  The
main function is the <code>ffi:raw_call/3</code> BIF, that performs a direct C
function call through an open port.  It converts C types to/from
Erlang types.</p>

<p>When taken alone, <code>ffi:raw_call/3</code> has got a major drawback: it introduces
great call overhead, due to the C symbol lookup and the dynamic
construction of the function call.</p>

<p>In order to exploit preloading option of <code>erl_ddll:load_library/3</code>, the
<code>ffi:raw_call/2</code> BIF is introduced: it avoids symbol lookup and call
structure compilation, thus guaranteeing a lower call overhead than
<code>ffi:raw_call/3</code>.</p>

<p>Furthermore, the low-level interface provides two BIFs for creating an
Erlang binary from a C pointer (possibly returned by a FFI call).
These BIFs are <code>ffi:raw_buffer_to_binary/2</code> and
<code>ffi:raw_cstring_to_binary/1</code>.</p>

<h2>High-level API</h2>

<p>The high-level interface is built upon the low-level one.  It
introduces the concept of type-tagged values: any value passed to or
returned from FFI calls has the form of a <code>{Type, Value}</code> tuple.  This
allows to:</p>

<ol>
<li><p>increase the readability of FFI calls;</p></li>
<li><p>make the C calls safer: the consistency of tagged values is checked
before the values themselves are passed to the low-level API.
Furthermore, the preload information given to
<code>erl_ddll:load_library/3</code> is used (when available) to ensure that the
tagged values actually match the function signature;</p></li>
<li><p>simulate the static typing of C code, thus requiring proper and
explicit "casts" when a tagged value needs to be converted to
another type.</p></li>
</ol>

<p>These checks are performed by <code>ffi:call/3</code>, <code>ffi:buffer_to_binary/2</code>
and <code>ffi:cstring_to_binary/1</code> (the type-tagged equivalents of the
low-level BIFs).  Type-tagged values can also be checked with
<code>ffi:check/1</code>.  Furthermore, the allowed minimum and maximum value of
each FFI type can be examined with <code>ffi:min/1</code> and <code>ffi:max/1</code>.</p>

<h2>Utility macros</h2>

<p>The FFI defines a series of utility macros in the <code>ffi_hardcodes.hrl</code>
header file, that could be used for binary matching of C buffers and
structures.</p>

<h1>Specifications</h1>

<h2>Types</h2>

<h3><code>c_func_name()</code></h3>

<pre><code>c_func_name() = atom() | string()
</code></pre>

<p>Name of a C function.</p>

<h3><code>type_tag()</code></h3>

<pre><code>type_tag() = atom()
</code></pre>

<p>Valid FFI type atom.  For the list of allowed values, see the
Appendix.</p>

<h3><code>tagged_value()</code></h3>

<pre><code>tagged_value() = tuple(type_tag(), term())
</code></pre>

<p>Type-tagged value used for FFI calls.</p>

<h3><code>tagged_func_name()</code></h3>

<pre><code>tagged_func_name() = tuple(type_tag(), c_func_name())
</code></pre>

<p>C function name with return type.</p>

<h3><code>func_index()</code></h3>

<pre><code>func_index() = integer()
</code></pre>

<p>Function position on the list of preloads given to
<code>erl_ddll:load_library/3</code>.</p>

<h3><code>tagged_func_index()</code></h3>

<pre><code>tagged_func_index() = tuple(type_tag(), func_index())
</code></pre>

<p>C function index with return type.</p>

<h3><code>signature()</code></h3>

<pre><code>signature() = tuple(type_tag(), ...)
</code></pre>

<p>Signature of a C function: return type followed by arguments types (if
any).</p>

<h2><code>erl_ddll:load_library/3</code></h2>

<pre><code>erl_ddll:load_library(Path, Name,
                      OptionsList) -&gt; ok | {error, ErrorDesc}
</code></pre>

<p>Types:</p>

<ul>
<li><p><code>Path = Name = string() | atom()</code></p></li>
<li><p><code>OptionList = [Option]</code></p></li>
<li><p><code>Option = tuple(preload, [Preload])</code></p></li>
<li><p><code>Preload = tuple(c_func_name(), signature())</code></p></li>
</ul>

<p>Load a generic shared library.</p>

<p>If an <code>ErlDrvEntry</code> structure and a driver init function are found when
loading the library, this BIF will behave like <code>erl_ddll:load/2</code>.  The
function parameters are also the same of <code>erl_ddll:load/2</code>, with the
following addition:</p>

<p><strong>OptionList</strong> is a list of options for library/driver loading.
The supported options are:</p>

<ul>
<li><p><strong><code>{preload, PreloadList}</code></strong>
Preload the given list of functions, and prepare their
call structures.  Each PreloadList element is a tuple
in the form:</p>

<pre><code>tuple(c_func_name(), `signature())
</code></pre>

<p>i.e. the function name followed by its return and
arguments types.</p></li>
</ul>

<p>The function return values are the same of <code>erl_ddll:load/2</code>.</p>

<p>Once a library has been loaded, it is possible to use
<code>erlang:open_port/2</code> to get a port.  That port could <em>always</em> be used
with <code>ffi:call/3</code>, <code>ffi:raw_call/3</code> or <code>ffi:raw_call/2</code>.  However,
if the loaded library does <em>not</em> contain a proper <code>ErlDrvEntry</code>
structure and a driver init function, the port will <strong>not</strong> be usable
with <code>erlang:port_command/2</code>, <code>erlang:port_control/3</code> etc.</p>

<p>The following example loads the C standard library and preloads some
functions: ::</p>

<pre><code>ok = erl_ddll:load_library("/lib", libc,
                           [{preload,
                             [{puts, {sint, nonnull}},
                              {putchar, {sint, sint}},
                              {malloc, {nonnull, size_t}},
                              {free, {void, nonnull}}]}]).
</code></pre>

<h2><code>erl_ddll:load_library/2</code></h2>

<pre><code>erl_ddll:load_library(Path, Name)
</code></pre>

<p>Utility function that calls <code>erl_ddll:load_library/3</code> with an empty
OptionsList.</p>

<h2><code>erlang:open_port/1</code></h2>

<pre><code>erlang:open_port(Library)
</code></pre>

<p>Types:</p>

<ul>
<li><code>Library = string() | atom()</code></li>
</ul>

<p>Open a port towards the specified shared library, possibly loaded with
<code>erl_ddll:load_library/3</code>.  Calling this function is equivalent to:</p>

<pre><code>erlang:open_port({spawn, Library}, [binary])
</code></pre>

<h2><code>erl_ddll:info/2</code></h2>

<p>This EEP proposes a new parameter for the <code>erl_ddll:info/2</code> BIF: the
'preloads' atom.  It allows to retrieve information about FFI preloads
for the given library.</p>

<p>The preload information is a list of proplists, one for each preloaded
function.  Each proplist, in turn, has the following format: </p>

<pre><code>[ { index,     integer()   },     % Position in the preload list
  { name,      string()    },     % Function name
  { address,   integer()   },     % Function address
  { signature, signature() } ]    % Function signature
</code></pre>

<p>This information would be made available also through <code>erl_ddll:info/0</code>
and <code>erl_ddll:info/1</code>.</p>

<h2><code>ffi:raw_call/3</code></h2>

<pre><code>ffi:raw_call(Port, CallArgs, Signature) -&gt; term()
</code></pre>

<p>Types:</p>

<ul>
<li><p><code>Port = port()</code></p></li>
<li><p><code>CallArgs = tuple(</code>c<em>func</em>name()<code>, Arg1, ...)</code></p></li>
<li><p><code>Arg1, ... = term()</code></p></li>
<li><p><code>Signature = signature()</code></p></li>
</ul>

<p>Call the specified C function.</p>

<p>This BIF accepts the following parameters:</p>

<ul>
<li><p><strong>Port</strong></p>

<p>A port opened towards the required driver/library.</p></li>
<li><p><strong>CallArgs</strong></p>

<p>A tuple with the function name (atom or string) followed by
its arguments (if any).</p></li>
<li><p><strong>Signature</strong></p>

<p>Function signature.</p></li>
</ul>

<p>This BIF returns the return value of the C function being called (or
'void' if the return type is void).  It automatically converts Erlang
terms to/from C values.  The supported C types and conversions are
reported in the Appendix.</p>

<p>The following example calls the <code>malloc()</code> and <code>free()</code> functions from the
standard C library (it should work with any Erlang linked-in driver): ::</p>

<pre><code>Pointer = ffi:raw_call(Port, {malloc, 1024}, {pointer, size_t}),
ok = ffi:raw_call(Port, {free, Pointer}, {void, pointer}).
</code></pre>

<p><strong>WARNING:</strong> bugs and/or misuses of the external C functions can
affect the Erlang VM, possibly making it crash.  Use this BIF with
extreme care.</p>

<h2><code>ffi:raw_call/2</code></h2>

<pre><code>ffi:raw_call(Port, OptimizedCall) -&gt; term()
</code></pre>

<p>Types:</p>

<ul>
<li><p><code>Port = port()</code></p></li>
<li><p><code>OptimizedCall = {FuncIndex, Arg1, ...}</code></p></li>
<li><p><code>FuncIndex = func_index()</code></p></li>
<li><p><code>Arg1, ... = term()</code></p></li>
</ul>

<p>Call a function preloaded with the 'preload' option of
<code>erl_ddll:load_library/3</code>.</p>

<p>This BIF accepts the following parameters:</p>

<ul>
<li><p><strong>Port</strong></p>

<p>A port opened towards the required driver/library (that
<strong>must</strong> have been loaded with <code>erl_ddll:load_library/3</code>).</p></li>
<li><p><strong>OptimizedCall</strong>
A tuple with the function index (i.e. its position in
the preload list) followed by its arguments (if any).</p></li>
</ul>

<p>This BIF returns the return value of the C function being called (or
'void' if the return type is void).  It automatically converts Erlang
terms to/from C values.  The supported C types and conversions are
reported in the Appendix.</p>

<p>The following example calls <code>malloc()</code> and <code>free()</code>, after they have been
preloaded with the code sample shown in <code>erl_ddll:load_library/3</code>:</p>

<pre><code>Port = open_port({spawn, "libc"}, [binary]),
Pointer = ffi:raw_call(Port, {3, 1024}),
ffi:raw_call(Port, {4, Pointer})
</code></pre>

<p><strong>WARNING:</strong> bugs and/or misuses of the external C functions can
affect the Erlang VM, possibly making it crash.  Use this BIF with
extreme care.</p>

<h2><code>ffi:raw_buffer_to_binary/2</code></h2>

<pre><code>ffi:raw_buffer_to_binary(Pointer, Size) -&gt; binary()
</code></pre>

<p>Types:</p>

<ul>
<li><p><code>Pointer = integer()</code></p></li>
<li><p><code>Size = integer()</code></p></li>
</ul>

<p>Return a binary with a copy of Size bytes read from the given C
pointer (represented by an integer, possibly returned by a FFI call).</p>

<p><strong>WARNING:</strong> passing the wrong pointer to this BIF may cause the
Erlang VM to crash.  Use with extreme care.</p>

<h2><code>ffi:raw_cstring_to_binary/1</code></h2>

<pre><code>ffi:raw_cstring_to_binary(CString) -&gt; binary()
</code></pre>

<p>Types:</p>

<ul>
<li><code>CString = integer()</code></li>
</ul>

<p>Return a binary with a copy of the given NULL-terminated C string (an
integer representing a pointer, possibly returned by a FFI call).  The
binary will include the trailing 0.</p>

<p><strong>WARNING:</strong> passing a wrong pointer to this BIF may cause the Erlang
VM to crash.  Use with extreme care.</p>

<h2><code>ffi:call/3</code></h2>

<pre><code>call(Port, CFunc, Args) -&gt; RetVal
</code></pre>

<p>Types:</p>

<ul>
<li><p><code>Port = port()</code></p></li>
<li><p><code>CFunc = c_func_name() | func_index()
| tagged_func_name()_ |</code>tagged<em>func</em>index()`</p></li>
<li><p>`Args = [tagged_value()]</p></li>
<li><p><code>RetVal = tagged_value()</code></p></li>
</ul>

<p>Call the C function <code>CFunc</code> with the given list of arguments, using
the port <code>Port</code>.  If the function was preloaded with
<code>ffi:load_library/3</code>, all the type tags will be matched against the
preloaded signature before performing the call.</p>

<p>Return the return value of the C function, with the proper type tag.</p>

<p><strong>Note:</strong> if <code>CFunc</code> is not of type <code>tagged_func_name()</code>, the C
function will be called if and only if it was preloaded with
<code>erl_ddll:load_library/3</code> (it is required in order to determine its
return type).</p>

<p>As an example, the following <code>malloc()</code> calls are all valid and
equivalent when executed after the code sample shown in
<code>erl_ddll:load_library/3</code>:</p>

<pre><code>%% Use function name, but require preloads for return type
{nonnull, Ptr1} = ffi:call(Port, "malloc", [{size_t, 1024}]),
{nonnull, Ptr2} = ffi:call(Port, malloc, [{size_t, 1024}]),

%% Use function index from preloads list
{nonnull, Ptr3} = ffi:call(Port, 3, [{size_t, 1024}]),
{nonnull, Ptr4} = ffi:call(Port, {nonnull, 3}, [{size_t, 1024}]),

%% These calls do not require any preload information
{nonnull, Ptr5} = ffi:call(Port, {nonnull, "malloc"}, [{size_t, 1024}]),
{nonnull, Ptr6} = ffi:call(Port, {nonnull, malloc}, [{size_t, 1024}]),
</code></pre>

<p><strong>WARNING:</strong> bugs and/or misuses of the external C functions can
affect the Erlang VM, possibly making it crash.  Use this BIF with
extreme care.</p>

<h2><code>ffi:buffer_to_binary/2</code></h2>

<pre><code>ffi:buffer_to_binary(TaggedNonNull, Size) -&gt; binary()
</code></pre>

<p>Types:</p>

<ul>
<li><p><code>TaggedNonNull = tuple(nonnull, integer())</code></p></li>
<li><p><code>Size: integer()</code></p></li>
</ul>

<p>Return a binary with a copy of <code>Size</code> bytes read from the given C
pointer.</p>

<p><strong>WARNING:</strong> passing a wrong pointer to this function may cause the
Erlang VM to crash.  Use with extreme care.</p>

<h2><code>ffi:cstring_to_binary/1</code></h2>

<pre><code>ffi:cstring_to_binary(TaggedCString) -&gt; binary()
</code></pre>

<p>Types:</p>

<ul>
<li><code>TaggedCString = tuple(cstring, integer())</code></li>
</ul>

<p>Return a binary with a copy of the given NULL-terminated C string.</p>

<p><strong>WARNING:</strong> passing a wrong pointer to this function may cause the
Erlang VM to crash.  Use with extreme care.</p>

<h2><code>ffi:sizeof/1</code></h2>

<pre><code>ffi:sizeof(TypeTag) -&gt; integer()
</code></pre>

<p>Types:</p>

<ul>
<li><code>TypeTag: type_tag()</code></li>
</ul>

<p>Return the size (in bytes) of the given FFI type, on the current
platform.</p>

<h2><code>ffi:check/1</code></h2>

<pre><code>ffi:check(TaggedValue) -&gt; true | false
</code></pre>

<p>Types:</p>

<ul>
<li><code>TaggedValue = tagged_value()</code></li>
</ul>

<p>Returns 'true' if the given type-tagged value is well-formed and
consistent (i.e. it falls in the allowed range for its type, on the
current platform).  Otherwise, returns 'false'.</p>

<h2><code>ffi:min/1</code></h2>

<pre><code>ffi:min(TypeTag) -&gt; integer()
</code></pre>

<p>Types:</p>

<ul>
<li><code>TypeTag = type_tag()</code></li>
</ul>

<p>Return the minimum value allowed for the given FFI type, on the
current platform.</p>

<h2><code>ffi:max/1</code></h2>

<pre><code>ffi:max(TypeTag) -&gt; integer()
</code></pre>

<p>Types:</p>

<ul>
<li><code>TypeTag = type_tag()</code></li>
</ul>

<p>Return the maximum value allowed for the given FFI type, on the
current platform.</p>

<h2><code>ffi_hardcodes.hrl</code></h2>

<p>The <code>ffi_hardcodes.hrl</code> file is part of the Erlang ffi library.  It
defines a set of macros for handling FFI types sizes, and for easy
binary matching on C buffers and structures:</p>

<ul>
<li><p><strong><code>FFI_HARDCODED_&lt;TYPE&gt;</code></strong></p>

<p>An Erlang bit-syntax snippet (Size/TypeSpecifier) that could
be used to match the given FFI type inside a binary (possibly
obtained from a C buffer).  For example, the following binary
matching:</p>

<pre><code>&lt;&lt;ULong:?FFI_HARDCODED_ULONG, _Rest/binary&gt;&gt; = Binary
</code></pre>

<p>on x86-64 will expand to:</p>

<pre><code>&lt;&lt;ULong:64/native-unsigned-integer, _Rest/binary&gt;&gt; = Binary
</code></pre></li>
<li><p><strong><code>FFI_HARDCODED_SIZEOF_&lt;TYPE&gt;</code></strong></p>

<p>The type size in <em>bytes</em></p></li>
<li><p><strong><code>FFI_HARDCODED_&lt;TYPE&gt;_BITS</code></strong></p>

<p>The type size in <em>bits</em></p></li>
</ul>

<p>As implied by their name, the <code>ffi_hardcodes.hrl</code> contents are
<em>specific to the build platform</em>, and when they are used, they will be
hard-coded in the resulting <code>.beam</code> files.  Thus, these macros
should be avoided if a developer expects his/her FFI-based code to be
<em>portable without recompilation</em>.  The recommended method for getting
FFI type sizes in a portable way is the <code>ffi:sizeof/1</code> function.</p>

<h1>Further notes</h1>

<h2>Notes on FFI preloading</h2>

<p>When a library is loaded with <code>erl_ddll:load_library/3</code>, it may be
reloaded or unloaded just like any Erlang linked-in driver.  If the
'preload' option is used, then two additional behaviors arise:</p>

<ul>
<li><p>if <code>erl_ddll:load_library/3</code> is called two or more times with the
same library, then the associated preload list must be rebuilt
according to the last call.  If no 'preload' option is used, then
the last preloads (if any) must be kept intact;</p></li>
<li><p>if an <code>erl_ddll:reload/2</code> is issued, then the last preloads must be
refreshed by performing a new symbol lookup in the loaded library.
If one or more symbols could not be found anymore, then they must be
disabled (and an error must raised when trying to use them with
<code>ffi:raw_call/2</code>).</p></li>
</ul>

<h2>Notes on vararg functions</h2>

<p><code>ffi:call/3</code> and <code>ffi:raw_call/3</code> may be used to call vararg C
functions, simply by providing the desired number of arguments.</p>

<p>In order to exploit the preloading optimizations, however, it is
necessary to use a different preload for each different function call
signature.  For example, if a developer is going to call <code>printf()</code>
with different arguments, he/she will need to use a preloading list
like the following one:</p>

<pre><code>ok = erl_ddll:load_library("/lib", libc,
                           [{preload,
                             [{printf, {sint, cstring}},
                              {printf, {sint, cstring, double}},
                              {printf, {sint, cstring, uint, sint}},
                              {printf, {sint, cstring, cstring}}]}]).
</code></pre>

<h2>Notes on C pointers and Erlang binaries</h2>

<p>As reported in the Appendix, an Erlang binary can be passed to a C
function as a 'pointer' value.  In this case, the C function will
receive a pointer to the first byte of binary data.</p>

<p>That pointer will be valid <em>only</em> until the C function returns.  If
the C side needs to access the pointer data later, then it should use
the 'binary' FFI type (see next paragraph) or copy the data itself in
a safe place.</p>

<h2>Notes on Erlang binaries and reference counting</h2>

<p>As reported in the Appendix, when the 'binary' FFI type is used as
argument, the C function will also receive a binary (in the form of an
<code>ErlDrvBinary</code> pointer).  Correspondingly, a C function with 'binary'
FFI return type must return an <code>ErlDrvBinary</code> pointer.  Furthermore,
an 'erliovec' argument type will cause the conversion of an Erlang
<code>iolist()</code> into an <code>ErlIOVec</code> (and its pointer will be passed to
the C function).</p>

<p>There are three rules for properly handling the refcount of binaries
passed to, or returned from, the C side through a FFI call.</p>

<ol>
<li><p>when a binary is received as argument (either directly, or inside
an <code>ErlIOVec</code>), and the C side needs to keep a reference, then
the refcount must be increased;</p></li>
<li><p>when a binary is created with <code>driver_alloc_binary()</code>, it will
have the refcount value of 1.  It is considered to be <em>still</em>
referenced by the C side;</p></li>
<li><p>as a consequence of the previous point, if the C side wants to
return a newly-crated binary <em>without</em> keeping references, it must
call <code>driver_binary_dec_refc()</code> before returning.</p></li>
</ol>

<h2>Notes on type-tagged values</h2>

<p>As reported above, the high-level FFI API is based on type-tagged
values.  Type tags, however, may introduce yet another way to
annotate/represent the types of Erlang function parameters --- and it
may become an annoying redundancy, expecially now that type <a href="http://user.it.uu.se/~kostis/Papers/contracts.pdf" title="A Language for Specifying Type Contracts in Erlang and its Interaction with Success Typings, Jiménez Lindahl and Sagonas (Presented at the 2007 SIGPLAN Erlang Workshop).">contracts</a>
are (probably) going to be introduced in Erlang.</p>

<p>Thus, the high-level FFI API should be considered highly experimental
and subject to change, depending on how type contracts will allow to
achieve the same tasks (see [High-level API][]).  This issue will need
to be explored if/when contracts will be available in the standard
Erlang/OTP distribution.</p>

<h1>Backwards Compatibility</h1>

<p>This EEP, and the proposed FFI patches (see below), do not introduce
incompatibilities with the standard OTP release.  However, three
(possibly) relevant internal changes are required:</p>

<ol>
<li><p>the <code>driver_binary_dec_refc()</code> function must be allowed to
reach the refcount of 0 without errors or warnings (even when
debugging).  This is necessary in order to allow a C function to
create a binary, drop its references and return it to the Erlang VM
(see 'Notes on Erlang binaries and reference counting');</p></li>
<li><p>as a consequence of the previous point,
<code>driver_binary_inc_refc()</code> must be allowed to reach a minimum
refcount of 1 without errors or warnings (the current minimum value
is 2);</p></li>
<li><p>the <code>iolist()</code> -> <code>ErlIOVec</code> conversion code in <code>io.c</code> needs
to be exposed as a stand-alone function, to be used by the FFI.</p></li>
</ol>

<h1>Reference implementation</h1>

<p>An implementation of this EEP is available on <a href="http://muvara.org/crs4/erlang/ffi" title="Foreign Function Interface (FFI) for Erlang/OTP">muvara.org</a>
as a set of patches against OTP R11B-5.</p>

<p>The code is based on the GCC FFI library <a href="http://gcc.gnu.org/viewcvs/trunk/libffi/" title="libffi: the GCC Foreign Function Interface Library">(libffi)</a>.  libffi is
multi-platform, can be packaged and used separately from the GCC
source code, and is released under a very permissive <a href="http://gcc.gnu.org/viewcvs/checkout/trunk/libffi/LICENSE" title="The libffi license">license</a>
(compatible with the Erlang Public License).  It has been used to
implement the FFI interface of several applications and languages,
including <a href="http://python.net/crew/theller/ctypes/" title="The CPython package">Python</a>.</p>

<p>The current EEP implementation looks for libffi on the build system,
and links the Erlang emulator against it (preferring the libffi shared
library, when available).  It may be a "good enough" approach, since
libffi is usually pre-packaged and easily available on GNU/Linux, BSD
and Solaris distributions.  However, this approach may create troubles
for developers that compile everything from scratch, could not install
a precompiled libffi package, or just want to force static linking
between the Erlang emulator and libffi.  In order to address these
issues, it is customary that a copy of libffi is distributed together
with the host language, and possibly kept in sync with the upstream
version.  This is what Python actually does, and Erlang/OTP could
possibly adopt the same approach depending on the developers'
feedback.</p>

<h1>Appendix</h1>

<h2>Erlang-to-C automatic type conversions</h2>

<p>The following table reports the Erlang-to-C conversions, used for
passing Erlang terms as C function call arguments.</p>

<pre><code>====================== ===============================
 C argument type        Supported Erlang types
====================== ===============================
uchar                  integer()
schar                  integer()
ushort                 integer()
sshort                 integer()
uint                   integer()
sint                   integer()
ulong                  integer()
slong                  integer()
uint8                  integer()
sint8                  integer()
uint16                 integer()
sint16                 integer()
uint32                 integer()
sint32                 integer()
uint64                 integer()
sint64                 integer()
float                  float()
double                 float()
longdouble             float()
pointer                binary() | integer()
cstring                binary() | integer()
nonnull                binary() | integer()
size_t                 integer()
ssize_t                integer()
pid_t                  integer()
off_t                  integer()
binary                 binary()
erliovec               iolist()
====================== ===============================
</code></pre>

<h2>C-to-Erlang automatic type conversions</h2>

<p>The following table reports the C-to-Erlang conversions, used for
converting C function return values into Erlang terms.</p>

<pre><code>====================== ===============================
 C return type          Resulting Erlang type
====================== ===============================
uchar                  integer()
schar                  integer()
ushort                 integer()
sshort                 integer()
uint                   integer()
sint                   integer()
ulong                  integer()
slong                  integer()
uint8                  integer()
sint8                  integer()
uint16                 integer()
sint16                 integer()
uint32                 integer()
sint32                 integer()
uint64                 integer()
sint64                 integer()
float                  float()
double                 float()
longdouble             float()
pointer                integer()
cstring                integer()
nonnull                integer()
size_t                 integer()
ssize_t                integer()
off_t                  integer()
pid_t                  integer()
binary                 binary()
====================== ===============================
</code></pre>

<h1>Copyright</h1>

<p>Copyright (C) 2007 by CRS4 (Center for Advanced Studies, Research and
Development in Sardinia) - <a href="http://www.crs4.it/">http://www.crs4.it/</a></p>

<p>Author: Alceste Scalas <alceste (at) crs4 (dot) it></p>

<p>This EEP is released under the terms of the Creative Commons
Attribution 3.0 License. See <a href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</a></p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0007","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Alceste Scalas \u0026lt;alceste(at)crs4(dot)it\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 3-Sep-2007\nErlang-Version: R12B\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 7: \u003ca href=\"eep-0007.md\" title=\"EEP Source\"\u003e Foreign Function Interface (FFI)\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP describes a Foreign Function Interface (FFI) for Erlang/OTP,\nthat allows to easily perform direct calls of external C functions.\nIt introduces three new BIFs (\u003ccode\u003effi:raw_call/3\u003c/code\u003e,\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e and \u003ccode\u003effi:raw_call/2\u003c/code\u003e) that accomplish the main\nFFI tasks: loading generic C libraries, making external function calls\nand performing automatic Erlang-to-C and C-to-Erlang type conversions.\u003c/p\u003e\n\n\u003cp\u003eIt also introduces two auxiliary BIFs for converting C buffers/strings\ninto binaries (\u003ccode\u003effi:raw_buffer_to_binary/2\u003c/code\u003e and\n\u003ccode\u003effi:raw_cstring_to_binary/1\u003c/code\u003e), a new \u003ccode\u003effi\u003c/code\u003e Erlang module that\nprovides a higher-level API with stricter type checking, and some\nutility macros.  Finally, it extends \u003ccode\u003eerl_ddll:info/2\u003c/code\u003e with FFI\ninformation.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThe current Erlang extension mechanisms can be divided in two main\ncategories:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eabsolute stability at the price of speed (C nodes, pipe drivers);\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003emore speed at the (potential) price of stability (linked-in\ndrivers).\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eLinked-in drivers have thus become the standard way for creating\nlibrary bindings when efficiency is an issue.  In both cases, however,\nthe Erlang driver interface implies the development of relevant\namounts of glue code, mostly because the communication between Erlang\nand C always requires data parsing and (de)serialization.  Several\ntools have been created in order to autogenerate (at least part of)\nthat glue: from the (now unmaintained) \u003ca href=\"http://www1.erlang.org/documentation/doc-4.8.2/lib/ig-1.8/doc/index.html\" title=\"IG: the Erlang Interface Generator, Törnquist and Lundell\"\u003eIG driver generation tool\u003c/a\u003e\nto the newer \u003ca href=\"http://www.erlang.se/workshop/2002/Fritchie.pdf\" title=\"The Evolution of Erlang Drivers and the Erlang Driver Toolkit, Fritchie\"\u003eErlang Driver Toolkit (EDTK)\u003c/a\u003e and \u003ca href=\"http://dryverl.objectweb.org/\" title=\"The Dryverl Erlang/C binding compiler\"\u003eDryverl\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eBut, even with the help of these tools, developing an Erlang driver is\na difficult and time-consuming task (especially when interfacing\nexternal libraries with tens or hundreds of functions), and the glue\ncode itself increases the possibility to introduce bugs --- that, in\nthe case of linked-in drivers, usually mean VM crashes.  For all these\nreasons, the lack of libraries and the difficulty of interfacing them\nfrom other languages is one of the negative aspects that are usually\nassociated with Erlang.\u003c/p\u003e\n\n\u003cp\u003eThe same problems also arise when a developer needs to replace\nperformance-critical portions of his/her Erlang code with optimized C\nfunctions.  In this case, also the data serialization/deserialization\noverhead may be a significant issue.\u003c/p\u003e\n\n\u003cp\u003eAn easier method for interfacing Erlang and C code could drastically\nextend the Erlang capabilities and open new usage scenarios.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes a Foreign Function Interface (FFI) extension that\nwould allow to easily perform direct C function calls.  This concept\nis implemented in almost every language, with two main (non-exclusive)\napproaches:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eautomatic type conversions between the host and the foreign\nlanguage (examples: \u003ca href=\"http://python.net/crew/theller/ctypes/\" title=\"The CPython package\"\u003ePython\u003c/a\u003e, \u003ca href=\"http://www.cse.unsw.edu.au/~chak/haskell/ffi/\" title=\"The Haskell 98 Foreign Function Interface\"\u003eHaskell\u003c/a\u003e);\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003edocumented C interface for handling host language types from the\nforeign language (examples: \u003ca href=\"http://java.sun.com/j2se/1.5.0/docs/guide/jni/\" title=\"The Java Native Interface\"\u003eJava\u003c/a\u003e, \u003ca href=\"http://docs.python.org/ext/ext.html\" title=\"Extending and Embedding the Python Interpreter\"\u003ePython\u003c/a\u003e \u003ca href=\"http://docs.python.org/api/api.html\" title=\"Python/C API Reference Manual\"\u003e(API)\u003c/a\u003e).\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThis EEP follows the first approach, but (when possible) also reuses\npart of the existing C Driver API (and, thus, allows to manage\n\u003ccode\u003eErlDrvBinary\u003c/code\u003e and \u003ccode\u003eErlIOVec\u003c/code\u003e pointers in the external C\nfunctions).\u003c/p\u003e\n\n\u003cp\u003eThe FFI has been designed \u003cem\u003enot\u003c/em\u003e to require language changes or\nintroduce incompatibilities.\u003c/p\u003e\n\n\u003cp\u003eThe BIFs and functions proposed in this EEP don't give any access to\nthe Erlang VM internals --- but the called C functions could leak\nmemory and/or cause the Erlang VM to crash.  The FFI is, thus, not\nintended for \"casual\" Erlang developers: this is a tool designed for\nlibrary bindings developers (that should take care of hiding FFI calls\nfrom final users), and advanced programmers looking for an easy (and\nefficient) way to call C code from Erlang.\u003c/p\u003e\n\n\u003ch1\u003eOverview\u003c/h1\u003e\n\n\u003cp\u003eIn order to call a C function, the FFI needs a port opened towards the\nrequired C code.  Thus, with the current driver loading mechanism, a\ndeveloper would be required to:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003ecreate a C file with a void \u003ccode\u003eErlDrvEntry\u003c/code\u003e structure and driver\ninit function;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ecompile it and possibly link it against the required C libraries,\nthus obtaining a void Erlang driver;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eload the driver in the Erlang VM, by using \u003ccode\u003eerl_ddll:load/2\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eIn order to simplify this procedure, this EEP proposes the\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e function, that allows to load a generic\nlibrary in the Erlang VM --- even if it lacks the structure of an\nErlang linked-in driver.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e also offers an option to preload a list of C\nfunction symbols and signatures, thus precompiling the internal\nstructures needed for performing dynamic function calls.  Information\nabout preloaded data can be retrieved with \u003ccode\u003eerl_ddll:info/2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eOnce a library or driver has been loaded, \u003ccode\u003eerlang:open_port/2\u003c/code\u003e or\n\u003ccode\u003eerlang:open_port/1\u003c/code\u003e could be used to get a port for the FFI\nfunctions, and perform calls either through the low-level or the\nhigh-level APIs.\u003c/p\u003e\n\n\u003ch2\u003eLow-level API\u003c/h2\u003e\n\n\u003cp\u003eThe low-level FFI methods are denoted by the \u003ccode\u003eraw_\u003c/code\u003e prefix.  The\nmain function is the \u003ccode\u003effi:raw_call/3\u003c/code\u003e BIF, that performs a direct C\nfunction call through an open port.  It converts C types to/from\nErlang types.\u003c/p\u003e\n\n\u003cp\u003eWhen taken alone, \u003ccode\u003effi:raw_call/3\u003c/code\u003e has got a major drawback: it introduces\ngreat call overhead, due to the C symbol lookup and the dynamic\nconstruction of the function call.\u003c/p\u003e\n\n\u003cp\u003eIn order to exploit preloading option of \u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e, the\n\u003ccode\u003effi:raw_call/2\u003c/code\u003e BIF is introduced: it avoids symbol lookup and call\nstructure compilation, thus guaranteeing a lower call overhead than\n\u003ccode\u003effi:raw_call/3\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFurthermore, the low-level interface provides two BIFs for creating an\nErlang binary from a C pointer (possibly returned by a FFI call).\nThese BIFs are \u003ccode\u003effi:raw_buffer_to_binary/2\u003c/code\u003e and\n\u003ccode\u003effi:raw_cstring_to_binary/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eHigh-level API\u003c/h2\u003e\n\n\u003cp\u003eThe high-level interface is built upon the low-level one.  It\nintroduces the concept of type-tagged values: any value passed to or\nreturned from FFI calls has the form of a \u003ccode\u003e{Type, Value}\u003c/code\u003e tuple.  This\nallows to:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eincrease the readability of FFI calls;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003emake the C calls safer: the consistency of tagged values is checked\nbefore the values themselves are passed to the low-level API.\nFurthermore, the preload information given to\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e is used (when available) to ensure that the\ntagged values actually match the function signature;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003esimulate the static typing of C code, thus requiring proper and\nexplicit \"casts\" when a tagged value needs to be converted to\nanother type.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThese checks are performed by \u003ccode\u003effi:call/3\u003c/code\u003e, \u003ccode\u003effi:buffer_to_binary/2\u003c/code\u003e\nand \u003ccode\u003effi:cstring_to_binary/1\u003c/code\u003e (the type-tagged equivalents of the\nlow-level BIFs).  Type-tagged values can also be checked with\n\u003ccode\u003effi:check/1\u003c/code\u003e.  Furthermore, the allowed minimum and maximum value of\neach FFI type can be examined with \u003ccode\u003effi:min/1\u003c/code\u003e and \u003ccode\u003effi:max/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003eUtility macros\u003c/h2\u003e\n\n\u003cp\u003eThe FFI defines a series of utility macros in the \u003ccode\u003effi_hardcodes.hrl\u003c/code\u003e\nheader file, that could be used for binary matching of C buffers and\nstructures.\u003c/p\u003e\n\n\u003ch1\u003eSpecifications\u003c/h1\u003e\n\n\u003ch2\u003eTypes\u003c/h2\u003e\n\n\u003ch3\u003e\u003ccode\u003ec_func_name()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003ec_func_name() = atom() | string()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eName of a C function.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003etype_tag()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003etype_tag() = atom()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eValid FFI type atom.  For the list of allowed values, see the\nAppendix.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003etagged_value()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003etagged_value() = tuple(type_tag(), term())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eType-tagged value used for FFI calls.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003etagged_func_name()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003etagged_func_name() = tuple(type_tag(), c_func_name())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eC function name with return type.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003efunc_index()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003efunc_index() = integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFunction position on the list of preloads given to\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003etagged_func_index()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003etagged_func_index() = tuple(type_tag(), func_index())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eC function index with return type.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003esignature()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003esignature() = tuple(type_tag(), ...)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSignature of a C function: return type followed by arguments types (if\nany).\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003eerl_ddll:load_library(Path, Name,\n                      OptionsList) -\u0026gt; ok | {error, ErrorDesc}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ePath = Name = string() | atom()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eOptionList = [Option]\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eOption = tuple(preload, [Preload])\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ePreload = tuple(c_func_name(), signature())\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eLoad a generic shared library.\u003c/p\u003e\n\n\u003cp\u003eIf an \u003ccode\u003eErlDrvEntry\u003c/code\u003e structure and a driver init function are found when\nloading the library, this BIF will behave like \u003ccode\u003eerl_ddll:load/2\u003c/code\u003e.  The\nfunction parameters are also the same of \u003ccode\u003eerl_ddll:load/2\u003c/code\u003e, with the\nfollowing addition:\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eOptionList\u003c/strong\u003e is a list of options for library/driver loading.\nThe supported options are:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003e{preload, PreloadList}\u003c/code\u003e\u003c/strong\u003e\nPreload the given list of functions, and prepare their\ncall structures.  Each PreloadList element is a tuple\nin the form:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etuple(c_func_name(), `signature())\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ei.e. the function name followed by its return and\narguments types.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe function return values are the same of \u003ccode\u003eerl_ddll:load/2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eOnce a library has been loaded, it is possible to use\n\u003ccode\u003eerlang:open_port/2\u003c/code\u003e to get a port.  That port could \u003cem\u003ealways\u003c/em\u003e be used\nwith \u003ccode\u003effi:call/3\u003c/code\u003e, \u003ccode\u003effi:raw_call/3\u003c/code\u003e or \u003ccode\u003effi:raw_call/2\u003c/code\u003e.  However,\nif the loaded library does \u003cem\u003enot\u003c/em\u003e contain a proper \u003ccode\u003eErlDrvEntry\u003c/code\u003e\nstructure and a driver init function, the port will \u003cstrong\u003enot\u003c/strong\u003e be usable\nwith \u003ccode\u003eerlang:port_command/2\u003c/code\u003e, \u003ccode\u003eerlang:port_control/3\u003c/code\u003e etc.\u003c/p\u003e\n\n\u003cp\u003eThe following example loads the C standard library and preloads some\nfunctions: ::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eok = erl_ddll:load_library(\"/lib\", libc,\n                           [{preload,\n                             [{puts, {sint, nonnull}},\n                              {putchar, {sint, sint}},\n                              {malloc, {nonnull, size_t}},\n                              {free, {void, nonnull}}]}]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003e\u003ccode\u003eerl_ddll:load_library/2\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003eerl_ddll:load_library(Path, Name)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUtility function that calls \u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e with an empty\nOptionsList.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003eerlang:open_port/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:open_port(Library)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLibrary = string() | atom()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOpen a port towards the specified shared library, possibly loaded with\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e.  Calling this function is equivalent to:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:open_port({spawn, Library}, [binary])\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003e\u003ccode\u003eerl_ddll:info/2\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eThis EEP proposes a new parameter for the \u003ccode\u003eerl_ddll:info/2\u003c/code\u003e BIF: the\n'preloads' atom.  It allows to retrieve information about FFI preloads\nfor the given library.\u003c/p\u003e\n\n\u003cp\u003eThe preload information is a list of proplists, one for each preloaded\nfunction.  Each proplist, in turn, has the following format: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[ { index,     integer()   },     % Position in the preload list\n  { name,      string()    },     % Function name\n  { address,   integer()   },     % Function address\n  { signature, signature() } ]    % Function signature\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis information would be made available also through \u003ccode\u003eerl_ddll:info/0\u003c/code\u003e\nand \u003ccode\u003eerl_ddll:info/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:raw_call/3\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:raw_call(Port, CallArgs, Signature) -\u0026gt; term()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ePort = port()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eCallArgs = tuple(\u003c/code\u003ec\u003cem\u003efunc\u003c/em\u003ename()\u003ccode\u003e, Arg1, ...)\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eArg1, ... = term()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSignature = signature()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCall the specified C function.\u003c/p\u003e\n\n\u003cp\u003eThis BIF accepts the following parameters:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ePort\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eA port opened towards the required driver/library.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eCallArgs\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eA tuple with the function name (atom or string) followed by\nits arguments (if any).\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eSignature\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eFunction signature.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis BIF returns the return value of the C function being called (or\n'void' if the return type is void).  It automatically converts Erlang\nterms to/from C values.  The supported C types and conversions are\nreported in the Appendix.\u003c/p\u003e\n\n\u003cp\u003eThe following example calls the \u003ccode\u003emalloc()\u003c/code\u003e and \u003ccode\u003efree()\u003c/code\u003e functions from the\nstandard C library (it should work with any Erlang linked-in driver): ::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePointer = ffi:raw_call(Port, {malloc, 1024}, {pointer, size_t}),\nok = ffi:raw_call(Port, {free, Pointer}, {void, pointer}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e bugs and/or misuses of the external C functions can\naffect the Erlang VM, possibly making it crash.  Use this BIF with\nextreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:raw_call/2\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:raw_call(Port, OptimizedCall) -\u0026gt; term()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ePort = port()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eOptimizedCall = {FuncIndex, Arg1, ...}\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eFuncIndex = func_index()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eArg1, ... = term()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCall a function preloaded with the 'preload' option of\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis BIF accepts the following parameters:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ePort\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eA port opened towards the required driver/library (that\n\u003cstrong\u003emust\u003c/strong\u003e have been loaded with \u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e).\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eOptimizedCall\u003c/strong\u003e\nA tuple with the function index (i.e. its position in\nthe preload list) followed by its arguments (if any).\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis BIF returns the return value of the C function being called (or\n'void' if the return type is void).  It automatically converts Erlang\nterms to/from C values.  The supported C types and conversions are\nreported in the Appendix.\u003c/p\u003e\n\n\u003cp\u003eThe following example calls \u003ccode\u003emalloc()\u003c/code\u003e and \u003ccode\u003efree()\u003c/code\u003e, after they have been\npreloaded with the code sample shown in \u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePort = open_port({spawn, \"libc\"}, [binary]),\nPointer = ffi:raw_call(Port, {3, 1024}),\nffi:raw_call(Port, {4, Pointer})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e bugs and/or misuses of the external C functions can\naffect the Erlang VM, possibly making it crash.  Use this BIF with\nextreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:raw_buffer_to_binary/2\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:raw_buffer_to_binary(Pointer, Size) -\u0026gt; binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ePointer = integer()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSize = integer()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn a binary with a copy of Size bytes read from the given C\npointer (represented by an integer, possibly returned by a FFI call).\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e passing the wrong pointer to this BIF may cause the\nErlang VM to crash.  Use with extreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:raw_cstring_to_binary/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:raw_cstring_to_binary(CString) -\u0026gt; binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCString = integer()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn a binary with a copy of the given NULL-terminated C string (an\ninteger representing a pointer, possibly returned by a FFI call).  The\nbinary will include the trailing 0.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e passing a wrong pointer to this BIF may cause the Erlang\nVM to crash.  Use with extreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:call/3\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003ecall(Port, CFunc, Args) -\u0026gt; RetVal\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ePort = port()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eCFunc = c_func_name() | func_index()\n| tagged_func_name()_ |\u003c/code\u003etagged\u003cem\u003efunc\u003c/em\u003eindex()`\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e`Args = [tagged_value()]\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eRetVal = tagged_value()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCall the C function \u003ccode\u003eCFunc\u003c/code\u003e with the given list of arguments, using\nthe port \u003ccode\u003ePort\u003c/code\u003e.  If the function was preloaded with\n\u003ccode\u003effi:load_library/3\u003c/code\u003e, all the type tags will be matched against the\npreloaded signature before performing the call.\u003c/p\u003e\n\n\u003cp\u003eReturn the return value of the C function, with the proper type tag.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e if \u003ccode\u003eCFunc\u003c/code\u003e is not of type \u003ccode\u003etagged_func_name()\u003c/code\u003e, the C\nfunction will be called if and only if it was preloaded with\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e (it is required in order to determine its\nreturn type).\u003c/p\u003e\n\n\u003cp\u003eAs an example, the following \u003ccode\u003emalloc()\u003c/code\u003e calls are all valid and\nequivalent when executed after the code sample shown in\n\u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e%% Use function name, but require preloads for return type\n{nonnull, Ptr1} = ffi:call(Port, \"malloc\", [{size_t, 1024}]),\n{nonnull, Ptr2} = ffi:call(Port, malloc, [{size_t, 1024}]),\n\n%% Use function index from preloads list\n{nonnull, Ptr3} = ffi:call(Port, 3, [{size_t, 1024}]),\n{nonnull, Ptr4} = ffi:call(Port, {nonnull, 3}, [{size_t, 1024}]),\n\n%% These calls do not require any preload information\n{nonnull, Ptr5} = ffi:call(Port, {nonnull, \"malloc\"}, [{size_t, 1024}]),\n{nonnull, Ptr6} = ffi:call(Port, {nonnull, malloc}, [{size_t, 1024}]),\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e bugs and/or misuses of the external C functions can\naffect the Erlang VM, possibly making it crash.  Use this BIF with\nextreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:buffer_to_binary/2\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:buffer_to_binary(TaggedNonNull, Size) -\u0026gt; binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eTaggedNonNull = tuple(nonnull, integer())\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSize: integer()\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn a binary with a copy of \u003ccode\u003eSize\u003c/code\u003e bytes read from the given C\npointer.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e passing a wrong pointer to this function may cause the\nErlang VM to crash.  Use with extreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:cstring_to_binary/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:cstring_to_binary(TaggedCString) -\u0026gt; binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTaggedCString = tuple(cstring, integer())\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn a binary with a copy of the given NULL-terminated C string.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eWARNING:\u003c/strong\u003e passing a wrong pointer to this function may cause the\nErlang VM to crash.  Use with extreme care.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:sizeof/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:sizeof(TypeTag) -\u0026gt; integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTypeTag: type_tag()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn the size (in bytes) of the given FFI type, on the current\nplatform.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:check/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:check(TaggedValue) -\u0026gt; true | false\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTaggedValue = tagged_value()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturns 'true' if the given type-tagged value is well-formed and\nconsistent (i.e. it falls in the allowed range for its type, on the\ncurrent platform).  Otherwise, returns 'false'.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:min/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:min(TypeTag) -\u0026gt; integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTypeTag = type_tag()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn the minimum value allowed for the given FFI type, on the\ncurrent platform.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi:max/1\u003c/code\u003e\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003effi:max(TypeTag) -\u0026gt; integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTypeTag = type_tag()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eReturn the maximum value allowed for the given FFI type, on the\ncurrent platform.\u003c/p\u003e\n\n\u003ch2\u003e\u003ccode\u003effi_hardcodes.hrl\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eThe \u003ccode\u003effi_hardcodes.hrl\u003c/code\u003e file is part of the Erlang ffi library.  It\ndefines a set of macros for handling FFI types sizes, and for easy\nbinary matching on C buffers and structures:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eFFI_HARDCODED_\u0026lt;TYPE\u0026gt;\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eAn Erlang bit-syntax snippet (Size/TypeSpecifier) that could\nbe used to match the given FFI type inside a binary (possibly\nobtained from a C buffer).  For example, the following binary\nmatching:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;ULong:?FFI_HARDCODED_ULONG, _Rest/binary\u0026gt;\u0026gt; = Binary\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eon x86-64 will expand to:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;ULong:64/native-unsigned-integer, _Rest/binary\u0026gt;\u0026gt; = Binary\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eFFI_HARDCODED_SIZEOF_\u0026lt;TYPE\u0026gt;\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe type size in \u003cem\u003ebytes\u003c/em\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eFFI_HARDCODED_\u0026lt;TYPE\u0026gt;_BITS\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe type size in \u003cem\u003ebits\u003c/em\u003e\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAs implied by their name, the \u003ccode\u003effi_hardcodes.hrl\u003c/code\u003e contents are\n\u003cem\u003especific to the build platform\u003c/em\u003e, and when they are used, they will be\nhard-coded in the resulting \u003ccode\u003e.beam\u003c/code\u003e files.  Thus, these macros\nshould be avoided if a developer expects his/her FFI-based code to be\n\u003cem\u003eportable without recompilation\u003c/em\u003e.  The recommended method for getting\nFFI type sizes in a portable way is the \u003ccode\u003effi:sizeof/1\u003c/code\u003e function.\u003c/p\u003e\n\n\u003ch1\u003eFurther notes\u003c/h1\u003e\n\n\u003ch2\u003eNotes on FFI preloading\u003c/h2\u003e\n\n\u003cp\u003eWhen a library is loaded with \u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e, it may be\nreloaded or unloaded just like any Erlang linked-in driver.  If the\n'preload' option is used, then two additional behaviors arise:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eif \u003ccode\u003eerl_ddll:load_library/3\u003c/code\u003e is called two or more times with the\nsame library, then the associated preload list must be rebuilt\naccording to the last call.  If no 'preload' option is used, then\nthe last preloads (if any) must be kept intact;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eif an \u003ccode\u003eerl_ddll:reload/2\u003c/code\u003e is issued, then the last preloads must be\nrefreshed by performing a new symbol lookup in the loaded library.\nIf one or more symbols could not be found anymore, then they must be\ndisabled (and an error must raised when trying to use them with\n\u003ccode\u003effi:raw_call/2\u003c/code\u003e).\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eNotes on vararg functions\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode\u003effi:call/3\u003c/code\u003e and \u003ccode\u003effi:raw_call/3\u003c/code\u003e may be used to call vararg C\nfunctions, simply by providing the desired number of arguments.\u003c/p\u003e\n\n\u003cp\u003eIn order to exploit the preloading optimizations, however, it is\nnecessary to use a different preload for each different function call\nsignature.  For example, if a developer is going to call \u003ccode\u003eprintf()\u003c/code\u003e\nwith different arguments, he/she will need to use a preloading list\nlike the following one:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eok = erl_ddll:load_library(\"/lib\", libc,\n                           [{preload,\n                             [{printf, {sint, cstring}},\n                              {printf, {sint, cstring, double}},\n                              {printf, {sint, cstring, uint, sint}},\n                              {printf, {sint, cstring, cstring}}]}]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eNotes on C pointers and Erlang binaries\u003c/h2\u003e\n\n\u003cp\u003eAs reported in the Appendix, an Erlang binary can be passed to a C\nfunction as a 'pointer' value.  In this case, the C function will\nreceive a pointer to the first byte of binary data.\u003c/p\u003e\n\n\u003cp\u003eThat pointer will be valid \u003cem\u003eonly\u003c/em\u003e until the C function returns.  If\nthe C side needs to access the pointer data later, then it should use\nthe 'binary' FFI type (see next paragraph) or copy the data itself in\na safe place.\u003c/p\u003e\n\n\u003ch2\u003eNotes on Erlang binaries and reference counting\u003c/h2\u003e\n\n\u003cp\u003eAs reported in the Appendix, when the 'binary' FFI type is used as\nargument, the C function will also receive a binary (in the form of an\n\u003ccode\u003eErlDrvBinary\u003c/code\u003e pointer).  Correspondingly, a C function with 'binary'\nFFI return type must return an \u003ccode\u003eErlDrvBinary\u003c/code\u003e pointer.  Furthermore,\nan 'erliovec' argument type will cause the conversion of an Erlang\n\u003ccode\u003eiolist()\u003c/code\u003e into an \u003ccode\u003eErlIOVec\u003c/code\u003e (and its pointer will be passed to\nthe C function).\u003c/p\u003e\n\n\u003cp\u003eThere are three rules for properly handling the refcount of binaries\npassed to, or returned from, the C side through a FFI call.\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003ewhen a binary is received as argument (either directly, or inside\nan \u003ccode\u003eErlIOVec\u003c/code\u003e), and the C side needs to keep a reference, then\nthe refcount must be increased;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ewhen a binary is created with \u003ccode\u003edriver_alloc_binary()\u003c/code\u003e, it will\nhave the refcount value of 1.  It is considered to be \u003cem\u003estill\u003c/em\u003e\nreferenced by the C side;\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eas a consequence of the previous point, if the C side wants to\nreturn a newly-crated binary \u003cem\u003ewithout\u003c/em\u003e keeping references, it must\ncall \u003ccode\u003edriver_binary_dec_refc()\u003c/code\u003e before returning.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2\u003eNotes on type-tagged values\u003c/h2\u003e\n\n\u003cp\u003eAs reported above, the high-level FFI API is based on type-tagged\nvalues.  Type tags, however, may introduce yet another way to\nannotate/represent the types of Erlang function parameters --- and it\nmay become an annoying redundancy, expecially now that type \u003ca href=\"http://user.it.uu.se/~kostis/Papers/contracts.pdf\" title=\"A Language for Specifying Type Contracts in Erlang and its Interaction with Success Typings, Jiménez Lindahl and Sagonas (Presented at the 2007 SIGPLAN Erlang Workshop).\"\u003econtracts\u003c/a\u003e\nare (probably) going to be introduced in Erlang.\u003c/p\u003e\n\n\u003cp\u003eThus, the high-level FFI API should be considered highly experimental\nand subject to change, depending on how type contracts will allow to\nachieve the same tasks (see [High-level API][]).  This issue will need\nto be explored if/when contracts will be available in the standard\nErlang/OTP distribution.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThis EEP, and the proposed FFI patches (see below), do not introduce\nincompatibilities with the standard OTP release.  However, three\n(possibly) relevant internal changes are required:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003ethe \u003ccode\u003edriver_binary_dec_refc()\u003c/code\u003e function must be allowed to\nreach the refcount of 0 without errors or warnings (even when\ndebugging).  This is necessary in order to allow a C function to\ncreate a binary, drop its references and return it to the Erlang VM\n(see 'Notes on Erlang binaries and reference counting');\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eas a consequence of the previous point,\n\u003ccode\u003edriver_binary_inc_refc()\u003c/code\u003e must be allowed to reach a minimum\nrefcount of 1 without errors or warnings (the current minimum value\nis 2);\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ethe \u003ccode\u003eiolist()\u003c/code\u003e -\u003e \u003ccode\u003eErlIOVec\u003c/code\u003e conversion code in \u003ccode\u003eio.c\u003c/code\u003e needs\nto be exposed as a stand-alone function, to be used by the FFI.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1\u003eReference implementation\u003c/h1\u003e\n\n\u003cp\u003eAn implementation of this EEP is available on \u003ca href=\"http://muvara.org/crs4/erlang/ffi\" title=\"Foreign Function Interface (FFI) for Erlang/OTP\"\u003emuvara.org\u003c/a\u003e\nas a set of patches against OTP R11B-5.\u003c/p\u003e\n\n\u003cp\u003eThe code is based on the GCC FFI library \u003ca href=\"http://gcc.gnu.org/viewcvs/trunk/libffi/\" title=\"libffi: the GCC Foreign Function Interface Library\"\u003e(libffi)\u003c/a\u003e.  libffi is\nmulti-platform, can be packaged and used separately from the GCC\nsource code, and is released under a very permissive \u003ca href=\"http://gcc.gnu.org/viewcvs/checkout/trunk/libffi/LICENSE\" title=\"The libffi license\"\u003elicense\u003c/a\u003e\n(compatible with the Erlang Public License).  It has been used to\nimplement the FFI interface of several applications and languages,\nincluding \u003ca href=\"http://python.net/crew/theller/ctypes/\" title=\"The CPython package\"\u003ePython\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe current EEP implementation looks for libffi on the build system,\nand links the Erlang emulator against it (preferring the libffi shared\nlibrary, when available).  It may be a \"good enough\" approach, since\nlibffi is usually pre-packaged and easily available on GNU/Linux, BSD\nand Solaris distributions.  However, this approach may create troubles\nfor developers that compile everything from scratch, could not install\na precompiled libffi package, or just want to force static linking\nbetween the Erlang emulator and libffi.  In order to address these\nissues, it is customary that a copy of libffi is distributed together\nwith the host language, and possibly kept in sync with the upstream\nversion.  This is what Python actually does, and Erlang/OTP could\npossibly adopt the same approach depending on the developers'\nfeedback.\u003c/p\u003e\n\n\u003ch1\u003eAppendix\u003c/h1\u003e\n\n\u003ch2\u003eErlang-to-C automatic type conversions\u003c/h2\u003e\n\n\u003cp\u003eThe following table reports the Erlang-to-C conversions, used for\npassing Erlang terms as C function call arguments.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e====================== ===============================\n C argument type        Supported Erlang types\n====================== ===============================\nuchar                  integer()\nschar                  integer()\nushort                 integer()\nsshort                 integer()\nuint                   integer()\nsint                   integer()\nulong                  integer()\nslong                  integer()\nuint8                  integer()\nsint8                  integer()\nuint16                 integer()\nsint16                 integer()\nuint32                 integer()\nsint32                 integer()\nuint64                 integer()\nsint64                 integer()\nfloat                  float()\ndouble                 float()\nlongdouble             float()\npointer                binary() | integer()\ncstring                binary() | integer()\nnonnull                binary() | integer()\nsize_t                 integer()\nssize_t                integer()\npid_t                  integer()\noff_t                  integer()\nbinary                 binary()\nerliovec               iolist()\n====================== ===============================\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eC-to-Erlang automatic type conversions\u003c/h2\u003e\n\n\u003cp\u003eThe following table reports the C-to-Erlang conversions, used for\nconverting C function return values into Erlang terms.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e====================== ===============================\n C return type          Resulting Erlang type\n====================== ===============================\nuchar                  integer()\nschar                  integer()\nushort                 integer()\nsshort                 integer()\nuint                   integer()\nsint                   integer()\nulong                  integer()\nslong                  integer()\nuint8                  integer()\nsint8                  integer()\nuint16                 integer()\nsint16                 integer()\nuint32                 integer()\nsint32                 integer()\nuint64                 integer()\nsint64                 integer()\nfloat                  float()\ndouble                 float()\nlongdouble             float()\npointer                integer()\ncstring                integer()\nnonnull                integer()\nsize_t                 integer()\nssize_t                integer()\noff_t                  integer()\npid_t                  integer()\nbinary                 binary()\n====================== ===============================\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eCopyright (C) 2007 by CRS4 (Center for Advanced Studies, Research and\nDevelopment in Sardinia) - \u003ca href=\"http://www.crs4.it/\"\u003ehttp://www.crs4.it/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eAuthor: Alceste Scalas \u003calceste (at) crs4 (dot) it\u003e\u003c/p\u003e\n\n\u003cp\u003eThis EEP is released under the terms of the Creative Commons\nAttribution 3.0 License. See \u003ca href=\"http://creativecommons.org/licenses/by/3.0/\"\u003ehttp://creativecommons.org/licenses/by/3.0/\u003c/a\u003e\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0007"},"buildId":"gLD8MrZYLxdGHP5ltLIGn","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/gLD8MrZYLxdGHP5ltLIGn/_buildManifest.js" async=""></script><script src="/_next/static/gLD8MrZYLxdGHP5ltLIGn/_ssgManifest.js" async=""></script></body></html>