<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Created: 10-Jul-2008
Erlang-Version: R12B-4
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 12: <a href="eep-0012.md" title="EEP Source"> Extensions to comprehensions</a></h2>

<h1>Abstract</h1>

<p>Add tuple-valued comprehensions to go with list and binary
comprehensions.</p>

<p>Add tuple generators to go with list and binary generators.</p>

<p>Fix a syntax botch in comprehension qualifiers by explicitly
recognising pattern = value bindings and treating them in a
way that makes sense.</p>

<h1>Specification</h1>

<p>Currently, Erlang has</p>

<pre><code>    '['  Expr '||' Generators-And-Tests ']'
    '&lt;&lt;' Expr '||' Generators-And-Tests '&gt;&gt;'
</code></pre>

<p>for generating lists and binaries, but there is no corresponding
form for generating tuples.  We add</p>

<pre><code>    '{' Expr '||' Generators-And-Tests '}'
</code></pre>

<p>with the meaning that <code>{ E || G }</code> has the same behaviour as
<code>erlang:list_to_tuple([E || G])</code> except that it need not call
<code>erlang:list_to_tuple/1</code>.</p>

<p>Currently, Erlang comprehensions allow</p>

<pre><code>    Pattern '&lt;-' Expr
</code></pre>

<p>to enumerate over list and</p>

<pre><code>    Pattern '&lt;=' Expr
</code></pre>

<p>to enumerate over binaries.  The second of these forms is,
I must say, not just asking for trouble, but screaming for it.
This proposal adds three new forms:</p>

<pre><code>    Pattern '['  '&lt;-' ']'  Expr
    Pattern '{'  '&lt;-' '}'  Expr
    Pattern '&lt;&lt;' '&lt;-' '&gt;&gt;' Expr
</code></pre>

<p>for enumerating over lists, tuples, and binaries respectively,
providing an iconic representation of what Expr should be.
<code>[&lt;-]</code> and <code>&lt;&lt; &lt;- &gt;&gt;</code> have exactly the same semantics as the
existing <code>&lt;-</code> and <code>&lt;=</code> do.  The semantics of Pattern <code>{&lt;=}</code> Expr
is that of <code>Pattern &lt;- erlang:tuple_to_list(Expr)</code>, except that
<code>erlang:tuple_to_list/1</code> need not be called.</p>

<p>Currently the Generators-And-Tests part allows a sequence of
generators and tests, where a test is any expression.  A test
must evaluate to either 'false' or 'true'.  The form <code>Pattern = Expr</code>
is syntactically an expression, so is allowed as a test.
However, in context, this makes no sense.  For a given Expr,
there are four possible outcomes:
1. Expr raises an exception => an exception is raised.
2. Expr does not yield false or true => an exception is raised.
3. Expr yields false => the test fails;
   this might as well have been Expr without Pattern.
4. Expr yields true => the test succeeds;
   this might as well have been Expr without Pattern,</p>

<h1>   and Pattern = true beforehand.</h1>

<p>This proposal changes part of the description of comprehensions to
each Qualifier is either a generator, a binder, or a filter.</p>

<p>A generator is a list generator, a tuple generator,
or a bit string generator.</p>

<p>A list generator is written as
        Pattern &lt;- List<em>Expr
or as
        Pattern [&lt;-] List</em>Expr
where List_Expr is an expression which must evaluate to
a list of terms.</p>

<p>A tuple generator is written as
        Pattern {&lt;-} Tuple<em>Expr
where Tuple</em>Expr is an expression which must evaluate to
a tuple of terms.</p>

<p>A bit string generator is written as
        Bit<em>String</em>Pattern &lt;= Bit<em>String</em>Expr
or as
        Bit<em>String</em>Pattern &lt;&lt; &lt;- >> Bit<em>String</em>Expr
where Bit<em>String</em>Expr is an expression which must
evaluate to a bit string.</p>

<p>The variables in the generator patterns shadow variables in the
function clause surrounding the comprehension.  These variables
are not visible outside the comprehension.</p>

<p>A binder has the form
    Pattern = Expr
or
    Pattern = Binder
This evaluates the Expr and matches the result against the
Pattern, binding variables in it.
The variables in the binder patterns shadow variables in the
function clause surrounding the comprehension.  These variables
are not visible outside the comprehension.</p>

<p>A filter is an expression which evaluates to 'true' or 'false'.
They are not limited to being guard tests.</p>

<h1>Motivation</h1>

<p>Using Clean as well as Erlang, the lack of tuple comprehensions
and tuple generators is an irritation.  It is possible to get the
desired effect in the existing language, but especially since
bit string comprehensions were added to the language, the
omission seems utterly pointless.  The new forms are easier to
think of and easier to read than forms that go through list
comprehensions.</p>

<p>Haskell list comprehensions allow generators, filters, and
'let' bindings.  The lack of let bindings in Erlang list
comprehensions is difficult to understand; the fact that what
LOOKS like Erlang's equivalent of let bindings is allowed but
misbehaves at run time is difficult to forgive.</p>

<h1>Rationale</h1>

<p>The syntax for tuple comprehensions is obvious; no other syntax
would be tolerable.</p>

<p>The syntax for tuple generators has a certain gawky charm;
perhaps only a mother could love it.  I tried &lt;-[] &lt;-{} &lt;-&lt;&lt;>>
but had trouble getting Yecc to like those.  If it can be
squeezed past Yecc's limited lookahead somehow, the forms with
the arrow outside the brackets would be prettier.  Contrast
    { X+1 || X {&lt;-} Xs }
    { X+1 || X &lt;-{} Xs }</p>

<p>The way Erlang currently allows Pattern = Expr in comprehension
qualifiers but gives it a completely useless meaning is a syntax
bug that needs urgent correction.  One approach is to recognise
attempts to use the form and report them as syntax errors; to me
it seems better to implement it so that it works as expected.</p>

<p>All three of these extensions can be implemented by mapping to
the current language:</p>

<pre><code>{ E || GT }  =&gt; erlang:list_to_tuple([E || GT])
P {&lt;-} E     =&gt; P &lt;- erlang:tuple_to_list(E)
P = E        =&gt; P &lt;- [E]
</code></pre>

<p>and the reference implementation does exactly that.  However,
better implementations are possible, as for that matter are
better implementations of list comprehension, and in the mean
time at least the code will be no less efficient than what the
programmer could have written and the source will be more
intention-revealing.</p>

<h1>Backwards Compatibility</h1>

<p>The new comprehension and generator forms are currently syntax
errors, so no existing code can be affected by them.</p>

<p>The new binder form (or rather, the newly correct recognition
of binder forms) is currently allowed by the Erlang compiler.
However, as explained above, it cannot possibly be USEFUL with
its current reading.  It is conceivable that there might be
test programs designed to elicit the bug which will stop working
once the syntax bug is fixed, but it is not likely that any real
code will be affected.</p>

<h1>Reference Implementation</h1>

<p>The auxiliary file <a href="eep-0012-1.diff" title="Patch file to be applied to erl_parse.yrl"><code>eep-0012-1.diff</code></a> is a patch file to be
applied to <code>erl_parse.yrl</code>. The patched file has been checked by <code>yecc</code>,
which is happy with it. However, that's all the testing that has been done.</p>

<p>This implementation does the three source to source rewrites
described in the previous section, entirely in the parser.
The rest of the Erlang system needs no changes whatever.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0012","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 10-Jul-2008\nErlang-Version: R12B-4\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 12: \u003ca href=\"eep-0012.md\" title=\"EEP Source\"\u003e Extensions to comprehensions\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eAdd tuple-valued comprehensions to go with list and binary\ncomprehensions.\u003c/p\u003e\n\n\u003cp\u003eAdd tuple generators to go with list and binary generators.\u003c/p\u003e\n\n\u003cp\u003eFix a syntax botch in comprehension qualifiers by explicitly\nrecognising pattern = value bindings and treating them in a\nway that makes sense.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eCurrently, Erlang has\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    '['  Expr '||' Generators-And-Tests ']'\n    '\u0026lt;\u0026lt;' Expr '||' Generators-And-Tests '\u0026gt;\u0026gt;'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003efor generating lists and binaries, but there is no corresponding\nform for generating tuples.  We add\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    '{' Expr '||' Generators-And-Tests '}'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewith the meaning that \u003ccode\u003e{ E || G }\u003c/code\u003e has the same behaviour as\n\u003ccode\u003eerlang:list_to_tuple([E || G])\u003c/code\u003e except that it need not call\n\u003ccode\u003eerlang:list_to_tuple/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eCurrently, Erlang comprehensions allow\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    Pattern '\u0026lt;-' Expr\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eto enumerate over list and\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    Pattern '\u0026lt;=' Expr\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eto enumerate over binaries.  The second of these forms is,\nI must say, not just asking for trouble, but screaming for it.\nThis proposal adds three new forms:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    Pattern '['  '\u0026lt;-' ']'  Expr\n    Pattern '{'  '\u0026lt;-' '}'  Expr\n    Pattern '\u0026lt;\u0026lt;' '\u0026lt;-' '\u0026gt;\u0026gt;' Expr\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003efor enumerating over lists, tuples, and binaries respectively,\nproviding an iconic representation of what Expr should be.\n\u003ccode\u003e[\u0026lt;-]\u003c/code\u003e and \u003ccode\u003e\u0026lt;\u0026lt; \u0026lt;- \u0026gt;\u0026gt;\u003c/code\u003e have exactly the same semantics as the\nexisting \u003ccode\u003e\u0026lt;-\u003c/code\u003e and \u003ccode\u003e\u0026lt;=\u003c/code\u003e do.  The semantics of Pattern \u003ccode\u003e{\u0026lt;=}\u003c/code\u003e Expr\nis that of \u003ccode\u003ePattern \u0026lt;- erlang:tuple_to_list(Expr)\u003c/code\u003e, except that\n\u003ccode\u003eerlang:tuple_to_list/1\u003c/code\u003e need not be called.\u003c/p\u003e\n\n\u003cp\u003eCurrently the Generators-And-Tests part allows a sequence of\ngenerators and tests, where a test is any expression.  A test\nmust evaluate to either 'false' or 'true'.  The form \u003ccode\u003ePattern = Expr\u003c/code\u003e\nis syntactically an expression, so is allowed as a test.\nHowever, in context, this makes no sense.  For a given Expr,\nthere are four possible outcomes:\n1. Expr raises an exception =\u003e an exception is raised.\n2. Expr does not yield false or true =\u003e an exception is raised.\n3. Expr yields false =\u003e the test fails;\n   this might as well have been Expr without Pattern.\n4. Expr yields true =\u003e the test succeeds;\n   this might as well have been Expr without Pattern,\u003c/p\u003e\n\n\u003ch1\u003e   and Pattern = true beforehand.\u003c/h1\u003e\n\n\u003cp\u003eThis proposal changes part of the description of comprehensions to\neach Qualifier is either a generator, a binder, or a filter.\u003c/p\u003e\n\n\u003cp\u003eA generator is a list generator, a tuple generator,\nor a bit string generator.\u003c/p\u003e\n\n\u003cp\u003eA list generator is written as\n        Pattern \u0026lt;- List\u003cem\u003eExpr\nor as\n        Pattern [\u0026lt;-] List\u003c/em\u003eExpr\nwhere List_Expr is an expression which must evaluate to\na list of terms.\u003c/p\u003e\n\n\u003cp\u003eA tuple generator is written as\n        Pattern {\u0026lt;-} Tuple\u003cem\u003eExpr\nwhere Tuple\u003c/em\u003eExpr is an expression which must evaluate to\na tuple of terms.\u003c/p\u003e\n\n\u003cp\u003eA bit string generator is written as\n        Bit\u003cem\u003eString\u003c/em\u003ePattern \u0026lt;= Bit\u003cem\u003eString\u003c/em\u003eExpr\nor as\n        Bit\u003cem\u003eString\u003c/em\u003ePattern \u0026lt;\u0026lt; \u0026lt;- \u003e\u003e Bit\u003cem\u003eString\u003c/em\u003eExpr\nwhere Bit\u003cem\u003eString\u003c/em\u003eExpr is an expression which must\nevaluate to a bit string.\u003c/p\u003e\n\n\u003cp\u003eThe variables in the generator patterns shadow variables in the\nfunction clause surrounding the comprehension.  These variables\nare not visible outside the comprehension.\u003c/p\u003e\n\n\u003cp\u003eA binder has the form\n    Pattern = Expr\nor\n    Pattern = Binder\nThis evaluates the Expr and matches the result against the\nPattern, binding variables in it.\nThe variables in the binder patterns shadow variables in the\nfunction clause surrounding the comprehension.  These variables\nare not visible outside the comprehension.\u003c/p\u003e\n\n\u003cp\u003eA filter is an expression which evaluates to 'true' or 'false'.\nThey are not limited to being guard tests.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eUsing Clean as well as Erlang, the lack of tuple comprehensions\nand tuple generators is an irritation.  It is possible to get the\ndesired effect in the existing language, but especially since\nbit string comprehensions were added to the language, the\nomission seems utterly pointless.  The new forms are easier to\nthink of and easier to read than forms that go through list\ncomprehensions.\u003c/p\u003e\n\n\u003cp\u003eHaskell list comprehensions allow generators, filters, and\n'let' bindings.  The lack of let bindings in Erlang list\ncomprehensions is difficult to understand; the fact that what\nLOOKS like Erlang's equivalent of let bindings is allowed but\nmisbehaves at run time is difficult to forgive.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe syntax for tuple comprehensions is obvious; no other syntax\nwould be tolerable.\u003c/p\u003e\n\n\u003cp\u003eThe syntax for tuple generators has a certain gawky charm;\nperhaps only a mother could love it.  I tried \u0026lt;-[] \u0026lt;-{} \u0026lt;-\u0026lt;\u0026lt;\u003e\u003e\nbut had trouble getting Yecc to like those.  If it can be\nsqueezed past Yecc's limited lookahead somehow, the forms with\nthe arrow outside the brackets would be prettier.  Contrast\n    { X+1 || X {\u0026lt;-} Xs }\n    { X+1 || X \u0026lt;-{} Xs }\u003c/p\u003e\n\n\u003cp\u003eThe way Erlang currently allows Pattern = Expr in comprehension\nqualifiers but gives it a completely useless meaning is a syntax\nbug that needs urgent correction.  One approach is to recognise\nattempts to use the form and report them as syntax errors; to me\nit seems better to implement it so that it works as expected.\u003c/p\u003e\n\n\u003cp\u003eAll three of these extensions can be implemented by mapping to\nthe current language:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{ E || GT }  =\u0026gt; erlang:list_to_tuple([E || GT])\nP {\u0026lt;-} E     =\u0026gt; P \u0026lt;- erlang:tuple_to_list(E)\nP = E        =\u0026gt; P \u0026lt;- [E]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand the reference implementation does exactly that.  However,\nbetter implementations are possible, as for that matter are\nbetter implementations of list comprehension, and in the mean\ntime at least the code will be no less efficient than what the\nprogrammer could have written and the source will be more\nintention-revealing.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThe new comprehension and generator forms are currently syntax\nerrors, so no existing code can be affected by them.\u003c/p\u003e\n\n\u003cp\u003eThe new binder form (or rather, the newly correct recognition\nof binder forms) is currently allowed by the Erlang compiler.\nHowever, as explained above, it cannot possibly be USEFUL with\nits current reading.  It is conceivable that there might be\ntest programs designed to elicit the bug which will stop working\nonce the syntax bug is fixed, but it is not likely that any real\ncode will be affected.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eThe auxiliary file \u003ca href=\"eep-0012-1.diff\" title=\"Patch file to be applied to erl_parse.yrl\"\u003e\u003ccode\u003eeep-0012-1.diff\u003c/code\u003e\u003c/a\u003e is a patch file to be\napplied to \u003ccode\u003eerl_parse.yrl\u003c/code\u003e. The patched file has been checked by \u003ccode\u003eyecc\u003c/code\u003e,\nwhich is happy with it. However, that's all the testing that has been done.\u003c/p\u003e\n\n\u003cp\u003eThis implementation does the three source to source rewrites\ndescribed in the previous section, entirely in the parser.\nThe rest of the Erlang system needs no changes whatever.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0012"},"buildId":"aoeL97fiGQMaunPBLLCoJ","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_buildManifest.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_ssgManifest.js" async=""></script></body></html>