{"pageProps":{"item":{"id":"IO-Polling","title":"I/O polling options in OTP 21","author":"Lukas Larsson","excerpt":"\nErlang/OTP 21 will introduce a completely new IO polling implementation.\nThis new implementation comes with a new set of tuneable parameters that\ncan be used to get the most out of your system. This blog post describes\nthe parameters and attempts to describe what they should be used for.","article_date":1523404800000,"tags":["erts","polling","tcp"],"frontmatter":{"layout":"post","title":"I/O polling options in OTP 21","tags":"erts polling tcp","author":"Lukas Larsson"},"content":"\nErlang/OTP 21 will introduce a completely new IO polling implementation.\nThis new implementation comes with a new set of tuneable parameters that\ncan be used to get the most out of your system. This blog post describes\nthe parameters and attempts to describe what they should be used for.\n\nThe I/O polling framework in erts is responsible for delivering events to\nports and processes that have subscribed to events on file descriptors.\nBefore OTP 21 it was the job of an Erlang scheduler thread to deliver these\nevents. In OTP 21 dedicated threads are used to deliver the events.\n\nFor information about how the new implementation works under the hood you can\nlook at Kenneth Lundin's presentation [Erlang VM News Regarding Dirty Schedulers and I/O](http://www.erlang-factory.com/euc2017/kenneth-lundin)\nfrom the EUC 2017.\n\n## Kernel-space vs User-space polling\n\nIn OTP 21 the `+K` option has been removed as it is not longer possible to\nchoose whether to use kernel-space poll or not at run-time. Instead the decision\nis made at compile time where kernel-space poll will be used by default. If you\nwant to use user-space poll instead you have to pass the `--disable-kernel-poll`\nflag to configure when compiling Erlang/OTP.\n\nBefore OTP 21 it made sense to run using user-space polling if the file\ndescriptors that was subscribed to tended to be removed quickly. For example\nif a HTTP server managed short-lived connection from only a handful other\nmachines, it could be beneficial to use user-space poll. However if the\nconnection start being long-lived, or the number of concurrent connection\ngo up, kernel-space poll becomes better.\n\nIn OTP 21, this is no longer true. Because the polling has been moved to another\nthread, it is almost always better to use kernel-space polling. The user-space\npolling implementation is left in place for platforms that do not support\nparallel update of the kernel-space pollset. Also user-space polling is used\nfor individual file descriptors when they cannot be put in a kernel-space pollset\nfor some reason.\n\n## Poll-threads and Poll-sets\n\nOTP 21 introduces two new configuration parameters: +IOt and +IOp.\n\n### Configure +IOt\n\n+IOt controls the number of threads that are used to deliver events. The default\nis 1 and it should be enough for most applications. However on very busy\nsystems with many concurrent connection it could be beneficial to increase this.\nOne way to get an indication of whether your system could benefit from it is\nby using [msacc](http://erlang.org/doc/man/msacc.html). If you turn it on briefly\nand when examining the `msacc:print()` output notice that sleep time\nof the the thread type `poll` is low, the system may benefit from increasing the\nnumber of polling threads.\n\n```\nEshell V9.3  (abort with ^G)\n1> msacc:start(10000),msacc:print().\nAverage thread real-time    : 10000410 us\nAccumulated system run-time :      937 us\nAverage scheduler run-time  :      897 us\n\n        Thread      aux check_io emulator       gc    other     port    sleep\n\nStats per thread:\n     async( 0)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n       aux( 1)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_cpu_( 1)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_io_s( 1)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n      poll( 0)    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n scheduler( 1)    0.00%    0.00%    0.00%    0.00%    0.01%    0.00%   99.99%\n\nStats per type:\n         async    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n           aux    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_cpu_sche    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\ndirty_io_sched    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n          poll    0.00%    0.00%    0.00%    0.00%    0.00%    0.00%  100.00%\n     scheduler    0.00%    0.00%    0.00%    0.00%    0.01%    0.00%   99.99%\n```\n\nIn the example above the poll thread is sleeping for 100% of the time so no need to\nincrease the number of poll threads.\n\n### Configure +IOp\n\n+IOp controls the number of pollsets used to put the file descriptors in. This\noptions defaults to 1, and it should be very rare for any system to benefit\nfrom changing this. The only time so far that I have seen it to be beneficial is when the\nkernel-space poll implementation does not scale well when accessed in parallel\nby multiple threads. So if you run [perf top](http://man7.org/linux/man-pages/man1/perf-top.1.html)\n(or something similar) on your system and notice that a lot of time is spent\nlocking the kernel-space pollset, it would be a good idea to increase the\nnumber of pollsets used.\n"}},"__N_SSG":true}