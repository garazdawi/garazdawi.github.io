<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 14-Aug-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 19: <a href="eep-0019.md" title="EEP Source"> Comprehension multigenerators</a></h2>

<h1>Abstract</h1>

<p>Add Clean-inspired multi-sequence generators to comprehensions,
making code more intention-revealing and reducing the need to zip.</p>

<p>This is related to <a href="/eeps/eep-0012" title="EEP 12">EEP 12</a>, but is independent of it.</p>

<h1>Specification</h1>

<p>Currently, Erlang has</p>

<pre><code>Pattern &lt;- Expr
</code></pre>

<p>to enumerate over the elements of a single list and</p>

<pre><code>Pattern &lt;= Expr
</code></pre>

<p>to enumerate over a binary.  <a href="/eeps/eep-0012" title="EEP 12">EEP 12</a> adds</p>

<pre><code>Pattern [&lt;-] List
Pattern {&lt;-} Tuple
Pattern &lt;&lt;&lt;-&gt;&gt; Binary
</code></pre>

<p>This proposal changes that to</p>

<pre><code>generator: term_generator | binary_generator;
binary_generator: pattern '&lt;=' expression;
term_generator: term_generator '&amp;&amp;' term_generator
              | pattern '&lt;-' expression;
</code></pre>

<p>if we otherwise stick with current Erlang, or</p>

<pre><code>generator: term_generator | binary_generator;
binary_generator: pattern '&lt;=' expression
                | pattern '&lt;&lt;' '&lt;-' '&gt;&gt;' expression;
term_generator: term_generator '&amp;&amp;' term_generator
              | pattern '&lt;-' expression
              | pattern '[' '&lt;-' ']' expression
              | pattern '{' '&lt;-' '}' expression;
</code></pre>

<p>if we go with <a href="/eeps/eep-0012" title="EEP 12">EEP 12</a>.</p>

<p>Roughly speaking, ignoring errors and side effects,
the effect of <code>P1 &lt;- E1 &amp;&amp; ... Pn &lt;- En</code>
is the effect of <code>{P1,...,Pn} &lt;- zip(E1, ..., En)</code>
where</p>

<pre><code>zip([X1|Xs1], ..., [Xn|Xsn]) -&gt;
    [{X1,...,Xn} | zip(Xs1, ..., Xsn)];
zip([], ..., []) -&gt;
    [].
</code></pre>

<p>However, it is expected that there will NOT be any extra list
or tuples created by the implementation; this specifies the
effect but NOT how it is to be implemented.</p>

<p>The effect of a term generator using the new notations of EEP 12
is that which would be obtained by first replacing</p>

<pre><code>P {&lt;-} E   with   P &lt;- tuple_to_list(E)
P [&lt;-] E   with   P &lt;- E
</code></pre>

<p>and then applying the translation above.</p>

<p>In the presence of errors, the behaviour of &amp;&amp; is not precisely
the same as using zip.  We need to specify the actual behaviour
more precisely.  For brevity, I ignore binary enumeration.  Both
tuple enumeration and tuple comprehension are currently defined
by rewriting to plain list comprehension, so that's all we need
to worry about for now.</p>

<p>A list comprehension has the form <code>[E || C1, ..., Cn]</code>
where each Ci is</p>

<ul>
<li>a generator <code>Pattern &lt;- List_Expression</code></li>
<li>a binding   <code>Pattern =  Any_Expression</code></li>
<li>a "guard"   <code>Other_Expression</code> that should give true or false.</li>
</ul>

<p>This acts like</p>

<pre><code>R = [],
&lt;| E || [C1, ..., Cn] |&gt;(R),
reverse(R)
</code></pre>

<p>where</p>

<pre><code>&lt;| E || [] |&gt;(R)
=&gt;  R = [E | R]             % reassign R

&lt;| E || [Pi &lt;- Ei|Cs] |&gt;(R)
=&gt;  Ti = Ei
    Label: case Ti
             of [Pi|X] -&gt; Ti = X % reassign Ti
                          &lt;| E || Cs |&gt;(R)
                          goto Label
              ; [_ |X] -&gt; Ti = X % reassign Ti
                          goto Label
              ; []     -&gt; ok                              
           end

&lt;| E || [Pi = Ei|Cs] |&gt;(R)
=&gt;  case Ei
      of Pi -&gt; &lt;| E || Cs |&gt;(R)
       ; _  -&gt; ok
    end

&lt;| E || [Ei|Cs] |&gt;(R)
=&gt;  case Ei
      of true  -&gt; &lt;| E || Cs |&gt;(R)
       ; false -&gt; ok
    end
</code></pre>

<p>In these translations, pattern matching syntax is used, with the
intent that the variables which are unbound according to the
normal rules of Erlang, and thus get bound by the Pi &lt;- or Pi =
matching, are treated <em>as if</em> unbound in the code to be generated,
ignoring whatever values they might previous have had.  That also
applies when R or Ti appears on the left of a pattern match; the
fact that the variable really was bound is ignored and a simple
assignment is done.</p>

<p>This does involve (re-)assignment to local variables in the code
to be generated, but it does NOT involve user-visible assignment
and it does NOT involve mutable data structures.  It is no more
problematic for the language or the runtime system than reusing a
dead register is.</p>

<p>Handling multi-list enumeration is a simple, albeit schematic,
change to the rule for enumeration.</p>

<pre><code>&lt;| E || [Pi1 &lt;- Ei1 &amp;&amp; Pi2 &lt;- Ei2 &amp;&amp; ... &amp;&amp; Pik &lt;- Eik|Cs] |&gt;(R)
=&gt;  Ti1 = Ei1
    ...
    Tik = Eik
    Label: case {Ti1,...,Tik}
             of {[Pi1|X1], ..., [Pik,Xk]} -&gt;
                Ti1 = X1    % reassign
                ...
                Tik = Xk    % reassign
                &lt;| E || Cs |&gt;(R)
                goto label
              ; {[_|X1], ..., [_|Xk]} -&gt;
                Ti1 = X1    % reassign
                ...
                Tik = Xk    % reassign
              ; {[], ..., []} -&gt;
                ok
           end
</code></pre>

<p>Note that the use of tuple syntax in the case expression and the
case clauses does not imply the literal creation of a tuple in
the generated code, only that k values are to be matched against
k patterns in each case clause.</p>

<h1>Motivation</h1>

<p>"How do I iterate over several lists at once?" is a moderately
common question from Erlang and Haskell beginners.  The stock
answer, "use zip", is almost tolerable for Haskell, where the
the zipping family goes up to 7 lists and the compiler works
hard to eliminate the intermediate data structures by using
deforestation.  For Erlang, where even zip4 is missing, and
where the apparent cost of creating the unwanted list and
tuples is all too real, the fact that the use of zips makes
the code harder to read means that there is no good to
outweigh the bad.</p>

<p>With the new notation,</p>

<pre><code>zip4(As, Bs, Cs, Ds) -&gt;
    [{A,B,C,D} || A &lt;- As &amp;&amp; B &lt;- Bs &amp;&amp; C &lt;- Cs &amp;&amp; D &lt;- Ds].

zipwith4(F, As, Bs, Cs, Ds) -&gt;
    [F(A,B,C,D) || A &lt;- As &amp;&amp; B &lt;- Bs &amp;&amp; C &lt;- Cs &amp;&amp; D &lt;- Ds].

dot(Xs, Ys) -&gt;
    sum([X*Y || X &lt;- Xs &amp;&amp; Y &lt;- Ys]).

ifelse(Tests, Xs, Ys) -&gt; % Simulate R's ifelse(,,)
    [  case T of true -&gt; X ; false -&gt; Y end
    || T &lt;- Tests &amp;&amp; X &lt;- Xs &amp;&amp; Y &lt;- Ys
    ].
</code></pre>

<p>This code from module <code>dialyzer_dep</code></p>

<pre><code>merge_outs([#output{type=list, content=L1}|Left],
           #output{type=list, content=L2}) -&gt;
  NewList = [merge_outs([X, Y]) || {X, Y} &lt;- lists:zip(L1, L2)],
  merge_outs(Left, output(NewList));
</code></pre>

<p>would become</p>

<pre><code>merge_outs([#output{type=list, content=L1}|Left],
            #output{type=list, content=L2]) -&gt;
    merge_outs(Left, output(
        [merge_outs([X,Y]) || X &lt;- L1 &amp;&amp; Y &lt;- L2]));
</code></pre>

<p>This code from <code>forward_args/3</code> in module <code>dialyzer_dataflow</code></p>

<pre><code>NewArgTypes = [t_sup(X, Y) ||
               {X, Y} &lt;- lists:zip(ArgTypes, OldArgTypes)],
</code></pre>

<p>would become</p>

<pre><code>NewArgTypes = [t_sup(X, Y) || X &lt;- ArgTypes &amp;&amp; Y &lt;- OldArgTypes],
</code></pre>

<h1>Rationale</h1>

<p>This is a case where no invention is required, really.
Clean has</p>

<pre><code>Qualifier = Generators {|Guard}
Generators = {Generator}-list
           | Generator {&amp; Generator}
Generator = Selector &lt;- ListExpr // lazy list
          | Selector &lt;|- ListExpr // overloaded list
          | Selector &lt;-: ArrayExpr //  array
</code></pre>

<p>All I have to do is bend this a little to fit it into Erlang
syntax.  Since we use "||" for list comprehensions, "&amp;&amp;" was
the obvious spelling for generators that step together.</p>

<p>I do not yet understand in detail what the Erlang compiler
does, but it seems to involve generating an auxiliary function.
Let's take</p>

<pre><code>[f(X) || X &lt;- Xs, X &gt; 0]
</code></pre>

<p>as an example.  This seems to be compiled as</p>

<pre><code>foo(Xs)
</code></pre>

<p>where</p>

<pre><code>foo([X|Xs]) when X &gt; 0 -&gt; [f(X) | foo(Xs)];
foo([_|Xs]) -&gt; foo(Xs);
foo([]) -&gt; [].
</code></pre>

<p>With a multi-sequence generator, the translation is similar.</p>

<pre><code>[g(X, Y) || X &lt;- Xs &amp;&amp; Y &lt;- Ys, X &gt; Y]
</code></pre>

<p>can be compiled as</p>

<pre><code>bar(Xs, Ys)
</code></pre>

<p>where</p>

<pre><code>bar([X|Xs], [Y|Ys]) when X &gt; Y -&gt;
    [g(X, Y) | bar(Xs, Ys)];
bar([_|Xs], [_|Ys]) -&gt; bar(Xs, Ys);
bar([], []) -&gt; [].
</code></pre>

<p>The specification above gives the kind of translation I would like
to see; I do have an implementation in mind (based on Pop-2) that
doesn't need the reversal but don't know how it would fit in BEAM.</p>

<p>One obvious question is whether we need this at all.  Why not just
get people to write calls to <code>lists:zip</code> and get the compiler to
optimise them?  One answer is that this notation is much clearer;
the programmer's <em>intent</em> is to advance along two or more lists
at the same time, not to create a list of pairs.  When you want to
create a list of pairs, <code>lists:zip/2</code> is the perfect way to do it.
A more important answer is that the proposed notation is NOT a
simple optimisation of equivalent code using <code>lists:zip/2</code>.</p>

<pre><code>[E || {P,Q} &lt;- lists:zip(A, B)]    % "zip version"
</code></pre>

<p>fails at once if A and B are not proper lists of the same length.</p>

<pre><code>[E || P &lt;- A &amp;&amp; Q &lt;- B]            % "Clean version"
</code></pre>

<p>eventually fails if A and B are not proper lists of the same
length, but may have evaluated E (which may have had side effects)
many times before that.  So an Erlang compiler would not be
allowed to replace the "zip version" by the "Clean version" unless
it could prove both that A and B were lists (which may be within
the abilities of the Dialyzer) and that they were exactly the same
length (which as far as I know isn't).</p>

<p>However, a multi-sequence generator and a single-sequence one
using calls to <code>lists:zip/2</code> are clearly <em>similar</em>, so they should
eventually react to lists of different length the same way.
In Haskell, zipping two lists of different length acts as if the
longer were truncated to the length of the shorter.  Since
Haskell has lazy evaluation, lists may be infinite, so you can't
afford to wait until the end to start a comprehension.  Since
Erlang is strict, and since mistakes are common, <code>lists:zip/2</code> in
Erlang makes sense as it is.</p>

<h1>Backwards Compatibility</h1>

<p>The "operator" '&amp;&amp;' is not legal syntax anywhere in Erlang
at the moment, so no existing code can be affected.</p>

<h1>Reference Implementation</h1>

<p>None yet, but I'd like to do it when I can figure out how.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0019","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 14-Aug-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 19: \u003ca href=\"eep-0019.md\" title=\"EEP Source\"\u003e Comprehension multigenerators\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eAdd Clean-inspired multi-sequence generators to comprehensions,\nmaking code more intention-revealing and reducing the need to zip.\u003c/p\u003e\n\n\u003cp\u003eThis is related to \u003ca href=\"/eeps/eep-0012\" title=\"EEP 12\"\u003eEEP 12\u003c/a\u003e, but is independent of it.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eCurrently, Erlang has\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePattern \u0026lt;- Expr\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eto enumerate over the elements of a single list and\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePattern \u0026lt;= Expr\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eto enumerate over a binary.  \u003ca href=\"/eeps/eep-0012\" title=\"EEP 12\"\u003eEEP 12\u003c/a\u003e adds\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePattern [\u0026lt;-] List\nPattern {\u0026lt;-} Tuple\nPattern \u0026lt;\u0026lt;\u0026lt;-\u0026gt;\u0026gt; Binary\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis proposal changes that to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003egenerator: term_generator | binary_generator;\nbinary_generator: pattern '\u0026lt;=' expression;\nterm_generator: term_generator '\u0026amp;\u0026amp;' term_generator\n              | pattern '\u0026lt;-' expression;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eif we otherwise stick with current Erlang, or\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003egenerator: term_generator | binary_generator;\nbinary_generator: pattern '\u0026lt;=' expression\n                | pattern '\u0026lt;\u0026lt;' '\u0026lt;-' '\u0026gt;\u0026gt;' expression;\nterm_generator: term_generator '\u0026amp;\u0026amp;' term_generator\n              | pattern '\u0026lt;-' expression\n              | pattern '[' '\u0026lt;-' ']' expression\n              | pattern '{' '\u0026lt;-' '}' expression;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eif we go with \u003ca href=\"/eeps/eep-0012\" title=\"EEP 12\"\u003eEEP 12\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eRoughly speaking, ignoring errors and side effects,\nthe effect of \u003ccode\u003eP1 \u0026lt;- E1 \u0026amp;\u0026amp; ... Pn \u0026lt;- En\u003c/code\u003e\nis the effect of \u003ccode\u003e{P1,...,Pn} \u0026lt;- zip(E1, ..., En)\u003c/code\u003e\nwhere\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ezip([X1|Xs1], ..., [Xn|Xsn]) -\u0026gt;\n    [{X1,...,Xn} | zip(Xs1, ..., Xsn)];\nzip([], ..., []) -\u0026gt;\n    [].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHowever, it is expected that there will NOT be any extra list\nor tuples created by the implementation; this specifies the\neffect but NOT how it is to be implemented.\u003c/p\u003e\n\n\u003cp\u003eThe effect of a term generator using the new notations of EEP 12\nis that which would be obtained by first replacing\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eP {\u0026lt;-} E   with   P \u0026lt;- tuple_to_list(E)\nP [\u0026lt;-] E   with   P \u0026lt;- E\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand then applying the translation above.\u003c/p\u003e\n\n\u003cp\u003eIn the presence of errors, the behaviour of \u0026amp;\u0026amp; is not precisely\nthe same as using zip.  We need to specify the actual behaviour\nmore precisely.  For brevity, I ignore binary enumeration.  Both\ntuple enumeration and tuple comprehension are currently defined\nby rewriting to plain list comprehension, so that's all we need\nto worry about for now.\u003c/p\u003e\n\n\u003cp\u003eA list comprehension has the form \u003ccode\u003e[E || C1, ..., Cn]\u003c/code\u003e\nwhere each Ci is\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ea generator \u003ccode\u003ePattern \u0026lt;- List_Expression\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ea binding   \u003ccode\u003ePattern =  Any_Expression\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003ea \"guard\"   \u003ccode\u003eOther_Expression\u003c/code\u003e that should give true or false.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThis acts like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eR = [],\n\u0026lt;| E || [C1, ..., Cn] |\u0026gt;(R),\nreverse(R)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;| E || [] |\u0026gt;(R)\n=\u0026gt;  R = [E | R]             % reassign R\n\n\u0026lt;| E || [Pi \u0026lt;- Ei|Cs] |\u0026gt;(R)\n=\u0026gt;  Ti = Ei\n    Label: case Ti\n             of [Pi|X] -\u0026gt; Ti = X % reassign Ti\n                          \u0026lt;| E || Cs |\u0026gt;(R)\n                          goto Label\n              ; [_ |X] -\u0026gt; Ti = X % reassign Ti\n                          goto Label\n              ; []     -\u0026gt; ok                              \n           end\n\n\u0026lt;| E || [Pi = Ei|Cs] |\u0026gt;(R)\n=\u0026gt;  case Ei\n      of Pi -\u0026gt; \u0026lt;| E || Cs |\u0026gt;(R)\n       ; _  -\u0026gt; ok\n    end\n\n\u0026lt;| E || [Ei|Cs] |\u0026gt;(R)\n=\u0026gt;  case Ei\n      of true  -\u0026gt; \u0026lt;| E || Cs |\u0026gt;(R)\n       ; false -\u0026gt; ok\n    end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn these translations, pattern matching syntax is used, with the\nintent that the variables which are unbound according to the\nnormal rules of Erlang, and thus get bound by the Pi \u0026lt;- or Pi =\nmatching, are treated \u003cem\u003eas if\u003c/em\u003e unbound in the code to be generated,\nignoring whatever values they might previous have had.  That also\napplies when R or Ti appears on the left of a pattern match; the\nfact that the variable really was bound is ignored and a simple\nassignment is done.\u003c/p\u003e\n\n\u003cp\u003eThis does involve (re-)assignment to local variables in the code\nto be generated, but it does NOT involve user-visible assignment\nand it does NOT involve mutable data structures.  It is no more\nproblematic for the language or the runtime system than reusing a\ndead register is.\u003c/p\u003e\n\n\u003cp\u003eHandling multi-list enumeration is a simple, albeit schematic,\nchange to the rule for enumeration.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;| E || [Pi1 \u0026lt;- Ei1 \u0026amp;\u0026amp; Pi2 \u0026lt;- Ei2 \u0026amp;\u0026amp; ... \u0026amp;\u0026amp; Pik \u0026lt;- Eik|Cs] |\u0026gt;(R)\n=\u0026gt;  Ti1 = Ei1\n    ...\n    Tik = Eik\n    Label: case {Ti1,...,Tik}\n             of {[Pi1|X1], ..., [Pik,Xk]} -\u0026gt;\n                Ti1 = X1    % reassign\n                ...\n                Tik = Xk    % reassign\n                \u0026lt;| E || Cs |\u0026gt;(R)\n                goto label\n              ; {[_|X1], ..., [_|Xk]} -\u0026gt;\n                Ti1 = X1    % reassign\n                ...\n                Tik = Xk    % reassign\n              ; {[], ..., []} -\u0026gt;\n                ok\n           end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that the use of tuple syntax in the case expression and the\ncase clauses does not imply the literal creation of a tuple in\nthe generated code, only that k values are to be matched against\nk patterns in each case clause.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003e\"How do I iterate over several lists at once?\" is a moderately\ncommon question from Erlang and Haskell beginners.  The stock\nanswer, \"use zip\", is almost tolerable for Haskell, where the\nthe zipping family goes up to 7 lists and the compiler works\nhard to eliminate the intermediate data structures by using\ndeforestation.  For Erlang, where even zip4 is missing, and\nwhere the apparent cost of creating the unwanted list and\ntuples is all too real, the fact that the use of zips makes\nthe code harder to read means that there is no good to\noutweigh the bad.\u003c/p\u003e\n\n\u003cp\u003eWith the new notation,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ezip4(As, Bs, Cs, Ds) -\u0026gt;\n    [{A,B,C,D} || A \u0026lt;- As \u0026amp;\u0026amp; B \u0026lt;- Bs \u0026amp;\u0026amp; C \u0026lt;- Cs \u0026amp;\u0026amp; D \u0026lt;- Ds].\n\nzipwith4(F, As, Bs, Cs, Ds) -\u0026gt;\n    [F(A,B,C,D) || A \u0026lt;- As \u0026amp;\u0026amp; B \u0026lt;- Bs \u0026amp;\u0026amp; C \u0026lt;- Cs \u0026amp;\u0026amp; D \u0026lt;- Ds].\n\ndot(Xs, Ys) -\u0026gt;\n    sum([X*Y || X \u0026lt;- Xs \u0026amp;\u0026amp; Y \u0026lt;- Ys]).\n\nifelse(Tests, Xs, Ys) -\u0026gt; % Simulate R's ifelse(,,)\n    [  case T of true -\u0026gt; X ; false -\u0026gt; Y end\n    || T \u0026lt;- Tests \u0026amp;\u0026amp; X \u0026lt;- Xs \u0026amp;\u0026amp; Y \u0026lt;- Ys\n    ].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis code from module \u003ccode\u003edialyzer_dep\u003c/code\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003emerge_outs([#output{type=list, content=L1}|Left],\n           #output{type=list, content=L2}) -\u0026gt;\n  NewList = [merge_outs([X, Y]) || {X, Y} \u0026lt;- lists:zip(L1, L2)],\n  merge_outs(Left, output(NewList));\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewould become\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003emerge_outs([#output{type=list, content=L1}|Left],\n            #output{type=list, content=L2]) -\u0026gt;\n    merge_outs(Left, output(\n        [merge_outs([X,Y]) || X \u0026lt;- L1 \u0026amp;\u0026amp; Y \u0026lt;- L2]));\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis code from \u003ccode\u003eforward_args/3\u003c/code\u003e in module \u003ccode\u003edialyzer_dataflow\u003c/code\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eNewArgTypes = [t_sup(X, Y) ||\n               {X, Y} \u0026lt;- lists:zip(ArgTypes, OldArgTypes)],\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewould become\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eNewArgTypes = [t_sup(X, Y) || X \u0026lt;- ArgTypes \u0026amp;\u0026amp; Y \u0026lt;- OldArgTypes],\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThis is a case where no invention is required, really.\nClean has\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eQualifier = Generators {|Guard}\nGenerators = {Generator}-list\n           | Generator {\u0026amp; Generator}\nGenerator = Selector \u0026lt;- ListExpr // lazy list\n          | Selector \u0026lt;|- ListExpr // overloaded list\n          | Selector \u0026lt;-: ArrayExpr //  array\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAll I have to do is bend this a little to fit it into Erlang\nsyntax.  Since we use \"||\" for list comprehensions, \"\u0026amp;\u0026amp;\" was\nthe obvious spelling for generators that step together.\u003c/p\u003e\n\n\u003cp\u003eI do not yet understand in detail what the Erlang compiler\ndoes, but it seems to involve generating an auxiliary function.\nLet's take\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[f(X) || X \u0026lt;- Xs, X \u0026gt; 0]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eas an example.  This seems to be compiled as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efoo(Xs)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efoo([X|Xs]) when X \u0026gt; 0 -\u0026gt; [f(X) | foo(Xs)];\nfoo([_|Xs]) -\u0026gt; foo(Xs);\nfoo([]) -\u0026gt; [].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWith a multi-sequence generator, the translation is similar.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[g(X, Y) || X \u0026lt;- Xs \u0026amp;\u0026amp; Y \u0026lt;- Ys, X \u0026gt; Y]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecan be compiled as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebar(Xs, Ys)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebar([X|Xs], [Y|Ys]) when X \u0026gt; Y -\u0026gt;\n    [g(X, Y) | bar(Xs, Ys)];\nbar([_|Xs], [_|Ys]) -\u0026gt; bar(Xs, Ys);\nbar([], []) -\u0026gt; [].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe specification above gives the kind of translation I would like\nto see; I do have an implementation in mind (based on Pop-2) that\ndoesn't need the reversal but don't know how it would fit in BEAM.\u003c/p\u003e\n\n\u003cp\u003eOne obvious question is whether we need this at all.  Why not just\nget people to write calls to \u003ccode\u003elists:zip\u003c/code\u003e and get the compiler to\noptimise them?  One answer is that this notation is much clearer;\nthe programmer's \u003cem\u003eintent\u003c/em\u003e is to advance along two or more lists\nat the same time, not to create a list of pairs.  When you want to\ncreate a list of pairs, \u003ccode\u003elists:zip/2\u003c/code\u003e is the perfect way to do it.\nA more important answer is that the proposed notation is NOT a\nsimple optimisation of equivalent code using \u003ccode\u003elists:zip/2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[E || {P,Q} \u0026lt;- lists:zip(A, B)]    % \"zip version\"\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003efails at once if A and B are not proper lists of the same length.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[E || P \u0026lt;- A \u0026amp;\u0026amp; Q \u0026lt;- B]            % \"Clean version\"\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eeventually fails if A and B are not proper lists of the same\nlength, but may have evaluated E (which may have had side effects)\nmany times before that.  So an Erlang compiler would not be\nallowed to replace the \"zip version\" by the \"Clean version\" unless\nit could prove both that A and B were lists (which may be within\nthe abilities of the Dialyzer) and that they were exactly the same\nlength (which as far as I know isn't).\u003c/p\u003e\n\n\u003cp\u003eHowever, a multi-sequence generator and a single-sequence one\nusing calls to \u003ccode\u003elists:zip/2\u003c/code\u003e are clearly \u003cem\u003esimilar\u003c/em\u003e, so they should\neventually react to lists of different length the same way.\nIn Haskell, zipping two lists of different length acts as if the\nlonger were truncated to the length of the shorter.  Since\nHaskell has lazy evaluation, lists may be infinite, so you can't\nafford to wait until the end to start a comprehension.  Since\nErlang is strict, and since mistakes are common, \u003ccode\u003elists:zip/2\u003c/code\u003e in\nErlang makes sense as it is.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThe \"operator\" '\u0026amp;\u0026amp;' is not legal syntax anywhere in Erlang\nat the moment, so no existing code can be affected.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone yet, but I'd like to do it when I can figure out how.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0019"},"buildId":"6JjQqocIWQ_TWFupI_6kC","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/6JjQqocIWQ_TWFupI_6kC/_buildManifest.js" async=""></script><script src="/_next/static/6JjQqocIWQ_TWFupI_6kC/_ssgManifest.js" async=""></script></body></html>