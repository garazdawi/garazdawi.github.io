<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.ea40b862c8a8db76db57.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/retired-pitfalls-22/">Retiring old performance pitfalls</a></h3><p><em>Wednesday, 7 November 2018<!-- --> - <!-- -->John Högberg</em></p><p>Erlang/OTP 22 will bring many performance improvements to the table, but most
of them have a broad impact and don&#x27;t affect the way you write efficient code.
In this post I&#x27;d like to highlight a few things that used to be surprisingly
slow but no longer need to be avoided.</p><h3>Named fun recursion</h3><p>Named funs have a neat little feature that might not be obvious at a first
glance; their name is a variable like any other and you&#x27;re free to pass it to
another function or even return it.</p><pre><code class="language-erlang">deepfoldl(F, Acc0, L) -&gt;
    (fun NamedFun([_|_]=Elem, Acc) -&gt; lists:foldl(NamedFun, Acc, Elem);
         NamedFun([], Acc) -&gt; Acc;
         NamedFun(Elem, Acc) -&gt; F(Elem, Acc)
     end)(L, Acc0).</code></pre><p>This is cool but a bit of a headache for the compiler. To create a fun we pass
its definition and free variables to a <code>make_fun2</code> instruction, but we can&#x27;t
include the fun itself as a free variable because it hasn&#x27;t been created yet.
Prior to OTP 22 we solved this by creating a new equivalent fun <em>inside</em> the
fun, but this made recursion surprisingly expensive both in terms of run-time
and memory use.</p><p>As of OTP 22 we translate recursion to a direct function call instead which
avoids creating a new fun. Other cases still require recreating the fun, but
they&#x27;re far less common.</p><p><a href="https://github.com/erlang/otp/pull/1973">Optimize named funs and fun-wrapped macros #1973</a></p><h3>List subtraction with large operands (-- operator)</h3><p>While the Erlang VM appears to be pre-emptively scheduled to the programmer,
it&#x27;s <a href="https://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking">co-operatively scheduled</a>
internally. When a native function runs it monopolizes the scheduler until it
returns, so a long-running one can severely harm the responsiveness of the
system. We&#x27;ve therefore written nearly all such functions in a style that
breaks the work into short units that complete quickly enough, but there&#x27;s
a steadily shrinking list of functions that misbehave, and list subtraction
was one of these.</p><p>It&#x27;s usually pretty straightforward to rewrite functions in this style, but
the <a href="https://github.com/erlang/otp/blob/d9682b02b81fa6e23e554b6e017650eb89ecebed/erts/emulator/beam/erl_bif_lists.c#L195">old algorithm</a>
processed the second list in a loop around the first list, which is problematic
since both lists can be very long and resuming work in nested loops is often
trickier than expected.</p><p>In this case it was easier to just get rid of the nested loop altogether. The
new algorithm starts out by building a red-black tree from the right-hand side
before removing elements from the left-hand side. As all operations on the tree
have <code>log n</code> complexity we know that they will finish really quickly, so all we
need to care about is yielding in the outer loops.</p><p>This also had the nice side-effect of reducing the worst-case complexity from
<code>O(n²)</code> to <code>O(n log n)</code> and let us remove some warnings from the reference
manual and <a href="http://erlang.org/documentation/doc-10.1/doc/efficiency_guide/commoncaveats.html#operator-----">efficiency guide</a>. It&#x27;s worth noting
that the new implementation is always faster than the proposed workarounds, and
that it falls back to the old algorithm when it&#x27;s faster to do so.</p><p>This change will be rolled out in OTP 21.2, big thanks to
Dmytro Lytovchenko (@kvakvs on GitHub) for writing the better half of it!</p><p><a href="https://github.com/erlang/otp/pull/1998">Optimize list subtraction (A -- B) and make it yield on large inputs #1998</a></p><h3>Lookahead in bit-syntax matching</h3><p>The optimization pass for bit-syntax matching was completely rewritten in OTP
22 to take advantage of the new SSA-based intermediate format. It applies the
same optimizations as before so already well-optimized code is unlikely to see
any benefit, but it manages to apply them in far more cases.</p><p>For those who aren&#x27;t familiar, all bit-syntax matching operates on a
<a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries">&quot;match context&quot;</a>
internally, which is a mutable object that keeps track of the current
match position. This helps a lot when matching complicated patterns as it can
zip back and forth as required, saving us from having to match components more
than once.</p><p>This is great when matching several different patterns, but it comes in real
handy in loops like the following:</p><pre><code class="language-erlang">trim_zero(&lt;&lt;0,Tail/binary&gt;&gt;) -&gt; trim_zero(Tail);
trim_zero(B) when is_binary(B) -&gt; B.</code></pre><p>As the compiler can see that <code>Tail</code> is passed directly to <code>trim_zero</code>, which
promptly begins with a bit-match, it can skip extracting <code>Tail</code> as a sub-binary
and pass the match context instead. This is a pretty well-known optimization
called &quot;match context reuse&quot; which greatly improves performance when applied,
and a lot of code has been written with it in mind.</p><p>The catch of passing a match context like this is that we have to maintain the
illusion that we&#x27;re dealing with an immutable <em>binary</em>. Whenever it&#x27;s used in
a non-matching expression we either need to convert the context to an
equivalent binary, or admit defeat and skip the optimization.</p><p>While the compiler did a pretty good job prior to OTP 22 it gave up a bit too
easily in many cases, and the most trivial example is almost funny:</p><pre><code class="language-erlang">calls_wrapper(&lt;&lt;&quot;hello&quot;,Tail/binary&gt;&gt;) -&gt;
    count_ones(Tail).

%% This simple wrapper prevents context reuse in the call above. :(
count_ones(Bin) -&gt; count_ones_1(Bin, 0).

count_ones_1(&lt;&lt;1, Tail/binary&gt;&gt;, Acc) -&gt; count_ones_1(Tail, Acc + 1);
count_ones_1(&lt;&lt;_, Tail/binary&gt;&gt;, Acc) -&gt; count_ones_1(Tail, Acc);
count_ones_1(&lt;&lt;&gt;&gt;, Acc) -&gt; Acc.</code></pre><p>A trickier example can be found in the <code>string</code> module:</p><pre><code class="language-erlang">bin_search_inv_1(&lt;&lt;CP1/utf8, BinRest/binary&gt;&gt;=Bin0, Cont, Sep) -&gt;
    case BinRest of
        %% 1
        &lt;&lt;CP2/utf8, _/binary&gt;&gt; when ?ASCII_LIST(CP1, CP2) -&gt;
            case CP1 of
                Sep -&gt;
                    %% 2
                    bin_search_inv_1(BinRest, Cont, Sep);
                _ -&gt;
                    %% 3
                    [Bin0|Cont]
            end;
        %% ... snip ...</code></pre><p>What we&#x27;re looking at is a fast-path for ASCII characters; when both <code>CP1</code> and
<code>CP2</code> are ASCII we know that <code>CP1</code> is not a part of a grapheme cluster and we
can thus avoid a call to <code>unicode_util:gc/1</code>. It&#x27;s not a particularly expensive
function but calling it once per character adds up quickly.</p><p>At first glance it might seem safe to pass the context at <code>2</code>, but this is made
difficult by <code>Bin0</code> being returned at <code>3</code>. As contexts are mutable and change
their position whenever a match succeeds, naively converting <code>Bin0</code> back to a
binary would give you what comes after <code>CP2</code> instead.</p><p>Now, you might be wondering why we couldn&#x27;t simply restore the position before
converting <code>Bin0</code> back to a binary. It&#x27;s an obvious thing to do but before OTP
22 the context tracked not only the current position but also previous ones
needed when backtracking. These were saved in per-context &quot;slots&quot; which were
mutable and heavily reused, and the match at <code>1</code> clobbered the slot needed to
restore <code>Bin0</code>.</p><p>This also meant that a context couldn&#x27;t be used again after being passed to
another function or entering a <code>try</code>/<code>catch</code>, which made it more or less
impossible to apply this optimization in code that requires looking ahead.</p><p>As of OTP 22 these positions are stored outside the context so there&#x27;s no need
to worry about them becoming invalid, making it possible to optimize the above
cases.</p><p><a href="https://github.com/erlang/otp/pull/1958">Rewrite BSM optimizations in the new SSA-based intermediate format #1958</a></p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"retired-pitfalls-22","title":"Retiring old performance pitfalls","author":"John Högberg","excerpt":"\nErlang/OTP 22 will bring many performance improvements to the table, but most\nof them have a broad impact and don't affect the way you write efficient code.\nIn this post I'd like to highlight a few things that used to be surprisingly\nslow but no longer need to be avoided.","article_date":1541548800000,"tags":["erts compiler"],"frontmatter":{"layout":"post","title":"Retiring old performance pitfalls","tags":"erts compiler","author":"John Högberg"},"content":"\nErlang/OTP 22 will bring many performance improvements to the table, but most\nof them have a broad impact and don't affect the way you write efficient code.\nIn this post I'd like to highlight a few things that used to be surprisingly\nslow but no longer need to be avoided.\n\n### Named fun recursion\n\nNamed funs have a neat little feature that might not be obvious at a first\nglance; their name is a variable like any other and you're free to pass it to\nanother function or even return it.\n\n```erlang\ndeepfoldl(F, Acc0, L) -\u003e\n    (fun NamedFun([_|_]=Elem, Acc) -\u003e lists:foldl(NamedFun, Acc, Elem);\n         NamedFun([], Acc) -\u003e Acc;\n         NamedFun(Elem, Acc) -\u003e F(Elem, Acc)\n     end)(L, Acc0).\n```\n\nThis is cool but a bit of a headache for the compiler. To create a fun we pass\nits definition and free variables to a `make_fun2` instruction, but we can't\ninclude the fun itself as a free variable because it hasn't been created yet.\nPrior to OTP 22 we solved this by creating a new equivalent fun _inside_ the\nfun, but this made recursion surprisingly expensive both in terms of run-time\nand memory use.\n\nAs of OTP 22 we translate recursion to a direct function call instead which\navoids creating a new fun. Other cases still require recreating the fun, but\nthey're far less common.\n\n[Optimize named funs and fun-wrapped macros #1973](https://github.com/erlang/otp/pull/1973)\n\n### List subtraction with large operands (-- operator)\n\nWhile the Erlang VM appears to be pre-emptively scheduled to the programmer,\nit's [co-operatively scheduled](https://en.wikipedia.org/wiki/Computer_multitasking#Cooperative_multitasking)\ninternally. When a native function runs it monopolizes the scheduler until it\nreturns, so a long-running one can severely harm the responsiveness of the\nsystem. We've therefore written nearly all such functions in a style that\nbreaks the work into short units that complete quickly enough, but there's\na steadily shrinking list of functions that misbehave, and list subtraction\nwas one of these.\n\nIt's usually pretty straightforward to rewrite functions in this style, but\nthe [old algorithm](https://github.com/erlang/otp/blob/d9682b02b81fa6e23e554b6e017650eb89ecebed/erts/emulator/beam/erl_bif_lists.c#L195)\nprocessed the second list in a loop around the first list, which is problematic\nsince both lists can be very long and resuming work in nested loops is often\ntrickier than expected.\n\nIn this case it was easier to just get rid of the nested loop altogether. The\nnew algorithm starts out by building a red-black tree from the right-hand side\nbefore removing elements from the left-hand side. As all operations on the tree\nhave `log n` complexity we know that they will finish really quickly, so all we\nneed to care about is yielding in the outer loops.\n\nThis also had the nice side-effect of reducing the worst-case complexity from\n`O(n²)` to `O(n log n)` and let us remove some warnings from the reference\nmanual and [efficiency guide](http://erlang.org/documentation/doc-10.1/doc/efficiency_guide/commoncaveats.html#operator-----). It's worth noting\nthat the new implementation is always faster than the proposed workarounds, and\nthat it falls back to the old algorithm when it's faster to do so.\n\nThis change will be rolled out in OTP 21.2, big thanks to\nDmytro Lytovchenko (@kvakvs on GitHub) for writing the better half of it!\n\n[Optimize list subtraction (A -- B) and make it yield on large inputs #1998](https://github.com/erlang/otp/pull/1998)\n\n### Lookahead in bit-syntax matching\n\nThe optimization pass for bit-syntax matching was completely rewritten in OTP\n22 to take advantage of the new SSA-based intermediate format. It applies the\nsame optimizations as before so already well-optimized code is unlikely to see\nany benefit, but it manages to apply them in far more cases.\n\nFor those who aren't familiar, all bit-syntax matching operates on a\n[\"match context\"](http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries)\ninternally, which is a mutable object that keeps track of the current\nmatch position. This helps a lot when matching complicated patterns as it can\nzip back and forth as required, saving us from having to match components more\nthan once.\n\nThis is great when matching several different patterns, but it comes in real\nhandy in loops like the following:\n\n```erlang\ntrim_zero(\u003c\u003c0,Tail/binary\u003e\u003e) -\u003e trim_zero(Tail);\ntrim_zero(B) when is_binary(B) -\u003e B.\n```\n\nAs the compiler can see that `Tail` is passed directly to `trim_zero`, which\npromptly begins with a bit-match, it can skip extracting `Tail` as a sub-binary\nand pass the match context instead. This is a pretty well-known optimization\ncalled \"match context reuse\" which greatly improves performance when applied,\nand a lot of code has been written with it in mind.\n\nThe catch of passing a match context like this is that we have to maintain the\nillusion that we're dealing with an immutable _binary_. Whenever it's used in\na non-matching expression we either need to convert the context to an\nequivalent binary, or admit defeat and skip the optimization.\n\nWhile the compiler did a pretty good job prior to OTP 22 it gave up a bit too\neasily in many cases, and the most trivial example is almost funny:\n\n```erlang\ncalls_wrapper(\u003c\u003c\"hello\",Tail/binary\u003e\u003e) -\u003e\n    count_ones(Tail).\n\n%% This simple wrapper prevents context reuse in the call above. :(\ncount_ones(Bin) -\u003e count_ones_1(Bin, 0).\n\ncount_ones_1(\u003c\u003c1, Tail/binary\u003e\u003e, Acc) -\u003e count_ones_1(Tail, Acc + 1);\ncount_ones_1(\u003c\u003c_, Tail/binary\u003e\u003e, Acc) -\u003e count_ones_1(Tail, Acc);\ncount_ones_1(\u003c\u003c\u003e\u003e, Acc) -\u003e Acc.\n```\n\nA trickier example can be found in the `string` module:\n\n```erlang\nbin_search_inv_1(\u003c\u003cCP1/utf8, BinRest/binary\u003e\u003e=Bin0, Cont, Sep) -\u003e\n    case BinRest of\n        %% 1\n        \u003c\u003cCP2/utf8, _/binary\u003e\u003e when ?ASCII_LIST(CP1, CP2) -\u003e\n            case CP1 of\n                Sep -\u003e\n                    %% 2\n                    bin_search_inv_1(BinRest, Cont, Sep);\n                _ -\u003e\n                    %% 3\n                    [Bin0|Cont]\n            end;\n        %% ... snip ...\n```\n\nWhat we're looking at is a fast-path for ASCII characters; when both `CP1` and\n`CP2` are ASCII we know that `CP1` is not a part of a grapheme cluster and we\ncan thus avoid a call to `unicode_util:gc/1`. It's not a particularly expensive\nfunction but calling it once per character adds up quickly.\n\nAt first glance it might seem safe to pass the context at `2`, but this is made\ndifficult by `Bin0` being returned at `3`. As contexts are mutable and change\ntheir position whenever a match succeeds, naively converting `Bin0` back to a\nbinary would give you what comes after `CP2` instead.\n\nNow, you might be wondering why we couldn't simply restore the position before\nconverting `Bin0` back to a binary. It's an obvious thing to do but before OTP\n22 the context tracked not only the current position but also previous ones\nneeded when backtracking. These were saved in per-context \"slots\" which were\nmutable and heavily reused, and the match at `1` clobbered the slot needed to\nrestore `Bin0`.\n\nThis also meant that a context couldn't be used again after being passed to\nanother function or entering a `try`/`catch`, which made it more or less\nimpossible to apply this optimization in code that requires looking ahead.\n\nAs of OTP 22 these positions are stored outside the context so there's no need\nto worry about them becoming invalid, making it possible to optimize the above\ncases.\n\n[Rewrite BSM optimizations in the new SSA-based intermediate format #1958](https://github.com/erlang/otp/pull/1958)\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"retired-pitfalls-22"},"buildId":"BGhkIUi1bNl03TKudis6o","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.ea40b862c8a8db76db57.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/BGhkIUi1bNl03TKudis6o/_buildManifest.js" async=""></script><script src="/_next/static/BGhkIUi1bNl03TKudis6o/_ssgManifest.js" async=""></script></body></html>