{"pageProps":{"index":{"id":"0038","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R14B04\nCreated: 27-May-2011\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 38: <a href=\"eep-0038.md\" title=\"EEP Source\"> -discontiguous directive</a></h2>\n\n<h1>Abstract</h1>\n\n<p>A <code>-discontiguous</code> directive is to be added so that specified\nfunctions may be presented as more than one group of clauses,\npossibly separated by other directives and function clause\ngroups.</p>\n\n<h1>Specification</h1>\n\n<p>A new directive</p>\n\n<pre><code>-discontiguous( Name_And_Arity_List ).\n</code></pre>\n\n<p>is added.  Each function named in such a list must have at\nleast one clause group in that module, and may have more.\nIt remains an error for any function not named in such a\nlist to have more than one clause group.</p>\n\n<p>A function named in a <code>-discontiguous</code> directive need not\nhave more than one clause group.  If it does, it is if\nthe clause groups were moved together without reordering\nand the full stop of each group but the last changed to\na semicolon.  The compiler should make no comment about\nthe existence of multiple clause groups or their fusion\ninto single clause groups.</p>\n\n<p>The parser stage would do the regrouping and would not\ninclude any representation of the <code>-discontiguous</code> directive\nin its output, so that downstream tools would never know\nthat <code>-discontiguous</code> had been there.</p>\n\n<h1>Motivation</h1>\n\n<p>There are three problems which a single mechanism can solve.</p>\n\n<p>The first is that Erlang has conditional compilation, but\nthere is no really satisfactory to use it to select some\nbut not all of the clauses of a function.</p>\n\n<p>The <code>-discontiguous</code> directive allows you to write</p>\n\n<pre><code>-discontiguous([f/3]).\n\nf(a, X, Y) -&gt; .... .\n-if(Cond).\nf(b, X, Y) -&gt; .... .\n-endif.\nf(c, X, T) -&gt; .... .\n</code></pre>\n\n<p>The second may be called \"topic-oriented programming\".\nIt relates to human structuring of code around the\ndata values computed on rather than the code they compute.\nI have found this in dealing with a virtual machine:  I've\nwanted to place the code that assembles an instruction,\nthe code that peephole optimises it, the code that encodes\nit into memory, and the code that interprets it into one\nplace (involving different function), rather than organising\nit by function, thus scattering related information the\nlength and breadth of the module.</p>\n\n<p>It may be clearest to start with an example.  The code\nin <code>erl_syntax.erl</code> reads:</p>\n\n<pre><code>-type syntaxTree() :: #tree{} | #wrapper{} | tuple().\n\n%% All `erl_parse' tree nodes are represented by tuples\n%% whose second field is the position information (usually\n%% an integer), *with the exceptions of*\n%% `{error, ...}' (type `error_marker') and\n%% `{warning, ...}' (type `warning_marker'),\n%% which only contain the associated line number *of the\n%% error descriptor*; this is all handled transparently\n%% by `get_pos' and `set_pos'.\n\n    get_pos(#tree{attr = Attr}) -&gt;\n        Attr#attr.pos;\n    get_pos(#wrapper{attr = Attr}) -&gt;\n        Attr#attr.pos;\n    get_pos({error, {Pos, _, _}}) -&gt;\n        Pos;\n    get_pos({warning, {Pos, _, _}}) -&gt;\n        Pos;\n    get_pos(Node) -&gt;\n        %% Here, we assume that we have an `erl_parse' node\n        %% with position information in element 2.\n        element(2, Node).\n\n    set_pos(Node, Pos) -&gt;\n        case Node of\n            #tree{attr = Attr} -&gt;\n                Node#tree{attr = Attr#attr{pos = Pos}};\n            #wrapper{attr = Attr} -&gt;\n                Node#wrapper{attr = Attr#attr{pos = Pos}};\n            _ -&gt;\n                %% We then assume we have an `erl_parse' node,\n                %% and create a wrapper around it to make\n                %% things more uniform.\n                set_pos(wrap(Node), Pos)\n        end.\n</code></pre>\n\n<p>The type here is a little vague.  The additional tuples appear\nto be <code>{error,{Pos,_,_}}, {warning,{Pos,_,_}}</code>, and the\n<code>{Tag,Pos...}</code> tuples returned by <code>erl_parse</code>.  The thing here is\nthat there are five different cases.  For some purposes,\nit would be better to write</p>\n\n<pre><code>-discontiguous([get_pos/1,set_pos/2]).\n\nget_pos(#tree{attr = Attr}) -&gt; Attr#attr.pos.\nset_pos(#tree{attr = Attr} = Node, Pos) -&gt;\n    Node#tree{attr = Attr#attr{pos = Pos}}.\n\nget_pos(#wrapper{attr = Attr}) -&gt; Attr#attr.pos.\nset_pos(#wrapper{attr = Attr} = Node, Pos) -&gt;\n    Node#wrapper{attr = Attr#attr{pos = Pos}}.\n\nget_pos({error, {Pos,_,_}}) -&gt; Pos.\n% What should set_pos/2 do in this case?\n\nget_pos({warning, {Pos,_,_}}) -&gt; Pos.\n% What should set_pos/2 do in this case?\n\nget_pos(Node) -&gt; element(2, Node).  % assume erl_parse node\nset_pos(Node, Pos) -&gt;               % assume erl_parse node\n    set_pos(wrap(Node), Pos).       % wrap it for uniformity\n</code></pre>\n\n<p>This brings out the parallel between the two functions,\nand the way the parallel fails, more clearly than any other\npossible layout.  It nags at you to either finish the\nparallel with the obvious</p>\n\n<pre><code>set_pos({error, {_,X,Y}}, Pos) -&gt;\n    {error, {Pos,X,Y}}.\n</code></pre>\n\n<p>and</p>\n\n<pre><code>set_pos({warning, {_,X,Y}), Pos) -&gt;\n    {warning, {Pos,X,Y}}.\n</code></pre>\n\n<p>clauses or to at least change the comments to</p>\n\n<pre><code>% set_pos/2 falls through to the last case.\n</code></pre>\n\n<p>comments.</p>\n\n<p>We have the same pattern, without the failure of parallelism,\nin two more functions from that file:</p>\n\n<pre><code>get_com(#tree{attr = Attr}) -&gt; Attr#attr.com;\nget_com(#wrapper{attr = Attr}) -&gt; Attr#attr.com;\nget_com(_) -&gt; none.\n\nset_com(Node, Com) -&gt;\n    case Node of\n        #tree{attr = Attr} -&gt;\n            Node#tree{attr = Attr#attr{com = Com}};\n        #wrapper{attr = Attr} -&gt;\n            Node#wrapper{attr = Attr#attr{com = Com}};\n        _ -&gt;\n            set_com(wrap(Node), Com)\n    end.\n</code></pre>\n\n<p>These could be</p>\n\n<pre><code>-discontiguous([get_com/1,set_com/1]).\n\nget_com(#tree{attr = Attr}) -&gt; Attr#attr.com.\nset_com(#tree{attr = Attr} = Node, Com) -&gt;\n    Node#tree{attr = Attr#attr{com = Com}}.\n\nget_com(#wrapper{attr = Attr}) -&gt; Attr#attr.com.\nset_com(#wrapper{attr = Attr} = Node, Com) -&gt;\n    Node#wrapper{attr = Attr#attr{com = Com}}.\n\nget_com(_) -&gt; none.  % error, warning, erl_parse.\nset_com(Node, Com) -&gt;\n    set_com(wrap(Node), Com).\n</code></pre>\n\n<p>Well, once again the parallel is not quite perfect.\nThe documentation for <code>wrap/1</code> says that it assumes\nits argument is a class <code>erl_parse</code> tuple, which here\nmeans that it appears that it should NOT be an error\nor warning.</p>\n\n<p>The point of interest here is that just looking at the\nexisting functions didn't ring any alarms; it was not\nuntil I said \"these seem to be about the same data\nstructure; I wonder if interleaving can make the\nconnection clearer and make it easier to ensure that\ngetters and setters are properly related?\" that my\nattention was properly drawn to the differences.</p>\n\n<p>It's particularly interesting that the very first Erlang/OTP\nsource file I looked at provided examples.\nThe third is like the second, but relates to code\nwritten by a computer, not a human.  For example, if\ngenerating a functional representation of some sort\nof state machine, it can be convenient to organise\nthe output around the states, but the present scheme\nrequires it to be organised around the functions that\ndeal with the states.</p>\n\n<h1>Rationale</h1>\n\n<p>Prolog systems have supported a <code>:- discontiguous</code> declaration\nfor 20+ years.  The approach is a proven one.  It is a simple\ngeneralisation of the language which can be hidden from all\n\"downstream\" tools.  Only tools that try to deal with Erlang\nsyntax without fully parsing it could notice the difference,\nand they should largely ignore it.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All existing Erlang code remains acceptable with unchanged\nsemantics.  Existing language-processing tools are unaffected\nif they rely on <code>erl_parse</code>.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None in this draft.</p>\n\n<h1>References</h1>\n\n<p>None.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}