{"pageProps":{"index":{"id":"0029","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-5\nCreated: 25-Feb-2009\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 29: <a href=\"eep-0029.md\" title=\"EEP Source\"> Abstract Patterns, Stage 1</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Abstract Patterns are named pattern/guard combinations\nwhich can be used</p>\n\n<ul>\n<li>in patterns, to support abstract data types</li>\n<li>as user-defined guards, guaranteed safe-for-guards</li>\n<li>as ordinary functions</li>\n<li>to replace many but not all uses of macros.</li>\n</ul>\n\n<p>The full proposal has six stages, of which this is stage 1.\nThis stage allows only simple abstract patterns which can be\nhandled by in-line substitution, so requiring no change to the\nErlang Virtual Machine.</p>\n\n<h1>Specification</h1>\n\n<p>We introduce abstract pattern declarations and calls.\nThe syntax is given as an adaptation of that in parse.yrl.</p>\n\n<pre><code>form -&gt; abstract_pattern dot.\n\nabstract_pattern -&gt; '#' atom clause_args clause_guard\n                    '-&gt;' expr.\n</code></pre>\n\n<p>For future reference, we'll use the schematic rule</p>\n\n<pre><code>#A(H1, ..., Hn) when G -&gt; B.\n</code></pre>\n\n<p>where an empty clause_guard is taken to mean that <code>G</code> is 'true'.\n<code>H1, ..., Hn</code> and <code>B</code> must all be patterns.</p>\n\n<p>Abstract patterns may not be directly or indirectly recursive.</p>\n\n<pre><code>expr_700 -&gt; pattern_call.\n\npattern_call -&gt; '#' atom argument_list\n</code></pre>\n\n<p>The expressions in the argument<em>list of a pattern</em>call must be</p>\n\n<ul>\n<li>patterns in a pattern</li>\n<li>guard expressions elsewhere in a guard</li>\n<li>any expression elsewhere in an ordinary expression.</li>\n</ul>\n\n<p>There are two ways to understand the semantics of abstract\npatterns: as function calls and as inline substitution.</p>\n\n<p>Considered as functions, stage 1 abstract patterns correspond\nto two functions.  Given our schematic rule, we get</p>\n\n<pre><code>'#A-&gt;'(H1, ..., Hn) when G -&gt; B.\n</code></pre>\n\n<p>That is, part of the meaning of an abstract pattern is a\nfunction that works just the way it looks as if it works.\n(The name '#A->' is for expository purposes and should not\nbe taken literally.  In particular, it is NOT part of this\nspecification that such a function should be directly\naccessible at all, still less that it should be accessible\nby a name of that form.)  So</p>\n\n<pre><code>#permute([R,A,T]) when is_atom(A) -&gt; [T,A,R].\n</code></pre>\n\n<p>acts in one direction just like</p>\n\n<pre><code>'#permute-&gt;'([R,A,T]) when is_atom(A) -&gt; [T,A,R].\n</code></pre>\n\n<p>would.  Because abstract patterns are not allowed to be\nrecursive and cannot have any side effects, it is safe\nto call them in guards.  As a guard test, <code>#A(E1,...,En)</code>\nis equivalent to <code>(true = '#A-&gt;'(E1,...,En))</code>.  </p>\n\n<p>In the other direction, we get</p>\n\n<pre><code>'#A='(B) when G -&gt; {H1, ..., Hn}.\n</code></pre>\n\n<p>A pattern match</p>\n\n<pre><code>#A(P1, ..., Pn) = E\n</code></pre>\n\n<p>is equivalent to</p>\n\n<pre><code>{P1, ..., Pn} = '#A='(E)\n</code></pre>\n\n<p>When some of the patterns Hi, B use '=', the definition is\na little trickier.  Suppose, for example, we have</p>\n\n<pre><code>#foo([H|T] = X) -&gt; {H,T}.\n</code></pre>\n\n<p>A naive translation would be</p>\n\n<pre><code>'#foo='({H,T}) -&gt; [H|T] = X.\n</code></pre>\n\n<p>which would not work, because X would be undefined.  The\nbasic problem here is that '=' in patterns is symmetric,\nwhile '=' in expressions is not.  The real translation\nhas to be that</p>\n\n<pre><code>#A(H11=H12=.., ..., Hn1=Hn2=..) when G -&gt; B\n</code></pre>\n\n<p>is equivalent to</p>\n\n<pre><code>'#A='(B)\nwhen G, X1=H11, X1=H12, ..., Xn=Hn1, Xn=Hn2, ...\n-&gt; {X1, ..., Xn}\n</code></pre>\n\n<p>where the bindings <code>Xi=Hij</code> are both sorted and re-ordered\n(that is, switched from <code>Xi=Hij</code> to <code>Hij=Xi</code>) according to\ndata flow.  In the case of the <code>#foo/1</code> example, we'd get</p>\n\n<pre><code>'#foo='({H,T}) when X1 = [H|T], X = X1 -&gt; {X1}.\n</code></pre>\n\n<p>The sorting and reordering process is easier than it sounds.\nWhile there is an equation <code>Xi=Hij</code> such that either every\nvariable in <code>Hij</code> is known or <code>Xi</code> is known, add <code>Xi=Hij</code> if\n<code>Hij</code> is all known, or <code>Hij = Xi</code> if <code>Xi</code> is known.</p>\n\n<p>This sorting-and-reordering-by-dataflow is also recommended\nin the forward direction when B contains '='.</p>\n\n<p>Sometimes one or the other direction of an abstract pattern\ncannot be constructed, even with sorting and reordering by\ndataflow.  This is typically because one side contains a\nvariable that doesn't occur on the other.  For example,</p>\n\n<pre><code>#first(X) -&gt; {X,_}.\n#second(Y) -&gt; {_,Y}.\n</code></pre>\n\n<p>are usable as patterns, but not as functions.  The compiler\nshould issue a warning for such abstract patterns but allow\nthem.  It should be a run-time error to call such a pattern\nas a function as well.  It should be possible to suppress\nthe warning, perhaps by</p>\n\n<pre><code>-compile({pattern_only,[{first,1,second,1}]}).\n</code></pre>\n\n<p>(That's within the current syntax.  Ideally that should be\n<code>#first/1</code> and <code>#second/1</code>.)</p>\n\n<p>For another example,</p>\n\n<pre><code>#is_date(#date(_,_,_)) -&gt; true.\n</code></pre>\n\n<p>is usable as a function, even/especially in a guard, but is <br />\nnot usable as a pattern.  The compiler should issue a\nwarning for such abstract patterns but allow them.  It\nshould be a run-time error to call such a pattern as well.\nIt should be possible to suppress the warning, perhaps by</p>\n\n<pre><code>-compile({function_only,[{is_date,1}]}).\n</code></pre>\n\n<p>Definition via in-line substituion is straightforward.\nAll of the following rewrites assume a standard renaming\nof variables.</p>\n\n<pre><code>f(... #A(P1,...,Pn) ...) when Gf -&gt; Bf\n</code></pre>\n\n<p>rewrites to</p>\n\n<pre><code>f(... B ...)\nwhen G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gf -&gt; Bf\n\ncase ... of ... #(P1,...,Pn) ... when Gc -&gt; Bc\n</code></pre>\n\n<p>rewrites to</p>\n\n<pre><code>case ... of ... B ...\nwhen G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gc -&gt; Bc\n\nP = E\n</code></pre>\n\n<p>rewrites to</p>\n\n<pre><code>case E of P -&gt; ok end\n</code></pre>\n\n<p>In a guard expression,</p>\n\n<pre><code>(... #A(E1, ..., En) ...)\n</code></pre>\n\n<p>rewrites to</p>\n\n<pre><code>{H1,...,Hn} = {E1,...,En}, G, (... B ...)\n</code></pre>\n\n<p>As a guard test,</p>\n\n<pre><code>#A(E1, ..., En)\n</code></pre>\n\n<p>rewrites to</p>\n\n<pre><code>{H1,...,Hn} = {E1,...,En}, G, true = B\n</code></pre>\n\n<p>As an ordinary expression,</p>\n\n<pre><code>#A(E1, ..., En)\n</code></pre>\n\n<p>rewrites to</p>\n\n<pre><code>case {E1,...,En} of {H1,...,Hn} when G -&gt; B end\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>Even in this restricted form, abstract patterns solve a lot\nof problems that keep coming up on the Erlang mailing list.\nThey were invented to serve two main purposes:  to greatly\nreduce the need for the preprocessor, and to support the\nuse of abstract data types.  It turns out that they can also\nreduce the amount of keyboard work a programmer has to do,\nand increase the amount of type information available to the\ncompiler.</p>\n\n<p>Macros are often used to provide named constants.\nFor example,</p>\n\n<pre><code>-define(unknown, \"UNKNOWN\").\nf(?unknown, Actors) -&gt; Actors;\nf(N, Actors) -&gt; lists:keydelete(N, #actor.name, Actors).\n</code></pre>\n\n<p>A function is not used here because function calls may not\nappear in patterns.  Abstract patterns are functions that\nare sufficiently restricted that they <em>may</em> appear in patterns:</p>\n\n<pre><code>#unknown() -&gt; \"UNKNOWN\".\nf(#unknown(), Actors) -&gt; Actors;\nf(N, Actors) -&gt; lists:keydelete(n, #actor.name, Actors).\n</code></pre>\n\n<p>Sometimes these constants must be computed.\nFor example,</p>\n\n<pre><code>-define(START_TIMEOUT, 1000 * 30).\n</code></pre>\n\n<p>Thanks to variable binding in guards, we can do that too:</p>\n\n<pre><code>#start_timeout() when N = 1000*30 -&gt; N.\n</code></pre>\n\n<p>There are things that macros cannot do, because there needs\nto be a guard test as well as a pattern.  Macros can't bilocate.</p>\n\n<pre><code>#date(D, M, Y)\nwhen is_integer(Y), Y &gt;= 1600, Y =&lt; 2500,\n     is_integer(M), M &gt;= 1,    M =&lt; 12,\n     is_integer(D), D &gt;= 1,    D =&lt; 31\n-&gt; {Y, M, D}.\n\n#vector3(X, Y, Z)\nwhen is_float(X), is_float(Y), is_float(Z)\n-&gt; {X, Y, Z}.\n\n#mod_func(M, F) when is_atom(M), is_atom(F) -&gt; {M, F}.\n\n#mod_func_arity(M, F, A)\nwhen is_atom(M), is_atom(F), is_integer(A), A &gt;= 0\n-&gt; {M, F, A}.\n</code></pre>\n\n<p>Some macros cannot be replaced by abstract patterns.</p>\n\n<pre><code>-define(DBG(DbgLvl, Format, Data),\n    dbg(DbgLvl, Format, Data)).\n</code></pre>\n\n<p>cannot be an abstract pattern because the right hand side\ninvolves a call to an ordinary function.</p>\n\n<p>Some macros define guard tests.  For example,</p>\n\n<pre><code>-define(tab, 9).\n-define(space, 32).\n-define(is_tab(X), X == ?tab).\n-define(is_space(X), X == ?space).\n-define(is_underline(X), X == $_).\n-define(is_number(X), X &gt;= $0, X =&lt; $9).\n-define(is_upper(X), X &gt;= $A, X =&lt; $Z).\n-define(is_lower(X), X &gt;= $a, X =&lt; $z).\n\ntoken([X|File], L, Result, Gen, BsNl)\n  when ?is_upper(X) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when ?is_lower(X) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when ?is_underline(X) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n</code></pre>\n\n<p>These can be converted to abstract patterns that are usable\nas guard tests,</p>\n\n<pre><code>#tab() -&gt; 9.\n#space() -&gt; 32.\n#is_tab(#tab()) -&gt; true.\n#is_space(#space()) -&gt; true.\n#is_underline($_)) -&gt; true.\n#is_number(X) when X &gt;= $0, X =&lt; $9 -&gt; true.\n#is_upper(X)  when X &gt;= $A, X =&lt; $Z -&gt; true.\n#is_lower(X)  when X &gt;= $a, X =&lt; $z -&gt; true.\n\ntoken([X|File], L, Result, Gen, BsNl)\n  when #is_upper(X) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when #is_lower(X) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when #is_underline(X) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n</code></pre>\n\n<p>or to abstract patterns that can be used as patterns,</p>\n\n<pre><code>#tab() -&gt; 9.\n#space() -&gt; 32.\n#underline(X) when X == $_ -&gt; X.\n#number(X) when X &gt;= $0, X =&lt; $9 -&gt; X.\n#upper(X)  when X &gt;= $A, X =&lt; $Z -&gt; X.\n#lower(X)  when X &gt;= $a, X =&lt; $z -&gt; X.\n\ntoken([#upper(X)|File], L, Result, Gen, BsNl) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([#lower(X)|File], L, Result, Gen, BsNl) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([#underline(X)|File], L, Result, Gen, BsNl) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n</code></pre>\n\n<p>Of course we can use disjunction in the guard of an\nabstract pattern.</p>\n\n<pre><code>#id_start(X) when X &gt;= $A, X =&lt; $Z\n        ; X &gt;= $a, X =&lt; $z\n        ; X == $_           -&gt; X.\n\ntoken([#is_start(X)|File], L, Result, Gen, BsNl) -&gt;\n    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n</code></pre>\n\n<p>Yes, the original macro-based version could have done the same.\nIt's from the OTP sources; don't blame me.</p>\n\n<p>Aside from replacing a pattern AND a guard, which macros cannot\ndo, the great advantages over patterns over macros are that</p>\n\n<ul>\n<li>they can be syntax-checked at the point of definition,\nwhile macros can only be syntax-checked at the point of use;</li>\n<li>there is no problem, indeed no possibility, of variable name\ncapture;</li>\n<li>abstract patterns are value based, not token-list based, so\nthere are no problems with operators.</li>\n</ul>\n\n<p>Consider the following OTP macro:</p>\n\n<pre><code>-define(IC_FLAG_TEST(_F1, _I1), ((_F1 band _I1) == _I1)).\n</code></pre>\n\n<p>First, the author was evidently scared of accidental collisions\nwith other variable names.  Second, the parentheses look as\nthough they are there in case of operator precedence bugs.</p>\n\n<p>There's at least one other like it,</p>\n\n<pre><code>-define(is_set(F, Bits), ((F) band (Bits)) == (F)).\n</code></pre>\n\n<p>which (correctly) suggests that the first macro doesn't have enough\nparentheses.    The abstract pattern equivalent,</p>\n\n<pre><code>#ic_flag_test(Flags, Mask) when Flags band Mask == Mask -&gt; true.\n</code></pre>\n\n<p>has neither problem.</p>\n\n<p>Once again, there are things that abstract patterns cannot do.\nFor example,</p>\n\n<pre><code>-define(get_max(_X, _Y), if _X &gt; _Y -&gt; _X; true -&gt; _Y end).\n-define(get_min(_X, _Y), if _X &gt; _Y -&gt; _Y; true -&gt; _X end).\n</code></pre>\n\n<p>These cannot be abstract patterns because an abstract pattern\ncannot contain an 'if' or a 'case' or any other control structure.\nBut they can, and should, be ordinary inline functions:</p>\n\n<pre><code>-compile({inline,[{max,2},{min,2}]}).\nmax(X, Y) -&gt; if X &gt; Y -&gt; X; true -&gt; Y end.\nmin(X, Y) -&gt; if X &gt; Y -&gt; Y; true -&gt; X end.\n</code></pre>\n\n<p>Abstract patterns don't need to do what ordinary functions can.\nHere's another example from the OTP sources.</p>\n\n<pre><code>-define(LOWER(Char),\n    if\n        Char &gt;= $A, Char =&lt; $Z -&gt;\n        Char - ($A - $a);\n        true -&gt;\n        Char\n    end).\ntolower(Chars) -&gt;\n    [?LOWER(Char) || Char &lt;- Chars].\n</code></pre>\n\n<p>This could, and should, have been an ordinary inlined function.\nAbstract patterns don't need to do what ordinary functions can.\nLet's examine it a little closer.  Suppose we had a pattern</p>\n\n<pre><code>Cl = #lower(Cx)\n</code></pre>\n\n<p>which when used as an ordinary function converted both <code>$x</code> and <code>$X</code>\nto <code>$x</code>.  Then when used as a pattern <code>#lower(Cx) = $x</code>, there would\nbe two correct answers for <code>Cx</code>.  There are no other cases where\na pattern may match more than one way.  The fact that abstract\npatterns cannot do conditionals is one of the things that makes\nthem usable as patterns.</p>\n\n<p>Macros are sometimes used for module names.</p>\n\n<pre><code>-define(SERVER,{rmod_random_impl,\n        list_to_atom(\"babbis@\" ++\n    hd(tl(string:tokens(atom_to_list(node()),\"@\"))))}).\n\n-define(CLIENTMOD,'rmod_random').\n\nproduce() -&gt; ?CLIENTMOD:produce(?SERVER).\n</code></pre>\n\n<p>Abstract patterns can be used for this too, but there is an\nerror waiting to happen.</p>\n\n<pre><code>server() -&gt; {rmod_random_impl,\n        list_to_atom(\"babbis@\" ++\n    hd(tl(string:tokens(atom_to_list(node()),\"@\"))))}.\n\n#client_mod() -&gt; 'rmod_random'.\n\nproduce -&gt; #client_mod():produce(server()).\n</code></pre>\n\n<p>The risk is that of writing <code>#client_mod:produce(server())</code>,\nwhich is the syntax we'll want in stage 2 for calling an\nabstract pattern defined in another module.\nThere is one thing that macros are used for that abstract\npatterns can be used for, but you'd probably rather not.</p>\n\n<p>Abstract patterns were also invented with the aim of\nreplacing at least some uses of records.  Frames (or Joe\nArmstrong's structs, which are essentially the same thing)\nare a superior way to do that.   Let's see a simple case.</p>\n\n<pre><code>-record(mark_params, {cell_id,\n              virtual_col,\n              virtual_row\n             }).\n...\nMarkP = mark_params(),\n...\nNewMarkP = MarkP#mark_params{cell_id     = undefined,\n                 virtual_col = undefined,\n                 virtual_row = VirtualRow\n                },\n</code></pre>\n\n<p>This becomes</p>\n\n<pre><code>% General\n#mark_params(Cell, Row, Col) -&gt; {mark_params, Cell, Row, Col}.\n% Initial value\n#mark_params() -&gt; #mark_params(undefined, undefined, undefined).\n% Recogniser\n#is_mark_params({mark_params,_,_,_}) -&gt; true.\n% Cell extractor\n#mark_params__cell(#mark_params(Cell,_,_)) -&gt; Cell.\n% Cell updater\n#mark_params__cell(Cell, #mark_params(_,R,C)) -&gt;\n    #mark_params(Cell, R, C).\n% Row extractor\n#mark_params__row(#mark_params(_,Row,_)) -&gt; Row.\n% Row updater\n#mark_params__row(Row, #mark_params(K,_,C)) -&gt;\n    #mark_params(K, Row, C).\n% Col extractor\n#mark_params__col(#mark_params(_,_,Col)) -&gt; Col.\n% Col updater\n#mark_params__col(Col, #mark_params(K,R,_)) -&gt;\n    #mark_params(K, R, Col).\n...\nMarkP = #mark_params(),\n...\nNewMarkP = #mark_params__row(VirtualRow,\n           #mark_params__col(undefined,\n           #mark_params__cell(undefined, MarkP)))\n</code></pre>\n\n<p>The extractor and updater patterns can be derived automatically,\nwhich comes in stage 4.  With frames/structs, we may never bother.</p>\n\n<p>There is a feature of Haskell that I have long loved.\nThat is so-called \"n+k patterns\", where a pattern may be N+K\nfor N a variable and K a positive integer.  This matches V\nif V is an integer greater than or equal to K, and binds N\nto V - K.  For example,</p>\n\n<pre><code>fib 0 = 1\nfib 1 = 1\nfib (n+2) = fib n + fib (n+1)\n</code></pre>\n\n<p>Not that that's a good way to implement the Fibonacci function,\nof course.  (It takes O(phi^N) when O(log N) is attainable.)\nThere's no such thing in Erlang.  But with abstract patterns,\nwe could program it:</p>\n\n<pre><code>#succ(M) when is_integer(N), N &gt;= 1, M = N - 1 -&gt; N.\n\nfib(0) -&gt; 1;\nfib(1) -&gt; 1;\nfib(#succ(#succ(N)) -&gt; fib(N) + fib(N+1).\n</code></pre>\n\n<p>Sometimes we want a three-way split:</p>\n\n<pre><code>N = 1\nN = 2k+0 (k &gt;= 1)\nN = 2k+1 (k &gt;= 1)\n</code></pre>\n\n<p>We can program that too:</p>\n\n<pre><code>#one() -&gt; 1.\n#even(K)\nwhen is_integer(N), (N band 1) == 0, N &gt;= 2, K = N div 2\n-&gt; N.\n#odd(K)\nwhen is_integer(N), (N band 1) == 1, N &gt;= 3, K = N div 2\n-&gt; N.\n\nruler(#one())   -&gt; 0 ;\nruler(#even(K)) -&gt; 1 + ruler(K);\nruler(#odd(K))  -&gt; 1.\n</code></pre>\n\n<p>Let's turn to abstract data types.\nThere are three obvious ways to implement association lists\nas single data structures:</p>\n\n<pre><code>[{K1,V1}, ..., {Kn,Vn}]     % pairs\n[K1,V1, ..., Kn,Vn]     % alternating\n{K1,V1, ..., {Kn,Vn,[]}}    % triples\n</code></pre>\n\n<p>Suppose you cannot make up your mind which is better.</p>\n\n<pre><code>#empty_alist() -&gt; [].\n-ifdef(PAIRS).\n#non_empty_alist(K,V,R) -&gt; [{K,V}|R].\n-else.\n-ifdef(TRIPLES).\n#non_empty_alist(K,V,R) -&gt; {K,V,R}.\n-else.\n#non_empty_alist(K,V,R) -&gt; [K,V|R].\n-endif.\n-endif.\n\nzip([K|Ks], [V|Vs]) -&gt;\n    #non_empty_alist(K, V, zip(Ks, Vs));\nzip([], []) -&gt;\n    #empty_alist().\n\nlookup(K, #non_empty_alist(K,V,_), _) -&gt;\n    V;\nlookup(K, #non_empty_alist(_,_,R), D) -&gt;\n    lookup(K, R, D);\nlookup(K, #empty_alist(), D) -&gt;\n    D.\n</code></pre>\n\n<p>Now you can switch between the three implementations, for <br />\ntesting and benchmarking, by flicking a single preprocessor\nswitch.  </p>\n\n<p>Sometimes there is something that would have been an algebraic\ndata type in Haskell or Clean or SML or CAML, but in Erlang we\njust have to use a variety of tuples.  The parsed form of\nErlang source code is a good example.</p>\n\n<pre><code>lform({attribute,Line,Name,Arg}, Hook) -&gt;\n    lattribute({attribute,Line,Name,Arg}, Hook);\nlform({function,Line,Name,Arity,Clauses}, Hook) -&gt;\n    lfunction({function,Line,Name,Arity,Clauses}, Hook);\nlform({rule,Line,Name,Arity,Clauses}, Hook) -&gt;\n    lrule({rule,Line,Name,Arity,Clauses}, Hook);\n%% These are specials to make it easier for the compiler.\nlform({error,E}, _Hook) -&gt;\n    leaf(format(\"~p\\n\", [{error,E}]));\nlform({warning,W}, _Hook) -&gt;\n    leaf(format(\"~p\\n\", [{warning,W}]));\nlform({eof,_Line}, _Hook) -&gt;\n    $\\n.\n</code></pre>\n\n<p>We can define abstract patterns for these.</p>\n\n<pre><code>#attribute(L, N, A)    -&gt; {attribute, L, N, A}.\n#function( L, N, A, C) -&gt; {function,  L, N, A, C}.\n#rule(     L, N, A, C) -&gt; {rule,      L, N, A, C}.\n#eof(      L)          -&gt; {eof,       L}.\n#error(    E_          -&gt; {error,     E}.\n#warning(  W)          -&gt; {warning,   W}.\n\n#attribute()        -&gt; #attribute(_,_,_).\n#function()     -&gt; #function(_,_,_,_).\n#rule()         -&gt; #rule(_,_,_,_).\n\nlform(Form, Hook) -&gt;\n    case Form\n      of #attribute() -&gt; lattribute(Form, Hook)\n       ; #function()  -&gt; lfunction( Form, Hook)\n       ; #rule()      -&gt; lrule(     Form, Hook)\n       ; #error(E)    -&gt; leaf(format(\"~p\\n\", [{error,E}]))\n       ; #warning(W)  -&gt; leaf(format(\"~p\\n\", [{warning,W}]))\n       ; #eof(_)      -&gt; $\\n\n    end.\n</code></pre>\n\n<p>It would almost be worth defining these patterns even if these\nwere their only occurrences, simply for the clarity they permit.\nBut these patterns would be used over and over again.  Using\nthe patterns not only makes the code shorter and clearer, it\ngives us two kinds of protection against changes to the data\nrepresentation.  For example, suppose we decided to hold\nName/Arity information in 'function' and 'rule' tuples as\npairs, not as separate fields.  Then we could do</p>\n\n<pre><code>-ifdef(OLD_DATA).\n#function( L, N, A,  C) -&gt; {function,  L, N, A, C}.\n#rule(     L, N, A,  C) -&gt; {rule,      L, N, A, C}.\n#function( L, {N,A}, C) -&gt; {function,  L, N, A, C}.\n#rule(     L, {N,A}, C) -&gt; {rule,      L, N, A, C}.\n-else.\n#function( L, N, A, C)  -&gt; {function,  L, {N,A}, C}.\n#rule(     L, N, A, C)  -&gt; {rule,      L, {N,A}, C}.\n#function( L, NA,   C)  -&gt; {function,  L, NA,    C}.\n#rule(     L, NA,   C)  -&gt; {rule,      L, NA,    C}.\n-endif.\n</code></pre>\n\n<p>The rest of the code would remain unchanged.  That's one kind of\nprotection.  It doesn't help us when we need to add new cases.\nThat's when the second kind of protection comes up.  Looking\nfor <code>#function</code> is a much safer guide to finding relevant places\nthan looking for <code>function</code>.</p>\n\n<h1>Rationale</h1>\n\n<p>There is more to the idea of abstract patterns than this\nspecification describes.  Here's a \"road map\".</p>\n\n<ul>\n<li><p>Stage 0:\nAllow pattern matching in guards.\nThis is the subject of another EEP, as it is\ndesirable in itself.  This MUST be implemented\nfirst before implementing Stage 1, because that's\nwhat we want inlinable pattern calls to expand to.</p></li>\n<li><p>Stage 1:\nSimple abstract patterns restricted so that they\ncan be implemented exclusively by inline expansion.\nThis requires no change to the VM other than the\nchanges required for Stage 0.</p>\n\n<p>Import/export of patterns can be faked using the\npreprocessor to -include definitions; this is not\nideal, but it's an acceptable stopgap.</p></li>\n<li><p>Stage 2:\nAbstract functions are (pairs of) real functions,\nthey may be -exported and -imported, may be called\nwith module prefixes, can be replaced by hot loading,\nshould be traceable, debuggable, profilable, and so\non, just like other functions.  In Stage 2, exported\nabstract patterns would need inline declarations if\nthey are to be inlined; other patterns would continue\nto be inlined except when compiled in debugging mode.</p>\n\n<p>This requires fairly substantial changes to the\nrun time system.  The big payoff here is that\nimported abstract patterns can be replaced by hot\nloading, unlike macros.</p></li>\n<li><p>Stage 3:</p>\n\n<pre><code>#fun [Module:]Name/Arity and\n#fun (P1, ..., Pn) when G -&gt; B end\n</code></pre>\n\n<p>forms are introduced, and a metacall</p>\n\n<pre><code>#Var(E1,...,En) is added.\n</code></pre>\n\n<p>This requires extensions to the Erlang term\nrepresentation and the VM.  The gain here is that\nthe FAQ \"how do I pass a pattern as a parameter\"\nfinally gets a safe answer.  For example,</p>\n\n<pre><code>collect_messages(P) -&gt;\n    lists:reverse(collect_messages_loop(P, [])).\n\n\ncollect_messages_loop(P, Ms) -&gt;\n    receive M = #P() -&gt; collect_messages_loop([M|Ms])\n      after 0        -&gt; Ms\n    end.\n</code></pre>\n\n<p>gathers all the messages currently in the mailbox\nthat match a pattern passed as a parameter.</p></li>\n<li><p>Stage 4:\n<code>&lt;expression&gt;#&lt;pattern call&gt;</code> field update,\nas described in the original proposal.</p></li>\n<li><p>Stage 5:\nMulti-clause abstract patterns,\nas described in the original proposal.\nMulti-clause abstract patterns CAN handle\nexamples like <code>?get_max</code> and <code>?LOWER</code>, which makes\nthem even more useful in guards, but more than\na little dubious as patterns.</p></li>\n<li><p>Stage 6:\n\"Hybrid\" abstract patterns, where in <code>#A/M+N</code> the\nfirst <code>M</code> arguments are always inputs, and only\nthe last <code>N</code> are outputs.  This one isn't actually\nmy idea.  The example</p>\n\n<pre><code>#range(L, U, N)\nwhen is_integer(N), L =&lt; N, N =&lt; U\n-&gt; N.\n</code></pre>\n\n<p>comes from the mailing list.  I don't like this very\nmuch, and note that for some purposes,</p>\n\n<p>range(L, U) ->\n       #fun(N) when is_integer(N), L =&lt; N, N =&lt; U\n               -> N end.</p>\n\n<p>can do the same job.</p></li>\n</ul>\n\n<p>What I've done for this proposal is to strip away everything\nthat isn't essential.  We get data abstraction, user defined\nguard tests and functions, and a replacement for many uses\nof macros, without run time overheads and without changes to\nanything except the compiler front end, assuming that Stage 0\nis done first.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Erlang currently uses the sharp sign for record syntax.\nSince record syntax uses curly braces, and abstract patterns\nuse round parentheses, no existing code should be affected.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>Sketched above.  Given stage 0, this stage 1 is within my\nknowledge and abilities, but I don't understand the Erlang\nVM well enough to do stage 0.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}