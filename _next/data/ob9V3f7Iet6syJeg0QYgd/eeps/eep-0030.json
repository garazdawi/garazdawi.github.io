{"pageProps":{"index":{"id":"0030","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Final/R13A/R14A Proposal is implemented in OTP release R13A and R14A \nType: Standards Track\nErlang-Version: R12B-4\nCreated: 10-Jul-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 30: <a href=\"eep-0030.md\" title=\"EEP Source\"> Maximum and Minimum</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Add maximum and minimum core functions.</p>\n\n<h1>Specification</h1>\n\n<p>Currently the Erlang language has no built-in support for\nthe maximum and minimum operations.  So we add new functions</p>\n\n<p><code>erlang:min(E1, E2)</code>  with the same effects and value as</p>\n\n<pre><code>(T1 = E1, T2 = E2, if T1 &gt; T2 -&gt; T2 ; true -&gt; T1 end)\n</code></pre>\n\n<p><code>erlang:max(E1, E2)</code>  with the same effects and value as</p>\n\n<pre><code>(T1 = E1, T2 = E2, if T1 &gt; T2 -&gt; T1 ; true -&gt; T2 end)\n</code></pre>\n\n<p>except that we expect them to be implemented using single VM\ninstructions, and we expect HiPE to use conditional moves on\nmachines that have them.</p>\n\n<p>The <code>erlang:</code> module prefix on <code>max/2</code> (respectively <code>min/2</code>) can\nbe omitted if and only if there is no locally defind <code>max/2</code>\n(respectively <code>min/2</code>).</p>\n\n<h1>Motivation</h1>\n\n<p>Maximum and minimum are extremely useful operations.\nThe fact that there is no standard way to express them in Erlang\nhas had the predictable result:  there are definitions of <code>max/2</code>\nin <code>tool_utils</code>, <code>tv_pg_gridfcns</code>, <code>tv_pb</code>, <code>tv_comm_func</code>,\n<code>ssh_connection_handler</code>, <code>bssh_connection_handler</code>, <code>ssh_cli</code>,\n<code>hipe_arm</code>, <code>hipe_schedule</code>, <code>hipe_ultra_prio</code>, <code>hipe_ppc_frame</code>,\n<code>?HIPE_X86_FRAME</code> (presumably one each for 32- and 64-bit PCs),\n<code>hipe_sparc_frame</code>, <code>erl_recomment</code>, <code>erl_syntax_lib</code>, <code>appmon_info</code>,\noh, the list goes on and on.  There are dozens of copies.\nThere are nearly as many copies of <code>min/2</code>.  And that's leaving\naside possible copies with different names.</p>\n\n<p>Not only are the operations useful, they can be implemented\nmore efficiently by the compiler than by the programmer.\nIf <code>X &lt; Y</code> can be a VM instruction, so can <code>min</code> and <code>max</code>.\nHere's a first draft implementation:</p>\n\n<pre><code>OpCase(i_minimum): {\n    r(0) = CMP_GT(tmp_arg1, tmp_arg2)) ? tmp_arg1 : tmp_arg2;\n    Next(1);\n}\nOpCase(i_maximum): {\n    r(0) = CMP_GT(tmp_arg1, tmp_arg2)) ? tmp_arg2 : tmp_arg1;\n    Next(1);\n}\n</code></pre>\n\n<p>Beware: untested code!  Amongst other things, I don't know all the\nplaces that need to be updated, or how, when new instructions are\nadded.  These instructions are intended to be preceded by an\n<code>i_fetch</code> instruction the way &lt; and its other friends are.</p>\n\n<p>This is much cheaper than an Erlang function call, and it's much\neasier for HiPE to recognise when a maximum or minimum of two\nfloating point numbers is involved and can be turned into a\ncompare and a conditional move.</p>\n\n<p>The most important thing is the barrier to thought that is\nremoved.  When I'm writing Fortran, I know that max and min have\nbeen there for decades, and I use those operations freely.\nWhen I'm writing C, I know that those operations are not there,\nand that there are problems with the conventional macros, so\nI avoid them.  As an experiment, I added max() and min() functions\nto the version of AWK that I maintain.  It was easy, and the\nresult is that I now have a lot of AWK code that can't be run by\nanything else, because the operations are so handy.  Erlang has\nno <em>documented</em> maximum or minimum functions other than those in\nthe <code>lists</code> module, and writing <code>lists:max([X,Y])</code> is sufficiently\npainful to deter all but the most determined.</p>\n\n<h1>Rationale</h1>\n\n<p>Function or operator?</p>\n\n<p>I believe that there are excellent reasons to use the standard\n<code>/\\</code> and <code>\\/</code> symbols from <a href=\"http://mathworld.wolfram.com/Lattice.html\" title=\"Lattice Algebra\">lattice</a> theory.  However, discussion in\nthe EEPs mailing list showed that the community was divided\ninto</p>\n\n<ul>\n<li>people who were familiar with the operators</li>\n<li>people who insisted that they were only Boolean operators</li>\n<li>people who didn't get them at all because they weren't C.</li>\n</ul>\n\n<p>The ready availability of the operations as a standard part of\nthe language is much more important than what they are called,\nso the second draft of this EEP switched to built in functions\nin order to increase acceptance.</p>\n\n<p>The argument which finally settled it for me was the\ninternationalisation one:  Japanese programmers may be using\nkeyboards where <code>\\</code> means or screens where <code>\\</code> displays as Yen,\nso <code>/\\</code> and <code>\\/</code> just won't work for them.</p>\n\n<p>We cannot use <code>max</code> and <code>min</code> as operators because the compiler\nwill not let you use a symbol as both an operator and a function\nname, and there are lots and lots of uses of <code>max</code> and <code>min</code> as\nfunction names.  That's precisely the problem we're trying to\naddress here.  So they have to be function names.</p>\n\n<p>There is no great difficulty in adding new functions to the\n<code>erlang:</code> module.</p>\n\n<p>I don't want to write the <code>erlang:</code> prefix here.  There is\nnothing new in making the <code>erlang:</code> prefix for some functions\noptional either.</p>\n\n<p>What we want is for existing modules with their own definitions\nof <code>max/2</code> and/or <code>min/2</code> to remain legal, and then to be upgraded\nsimply by removing the redundant definitions.</p>\n\n<p>Imagine that you want to find the bounding box for a set\nof 2D points.  (This is adapted from code in Wings3D.)</p>\n\n<pre><code>bounding_box([{X0,Y0}|Pts]) -&gt;\n    bounding_box(Pts, X0,X0, Y0,Y0).\n\nbounding_box([{X,Y}|Pts], Xlo,Xhi, Ylo,Yhi) -&gt;\n    if X &lt; Xlo -&gt; Xlo1 = X,   Xhi1 = Xhi\n     ; X &gt; Xhi -&gt; Xlo1 = Xlo, Xhi1 = X\n     ; true    -&gt; Xlo1 = Xlo, Xhi1 = Xhi\n    end,\n    if Y &lt; Ylo -&gt; Ylo1 = Y,   Yhi1 = Yhi\n     ; Y &gt; Yhi -&gt; Ylo1 = Ylo, Yhi1 = Y\n     ; true    -&gt; Ylo1 = Ylo, Yhi1 = Yhi\n    end,\n    bounding_box(Pts, Xlo1,Xhi1, Ylo1,Yhi1);\nbounding_box([], Xlo,Xhi, Ylo,Yhi) -&gt;\n    {{Xlo,Ylo}, {Xhi,Yhi}}.\n</code></pre>\n\n<p>With maximum and minimum operators, this becomes</p>\n\n<pre><code>bounding_box([{X,Y}|Pts], Xlo,Xhi, Ylo,Yhi) -&gt;\n    bounding_box(Pts, min(X,Xlo), max(X,Xhi),\n              min(Y,Ylo), max(Y,Yhi));\nbounding_box([], Xlo,Xhi, Ylo,Yhi) -&gt;\n    {{Xlo,Ylo}, {Xhi,Yhi}}.\n</code></pre>\n\n<h1>Backwards Compatibility</h1>\n\n<p>No issues.  Where a module already has <code>max/2</code> or <code>min/2</code>,\nthe <code>erlang:</code> prefix is required to get the new function.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>I don't understand BEAM or the compiler well enough to\nprovide one, but the instruction definitions above are\noffered as evidence that it should not be hard for those\nwho do.  If this EEP is accepted I will be happy to write\nthe documentation for these operators.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}