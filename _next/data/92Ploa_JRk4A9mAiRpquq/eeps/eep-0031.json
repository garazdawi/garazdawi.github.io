{"pageProps":{"index":{"id":"0031","content":"<pre><code>Author:         Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;,\n            Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;\nStatus:         Final/R14A Proposal is implemented in OTP release R14A\nType:           Standards Track\nCreated:        28-Nov-2009\nErlang-Version: R13B03\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 31: <a href=\"eep-0031.md\" title=\"EEP Source\"> Binary manipulation and searching module</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP contains developed suggestions regarding the module <code>binary</code>\nfirst suggested in <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>. </p>\n\n<p><a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a> suggests several modules and is partially superseded by later\nEEP's (i.e. <a href=\"/eeps/eep-0011\" title=\"EEP 11, intresting extensions to EEP 9\">EEP 11</a>), while still containing valuable suggestions not\nyet implemented. The remaining modules from <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a> will therefore\nappear in separate EEP's. This construction is made in agreement with\nthe original author of <a href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\">EEP 9</a>.</p>\n\n<p>The module <code>binary</code> is suggested to contain fast searching\nalgorithms together with some common operations on binaries already\npresent for lists (in the lists module).</p>\n\n<h1>Motivation</h1>\n\n<p>While efficient searching is already present in the <code>re</code> library,\ndedicated search functions can further speed up searching in\nbinaries, given an efficient implementation (i.e. Boyer-More\nand Aho-Corassick algorithm). Another important advantage of\nseparate searching algorithms are ease of use to the programmer,\nas the suggested interfaces do not require knowledge about regular\nexpression syntax and special characters in the binaries need not\nbe escaped. It's interesting to note how often regular expressions\nare used for simple sub-string searching or replacement, which can\nwith this suggested module be done easily.</p>\n\n<p>Decomposition of binaries are usually done by using bit-syntax.\nHowever some common operations are useful to have as ordinary functions,\nboth for performance and to support a more traditiona functional\nprogramming style.</p>\n\n<p>Some operations for converting lists to binaries and v.v. are today in\nthe erlang module. BIFs concerning binaries now present have varied\nview of zero vs. one-based positioning in binaries. I.e.\n<code>binary_to_list/3</code> uses one-based while <code>split_binary/2</code> uses\nzero-based. As the convention is to use zero-based, new functions for\nconverting binaries to lists and v.v. are needed.</p>\n\n<p>Binaries are in fact a shared data-type, with small binaries often\nreferencing parts of larger binaries in a way not controllable by\nthe programmer in a simple way. The bitstring data-type further\ncomplicate things to the programmer in a way hard to easily\nmanage. I therefore also suggest some low level functions to\ninspect binary representation and to clone binaries to ensure a\nminimal representation.</p>\n\n<p>As matching is not allowed in guard expressions, I furthermore suggest\nthat a function for extracting parts of binaries is added to the set\nof guard BIFs. This would be consistent with the function element/2\nbeing allowed in guards.</p>\n\n<h1>Rationale</h1>\n\n<p>For the lists data type there is a help library providing functions for\ncommon operations such as searching and splitting lists.  This EEP suggests\nthat a similar set of library functions should be created for binaries.\nMany of the proposed functions are based on answers to questions regarding\nbinaries on the erlang-questions mailing list, e.g. \"how do I convert a\nnumber to a binary?\". This EEP therefore suggests the addition of one\nmodule in stdlib, namely a module <code>binary</code> which will implement the\nrequested functionality in an efficient way. Most of this module will\nneed to be implemented in native code (residing in the virtual\nmachine) why the proposed implementation will be delivered as \"beta\"\nfunctionality in a forthcoming Erlang release.</p>\n\n<p>The functionality suggested is the following:</p>\n\n<ul>\n<li><p>Functionality for searching, splitting and replacing in\nbinaries. The functionality in some ways will overlap that of the\nregular expression library already present in Erlang, but will be\neven more efficient and will have a simpler interface. </p></li>\n<li><p>Common operations on binaries that have their counterparts for lists\nalready in the stdlib module <code>lists</code>. While not all interfaces in\nthe <code>lists</code> module are applicable to binaries, many are. This module\nalso provides a good place for future operations on binaries,\noperations that are not applicable to lists or that we still don't\nknow the need for.</p></li>\n<li><p>Functions for converting lists to binaries and v.v. These functions\nshould have a consistent view of zero-based indexing in binaries.</p></li>\n<li><p>Operations on binaries concerning their internal\nrepresentation. This functionality is sometimes necessary to avoid\nextensive use of memory due to the shared nature of the binaries. As\noperations on binaries do not involve copying when binaries are\ntaken apart, programs can unknowingly (or at least unintentionally)\nkeep references to large binaries by holding seemingly small amounts\nof data in the process. The O(1) nature of many operations on\nbinaries makes the data sharing necessary, but the effects can\nsometimes be surprising. On the other hand, O(n) complexity and\ninstant memory explosions when splitting a binary would be even more\nsurprising, why the current behavior need to be retained. It is suggested\nthat functions for both inspecting the nature of sharing of a binary\nand to clone a copy of a binary to avoid sharing effects is present\nin this suggested module.</p></li>\n</ul>\n\n<p>All functionality is to be applied to byte oriented binaries, never\nbitstrings that do not have a bitlength that is a multiple of\neight. All binaries supplied to and returned by these functions should\npass the <code>is_binary/1</code> test, otherwise an error will be raised.</p>\n\n<h2>Suggested module reference</h2>\n\n<p>I suggest the following functionality (presented as an excerpt of an Erlang\nmanual pages). A discussion about the interface can be found below.</p>\n\n<h3>DATA TYPES</h3>\n\n<pre><code>cp()\n</code></pre>\n\n<p>Opaque data-type representing a compiled search-pattern.\nguaranteed to be a tuple() to allow programs to distinguish it from\nnon precompiled search patterns.</p>\n\n<pre><code>part() = {Pos,Length}\n\nStart = int()\nLength = int()\n</code></pre>\n\n<p>A representaion of a part (or range) in a binary. <code>Start</code> is a\nzero-based offset into a binary() and Length is the length of that\npart. As input to functions in this module, a reverse part\nspecification is allowed, constructed with a negative <code>Length</code>, so\nthat the part of the binary begins at <code>Start</code> + <code>Length</code> and is\n-<code>Length</code> long. This is useful for referencing the last N bytes\nof a binary as <code>{size(Binary), -N}</code>. The functions in this module\nalways return part()'s with positive <code>Length</code>.</p>\n\n<h3>EXPORTS</h3>\n\n<h4><code>compile_pattern(Pattern) -&gt; cp()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Pattern = binary() | [ binary() ]\n</code></pre>\n\n<p>Builds an internal structure representing a compilation of a\nsearch-pattern, later to be used in the find, split or replace\nfunctions. The cp() returned is guaranteed to be a tuple() to allow\nprograms to distinguish it from non precompiled search patterns</p>\n\n<p>When a list of binaries is given, it denotes a <em>set</em> of alternative\nbinaries to search for. I.e if <code>[&lt;&lt;\"functional\"&gt;&gt;, &lt;&lt;\"programming\"&gt;&gt;]</code> \nis given as <code>Pattern</code>, this means ''either <code>&lt;&lt;\"functional\"&gt;&gt;</code> <em>or</em>\n<code>&lt;&lt;\"programming\"&gt;&gt;</code>''. The pattern is a <em>set</em> of alternatives; when\nonly a single binary is given, the set has only one element. </p>\n\n<p>If pattern is not a binary or a flat proper list of binaries, a <code>badarg</code>\nexception will be raised.</p>\n\n<h4><code>match(Subject, Pattern) -&gt; Found | no</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = part()\n</code></pre>\n\n<p>The same as <code>match(Subject, Pattern, [])</code>.</p>\n\n<h4><code>match(Subject,Pattern,Options) -&gt; Found | no</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = part()\nOptions = [ Option ]\nOption = {scope, part()}\n</code></pre>\n\n<p>Searches for the first occurrence of <code>Pattern</code> in <code>Subject</code> and returns\nthe position and length.</p>\n\n<p>The function will return\n<code>{Pos,Length}</code> for the binary in <code>Pattern</code> starting at\nthe lowest position in <code>Subject</code>.</p>\n\n<p>Example::</p>\n\n<pre><code>1&gt; binary:find(&lt;&lt;\"abcde\"&gt;&gt;, [&lt;&lt;\"bcde\"&gt;&gt;,&lt;&lt;\"cd\"&gt;&gt;],[]).\n{1,4}\n</code></pre>\n\n<p>Even though <code>&lt;&lt;\"cd\"&gt;&gt;</code> ends before <code>&lt;&lt;\"bcde\"&gt;&gt;</code>, <code>&lt;&lt;\"bcde\"&gt;&gt;</code>\nbegins first and is therefore the first match. If two overlapping\nmatches begins at the same position, the longest is returned.</p>\n\n<p>Summary of the options:</p>\n\n<ul>\n<li><p><code>{scope, {Start, Length}}</code> <br />\nOnly the given part is searched. Return values still have offsets\nfrom the beginning of <code>Subject</code>. A negative <code>Length</code> is\nallowed as described in the <strong>TYPES</strong> section of this manual.</p>\n\n<p>The found part() is returned, if none of the strings in <code>Pattern</code> is\nfound, the atom <code>no</code> is returned.</p>\n\n<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>\n\n<p>If <code>{scope, {Start,Length}}</code> is given in the options such that\n<code>Start</code> is larger than the size of <code>Subject</code>, <code>Start</code> +\n<code>Length</code> is less than zero or <code>Start</code> + <code>Length</code> is larger than\nthe size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p></li>\n</ul>\n\n<h4><code>matches(Subject, Pattern) -&gt; Found</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = [ part() ] | []\n</code></pre>\n\n<p>The same as <code>matches(Subject, Pattern, [])</code>.</p>\n\n<h4><code>matches(Subject,Pattern,Options) -&gt; Found</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = [ part() ] | []\nOptions = [ Option ]\nOption = {scope, part()}\n</code></pre>\n\n<p>Works like match, but the <code>Subject</code> is search until exhausted and\na list of all non-overlapping parts present in Pattern are returned (in order).</p>\n\n<p>The first and <em>longest</em> match is preferred\nto a shorter, which is illustrated by the following example::</p>\n\n<pre><code>1&gt; binary:matches(&lt;&lt;\"abcde\"&gt;&gt;, [&lt;&lt;\"bcde\"&gt;&gt;,&lt;&lt;\"bc\"&gt;&gt;&gt;,&lt;&lt;\"de\"&gt;&gt;],[]).\n[{1,4}]\n</code></pre>\n\n<p>The result shows that <code>&lt;&lt;\"bcde\"&gt;&gt;&gt;</code> is selected instead of the\nshorter match <code>&lt;&lt;\"bc\"&gt;&gt;</code> (which would have given raise to one more\nmatch,<code>&lt;&lt;\"de\"&gt;&gt;</code>). This corresponds to the behavior of\nposix regular expressions (and programs like <code>awk</code>), but is not\nconsistent with alternative matches in <code>re</code> (and Perl), where\ninstead lexical ordering in the search pattern selects which string\nmatches.</p>\n\n<p>If none of the strings in pattern is found, an empty list is returned.</p>\n\n<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code> and for a\ndesctioption of available options, see <code>match/3</code>.</p>\n\n<p>If <code>{scope, {Start,Length}}</code> is given in the options such that\n<code>Start</code> is larger than the size of <code>Subject</code>, <code>Start</code> +\n<code>Length</code> is less than zero or <code>Start</code> + <code>Length</code> is larger than\nthe size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p>\n\n<h4><code>split(Subject,Pattern) -&gt; Parts</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nParts = [ binary() ]\n</code></pre>\n\n<p>The same as <code>split(Subject, Pattern, [])</code>.</p>\n\n<h4><code>split(Subject,Pattern,Options) -&gt; Parts</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nParts = [ binary() ]\nOptions = [ Option ]\nOption = {scope, part()} | trim | global\n</code></pre>\n\n<p>Splits Binary into a list of binaries based on <code>Pattern</code>. If the\noption <code>global</code> is not given, only the first occurrence of\n<code>Pattern</code> in <code>Subject</code> will give rise to a split. </p>\n\n<p>The parts of <code>Pattern</code> actually found in <code>Subject</code> are not included\nin the result.</p>\n\n<p>Example::</p>\n\n<pre><code>1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]).\n[&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;] \n2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]).\n[&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;]\n</code></pre>\n\n<p>Summary of options:</p>\n\n<ul>\n<li><p><code>{scope, part()}</code> <br />\nWorks as in <code>binary:match/3</code> and <code>binary:matches/3</code>. Note\nthat this only defines the scope of the search for matching\nstrings, it does not cut the binary before splitting. The\nbytes before and after the scope will be kept in the result.\nSee example below.</p></li>\n<li><p><code>trim</code> <br />\nRemoves trailing empty parts of the result (as does <code>trim</code>\nin <code>re:split/3</code>)</p></li>\n<li><p><code>global</code> <br />\nRepeats the split until the <code>Subject</code> is\nexhausted. Conceptually the <code>global</code> option makes <code>split</code>\nwork on the positions returned by <code>binary:matches/3</code>, while\nit normally works on the position returned by\n<code>binary:match/3</code>.</p></li>\n</ul>\n\n<p>Example of the difference between a <code>scope</code> and taking the binary apart \nbefore splitting::</p>\n\n<pre><code>1&gt; binary:split(&lt;&lt;\"banana\"&gt;&gt;,[&lt;&lt;\"a\"&gt;&gt;],[{scope,{2,3}}]).\n[&lt;&lt;\"ban\"&gt;&gt;,&lt;&lt;\"na\"&gt;&gt;]\n2&gt; binary:split(binary:part(&lt;&lt;\"banana\"&gt;&gt;,{2,3}),[&lt;&lt;\"a\"&gt;&gt;],[]).\n[&lt;&lt;\"n\"&gt;&gt;,&lt;&lt;\"n\"&gt;&gt;]\n</code></pre>\n\n<p>The return type is always a list of binaries which are all referencing\n<code>Subject</code>. This means that the data in <code>Subject</code> is not actually\ncopied to new binaries and that <code>Subject</code> cannot be garbage\ncollected until the results of the split are no longer referenced.</p>\n\n<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>\n\n<h4><code>replace(Subject,Pattern,Replacement) -&gt; Result</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nReplacement = binary()\nResult = binary()\n</code></pre>\n\n<p>The same as <code>replace(Subject,Pattern,Replacement,[])</code>.</p>\n\n<h4><code>replace(Subject,Pattern,Replacement,Options) -&gt; Result</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPattern = binary() | [ binary() ] | cp()\nReplacement = binary()\nResult = binary()\nOptions = [ Option ]\nOption = global | {scope, part()} | {insert_replaced, InsPos}\nInsPos = OnePos | [ OnePos ]\nOnePos = int() =&lt; byte_size(Replacement)\n</code></pre>\n\n<p>Constructs a new binary by replacing the parts in <code>Subject</code> matching\n<code>Pattern</code> with the content of <code>Replacement</code>.</p>\n\n<p>If the matching sub-part of <code>Subject</code> giving raise to the\nreplacement is to be inserted in the result, the option\n<code>{insert_replaced, InsPos}</code> will insert the matching part into\n<code>Replacement</code> at the given position (or positions) before actually\ninserting <code>Replacement</code> into the Subject. Example::</p>\n\n<pre><code>1&gt; binary:replace(&lt;&lt;\"abcde\"&gt;&gt;,&lt;&lt;\"b\"&gt;&gt;,&lt;&lt;\"[]\"&gt;&gt;,[{insert_replaced,1}]).\n&lt;&lt;\"a[b]cde\"&gt;&gt;\n2&gt; binary:replace(&lt;&lt;\"abcde\"&gt;&gt;,[&lt;&lt;\"b\"&gt;&gt;,&lt;&lt;\"d\"&gt;&gt;],&lt;&lt;\"[]\"&gt;&gt;,\n                 [global,{insert_replaced,1}]).\n&lt;&lt;\"a[b]c[d]e\"&gt;&gt;\n3&gt; binary:replace(&lt;&lt;\"abcde\"&gt;&gt;,[&lt;&lt;\"b\"&gt;&gt;,&lt;&lt;\"d\"&gt;&gt;],&lt;&lt;\"[]\"&gt;&gt;,\n                 [global,{insert_replaced,[1,1]}]).\n&lt;&lt;\"a[bb]c[dd]e\"&gt;&gt;\n4&gt; binary:replace(&lt;&lt;\"abcde\"&gt;&gt;,[&lt;&lt;\"b\"&gt;&gt;,&lt;&lt;\"d\"&gt;&gt;],&lt;&lt;\"[-]\"&gt;&gt;,\n                 [global,{insert_replaced,[1,2]}]).\n&lt;&lt;\"a[b-b]c[d-d]e\"&gt;&gt;\n</code></pre>\n\n<p>If any position given in <code>InsPos</code> is greater than the size of\nthe replacement binary, a <code>badarg</code> exception is raised.</p>\n\n<p>The options <code>global</code> and <code>{scope, part()}</code> works as for\n<code>binary:split/3</code>. The return type is always a binary.</p>\n\n<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>\n\n<h4><code>longest_common_prefix(Binaries) -&gt; int()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Binaries = [ binary() ]\n</code></pre>\n\n<p>Returns the length of the longest common prefix of the binaries in the\nlist <code>Binaries</code>. Example::</p>\n\n<pre><code>1&gt; binary:longest_common_prefix([&lt;&lt;\"erlang\"&gt;&gt;,&lt;&lt;\"ergonomy\"&gt;&gt;]).\n2\n2&gt; binary:longest_common_prefix([&lt;&lt;\"erlang\"&gt;&gt;,&lt;&lt;\"perl\"&gt;&gt;]).\n0\n</code></pre>\n\n<p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception\nis raised. </p>\n\n<h4><code>longest_common_suffix(Binaries) -&gt; int()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Binaries = [ binary() ]\n</code></pre>\n\n<p>Returns the length of the longest common suffix of the binaries in the\nlist <code>Binaries</code>. Example::</p>\n\n<pre><code>1&gt; binary:longest_common_suffix([&lt;&lt;\"erlang\"&gt;&gt;,&lt;&lt;\"fang\"&gt;&gt;]).\n3\n2&gt; binary:longest_common_suffix([&lt;&lt;\"erlang\"&gt;&gt;,&lt;&lt;\"perl\"&gt;&gt;]).\n0\n</code></pre>\n\n<p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception\nis raised. </p>\n\n<h4><code>first(Subject) -&gt; int()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\n</code></pre>\n\n<p>Returns the first byte of the binary as an integer. If the binary\nlength is zero, a <code>badarg</code> exception is raised.</p>\n\n<h4><code>last(Subject) -&gt; int()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\n</code></pre>\n\n<p>Returns the last byte of the binary as an integer. If the binary\nlength is zero, a <code>badarg</code> exception is raised.</p>\n\n<h4><code>at(Subject, Pos) -&gt; int()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPos = int() &gt;= 0\n</code></pre>\n\n<p>Returns the byte at position <code>Pos</code> (zero-based) in the binary\n<code>Subject</code> as an integer. If <code>Pos</code> >= <code>byte_size(Subject)</code>, a\n<code>badarg</code> exception is raised.</p>\n\n<h4><code>part(Subject, PosLen) -&gt; binary()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPosLen = part()\n</code></pre>\n\n<p>Extracts the part of the binary described by <code>PosLen</code>. </p>\n\n<p>Negative length can be used to extract bytes at the end of a binary::</p>\n\n<pre><code>1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.\n2&gt; binary:part(Bin,{byte_size(Bin), -5)).\n&lt;&lt;6,7,8,9,10&gt;&gt;\n</code></pre>\n\n<p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code>\nexception is raised.</p>\n\n<h4><code>part(Subject, Pos, Len) -&gt; binary()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPos = int()\nLen = int()\n</code></pre>\n\n<p>The same as <code>part(Subject, {Pos, Len})</code>.</p>\n\n<h4><code>bin_to_list(Subject) -&gt; list()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\n</code></pre>\n\n<p>The same as <code>bin_to_list(Subject,{0,byte_size(Subject)})</code>.</p>\n\n<h4><code>bin_to_list(Subject, PosLen) -&gt; list()</code></h4>\n\n<pre><code>Subject = binary()\nPosLen = part()\n</code></pre>\n\n<p>Converts <code>Subject</code> to a list of int(), each int representing the\nvalue of one byte. The <code>part()</code> denotes which part of the\n<code>binary()</code> to convert. Example::</p>\n\n<pre><code>1&gt; binary:bin_to_list(&lt;&lt;\"erlang\"&gt;&gt;,{1,3}).\n\"rla\"\n%% or [114,108,97] in list notation.\n</code></pre>\n\n<p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code>\nexception is raised.</p>\n\n<h3><code>bin_to_list(Subject, Pos, Len) -&gt; list()</code></h3>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nPos = int()\nLen = int()\n</code></pre>\n\n<p>The same as <code>bin_to_list(Subject,{Pos,Len})</code>.</p>\n\n<h4><code>list_to_bin(ByteList) -&gt; binary()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>ByteList = iodata() (see module erlang)\n</code></pre>\n\n<p>Works exactly like <code>erlang:list_to_binary/1</code>, added for completeness.</p>\n\n<h4><code>copy(Subject) -&gt; binary()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\n</code></pre>\n\n<p>The same as <code>copy(Subject, 1)</code>.</p>\n\n<h3><code>copy(Subject,N) -&gt; binary()</code></h3>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nN = int() &gt;= 0\n</code></pre>\n\n<p>Creates a binary with the content of <code>Subject</code> duplicated <code>N</code>\ntimes. </p>\n\n<p>This function will always create a new binary, even if <code>N</code> = 1. By\nusing <code>copy/1</code> on a binary referencing a larger binary, one might\nfree up the larger binary for garbage collection.  </p>\n\n<blockquote>\n  <p>NOTE! By deliberately copying a single binary to avoid referencing a\nlarger binary, one might, instead of freeing up the larger binary for\nlater garbage collection, create much more binary data than\nneeded. Sharing binary data is usually good. Only in special cases,\nwhen small parts reference large binaries and the large binaries are\nno longer used <em>in any process</em>, deliberate copying might be a good idea.</p>\n</blockquote>\n\n<p>If <code>N</code> &lt; 0, a <code>badarg</code> exception is raised.</p>\n\n<h4><code>referenced_byte_size(binary()) -&gt; int()</code></h4>\n\n<p>If a binary references a larger binary (often described as being a\nsub-binary), it can be useful to get the size of the actual referenced\nbinary. This function can be used in a program to trigger the\nuse of <code>copy/1</code>. By copying a binary, one might dereference the\noriginal, possibly large, binary which a smaller binary is a reference\nto.</p>\n\n<p>Example::</p>\n\n<pre><code>store(Binary, GBSet) -&gt;\n  NewBin = \n      case binary:referenced_byte_size(Binary) of\n          Large when Large &gt; 2 * byte_size(Binary) -&gt;\n             binary:copy(Binary);\n          _ -&gt;\n         Binary\n      end,\n  gb_sets:insert(NewBin,GBSet).\n</code></pre>\n\n<p>In this example, we chose to copy the binary content before inserting\nit in the <code>gb_set()</code> if it references a binary more than twice the size\nof the data we're going to keep. Of course different rules for when\ncopying will apply to different programs.</p>\n\n<p>Binary sharing will occur whenever binaries are taken apart, this is\nthe fundamental reason why binaries are fast, decomposition can always\nbe done with O(1) complexity. In rare circumstances this data sharing\nis however undesirable, why this function together with <code>copy/1</code>\nmight be useful when optimizing for memory use.  </p>\n\n<p>Example of binary sharing::</p>\n\n<pre><code>1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;,100).\n&lt;&lt;1,1,1,1,1 ...\n2&gt; byte_size(A).\n100\n3&gt; binary:referenced_byte_size(A)\n100\n4&gt; &lt;&lt;_:10/binary,B:10/binary,_/binary&gt;&gt; = A.\n&lt;&lt;1,1,1,1,1 ...\n5&gt; byte_size(B).\n10\n6&gt; binary:referenced_byte_size(B)\n100\n</code></pre>\n\n<blockquote>\n  <p>NOTE! Binary data is shared among processes. If another process still\nreferences the larger binary, copying the part this process uses only\nconsumes more memory and will not free up the larger binary for garbage\ncollection. Use this kind of intrusive functions with extreme care,\nand only if a <em>real</em> problem is detected.</p>\n</blockquote>\n\n<h4><code>encode_unsigned(Unsigned) -&gt; binary()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Unsigned = int() &gt;= 0\n</code></pre>\n\n<p>The same as <code>encode_unsigned(Unsigned,big)</code>.</p>\n\n<h4><code>encode_unsigned(Unsigned,Endianess) -&gt; binary()</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Unsigned = int() &gt;= 0\nEndianess = big | little\n</code></pre>\n\n<p>Converts a positive integer to the smallest possible representation\nin in a binary digit representation, either big or little endian.</p>\n\n<p>Example:</p>\n\n<pre><code>1&gt; binary:encode_unsigned(11111111,big). \n&lt;&lt;169,138,199&gt;&gt;\n</code></pre>\n\n<h4><code>decode_unsigned(Subject) -&gt; Unsigned</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nUnsigned = int() &gt;= 0\n</code></pre>\n\n<p>The same as <code>encode_unsigned(Subject,big)</code>.</p>\n\n<h4><code>decode_unsigned(Subject, Endianess) -&gt; Unsigned</code></h4>\n\n<p>Types:</p>\n\n<pre><code>Subject = binary()\nEndianess = big | little\nUnsigned = int() &gt;= 0\n</code></pre>\n\n<p>Converts the binary digit representation, in big or little endian, of\na positive integer in <code>Subject</code> to an Erlang int().</p>\n\n<p>Example::</p>\n\n<pre><code>1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big). \n11111111\n</code></pre>\n\n<h2>Guard BIF</h2>\n\n<p>I suggest adding the functions <code>binary:part/2</code> and <code>binary:part/3</code>\nto the set of BIFs allowed in guard tests. As guard BIFs are traditionally\nput in the erlang module, the following names for the guard BIFs are\nsuggested::</p>\n\n<pre><code>erlang:binary_part/2\nerlang:binary_part/3\n</code></pre>\n\n<p>They should both work exactly as their counterparts in the binary module.</p>\n\n<h2>Interface design discussion</h2>\n\n<p>As with all modules, there are a lot of arguments about the actual\ninterface, sometimes more than about the functionality. In this case a\nnumber of parameters has to be considered.</p>\n\n<ul>\n<li><p>Effectiveness - The interface should be constructed so that fast\nimplementation is possible and so that code using the interface can\nbe written in an effective way. To not create unnecessary garbage is\none parameter, to allow for general code is another. </p></li>\n<li><p>Parameter ordering - I've chosen to make the binary subject the\nfirst parameter in all applicable calls. Putting the subject first\ncorresponds to the <code>re</code> interface. The <code>lists</code> module, however,\nusually has the subject as last parameter. We could go for that\ninstead, but unfortunately the <code>lists:sublist/{2,3}</code> interface,\nwhich corresponds to the <code>part</code> function, has the subject\nfirst, why following the conventions of <code>lists</code> would not only\nbreak conformance with <code>re</code>, it would also give us a generally\nnon-stringent interface. The effect of not conforming to the\n<code>lists</code> interface is that using function names from that module\nwould lead to confusion and therefore is avoided.</p></li>\n<li><p>Function naming - We have two related modules to take into account\nwhen naming functions here. The module <code>re</code> is related to the\nsearching function (<code>match</code>, <code>replace</code> etc), while the <code>lists</code>\nmodule is related to the decomposition functions (<code>first</code>,\n<code>last</code> etc). </p>\n\n<p>I've basically retained the names from <code>re</code> when I find the\nfunctionality, both in concept and interface to be similar\nenough. The nature of regular expressions as small executable\nprograms, which is to much to say for a collection of binaries as\nthe patterns are in this module, prohibits the use of the function\nname <code>run</code> for actually doing the searching. We use <code>match</code> and \n<code>matches</code> instead of <code>run</code>. </p>\n\n<p>As this module is more general than <code>re</code>, a function name like\n<code>compile</code> is not really good. <code>re:compile</code> means \"compile a\nregular expression\", but what would <code>binary:compile</code> mean?\nTherefore the pre-processing function is instead called\n<code>compile_pattern</code>.</p>\n\n<p>When it comes to the <code>lists</code> module, the parameter ordering has\nprevented me from reusing any function names but <code>last</code>, which\nonly takes one parameter in <code>lists</code> and there is no real\nalternative there.</p></li>\n<li><p>Options or multiple functions - I believe a good rule of thumb is to\nnot have options that change the return type of the function, which\nwould have been the case if we i.e. had a <code>global</code> option to\n<code>match/3</code> instead of a separate <code>matches/3</code> function.</p>\n\n<p>The fact that there are a manageable set of possible return types\nfor the searching and decomposition functions allows us to follow\nthat rule of thumb.</p>\n\n<p>(Unfortunately that rule could not be easilly followed in <code>re</code>, as the\nrich assortment of options would have given rise to a non-manageable\namount of function names). </p></li>\n</ul>\n\n<h1>Performance</h1>\n\n<p>Although the decomposition functions are not really faster than using\nbit-syntax for decomposition, they create slightly less garbage than\nthe bit syntax. As they are not slower than bit-syntax, they also have\na purpose in allowing for a different programming style.</p>\n\n<p>The match/replace/split functionality should be compared to similar\nfunctionality in the <code>re</code> module. Implementation methods has to be\nchosen so that this modules search functions are faster, or possibly\neven significantly faster, than <code>re</code>.</p>\n\n<h1>Reference implementation</h1>\n\n<p>A reference implementation was available on GitHub development branch \nbefore the final inclusion in R14A. </p>\n\n<h1>Copyright</h1>\n\n<p>This document is licensed under the <a href=\"http://creativecommons.org/licenses/by/3.0/\" title=\"Creative Commons Attribution 3.0 License\">Creative Commons license</a>.</p>\n"}},"__N_SSG":true}