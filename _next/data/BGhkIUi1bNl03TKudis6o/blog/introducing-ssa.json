{"pageProps":{"item":{"id":"introducing-ssa","title":"Introduction to SSA","author":"Björn Gustavsson","excerpt":"\nThis blog post is an introduction to the [new SSA-based intermediate\nrepresentation][pr1935] that has recently been merged to the `master`\nbranch in the [Erlang/OTP repository][otp]. It uses the same\nexample as in the [previous blog post][prev], first looking at the\ngenerated SSA code, and then at some optimizations.","article_date":1536105600000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Introduction to SSA","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post is an introduction to the [new SSA-based intermediate\nrepresentation][pr1935] that has recently been merged to the `master`\nbranch in the [Erlang/OTP repository][otp]. It uses the same\nexample as in the [previous blog post][prev], first looking at the\ngenerated SSA code, and then at some optimizations.\n\nHere again is the example function that does the kind of tuple matching\ntypically done when matching records:\n\n```erlang\nfoo({tag,A,_,_}) ->\n    {ok,A}.\n```\n\nAt the end of this blog post there will be section on [how to generate\nlisting files](#generating_listings) to inspect the code from the\ncompiler passes.\n\n## A brief introduction to the SSA intermediate format\n\nSSA stands for [Static Single Assignment][ssa]. Strictly speaking, SSA\nis the property of an [intermediate representation][intermediate] where\neach variable is assigned exactly once, and where every variable is\ndefined before it is used. In this blog post, we will use the term\n*SSA code* to refer to the new intermediate representation in the\nErlang compiler.\n\nHere is the SSA code for the `foo/1` function:\n\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = bif:is_tuple _0\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n\n%% Unreachable blocks\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\n### A deeper look at the example\n\nWe will go through the code a few lines at the time.\n\n```\nfunction blog:foo(_0) {\n```\n\nThis is the head of the function. It gives the module name (`blog`),\nfunction name (`foo`), and the arguments (the single variable _0).\n\nVariables named as `_` followed by an integer are inherited from\n[Core Erlang][core_erlang]. In OTP 22, variable names in Core Erlang\nare integers (to avoid filling the atom table when compiling huge\nfunctions).\n\n```\n0:\n```\n\nFollowing the function head is one or more *blocks* (sometimes called\n*nodes*).  A integer followed by a colon gives the number of the block\nthat follows.\n\nThe block number `0` is special.  It is the first block that will be\nexecuted in this function.\n\n```\n  @ssa_bool:6 = bif:is_tuple _0\n```\n\nHere is the first real instruction! All instructions have this\nbasic format. First there is a variable, followed by `=`, followed\nby the name of the instruction, followed by its operands.\n\nThe variable to the left, `@ssa_bool:6` in this example, will be\nassigned the value of the expression to right of the `=`.\n\nEach variable can only be assigned once, just as in Erlang. The name\nof this variable consists of two parts, the base part `@ssa_bool` and\nthe numeric suffix `6`. Whenever the base name itself is not unique,\nthe numeric suffix is added to make the name unique.\n\nThe instruction name is `bif:is_tuple`. This is one of the\ninstructions that use a two-part name.  The `bif` prefix means that\nthe second part must be the name of an Erlang guard BIF, in this case\n`is_tuple/1`.\n\nFollowing the name of the instruction is the operand `_0`, which is\nthe name of the function argument for the `foo/1` function.\n\nThus, this instruction will call `is_tuple/1` and assign the result\n(either `true` or `false`) to `ssa_bool:6`.\n\n```\n  br @ssa_bool:6, label 7, label 3\n```\n\nThis is the last instruction of block 0. Instructions at the end\nof a block are called *terminators* and they have a different format\ncompared to instructions in the interior of a block. Terminators\neither transfer control to another block or returns from the\nfunction.\n\n`br` transfers control to another block. The first operand is a\nvariable, whose value must be `true` or `false`. If the value of\n`ssa_bool:6` is `true`, the second operand (`label 7`) is used as the\nblock number for the block where execution will continue. In this\nexample: block 7. Similarly, if the value of `ssa_bool:6` is `false`,\nthe third operand (`label 3`) will be used to transfer control to\nblock 3.\n\n\n```\n7:\n  @ssa_arity = bif:tuple_size _0\n```\n\nThis is the beginning of block 7. This block will be executed\nif `_0` was found to be a tuple. `@ssa_arity` will be assigned\nthe value of the call `tuple_size(_0)`.\n\nNote that `@ssa_arity` does not have a numeric suffix, since there\nis no other variable in this function having the same base name.\n\n```\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n```\n\nHere `bif:=:=` compares `@ssa_arity` and `4` and assigns the\nresult to `@ssa_bool:8`. (Note that `=:=` is a guard BIF\nin Erlang; it is allowed but unusual to write\n`erlang:'=:='(Arity, 4)` instead of `Arity =:= 4`.)\n\n```\n  br @ssa_bool:8, label 5, label 3\n```\n\nHere is another `br` instruction. It will transfer control to\nblock 5 if `@ssa_bool:8` is `true` (that is, if `@ssa_arity`\nis equal to 4), and to block 3 otherwise.\n\n```\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n```\n\nBlock 5 is executed if `_0` has been found to be a tuple of\nsize 4. The `get_tuple_element` instruction extracts an element\nfrom a tuple at the given position. The position is zero-based.\n\nThe `get_tuple_element` instruction in SSA in named after the\nBEAM instruction with the same name:\n\n    {get_tuple_element,{x,0},0,{x,1}}.\n\nNotice the similarity between the SSA instruction and the BEAM\ninstruction. The SSA form uses variables instead of registers,\nand the destination variable is to the left of the `=` as in\nall SSA instructions.\n\n```\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n```\n\nHere comes the test that the first element of the tuple\nis equal to the atom `tag`. If the first element is `tag`,\nexecution continues at block 4, otherwise at block 3.\n\n```\n4:\n  _9 = put_tuple literal ok, _7\n```\n\nThis instruction constructs the `{ok,A}` tuple. The variable `_7`\ncontains the second element of the tuple.\n\nThe `put_tuple` instruction takes any number of operands and\nconstructs a tuple from them. The result is assigned to the \nvariable `_9`.\n\nIn this case, the `put_tuple` instruction in SSA does more than the\ncorresponding BEAM instruction. To construct the same tuple, three\nBEAM instructions are needed:\n\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n\nHaving a single instruction to construct a tuple instead of\nthe multiple BEAM instructions simplifies optimizations\nimmensely. Also note that SSA has no equivalent of the `test_heap`\ninstruction that caused so much trouble in the [previous blog post][prev].\n\n```\n  ret _9\n```\n\n`ret` is another terminator instruction. `ret` returns from the function\nwith the value of variable `_9` as the return value.\n\nThat concludes the successful path through the function.\n\n```\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n```\n\nThis block is executed if any of `br` instructions in the previous blocks\nwere given the value `false`, that is if the function argument was not a tuple or\nhad the wrong size or wrong first element.\n\nThe comment line (starting with `%%`) has been added by the pretty printer based on\nannotation in the `call` instruction.\n\nIt is left as an exercise to the reader to figure out exactly what the\ninstructions in the block do.  As a hint, here is the code for the\nblock translated back to Erlang code:\n\n```erlang\nerlang:error(function_clause, [_0]).\n```\n\nMoving on to the part of the function that is not executed at all:\n\n```\n%% Unreachable blocks\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n```\n\nThe comment (`Unreachable blocks`) was added by the pretty printer to\nindicate that the blocks that follow can never be executed, because no\nblock will ever branch to them.\n\nWhy is there an unreachable block?\n\nBlock 1 is a special block. It generates a `badarg` exeception, just\nas a call to `error:error(badarg)`. The SSA code generator always\nincludes block 1 with the exact same instructions in every function,\neven if it never actually used.\n\nWe will not go into details about the purpose of this block in this\nblog post (but we will see how it is used in the next blog post).\n\n## Optimizing the code\n\nNow it's time to see how the SSA code can be optimized. The SSA\noptimizations follow the same idea as the [Core Erlang\noptimizations][sys_core_fold] of using many simple optimizations\nworking together rather than a few complicated optimizations.\n\nHere is the code for the function again as it looks after running a few preliminary\noptimization passes:\n\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = bif:is_tuple _0\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n  br label 10\n\n10:\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\nThe unreachable block 1 has been deleted.\n\nA pass that [splits blocks][ssa_opt_split_blocks] before certain\ninstructions has also been run (in order to make the passes for\n[sinking `get_tuple_element` instructions][ssa_opt_sink] and [swapping\n`element/2` calls][ssa_opt_element] more effective). This pass has\nsplit block 3 into two blocks. At the end of block 3 there is a\nvariant of the `br` terminator that we have not seen before.  `br label\n10` unconditionally continues the execution at block 10.\n\nThe first interesting optimization for our example is the\n[ssa_opt_record] optimizations, which attempts to translate tuple\nmatching instructions with an `is_tagged_tuple` instruction.\nHere is the part of the code that will be optimized:\n\n<pre class=\"highlight\">\n    0:\n      @ssa_bool:6 = bif:is_tuple _0\n      br @ssa_bool:6, label 7, <b>label 3</b>\n\n    7:\n      @ssa_arity = bif:tuple_size _0\n      @ssa_bool:8 = bif:'=:=' @ssa_arity, <b>literal 4</b>\n      br @ssa_bool:8, label 5, <b>label 3</b>\n\n    5:\n      _8 = get_tuple_element _0, literal 0\n      @ssa_bool = bif:'=:=' _8, <b>literal tag</b>\n      br @ssa_bool, label 4, <b>label 3</b>\n</pre>\n\nThe optimization is done in two stages. First the code is analyzed to find out\nwhether the optimization is applicable. There must be a test for a tuple of\na certain size (4 in this example) and with a certain first element\n(`tag` in this example). Furthermore all failure labels must be the same.\n\nIf all conditions are fulfilled, the optimization is done in the second stage.\nHere is the code again, with the optimized part of the code highlighted:\n\n<pre class=\"highlight\">\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = <b>is_tagged_tuple _0, literal 4, literal tag</b>\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      @ssa_arity = bif:tuple_size _0\n      @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n      br @ssa_bool:8, label 5, label 3\n\n    5:\n      _8 = get_tuple_element _0, literal 0\n      @ssa_bool = bif:'=:=' _8, literal tag\n      br @ssa_bool, label 4, label 3\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n</pre>\n\nYes, it really is this simple, but so far it is more of a\n[pessimization] than an optimization, because the `bif:is_tuple`\ninstruction has been replaced with the more expensive\n`is_tagged_tuple` instruction.\n\nThe next optimization is a type analysis pass, which is implemented in\nthe module [beam_ssa_type]. Here is the code after running `beam_ssa_type`:\n\n<pre class=\"highlight\">\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      @ssa_arity = bif:tuple_size _0\n      @ssa_bool:8 = bif:'=:=' <b>literal 4, literal 4</b>\n      <b>br label 5</b>\n\n    5:\n      _8 = get_tuple_element _0, literal 0\n      @ssa_bool = bif:'=:=' <b>literal tag, literal tag</b>\n      <b>br label 4</b>\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n</pre>\n\n`beam_ssa_type` analyzes the code in execution order, remembering the\ntype of each variable seen. Based on the types, `beam_ssa_type` replaces\nvariables with known values with the values themselves.\n\nTwo of the conditional branchs have been converted to unconditional\nbranches.\n\nThe next optimization is [liveness analysis][ssa_opt_live]. The code\nis scanned in reverse execution order, and if an expression is never\nused, and has no observable side effect, it can be deleted. The\nhighlighted instructions in the code that follows was identified by\nthe liveness analysis pass as unused:\n\n<pre class=\"highlight\">\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      <b>@ssa_arity = bif:tuple_size _0</b>\n      <b>@ssa_bool:8 = bif:'=:=' literal 4, literal 4</b>\n      br label 5\n\n    5:\n      <b>_8 = get_tuple_element _0, literal 0</b>\n      <b>@ssa_bool = bif:'=:=' literal tag, literal tag</b>\n      br label 4\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n</pre>\n\nBecause those expressions don't have any side effects, they can be deleted:\n\n<pre class=\"highlight\">\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      br label 5\n\n    5:\n      br label 4\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n</pre>\n\nAfter running a pass that [merges blocks][ssa_opt_merge_blocks], the final code\nlooks like this:\n\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n  br @ssa_bool:6, label 5, label 3\n\n5:\n  _7 = get_tuple_element _0, literal 1\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\nNow it's time to look at the resulting BEAM code. Here is the successful part of the\nfunction:\n\n    %% Block 0.\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n\n    %% Block 5.\n    {test_heap,3,1}.\n    {get_tuple_element,{x,0},1,{x,0}}.\n    {put_tuple,2,{x,1}}.\n    {put,{atom,ok}}.\n    {put,{x,0}}.\n    {move,{x,1},{x,0}}.\n    return.\n\nSince register allocation was done after the `is_tagged_tuple`\noptimization, the `get_tuple_instruction` will extract the second\nelement of the tuple to the first available register, namely\n`{x,0}`. That avoids any potential problem of registers being\nundefined at a `test_heap` instruction. The `put_tuple` instruction\nwill put the built tuple into `{x,1}` since the following\n`{put,{x,0}}` instruction still needs the contents of `{x,0}`. To\nreturn the built tuple, the `{move,{x,1},{x,0}}` instruction just\nbefore the `return` instruction copies the contents of `{x,1}`\nto `{x,0}`.\n\nIt happens that for this particular example, the OTP 21 compiler will produce\nslightly better code:\n\n<pre class=\"highlight\">\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    {test_heap,3,1}.\n    {get_tuple_element,{x,0},1,<b>{x,2}</b>}.\n    {put_tuple,2,<b>{x,0}</b>}.\n    {put,{atom,ok}}.\n    {put,<b>{x,2}</b>}.\n    return.\n</pre>\n\n(The tuple can be built to `{x,0}` directly, avoiding the `move`\ninstruction before the `return`.)\n\n## Getting rid of the `move` instruction\n\nPerhaps I should have chosen another example to avoid revealing that\nthe SSA-based compiler sometimes produces worse code than the old\ncompiler.\n\nAnyway, now that the secret is out, let's see what can been done\nabout that extra `move` instruction.\n\nLet's look at another example:\n\n```erlang\nmake_tuple(A) ->\n    {ok,A}.\n```\n\nThe BEAM code produced by either the compiler in OTP 21\nor the new SSA-based compiler looks like this:\n\n    {test_heap,3,1}.\n    {put_tuple,2,{x,1}}.\n    {put,{atom,ok}}.\n    {put,{x,0}}.\n    {move,{x,1},{x,0}}.\n    return.\n\nClearly, the way the tuple building instructions work, it would be\nimpossible to avoid the `move` instruction. When building a tuple, the\ndestination register for the built tuple must not be the same\nas one of the source registers. It seems that we will need\nbetter instructions for constructing tuples if we are to avoid\nthe `move` instruction.\n\nThe problem doesn't exist when building a list:\n\n    %% build_list(A) -> [A].\n    {test_heap,2,1}.\n    {put_list,{x,0},nil,{x,0}}.\n    return.\n\nThe `put_list` instruction can safely place the built list into the\nsame register as either of the source registers.\n\nIntroducing a new `put_tuple2` instruction that builds a tuple in a\nsingle instruction, the `move` instruction can be eliminated:\n\n    {test_heap,3,1}.\n    {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n    return.\n\nAt the time of writing, the implementation of `put_tuple2` has not yet\nbeen merged to the `master` branch, but can be found in [#1947:\nIntroduce a put_tuple2 instruction][pr1947].\n\n## Next time\n\nAs we have seen, a variable in the SSA code can only be assigned\nonce (just as in Erlang). So how can the following code be\ntranslated to SSA code?\n\n```\nbar(X) ->\n    case X of\n        none ->\n            Y = 0;\n        _ ->\n            Y = X\n    end,\n    Y + 1.\n```\n\n## <a name=\"generating_listings\"></a>How to generate listing files\n\nTo generate the unoptimized SSA code for a module, use the `dssa` option:\n\n```\nerlc +dssa blog.erl\n```\n\nThe SSA code will be pretty printed into the file `blog.ssa`.\n\nUse the `dssaopt` option to generate the optimized SSA code, printing\nit to the file `blog.ssaopt`.\n\n```\nerlc +dssaopt blog.erl\n```\n\nTo see how the SSA code looked when not all optimization passes had been\nrun, I used variations of the following command line\n\n```\nerlc +dssaopt +no_ssa_opt_type +no_ssa_opt_live +no_ssa_opt_merge_blocks blog.erl\n```\n\nThose options are intentionally not documented. Skipping optimization\nis only intended for debugging or exploring how the optimization\npasses work. Skipping some optimizations passes that are actually\nmandatory will crash the compiler.\n\nTo find the names of the options for skipping passes, see the [list of\nsub passes of `beam_ssa_opt`][passes] and add `no_` to the name of the\npass.\n\nTo generate `blog.S` with the BEAM code, use the `-S` option:\n\n```\nerlc -S blog.erl\n```\n\nTo skip all SSA optimizations, use the `no_ssa_opt` option:\n\n```\nerlc +no_ssa_opt -S blog.erl\n```\n\n[pr1935]: https://github.com/erlang/otp/pull/1935\n[pr1947]: https://github.com/erlang/otp/pull/1947\n[otp]: https://github.com/erlang/otp\n[intermediate]: https://en.wikipedia.org/wiki/Intermediate_representation\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form\n[prev]: http://blog.erlang.org/opt-traps-and-pitfalls/\n[sys_core_fold]: http://blog.erlang.org/core-erlang-optimizations/\n[pessimization]: https://stackoverflow.com/questions/32618848/what-is-pessimization\n[core_erlang]: http://blog.erlang.org/core-erlang-by-example/\n\n[passes]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L49\n[ssa_opt_split_blocks]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L100\n[ssa_opt_element]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L119\n[ssa_opt_record]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L194\n[ssa_opt_live]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L683\n[ssa_opt_merge_blocks]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L976\n[ssa_opt_sink]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L1025\n\n[beam_ssa_type]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_type.erl\n"}},"__N_SSG":true}