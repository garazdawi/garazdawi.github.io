<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/Memory-instrumentation-in-OTP-21/">Memory instrumentation in OTP 21</a></h3><p><em>Wednesday, 2 May 2018<!-- --> - <!-- -->John Högberg</em></p><p>The memory instrumentation module was rewritten for Erlang/OTP 21 to make it
easier to use. In this post I&#x27;ll describe the rationale behind the new features
and how to make use of them.</p><p>One of the most important features that a diagnostic tool can have is the
ability to work on the fly. If it requires a restart then the condition you&#x27;re
trying to diagnose might vanish, and you can&#x27;t use it to troubleshoot issues on
&quot;production&quot; systems.</p><p>The previous implementation had a few major issues to this effect; you had to
start the Erlang VM with a certain flag, accept considerable overhead, and
worst of all suspend the VM while it collected all its data.</p><p>The amount of data it collected was also quite problematic; with one entry for
every single allocation it was difficult to tell what was hiding in all that
information, and since there was no way to tell whether a gap between two
allocations was mapped or not it was needlessly difficult to use when trying
to troubleshoot memory fragmentation.</p><p>The new implementation tackles these problems by scanning existing data
structures to lower its overhead to the point it can be turned on by default,
and tries to collect information in a manner that doesn&#x27;t harm the
responsiveness of the system.</p><h2>Carriers and memory fragmentation</h2><p>The VM allocates memory in large segments we call &quot;carriers&quot; and then allocates
blocks within those. This has many benefits; since each carrier is completely
separate from the others it&#x27;s easy to determine when they can be returned to
the operating system, and they scale very well since we can guarantee that
they&#x27;re only modified by per-thread instances which makes allocation and
deallocation wait-free in most cases.</p><p>There are two types of carriers; single-block which always contain one large
block, and multi-block that can contain several smaller blocks. While both of
these rely on the operating system to minimize address space fragmentation, the
latter kind can also become internally fragmented which will result in new
carriers being created if no existing multi-block carrier can satisfy an
allocation, even if the amount of unused memory exceeds the request.</p><p>While you can glean some information about average carrier utilization from
<code>erlang:system_info({allocator, Alloc})</code> and use <code>pmap</code> (or similar) to get an
idea of how fragmented the address space is, it has always been a pain to get
information about the individual carriers. Starting in OTP 21 you can ask the
system for a list of all carriers without having to start the VM with any
particular flags. The list contains information about each carrier&#x27;s total
size, combined allocation size, allocation count, whether it&#x27;s in the migration
pool, and a histogram over free block sizes.</p><p>We chose to represent the free blocks with histograms (log2, starting at 512 by
default) as they make it easy to tell at a glance whether a carrier has
fragmentation issues; if there&#x27;s a lot of free blocks clustered along the left
side then it&#x27;s pretty safe to say there&#x27;s a problem.</p><p>In the example below, the <code>ll_alloc</code> carrier has no free blocks at all, the
<code>binary_alloc</code> and <code>eheap_alloc</code> ones look healthy with a few very large
blocks, and the <code>fix_alloc</code> carrier is somewhat fragmented with ~3KB free split
into 22 blocks smaller than 512 bytes (although this is not a problem for this
allocator type).</p><pre><code class="language-erlang">1&gt; instrument:carriers().
{ok,{512,
     [{ll_alloc,1048576,0,1048344,71,false,{0,0,0,0,0,0,0,0,0,0,0,0,0,0}},
      {binary_alloc,1048576,0,324640,13,false,{3,0,0,1,0,0,0,2,0,0,0,0,0,0}},
      {eheap_alloc,2097152,0,1037200,45,false,{2,1,1,3,4,3,2,2,0,0,0,0,0,0}},
      {fix_alloc,32768,0,29544,82,false,{22,0,0,0,0,0,0,0,0,0,0,0,0,0}},
      {...}|...]}}</code></pre><p>(<code>instrument:carriers/1</code> can be used to tweak the histograms and which
allocators to look in.)</p><h2>Allocations and memory utilization</h2><p>Those who have used <code>erlang:memory()</code> are probably familiar with how annoyingly
general the <code>system</code> category can be. It&#x27;s possible to get a bit more
information by using <code>erlang:system_info({allocator, Alloc})</code> but the most it
will do is tell you that it&#x27;s (say) <code>driver_alloc</code> that eats all that memory
and leave you with no clue which one.</p><p>While it&#x27;s often easy to tell which driver or NIF is causing problems while
you&#x27;re developing, it&#x27;s not as easy when it&#x27;s used in anger alongside half a
dozen others. The new &quot;allocation tagging&quot; feature will help you figure out
where the memory went at the cost of one word per allocation. The allocations
are presented as block size histograms (similar to carrier information)
grouped by their origin and type:</p><pre><code class="language-erlang">2&gt; instrument:allocations()
{ok,{128,0,
     #{udp_inet =&gt;
           #{driver_event_state =&gt; {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0}},
       tty_sl =&gt;
           #{io_queue =&gt; {0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             drv_internal =&gt; {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0}},
       system =&gt;
           #{db_segment =&gt; {0,0,0,0,0,18,0,0,1,0,0,0,0,0,0,0,0,0},
             heap =&gt; {0,0,0,0,20,4,2,2,2,3,0,1,0,0,1,0,0,0},
             thr_prgr_data =&gt; {38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             db_term =&gt; {271,3,1,52,80,1,0,0,0,0,0,0,0,0,0,0,0,0},
             code =&gt; {0,0,0,5,3,6,11,22,19,20,10,2,1,0,0,0,0,0},
             binary =&gt; {18,0,0,0,7,0,0,1,0,0,0,0,0,0,0,0,0,0},
             atom_entry =&gt; {8681,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             message =&gt; {0,40,78,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
             ... }
       spawn_forker =&gt;
           #{driver_select_data_state =&gt;
                 {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},
       ram_file_drv =&gt; #{drv_binary =&gt; {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}},
       prim_file =&gt;
           #{process_specific_data =&gt; {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             nif_trap_export_entry =&gt; {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             monitor_extended =&gt; {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             drv_binary =&gt; {0,0,0,0,0,0,1,0,3,5,0,0,0,1,0,0,0,0},
             binary =&gt; {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},
       prim_buffer =&gt;
           #{nif_internal =&gt; {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
             binary =&gt; {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}}}</code></pre><p>The above example was taken with allocation tagging turned on for all
allocators (<code>+Muatags true</code> command line argument) to give you a better idea of
what it can do. By default it will only be turned on for driver/NIF allocations
and binaries since those are the most common culprits, and their allocations
are generally so large that the overhead of a single word is a drop in the
bucket.</p><p>(As with carriers, <code>instrument:allocations/1</code> can be used to tweak the
histograms and which allocators to look in.)</p><h2>Further reading</h2><p>For those who&#x27;d like to know more about how our memory allocators work, Lukas
Larsson&#x27;s <a href="https://erlangcentral.org/videos/euc-2014-lukas-larsson-memory-allocators-in-the-vm-memory-management-battle-stories/">talk at EUC 2014</a> is a good primer. Our internal
documentation on <a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/CarrierMigration.md">carrier migration</a> and <a href="https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/DelayedDealloc.md">inter-thread deallocation</a> may also be of interest.</p><p>The PR implementing this change can be found <a href="https://github.com/erlang/otp/pull/1790">here</a>, and the documentation for the old instrumentation module can be found <a href="http://erlang.org/documentation/doc-9.3/lib/tools-2.11.2/doc/html/instrument.html">here</a>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"Memory-instrumentation-in-OTP-21","title":"Memory instrumentation in OTP 21","author":"John Högberg","excerpt":"\nThe memory instrumentation module was rewritten for Erlang/OTP 21 to make it\neasier to use. In this post I'll describe the rationale behind the new features\nand how to make use of them.","article_date":1525219200000,"tags":["erts","memory","instrumentation"],"frontmatter":{"layout":"post","title":"Memory instrumentation in OTP 21","tags":"erts memory instrumentation","author":"John Högberg"},"content":"\nThe memory instrumentation module was rewritten for Erlang/OTP 21 to make it\neasier to use. In this post I'll describe the rationale behind the new features\nand how to make use of them.\n\nOne of the most important features that a diagnostic tool can have is the\nability to work on the fly. If it requires a restart then the condition you're\ntrying to diagnose might vanish, and you can't use it to troubleshoot issues on\n\"production\" systems.\n\nThe previous implementation had a few major issues to this effect; you had to\nstart the Erlang VM with a certain flag, accept considerable overhead, and\nworst of all suspend the VM while it collected all its data.\n\nThe amount of data it collected was also quite problematic; with one entry for\nevery single allocation it was difficult to tell what was hiding in all that\ninformation, and since there was no way to tell whether a gap between two\nallocations was mapped or not it was needlessly difficult to use when trying\nto troubleshoot memory fragmentation.\n\nThe new implementation tackles these problems by scanning existing data\nstructures to lower its overhead to the point it can be turned on by default,\nand tries to collect information in a manner that doesn't harm the\nresponsiveness of the system.\n\n## Carriers and memory fragmentation\n\nThe VM allocates memory in large segments we call \"carriers\" and then allocates\nblocks within those. This has many benefits; since each carrier is completely\nseparate from the others it's easy to determine when they can be returned to\nthe operating system, and they scale very well since we can guarantee that\nthey're only modified by per-thread instances which makes allocation and\ndeallocation wait-free in most cases.\n\nThere are two types of carriers; single-block which always contain one large\nblock, and multi-block that can contain several smaller blocks. While both of\nthese rely on the operating system to minimize address space fragmentation, the\nlatter kind can also become internally fragmented which will result in new\ncarriers being created if no existing multi-block carrier can satisfy an\nallocation, even if the amount of unused memory exceeds the request.\n\nWhile you can glean some information about average carrier utilization from\n`erlang:system_info({allocator, Alloc})` and use `pmap` (or similar) to get an\nidea of how fragmented the address space is, it has always been a pain to get\ninformation about the individual carriers. Starting in OTP 21 you can ask the\nsystem for a list of all carriers without having to start the VM with any\nparticular flags. The list contains information about each carrier's total\nsize, combined allocation size, allocation count, whether it's in the migration\npool, and a histogram over free block sizes.\n\nWe chose to represent the free blocks with histograms (log2, starting at 512 by\ndefault) as they make it easy to tell at a glance whether a carrier has\nfragmentation issues; if there's a lot of free blocks clustered along the left\nside then it's pretty safe to say there's a problem.\n\nIn the example below, the `ll_alloc` carrier has no free blocks at all, the\n`binary_alloc` and `eheap_alloc` ones look healthy with a few very large\nblocks, and the `fix_alloc` carrier is somewhat fragmented with ~3KB free split\ninto 22 blocks smaller than 512 bytes (although this is not a problem for this\nallocator type).\n\n```erlang\n1\u003e instrument:carriers().\n{ok,{512,\n     [{ll_alloc,1048576,0,1048344,71,false,{0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n      {binary_alloc,1048576,0,324640,13,false,{3,0,0,1,0,0,0,2,0,0,0,0,0,0}},\n      {eheap_alloc,2097152,0,1037200,45,false,{2,1,1,3,4,3,2,2,0,0,0,0,0,0}},\n      {fix_alloc,32768,0,29544,82,false,{22,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n      {...}|...]}}\n```\n\n(`instrument:carriers/1` can be used to tweak the histograms and which\nallocators to look in.)\n\n## Allocations and memory utilization\n\nThose who have used `erlang:memory()` are probably familiar with how annoyingly\ngeneral the `system` category can be. It's possible to get a bit more\ninformation by using `erlang:system_info({allocator, Alloc})` but the most it\nwill do is tell you that it's (say) `driver_alloc` that eats all that memory\nand leave you with no clue which one.\n\nWhile it's often easy to tell which driver or NIF is causing problems while\nyou're developing, it's not as easy when it's used in anger alongside half a\ndozen others. The new \"allocation tagging\" feature will help you figure out\nwhere the memory went at the cost of one word per allocation. The allocations\nare presented as block size histograms (similar to carrier information)\ngrouped by their origin and type:\n\n```erlang\n2\u003e instrument:allocations()\n{ok,{128,0,\n     #{udp_inet =\u003e\n           #{driver_event_state =\u003e {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0}},\n       tty_sl =\u003e\n           #{io_queue =\u003e {0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             drv_internal =\u003e {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0}},\n       system =\u003e\n           #{db_segment =\u003e {0,0,0,0,0,18,0,0,1,0,0,0,0,0,0,0,0,0},\n             heap =\u003e {0,0,0,0,20,4,2,2,2,3,0,1,0,0,1,0,0,0},\n             thr_prgr_data =\u003e {38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             db_term =\u003e {271,3,1,52,80,1,0,0,0,0,0,0,0,0,0,0,0,0},\n             code =\u003e {0,0,0,5,3,6,11,22,19,20,10,2,1,0,0,0,0,0},\n             binary =\u003e {18,0,0,0,7,0,0,1,0,0,0,0,0,0,0,0,0,0},\n             atom_entry =\u003e {8681,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             message =\u003e {0,40,78,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             ... }\n       spawn_forker =\u003e\n           #{driver_select_data_state =\u003e\n                 {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n       ram_file_drv =\u003e #{drv_binary =\u003e {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}},\n       prim_file =\u003e\n           #{process_specific_data =\u003e {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             nif_trap_export_entry =\u003e {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             monitor_extended =\u003e {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             drv_binary =\u003e {0,0,0,0,0,0,1,0,3,5,0,0,0,1,0,0,0,0},\n             binary =\u003e {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n       prim_buffer =\u003e\n           #{nif_internal =\u003e {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             binary =\u003e {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}}}\n```\n\nThe above example was taken with allocation tagging turned on for all\nallocators (`+Muatags true` command line argument) to give you a better idea of\nwhat it can do. By default it will only be turned on for driver/NIF allocations\nand binaries since those are the most common culprits, and their allocations\nare generally so large that the overhead of a single word is a drop in the\nbucket.\n\n(As with carriers, `instrument:allocations/1` can be used to tweak the\nhistograms and which allocators to look in.)\n\n## Further reading\n\nFor those who'd like to know more about how our memory allocators work, Lukas\nLarsson's [talk at EUC 2014](https://erlangcentral.org/videos/euc-2014-lukas-larsson-memory-allocators-in-the-vm-memory-management-battle-stories/) is a good primer. Our internal\ndocumentation on [carrier migration](https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/CarrierMigration.md) and [inter-thread deallocation](https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/DelayedDealloc.md) may also be of interest.\n\nThe PR implementing this change can be found [here](https://github.com/erlang/otp/pull/1790), and the documentation for the old instrumentation module can be found [here](http://erlang.org/documentation/doc-9.3/lib/tools-2.11.2/doc/html/instrument.html).\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"Memory-instrumentation-in-OTP-21"},"buildId":"92Ploa_JRk4A9mAiRpquq","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_buildManifest.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_ssgManifest.js" async=""></script></body></html>