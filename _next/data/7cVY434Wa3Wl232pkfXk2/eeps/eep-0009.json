{"pageProps":{"index":{"id":"0009","content":"<pre><code>Author: Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;\nStatus: Draft\nType: Standards Track\nCreated: 28-Dec-2007\nErlang-Version: R12B-2\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 9: <a href=\"eep-0009.md\" title=\"EEP Source\"> Library for working with binaries</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP suggests the addition of two binary help libraries with built-in\nfunctions for time critical activities such as searching and splitting\nerlang binaries as well as library functions for common operations on\nbinaries. The EEP also suggest the addition of a regular expressions\nlibrary using built in functions.</p>\n\n<h1>Rationale</h1>\n\n<p>For the lists data type there is a help library providing functions for\ncommon operations such as searching and splitting lists.  This EEP suggests\nthat a similar set of library functions should be created for binaries.\nMany of the proposed functions are based on answers to questions regarding\nbinaries on the erlang-questions mailing list, e.g. \"how do I convert a\nnumber to a binary?\". </p>\n\n<h1>Motivation</h1>\n\n<p>Since binaries are typically used for time critical activities on larger\namounts of data it is suggested that some operations on binaries are\nimplemented as built-in functions, BIF:s.</p>\n\n<p>Specifically there seems to be a huge interest in the community for an \nefficient regexp implementation for searching binaries. Also for maximum\nperformance when searching and splitting binaries it is suggested that the\nthe regexp search function is complemented by a high performance function\nfor simple searches, e.g. locating and splitting binaries on newline\ncharacters. Tests show that e.g. the Boyer-Moore algorithm may be \nsignificantly faster than regular expression algorithms for such purposes.</p>\n\n<p>When reviewing the EEP it is clear that there is also a strong demand for\nstring operations on binaries for better performance. </p>\n\n<p>The reference implementation sent separately to the OTP team gives \nan indication of the expected performance improvements compared to e.g.\nthe current regular expression module for searching on lists. Some results\nare available at the end of this EEP.</p>\n\n<h1>Suggested Changes</h1>\n\n<p>This EEP suggests the addition of two new modules; one module named\nbinary and one called binary_string.</p>\n\n<p>The EEP also suggests a new regular expression library based on Perl\nCompatible Regular Expressions (PCRE). The library should be able to \noperate both on binary_strings and on strings.</p>\n\n<p>Finally, the following functions should be added to the erlang module:</p>\n\n<pre><code>binary_to_atom(Binary) -&gt; Atom\natom_to_binary(Atom) -&gt; Binary\nbinary_to_existing_atom(Binary) -&gt; Atom\n</code></pre>\n\n<h2>Not Included</h2>\n\n<pre><code>At the moment the following is not included in the EEP:\n- Support for different encodings, e.g. UTF-8\n- Changes to the string module\n</code></pre>\n\n<h2>The \"binary_string\" Module</h2>\n\n<p>The binary_string module should be based on the current string module but \nshould operate on strings represented by binaries as opposed to the \ncurrent strings module which operates on strings represented by lists.</p>\n\n<p>Apart from operating on binaries the interface of binary_string should be \nthe same as for string with the following exceptions:</p>\n\n<ol>\n<li><p>str/2 and rstr/2 should be modified to optionally take a list of \nbinaries or a MatchSpec such as the one returned by \nbinary:match_compile/2 as second argument. If the Keys argument \ncorresponds to several keys the function should return a tuple\nindicating the Key that matched and the matching Index, i.e. </p>\n\n<pre><code>str(Binary, Keys) -&gt; Return\nrstr(Binary, Keys) -&gt; Return\n</code></pre>\n\n<p>Binary = binary()\nKeys = Key | [ Key ] | MatchSpec\nKey = string() | binary()\nMatchSpec = tuple() as returned by binary:match_compile/1\nReturn = Index | {NeedleNumber, Index}\nIndex = integer()</p>\n\n<p>str/rstr should be implemented as built-in functions using \nefficient algorithms such as Boyer-Moore, Aho-Corasick or\nsimilar. Typically the function could be built on binary:match/2.</p></li>\n<li><p>A new function split should be added. It should behave as tokens/2\nbut take a list of separator binaries/strings instead of a list of\nseparator characters.</p>\n\n<pre><code>split(Binary, SplitKeys) -&gt; List\n\n\nBinary = binary()\nSplitKeys = Key | [ Key ] | MatchSpec\nKey = string() | binary()\nMatchSpec = tuple() as returned by binary:match_compile/1\nList = [ binary() ]\n</code></pre>\n\n<p>Splits Binary into a list of binaries based on matching the pattern\nspecified in the SplitKeys binary.</p>\n\n<p>Examples:</p>\n\n<blockquote>\n  <p>binary_string:split(&lt;&lt;\"cat and dog\">>, &lt;&lt;\"and\">>).\n    [&lt;&lt;\"cat \">>, &lt;&lt;\" dog\">>] </p>\n</blockquote>\n\n<pre><code>&gt; binary_string:split(&lt;&lt;\"cat and dog\"&gt;&gt;, \"and\").\n[&lt;&lt;\"cat \"&gt;&gt;, &lt;&lt;\" dog\"&gt;&gt;] \n\n\n&gt; binary_string:split(&lt;&lt;\"cat and dog\"&gt;&gt;,[\"a\",\"n\",&lt;&lt;\"d\"&gt;&gt;]).\n[&lt;&lt;\"c\"&gt;&gt;,&lt;&lt;\"t \"&gt;&gt;,&lt;&lt;\" \"&gt;&gt;,&lt;&lt;\"og\"&gt;&gt;]\n</code></pre>\n\n<p>The resulting list should be the same as for regexp:split/2 \n(with the obvious exception for special characters such as \"*\", \n\".\", \"^\", etc).</p>\n\n<p>Please note that the third example should give the same result as\nbinary_string:tokens(&lt;&lt;\"cat and dog\">>, \"and\"). </p></li>\n<li><p>The new functions substitute and globally_substitute should be \nadded. </p>\n\n<pre><code> substitute(OldBinary, Key, Replacement)-&gt; NewBinary\n\n\n OldBinary, NewBinary, Replacement = binary()\n Keys = binary() | [ binary() ] | MatchSpec\n MatchSpec = tuple() as returned by binary:match_compile/1\n</code></pre>\n\n<p>Creates a binary NewBinary from OldBinary by substituting the \n first occurence of any of the binaries in Keys in OldBinary\n with the Replacement binary. </p>\n\n<p>The Replacement binary need not have the same size as the matched \n Key.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <p>binary_string:substitute(&lt;&lt;\"cat anf dog\">>,&lt;&lt;\"anf\">>,&lt;&lt;\"and\">>).\n    [&lt;&lt;\"cat and dog\">>] </p>\n</blockquote>\n\n<pre><code>globally_substitute(OldBinary, Key, Replacement)-&gt; NewBinary\n\n\nOldBinary, NewBinary, Replacement = binary()\nKeys = binary() | [ binary() ] | MatchSpec\nMatchSpec = tuple() as returned by binary:match_compile/1\n</code></pre>\n\n<p>Same as substitute except that all non-overlapping occurrences of \na subbinary in OldBinary are replaced by the Replacement binary.</p>\n\n<p>It is suggested that the same functions are also added to the string\nmodule, but this is out of the scope of this EEP.</p></li>\n</ol>\n\n<h2>The \"binary\" Module</h2>\n\n<p>The interface of the binary module should have the following exported \nfunctions (please note that some functions are intentionally the same as\nin binary_string since it is believed they can be useful both for string\nand binary data manipulation):</p>\n\n<pre><code>match(Binary, Keys) -&gt; Return\nmatch(Binary, Keys, {StartIndex, EndIndex}) -&gt; Return\n\nBinary = binary()\nKeys = binary() | [ binary() ] | MatchSpec\nMatchSpec = tuple() as returned by binary:match_compile/1\nStartIndex = EndIndex = integer()\n\nReturn = Index | {KeyNumber, Index}\nIndex = KeyNumber = integer()\n</code></pre>\n\n<p>Returns position of first occurence in Binary of the first \nmatching binary in Keys or 0 if no match. If a list of keys\nis given, the function will return a tuple with the KeyNumber of\nthe matched Key and the position in Binary where it was found.</p>\n\n<p>There has been a discussion on whether the function should return\nthe matched Key instead of the KeyNumber. Returning the KeyNumber\nshould be slightly more efficient, and since the matched key\ncan easily be retrieved by lists:nth(KeyNumber, Keys) if needed it\nis suggested that the function returns the KeyNumber.</p>\n\n<p>Binary is searched from StartIndex to EndIndex. If StartIndex \nand EndIndex are not specified the default is to search Binary \nfrom the beginning to the end.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <p>binary:match(&lt;&lt;1,2,3,0,0,0,4>>, &lt;&lt;0,0,0>>).\n    4 </p>\n</blockquote>\n\n<pre><code>&gt; binary:match(&lt;&lt;1,2,255,0,0,0,4,255&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;, &lt;&lt;255&gt;&gt;]).\n{2, 3}\n</code></pre>\n\n<p>Suggestions on implementation: Should be implemented as one or\nmore BIF:s using e.g. Boyer-Moore, Aho-Corasick or similar \nefficient algorithms.</p>\n\n<pre><code>matches(Binary, Keys) -&gt; Return\nmatches(Binary, Keys, {StartIndex, EndIndex}) -&gt; Return\n\nBinary = binary()\nKeys = binary() | [ binary() ] | MatchSpec\nMatchSpec = tuple() as returned by binary:match_compile/1\nStartIndex = EndIndex = integer() \n\nReturn = [ Index ] | [ {KeyNumber, Index} ]\nIndex = KeyNumber = integer()\n</code></pre>\n\n<p>Finds all matches of the Keys in Haystack. Returns a list of the\nindexes for all non-overlapping ocurrences of the key or keys.</p>\n\n<pre><code>split(Binary, SplitKeys) -&gt; List\nsplit(Binary, SplitKeys, {StartIndex, EndIndex}) -&gt; List\n\nBinary = binary()\nSplitKeys = binary() | [ binary() ] | MatchSpec\nMatchSpec = tuple() as returned by binary:match_compile/1\nStartIndex = EndIndex = integer()\n\nList = [ binary() ]\n</code></pre>\n\n<p>Splits Binary into a list of binaries based on matching the pattern\nspecified in SplitKeys.</p>\n\n<p>Example:</p>\n\n<blockquote>\n  <p>binary:split(&lt;&lt;1,255,4,0,0,0,2,3>>, &lt;&lt;0,0,0>>).\n    [&lt;&lt;1,255,4>>, &lt;&lt;2,3>>] </p>\n</blockquote>\n\n<pre><code>&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;]).\n[&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;]\n</code></pre>\n\n<p>The resulting list should basically be the same as for \nregexp:split/2 (with the obvious exception for special characters\nsuch as \"*\", \".\", \"^\", etc).</p>\n\n<p>The binaries in List are all subbinaries of Binary meaning that\nthe data in Binary is not actually copied to new binaries.</p>\n\n<pre><code>substitute(OldBinary, Key, Replacement)-&gt; NewBinary\n\nOldBinary, NewBinary, Replacement = binary()\nKeys = binary() | [ binary() ] | MatchSpec\nMatchSpec = tuple() as returned by binary:match_compile/1\n</code></pre>\n\n<p>Creates a binary NewBinary from OldBinary by substituting the \nfirst occurence of any of the binaries in Keys in OldBinary\nwith the Replacement binary. </p>\n\n<p>The Replacement binary need not have the same size as the matched \nKey.</p>\n\n<pre><code>globally_substitute(OldBinary, Key, Replacement)-&gt; NewBinary\n\nOldBinary, NewBinary, Replacement = binary()\nKeys = binary() | [ binary() ] | MatchSpec\nMatchSpec = tuple() as returned by binary:match_compile/1\n</code></pre>\n\n<p>Same as substitute except that all non-overlapping occurrences of \na subbinary in OldBinary are replaced by the Replacement binary.</p>\n\n<pre><code>match_compile(Keys) -&gt; MatchSpec\n\nKeys = binary() | [ binary() ] \nMatchSpec = tuple()\n</code></pre>\n\n<p>Builds an internal structure representing one or more search\nkeys. The MatchSpec structure can be used to speed up searching if\nmultiple searches with binary:match/2 or binary_string:str/2\nare to be performed with the same search keywords.</p>\n\n<pre><code>binary:from_unsigned(Integer)-&gt; Binary\nbinary:to_unsigned(Binary)-&gt; Integer\n</code></pre>\n\n<p>Converts a positive integer the smallest possible representation\nin the binary data type format and vice versa.</p>\n\n<pre><code>Example:\n&gt; binary:from_unsigned(11111111). \n&lt;&lt;169,138,199&gt;&gt;\n\n&gt; binary:to_unsigned(&lt;&lt;169,138,199&gt;&gt;).\n11111111\n\n\nfirst(Binary1)-&gt; Binary2\nfirst(SizeBytes, Binary1)-&gt; Binary2\n</code></pre>\n\n<p>Returns a subbinary with the first byte or the SizeBytes first \nbytes in Binary1. </p>\n\n<pre><code>Example:\n&gt; binary:first(2, &lt;&lt;\"abc\"&gt;&gt;).                                  \n&lt;&lt;\"ab\"&gt;&gt;\n\n\nlast(Binary1)-&gt; Binary2.\nlast(SizeBytes, Binary1)-&gt; Binary2\n</code></pre>\n\n<p>Returns a subbinary with the last byte or the SizeBytes last bytes\nin Binary1. </p>\n\n<p>Example:</p>\n\n<blockquote>\n  <p>binary:last(2, &lt;&lt;\"abc\">>). <br />\n    &lt;&lt;\"bc\">></p>\n</blockquote>\n\n<pre><code>nth(N, Binary) -&gt; Value\n\nN = integer(), 1 =&lt; N =&lt; size(Binary)\nValue = integer()\n</code></pre>\n\n<p>Extracts a byte at position N from Binary. Same as</p>\n\n<pre><code>T = N-1,\n&lt;&lt;_:T/binary, Value:Size/binary, _/binary&gt;&gt; = Binary, \nValue.\n</code></pre>\n\n<p>although this function is somewhat shorter and easier to write.</p>\n\n<pre><code>extract(N, Size, Binary) -&gt; SubBinary\n\nN = integer(), 1 =&lt; N =&lt; size(Binary)\nSize = integer()\nSubBinary = subbinary()\n</code></pre>\n\n<p>Returns a subbinary of size Size starting at position N from \nBinary. No data is copied in this operation.</p>\n\n<p>It has been discussed if there should be a function for copying\na part of a binary rather than getting a subbinary. This would\nmake it possible to get a small part of a binary and let the\nrest be garbage collected. Since it is possible to achieve the same\nresult by converting the extracted part to a list and then back\nagain to a binary and it is a very specialized operation which\nmay confuse new users it has been excluded at this stage.</p>\n\n<p>When talking to designers many seem to prefer the name extract\nover the name subbinary for this function.</p>\n\n<pre><code>duplicate(N, Byte)-&gt; Binary\n</code></pre>\n\n<p>Similar to <code>lists:duplicate/2</code>. Creates a new binary consisting of\nByte repeated N times. </p>\n\n<p>Example:</p>\n\n<blockquote>\n  <p>binary:duplicate(5, $a).\n    &lt;&lt;\"aaaaa\">></p>\n</blockquote>\n\n<h2>The Regular Expressions Library</h2>\n\n<p>It is suggested that a new regular expression library based on\nbuilt in functions is added. It should have the following interface\nfunctions (name of the module to be decided, for backwards\ncompatibility reasons it should probably exists in parallell with\nthe old regexp module):</p>\n\n<p>During a first round of feedback it has been suggested that the \nfinal implementation should be a built in function based on the \n<a href=\"http://en.wikipedia.org/wiki/PCRE\">Perl Compatible Regular Expressions (PCRE) library</a>. It is \noptimised, well supported, and is more or less considered a <a href=\"http://www.pcre.org/pcre.txt\" title=\"Man page for pcrematching\">standard</a>\ntoday. It is used in a number of prominent products and projects, e.g.\nApples Safari, Apache, KDE, PHP, Postfix and Nmap.</p>\n\n<p>It is suggested that the module has the following exported functions:</p>\n\n<pre><code>compile(Regex) -&gt; MatchSpec\n\nRegex = string()\nMatchSpec = tuple()\n</code></pre>\n\n<p>Builds an internal structure representing one or more search\nkeys. The MatchSpec structure can be used to speed up searching if\nmultiple searches are to be performed with the same search \nkeywords.</p>\n\n<pre><code>match(BinOrString, RegExp)-&gt; Return\nmatch(BinOrString, RegExp, {StartIndex, EndIndex})-&gt; Return\n\nBinOrString = binary() | string()\nRegExp = string() | MatchSpec\nMatchSpec = tuple() as returned by match_compile/1\nStartIndex = EndIndex = integer()\nReturn = 0 | {Start, Length, [CapturedPatterns]}\n</code></pre>\n\n<p>Finds the first, longest match of the regular expression RegExp \nin BinOrString. This function searches for the longest possible \nmatch and returns the first one found if there are several \nexpressions of the same length.</p>\n\n<p>The function supports pattern capturing. Patterns captured (if\nany) are returned in a list in the Return tuple.</p>\n\n<pre><code>Examples:\n&gt; binary:regex_match(&lt;&lt;\"abcde\"&gt;&gt;, \"b?cd\").\n{2,3,[]}\n\n&gt; binary:regex_match(&lt;&lt;\"127.0.0.1\"&gt;&gt;, \"(\\d*)\\.(\\d*)\\.\").\n{1,6,[&lt;&lt;\"127\"&gt;&gt;, &lt;&lt;\"0\"&gt;&gt;]}\n</code></pre>\n\n<p>Open questions: \n - It might be a good idea to add an Options parameter (optional \n   of course), e.g. to specify that the partial matching feature \n   should be activated\n - handling of Encodings.</p>\n\n<pre><code>matches(BinOrString, RegExp)-&gt; Return\nmatches(BinOrString, RegExp, {StartIndex, EndIndex})-&gt; Return\n\nBinOrString = binary() | string()\nRegExp = string() | MatchSpec\nMatchSpec = tuple() as returned by match_compile/1\nStartIndex = EndIndex = integer()\n\nReturn = 0 | [ {Start, Length, [CapturedPatterns]} ]\n</code></pre>\n\n<p>Finds all matches of the regular expression RegExp in BinOrString. </p>\n\n<p>Example:</p>\n\n<blockquote>\n  <p>binary:regex_matches(&lt;&lt;\"aaa\">>, \"a\").\n    [{1,1,[]},{2,1,[]},{3,1,[]}]</p>\n</blockquote>\n\n<pre><code>sub(BinOrString, RegExp, Replacement)-&gt; NewStringOrBinary\n\nBinOrString = NewStringOrBinary = binary() | string()\nRegExp = string() | MatchSpec\nMatchSpec = tuple() as returned by match_compile/1\nReplacement = string()\n</code></pre>\n\n<p>Substitutes the first occurence of a substring or subbinary \nmatching RegExp in BinOrString with Replacement. A &amp; in the \nReplacement string is replaced by the matched substring or\nsubbinary of BinOrString. \\&amp; puts a literal &amp; into the \nreplacement string or binary. The type of NewStringOrBinary\nwill be the same as the type of BinOrString.</p>\n\n<pre><code>gsub(BinOrString, RegExp, Replacement)-&gt; Binary2\n</code></pre>\n\n<p>Same as sub except that all non-overlapping occurrences of \na substring or subbinary matching RegExp in BinOrString are \nreplaced by the string Replacement.</p>\n\n<pre><code>split(BinOrString, RegExp) -&gt; List\nsplit(BinOrString, RegExp, {StartIndex, EndIndex}) -&gt; List\n\nBinOrString = binary() | string()\nRegExp = string() | MatchSpec\nMatchSpec = tuple() as returned by match_compile/1\nStartIndex = EndIndex = integer()\n\nList = [ binary() ]\n</code></pre>\n\n<p>Splits Binary into a list of binaries based on the pattern\nspecified in RegExp.</p>\n\n<p>The resulting list should basically be the same as for \nregexp:split/2. </p>\n\n<h1>Performance</h1>\n\n<p>Performance was measured for the functions considered most \nimportant using the reference implementation. Some examples:</p>\n\n<ol>\n<li><p>Searching for a non-existing 1 and 3 byte binary in a ~1 Mb binary. \nNotice how binary:match/2 gets faster the longer the needle is thanks to \nthe O(n/m) <a href=\"http://swtch.com/~rsc/regexp/regexp1.html\">algorithm</a>. All times in microseconds.</p>\n\n<pre><code>    Search for:        1 byte   3 bytes\n---------------------------------------   \nbinary:match/2:        17598      6045 \nbinary:regex_first/2:  47299     46701\nstring:str/2:          68969     69637\nregexp:first_match/2: 460858    887485\n</code></pre></li>\n<li><p>Splitting a ~1 Mb binary on newline chars. This particular binary \ncontained a newline every 60 chars on average.</p>\n\n<pre><code>binary:split/2:  89142 microseconds\nregexp:split/2: 564911 microseconds\n</code></pre></li>\n<li><p>Regex-DNA benchmark from computer language shootout</p>\n\n<pre><code>prototype regexp bif:    1.9 seconds\nregexp module in R12B:  99.1 seconds\n</code></pre></li>\n</ol>\n\n<p>In the examples at the computer language shootout PCRE has a slightly \nlower performance compared to other algorithms such as the one in the \nreference implementation or in particular the one featured in TCL. This\nmay not necessarily mean that this is true for all types of patterns.</p>\n\n<h1>Reference implementation</h1>\n\n<p>A reference implementation has been provided to the OTP team.</p>\n\n<h1>Copyright</h1>\n\n<p>This document is licensed under the Creative Commons license.</p>\n"}},"__N_SSG":true}