{"pageProps":{"item":{"id":"the-new-scalable-ets-ordered_set","title":"The New Scalable ETS ordered_set","author":"Kjell Winblad","excerpt":"\nThe scalability of ETS tables of type `ordered_set` with the\n`write_concurrency` option is substantially better in Erlang/OTP 22\nthan earlier releases. In some extreme cases, you can expect\nmore than 100 times better throughput in Erlang/OTP 22 compared to\nErlang/OTP 21. The cause of this improvement is a new data structure\ncalled [the contention adapting search tree][jpdc_ca_tree] (CA tree\nfor short). This blog post will give you insights into how the CA tree\nworks and show you benchmark results comparing the performance of ETS\n`ordered_set` tables in OTP 21 and OTP 22.","article_date":1597795200000,"tags":["ETS ordered_set scalability CA tree"],"frontmatter":{"layout":"post","title":"The New Scalable ETS ordered_set","tags":"ETS ordered_set scalability CA tree","author":"Kjell Winblad"},"content":"\nThe scalability of ETS tables of type `ordered_set` with the\n`write_concurrency` option is substantially better in Erlang/OTP 22\nthan earlier releases. In some extreme cases, you can expect\nmore than 100 times better throughput in Erlang/OTP 22 compared to\nErlang/OTP 21. The cause of this improvement is a new data structure\ncalled [the contention adapting search tree][jpdc_ca_tree] (CA tree\nfor short). This blog post will give you insights into how the CA tree\nworks and show you benchmark results comparing the performance of ETS\n`ordered_set` tables in OTP 21 and OTP 22.\n\n## Try it Out!\n\n[This escript](/code/insert_disjoint_ranges.erl) makes it convenient for you\nto try the new `ordered_set` implementation on your own machine with\nErlang/OTP 22+ installed.\n\nThe escript measures the time it takes for `P` Erlang processes to\ninsert `N` integers into an `ordered_set` ETS table, where `P` and `N`\nare parameters to the escript. The CA tree is only utilized when the\nETS table options `ordered_set` and `{write_concurrency, true}` are\nactive. One can, therefore, easily compare the new data structure's\nperformance with the old one (an [AVL tree][AVLTree] protected by a\nsingle readers-writer lock). The `write_concurrency` option had no\neffect on `ordered_set` tables before the release of Erlang/OTP 22.\n\nWe get the following results when running the escript on a developer laptop with\ntwo cores (Intel(R) Core(TM) i7-7500U CPU @ 2.70GHz):\n\n{% highlight console %}\n\n$ escript insert_disjoint_ranges.erl old 1 10000000\nTime: 3.352332 seconds\n$ escript insert_disjoint_ranges.erl old 2 10000000\nTime: 3.961732 seconds\n$ escript insert_disjoint_ranges.erl old 4 10000000\nTime: 6.382199 seconds\n$ escript insert_disjoint_ranges.erl new 1 10000000\nTime: 3.832119 seconds\n$ escript insert_disjoint_ranges.erl new 2 10000000\nTime: 2.109476 seconds\n$ escript insert_disjoint_ranges.erl new 4 10000000\nTime: 1.66509 seconds\n\n{% endhighlight %}\n\nWe see that in this particular benchmark, the CA tree has superior\nscalability to the old data structure. The benchmark ran about twice\nas fast with the new data structure and four processes as with the old\ndata structure and one process (the machine only has two\ncores). We will look at the performance and scalability of the new CA\ntree-based implementation in greater detail later after describing how\nthe CA tree works.\n\n## The Contention Adapting Search Tree in a Nutshell\n\nThe key feature that distinguishes the CA tree from other concurrent\ndata structures is that the CA tree dynamically changes its\nsynchronization granularity based on how much contention is detected\ninside the data structure. This way, the CA tree can avoid the\nperformance and memory overheads that come from using many unnecessary\nlocks without sacrificing performance when many operations happen in\nparallel. For example, let us imagine a scenario where the CA tree is\ninitially populated from many threads in parallel, and then it is only\nused from a single thread. In this scenario, the CA tree will adapt to\nuse fine-grained synchronization in the population phase (when\nfine-grained synchronization reduces contention). The CA tree will then change\nto use coarse-grained synchronization in the single-threaded phase\n(when coarse-grained synchronization reduces the locking and memory\noverheads).\n\nThe structure of a CA tree is illustrated in the following\npicture:\n\n![alt text](/images/ca_tree/ca_tree_9.png \"Contention Adapting Search Tree Structure\")\n\nThe actual items stored in the CA tree are located in\nsequential data structures in the bottom layer. These\nsequential data structures are protected by the locks in the base\nnodes in the middle layer. The base node locks have counters\nassociated with them. The counter of a base node lock is increased when\ncontention is detected in the base node lock and decreased when no\nsuch contention is detected. The value of this base node lock counter\ndecides if a split or a join should happen after an operation has been\nperformed in a base node. The routing nodes at the top of the picture\nabove form a binary search tree that directs the search for a\nparticular item. A routing node also contains a lock and a flag. These\nare used when joining base nodes. The details of how splitting and\njoining work will not be described in this article, but\nthe interested reader can find a detailed description in this [CA tree\npaper][jpdc_ca_tree] ([preprint PDF][jpdc_ca_tree_preprint]). We will now\nillustrate how the CA tree changes its synchronization granularity by\ngoing through an example:\n\n1. Initially, a CA tree only consists of a single base node with a\n   sequential data structure as is depicted in the picture below:\n   \n   \n   ![alt text](/images/ca_tree/ca_tree_1.png \"Initial Contention Adapting Search Tree\")\n2. If parallel threads access the CA tree, the value of a base node's\n   counter may eventually reach the threshold that indicates that the\n   base node should be split. A base node split divides the items in a\n   base node between two new base nodes and replaces the original base\n   node with a routing node where the two new base nodes are\n   rooted. The following picture shows the CA tree after the base node\n   pointed to by the tree's root has been split:\n   \n   \n   ![alt text](/images/ca_tree/ca_tree_2.png \"First Split Contention Adapting Search Tree\")\n3. The process of base node splitting will continue as long as there\n   is enough contention in base node locks or until the max depth of the\n   routing layer is reached. The following picture shows how the CA\n   tree looks like after another split:\n   \n   \n   ![alt text](/images/ca_tree/ca_tree_3.png \"Second Split Contention Adapting Search Tree\")\n4. The synchronization granularity may differ in different parts of a\n   CA tree if, for example, a particular part of a CA tree is accessed\n   more frequently in parallel than the rest. The following picture\n   shows the CA tree after yet another split:\n   \n   \n   ![alt text](/images/ca_tree/ca_tree_4.png \"Third Split Contention Adapting Search Tree\")\n5. The following picture shows the CA tree after the fourth split:\n   \n   \n   ![alt text](/images/ca_tree/ca_tree_5.png \"Fourth Split Contention Adapting Search Tree\")\n6. The following picture shows the CA tree after the fifth split:\n   \n   \n   ![alt text](/images/ca_tree/ca_tree_6.png \"Fifth Split Contention Adapting Search Tree\")\n7. Two base nodes holding adjacent ranges of items can be joined. Such\n   a join will be triggered after an operation sees that a base\n   node counter's value is below a certain threshold. Remember that a\n   base node's counter is decreased if a thread does not experience\n   contention when acquiring the base node's lock.\n   <!--The conters The likelihood that\n   a join will be triggered in a certain base node gets higher when\n   the probablity of contention that does not detect contention in the\n   base node lock is high. The likelihood that two base nodes are\n   joined is also increased if operations that require both base nodes\n   happens often enough (to reduce the overhead of acquiring locks).-->\n   \n   ![alt text](/images/ca_tree/ca_tree_7.png \"Join of two base nodes in a  Contention Adapting Search Tree\")\n8. As you might have noticed from the illustrations above, splitting\n   and joining results in that old base nodes and\n   routing nodes gets spliced-out from the tree. The memory that these\n   nodes occupy needs to be reclaimed, but this can not happen directly\n   after they have got spliced-out as some threads might still be\n   reading them. The Erlang run-time system has a mechanism called\n   [thread progress](https://github.com/erlang/otp/blob/d6285b0a347b9489ce939511ee9a979acd868f71/erts/emulator/internal_doc/ThreadProgress.md),\n   which the ETS CA tree implementation uses to reclaim these nodes\n   safely.\n   \n   ![alt text](/images/ca_tree/ca_tree_8.png \"Spliced-out base nodes and routing nodes have been reclaimed.\")\n\n[Click here](/images/ca_tree/ca_tree_ani.gif) to see an animation of the example.\n\n## Benchmark\n\nThe performance of the new CA tree-based ETS `ordered_set`\nimplementation has been evaluated in a benchmark that measures the\nthroughput (operations per second) in many scenarios. The\nbenchmark lets a configurable number of Erlang processes perform a\nconfigurable distribution of operations on a single ETS table. The\ncurious reader can find the source code of the benchmark in the [test\nsuite for\nETS](https://github.com/erlang/otp/blob/ba2c374d3d6fcba479bb542eb6ecd5d8216ce84b/lib/stdlib/test/ets_SUITE.erl#L7623).\n\nThe following figures show results from this benchmark on a machine\nwith two Intel(R) Xeon(R) CPU E5-2673 v4 @ 2.30GHz (32 cores in total\nwith hyper-threading). The average set size in all scenarios was\nabout 500K. More details about the benchmark machine and configuration\ncan be found on [this\npage](http://blog.erlang.org/bench/ets_ord_set_21_vs_22/21_vs_22.html).\n\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_1.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_2.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_3.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_7.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_8.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_5.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_6.png \"benchmark results\")\n\n![alt text](/bench/ets_ord_set_21_vs_22/plot_4.png \"benchmark results\")\n\nWe see that the throughput of the CA tree-based `ordered_set` (OTP-22)\nimproves when we add cores all the way up to 64 cores, while the old\nimplementation's (OTP-21) throughput often gets worse when more\nprocesses are added. The old implementation's write operations are\nserialized as the data structure is protected by a single\nreaders-writer lock. The slowdown of the old version when adding more\ncores is mainly caused by increased communication overhead when more\ncores try to acquire the same lock and by the fact that the competing\ncores frequently invalidate each other's cache lines.\n\nThe graph for the 100% lookups scenario (the last graph in the list of\ngraphs above) looks a bit strange at first sight. Why does the CA tree\nscale so much better than the old implementation in this scenario? The\nanswer is almost impossible to guess without knowing the\nimplementation details of the `ordered_set` table type. First of all,\nthe CA tree uses the same readers-writer lock implementation\nfor its base node locks as the old implementation uses to protect the whole\ntable. The difference is thus not due to any lock differences. The\ndefault `ordered_set` implementation (the one that is active when\n`write_concurrency` is off) has an optimization that mainly improves\nusage scenarios where a single process iterates over items of the\ntable, for example, with a sequence of calls to the `ets:next/2`\nfunction. This optimization keeps a static stack per table. Some\noperations use this stack to reduce the number of tree nodes that need\nto be traversed. For example, the `ets:next/2` operation does not need\nto recreate the stack, if the top of the stack contains the same key\nas the one passed to the operation (see\n[here][ets_next_stack_opt]). As there is only one static stack per\ntable and potentially many readers (due to the readers-writer lock),\nthe static stack has to be reserved by the thread that is currently\nusing it. Unfortunately, the static stack handling is a scalability\nbottleneck in scenarios like the one with 100% lookups above. The CA\ntree implementation does not have this type of optimization, so it\ndoes not suffer from this scalability bottleneck. However, this also\nmeans that the old implementation may perform better than the new one\nwhen the table is mainly sequentially accessed. One example of when\nthe old implementation (that still can be used by setting the\n`write_concurrency` option to false) performs better is the single\nprocess case of the 10% `insert`, 10% `delete`, 40% `lookup` and 40%\n`nextseq1000` (a sequence of 1000 `ets:next/2` calls) scenario (the\nsecond last graph in the list of graphs above).\n\nTherefore, we can conclude that that turning on `write_concurrency`\nfor an `ordered_set` table is probably a good idea if the table is\naccessed from multiple processes in parallel. Still, turning off\n`write_concurrency` might be better if you mainly access the table\nsequentially.\n\n## A Note on Decentralized Counters\n\nThe CA tree implementation was not the only optimization introduced in\nErlang/OTP 22, affecting the scalability of `ordered_set` with\n`write_concurrency`. An optimization that decentralized counters in\n`ordered_set` tables with `write_concurrency` turned on was also\nintroduced in Erlang/OTP 22 (see [here][decent_ctrs_pull1]).  An\noption to enable the same optimization in all table types was\nintroduced in Erlang/OTP 23 (see [here][decent_ctrs_pull2]). You can\nfind benchmark results comparing the scalability of the tables with\nand without decentralized counters [here][decent_ctrs_bench].\n\n## Further Reading\n\n\nThe following paper describes the CA tree and some optimizations (of which some have not been applied to the ETS CA tree yet) in much more detail than this blog post. The paper also includes an experimental comparison with related data structures.\n\n* *[A Contention Adapting Approach to Concurrent Ordered Sets][jpdc_ca_tree] ([preprint][jpdc_ca_tree_preprint]). Journal of Parallel and Distributed Computing, 2018. Konstantinos Sagonas and Kjell Winblad*\n\nThere is also a lock-free variant of the CA tree that is described in the following paper. The lock-free CA tree uses immutable data structures in its base nodes to substantially reduce the amount of time range queries, and similar operations can conflict with other operations.\n\n* *[Lock-free Contention Adapting Search Trees][lfca_tree] ([preprint][lfca_tree_preprint]). In the proceedings of the 30th Symposium on Parallelism in Algorithms and Architectures (SPAA 2018). Kjell Winblad, Konstantinos Sagonas, and Bengt Jonsson.*\n\nThe following paper, which discusses and evaluates a prototypical CA tree implementation for ETS, was the first CA tree-related paper.\n\n* *[More Scalable Ordered Set for ETS Using Adaptation][erlang_workshop] ([preprint][erlang_workshop_preprint]). In Thirteenth ACM SIGPLAN workshop on Erlang (2014). Konstantinos Sagonas and Kjell Winblad*\n\nYou can look directly at the [ETS CA tree source\ncode][ets_ca_tree_code] if you are interested in specific\nimplementation details. Finally, it might also be interesting to look\nat the [author's Ph.D. thesis][kjell_phd_thesis] if you want to get\nmore links to related work or want to know more about the motivation\nfor concurrent data structures that adapt to contention.\n\n## Conclusion\n\nThe Erlang/OTP 22 release introduced a new ETS `ordered_set`\nimplementation that is active when the `write_concurrency` option is\nturned on. This data structure (a contention adapting search tree) has\nsuperior scalability to the old data structure in many different\nscenarios and a design that gives it excellent performance in a variety\nof scenarios that benefit from different synchronization\ngranularities.\n\n\n[jpdc_ca_tree]: https://doi.org/10.1016/j.jpdc.2017.11.007\n[jpdc_ca_tree_preprint]: http://winsh.me/papers/catree_jpdc_paper.pdf\n[lfca_tree]: https://doi.org/10.1145/3210377.3210413\n[lfca_tree_preprint]: http://winsh.me/papers/spaa2018lfcatree.pdf\n[erlang_workshop]: http://dl.acm.org/citation.cfm?id=2633455\n[erlang_workshop_preprint]: http://winsh.me/papers/erlang_workshop_2014.pdf\n[AVLTree]: https://en.wikipedia.org/wiki/AVL_tree\n[kjell_phd_thesis]: http://uu.diva-portal.org/smash/record.jsf?pid=diva2%3A1220366&dswid=6575\n[ets_lookup_stack_opt]: https://github.com/erlang/otp/blob/4ca912b859f779d6d9b235ea0cf6fb7662edcc59/erts/emulator/beam/erl_db_tree.c#L3306\n[decent_ctrs_pull1]: https://github.com/erlang/otp/pull/2190\n[decent_ctrs_pull2]: https://github.com/erlang/otp/pull/2229\n[decent_ctrs_bench]: http://winsh.me/ets_catree_benchmark/azure_D64s_decent_ctrs/hash_decentralized_ctrs.html\n[ets_ca_tree_code]: https://github.com/erlang/otp/blob/4ca912b859f779d6d9b235ea0cf6fb7662edcc59/erts/emulator/beam/erl_db_catree.c\n[ets_next_stack_opt]: https://github.com/erlang/otp/blob/master/erts/emulator/beam/erl_db_tree.c#L3084\n"}},"__N_SSG":true}