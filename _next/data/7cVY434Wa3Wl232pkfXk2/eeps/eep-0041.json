{"pageProps":{"index":{"id":"0041","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R16A\nCreated: 04-Feb-2013\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 41: <a href=\"eep-0041.md\" title=\"EEP Source\"> Pseudo-assignment for Erlang</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Add the infix token ':=' to Erlang with the purely\nfunctional update semantics of '&lt;-' in R.</p>\n\n<h1>Example</h1>\n\n<p>Given the declarations</p>\n\n<pre><code>-record(rect, {top,left,bottom,right}).\n-record(whatever, {region, ...}).\n\ncentre(#rect{top=T,left=L,bottom=B,right=R}) -&gt;\n    {(L+R)/2, (T+B)/2}.\n\n'centre:='(#rect{top=T,left=L,bottom=B,right=R}, {X,Y}) -&gt;\n    DX = X - (L+R)/2,\n    DY = Y - (T+B)/2,\n    #rect{top=T+DY,left=L+DX,bottom=B+DY,right=R+DX}.\n</code></pre>\n\n<p>the pseudo-assignment</p>\n\n<pre><code>centre(W#whatever.region) := P\n</code></pre>\n\n<p>expands to</p>\n\n<pre><code>W' = W#whatever{\n       region = 'centre:='(W#whatever.region, P)}\n</code></pre>\n\n<p>with W' automatically replacing downstream mentions of W.</p>\n\n<h1>Specification</h1>\n\n<p>A new token ':=' is introduced.  It may only be used in\nthe form</p>\n\n<pre><code>Lhs := Rhs\n</code></pre>\n\n<p>where Rhs is any Erlang expression, called the source, and\nLhs, called the target, is</p>\n\n<ul>\n<li>a variable (not a wildcard),</li>\n<li>Lhs' #record.field, or</li>\n<li>~f(Lhs'), or</li>\n<li>f(Lhs', E2, ..., En), or</li>\n<li>m:f(Lhs', E2, ..., En)</li>\n</ul>\n\n<p>where E2 ... En are any Erlang expressions, Lhs'\nis another instance of the same form, f is an atom,\nand the module prefix m may only be an atom or a variable.</p>\n\n<p>The \"ultimate target\"</p>\n\n<ul>\n<li>of a variable is that variable,</li>\n<li>of L#r.f is the ultimate target of L,</li>\n<li>of ~f(L) is the ultimate target of L,</li>\n<li>of f(L,...) is the ultimate target of L,</li>\n<li>of m:f(L,...) is the ultimate target of L.</li>\n</ul>\n\n<p>Any pseudo-assignment is basically a (re)binding of its\nultimate target and has as its value the value\ngiven to that variable, <em>not</em> the source right hand side.</p>\n\n<p>A pseudo-assignment is equivalent to a sequence of\nsimple variable=expression bindings joined by comma,\nand may appear anywhere in an expression that such a\nsequence of bindings may appear, except that if it\noccurs inside a list comprehension, the ultimate\ntarget must not be mentioned outside that comprehension.</p>\n\n<p>The semantics of pseudo-assignment is defined using\nthree conceptual stages:  protection, expansion, and\nrenaming.</p>\n\n<h2>Protection</h2>\n\n<p>The basic idea is that</p>\n\n<pre><code>f(T, E2, ..., En) := S\n</code></pre>\n\n<p>is syntactic sugar for</p>\n\n<pre><code>T := 'f:='(T, E2, ..., En, S)\n</code></pre>\n\n<p>This form of pseudo-assignment comes from S (<a href=\"http://en.wikipedia.org/wiki/S_%28programming_language%29\" title=\"The S programming language\">S</a> <a href=\"http://www.r-project.org/\" title=\"The R Project for Statistical Computing\">R</a>),\nalthough Pop-2 (<a href=\"http://en.wikipedia.org/wiki/POP-2\" title=\"Pop-2\">P</a>) had an analogous approach much earlier,\nand somewhat similar \"sinister function calls\" were found in\nSETL (<a href=\"http://www.setl.org\" title=\"GNU SETL\">M</a>) (which looks imperative but whose values are\nsemantically immutable).</p>\n\n<p>Where things get slightly complicated is that we want\nsubexpressions of T1, E2, ..., En, S evaluated exactly\nonce and in order.  This is like the way the Common Lisp\n(<a href=\"http://www.lispworks.com/documentation/common-lisp.html\" title=\"The Common Lisp HyperSpec\">L</a>) macros that work with generalised variables \"[evaluate]\nthe subforms of the macro call [...] exactly once in\nleft-to-right order\".  Let's start with an example:</p>\n\n<p>f(g(T, E1), E2) := E3</p>\n\n<p>=> V1 = E1,\n      g(T, V1) := 'f:='(g(T, V1), E2, E3)</p>\n\n<p>=> V1 = E1,\n      T := 'g:='(T, V1, 'f:='(g(T, V1), E2, E3))</p>\n\n<p>so that E1 is not evaluated twice.</p>\n\n<p>This step is defined using Erlang pseudo-code, in which\n&lt;[...]> brackets are \"quasi-quotes\" enclosing source\nsyntax representations of abstract syntax trees.\nInformally, do a pre-order walk over the AST adding\nV=Arg bindings for every non-first argument Arg of each\nfunction but the top-most, for any Arg that needs it.\nWhich arguments do not need this protection?  Ones whose\nevaluation cannot produce any observable effects, which\nwe can approximate well enough by saying that variables\nand constants don't need protection and everything else does.</p>\n\n<pre><code>% protect(ast()) -&gt; ast()\n\nprotect(&lt;[ Lhs := Rhs ]&gt;) -&gt;\n    {Lhs', Bindings} = protect(Lhs, 0, []),\n    prepend_bindings(Bindings, &lt;[ Lhs' := Rhs ]&gt;).\n\n% prepend_bindings([ast()], ast()) -&gt; ast().\n\nprepend_bindings([Binding|Bindings], E) -&gt;\n    E' = prepend_bindings(Bindings, E),\n    &lt;[ Binding, E' ]&gt;;\nprepend_bindings([], E) -&gt;\n    E.\n\n% protect(Expr::ast(), Depth::int(), [ast()]) -&gt;\n%     {ast(), [ast()].\n\nprotect(&lt;[ Var ]&gt;, _, B) -&gt;\n    {&lt;[ Var ]&gt;, B};\nprotect(&lt;[ ~F(T) ]&gt;, D, B) -&gt;\n    {T', B'} = protect(T, D+1, B),\n    {&lt;[ ~F(T') ]&gt;, B'};\nprotect(&lt;[ T#R.F ]&gt;, D, B) -&gt;\n    {T', B'} = protect(T, D+1, B),\n    {&lt;[ T'@R.F ]&gt;, B'};\nprotect(&lt;[ F(T,E2,...,En) ]&gt;, D = 0, B) -&gt;\n    {T', B'} = protect(T, D+1, B),\n    {&lt;[ F(T',E2,...,En) ]&gt;, B');\nprotect(&lt;[ F(T,E2,...,En) ]&gt;, D, B) when D &gt; 0 -&gt;\n    {[E2',...,En'], B'} = protect_args([E2,...,En], B),\n    {T', B''} = protect(T, D+1, B),\n    {F(T',E2',...,En'), B''};\nprotect(&lt;[ M:F(T,E2,...,En) ]&gt;, D = 0, B) -&gt;\n    {T', B'} = protect(T, D+1, B),\n    {&lt;[ M:F(T',E2,...,En) ]&gt;, B'');\nprotect(&lt;[ M:F(T,E2,...,En) ]&gt;, D, B) when D &gt; 0 -&gt;\n    {[E2',...,En'], B'} = protect_args([E2,...,En], B),\n    {T', B''} = protect(T, D+1, B),\n    {M:F(T',E2',...,En'), B''};\n\n% protect_args([ast()], [ast()]) -&gt; {[ast()], [ast()]}.\n\nprotect_args([], B) -&gt;\n    {[], B};\nprotect_args([&lt;[ Var ]&gt;|Args], B) -&gt;\n    {Args', B'} = protect_args(Args, B),\n    {[&lt; Var ]&gt;|Args'], B'};\nprotect_args([&lt;[ Const ]&gt;|Args], B) -&gt;\n    {Args', B'} = protect_args(Args, B),\n    {[&lt; Const ]&gt;|Args'], B'};\nprotect_args([&lt;[ E ]&gt;|Args], B) -&gt;\n    V = a new variable,\n    {Args', B'} = protect_args(Args, [&lt;[ V = E ]&gt;|B]),\n    {[&lt;[ V ]&gt;|Args'], B'}.\n</code></pre>\n\n<h2>Expansion</h2>\n\n<p>Expansion recursively rewrites pseudo-assignments until\nthe target is a simple variable.</p>\n\n<pre><code>L#r.f := E\n=&gt;  L := L#r{f = E}\n\n~f(L) := E          \n=&gt;  L := &lt;{f ~ E | L}&gt;\n\nf(L, E2, ..., En) := E\n=&gt; L := 'f:='(L, E2, ..., En, E)\n\nm:f(L, E2, ..., En) := E\n=&gt; L := m:'f:='(L, L2, ..., En, E)\n</code></pre>\n\n<p>An assignment function is not a special kind of function but\nan ordinary function with a special form of name.  They can\nbe exported, imported, remote-called, passed around in or as\nfuns, using existing Erlang means.</p>\n\n<p>In particular, there is no automatic connection between\nf/n and 'f:=/(n+1).  Importing or exporting one does not\nautomatically import or export the other.</p>\n\n<h2>Renaming</h2>\n\n<p>After expansion and renaming, there are exactly as many\npseudo-assignments as there were before, but each one now\nhas a simple variable as its entire target.</p>\n\n<p>This is handled by renaming.  Instead of thinking of a\nvariable as identified by a name, think of it as identified\nby a «name,version» pair.  So the assignment</p>\n\n<pre><code>V := E\n</code></pre>\n\n<p>is to be thought of (and indeed transformed to)</p>\n\n<pre><code>«V,n+1» = E\n</code></pre>\n\n<p>where n is the highest version of V appearing on the\nexecution path to this rebinding.  If there is no\nsuch version, n = 0.  So</p>\n\n<pre><code>X := f(...),\nX := g(..X..),\nX := h(..X..),\n</code></pre>\n\n<p>becomes</p>\n\n<pre><code>«X,1» = f(...),\n«X,2» = g(..«X,1»..),\n«X,3» = h(..«X,2»..),\n</code></pre>\n\n<p>Sequenceas are easy.  The difficulty is control\npaths that split and rejoin, like 'if' or 'case'.</p>\n\n<p>If E is a split-join control path, and X is a variable that appears in\nin E and is live after it, and the last occurrences of X in each branch\nof E do not all have the same version, then let «X,m» be the highest\nversion of X in E. On each branch of E where a version of X is created,\nreplace the highest version of X by «X,m».  If a branch does not\ncreate a version of X and X is not live on entry to E, this is already\nan error in Erlang, and we don't change that.  If «X,p» is the version\nof X that is live on entry to E, then add</p>\n\n<pre><code>«X,m» = «X,p»\n</code></pre>\n\n<p>just after the -> arrow of each branch that does not update X.\nHere's an exmaple.</p>\n\n<pre><code>W = 137,\nif X &lt; Y  -&gt; Z = X-1, Z := Z*(Y+1)\n ; X &gt;= Y -&gt; Z = 42, W := 3145\nend,\nf(Z, W)\n</code></pre>\n\n<p>becomes</p>\n\n<pre><code>«W,1» = 137,\nif «X,1» &lt; «Y,1» -&gt;\n      «W,2» = «W,1»,   % patch\n      «Z,1» = «X,1» - 1,\n      «Z,2» = «Z,1»*(«Y,1»+1)\n ; «X,1» &gt;= «Y,1» -&gt;\n      «Z,2» = 42,     % patch\n      «W,2» = 3145\nend,\nf(«Z,2», «W,2»)\n</code></pre>\n\n<p>The first patch line is added because that branch does not\nupdate W, and it is added where it is so as not to interfere\nwith the result of the rest of the branch.\nThe second patch line would have bound «Z,1» except that\nthe version was pushed up to to match the other branch.</p>\n\n<p>In effect, we are working with static single assignment form,\nand the patches are pushing the phi-function back into the\nbranches.</p>\n\n<p>The semantic analyser and code generator of the compiler never\nget to hear about pseudo-assignment.  There is no reason why\ndifferent versions of a variable should be allocated the same\nvirtual register or memory cell; it's up to the register\nallocator to do that if it is useful or to do otherwise if\nthat's more useful.</p>\n\n<h1>Motivation</h1>\n\n<p>Several people have complained on the Erlang mailing list\nthat having to write</p>\n\n<pre><code>X  = f(...),\nX1 = g(..X..),\nX2 = h(..X1...)\n</code></pre>\n\n<p>is error prone as well as tedious because if they have to\nreorder the sequence of transformations, add a transformation,\nor remove one, they have to rename the variables.</p>\n\n<p>The fact that \"assignment\" to whole variables can be modelled\nin a pure declarative language using renaming has been known\nfor a long time.  I knew it when writing \"The Craft of Prolog\",\nand it was folklore then.  The question was not <em>could</em> we\nsupport</p>\n\n<pre><code>X := f(...),\nX := g(..X..),\nX := h(..X..),\n</code></pre>\n\n<p>but <em>should</em> we?</p>\n\n<p>Loïc Hoguin has argued strongly that \"[he] just want[s]\nprimitives to easily update deep data structures\" (26 Jan 2013),\nsaying that Erlang's handling of records is inadequate because it\nmakes this difficult.  He wrote (25 Jan 2013):</p>\n\n<blockquote>\n  <p>Assume a variable Character.\nThis variable contains everything about the character.\nHow do you best access and modify Character?\nThe answer must not involve the process dictionary, processes or\nmessage passing.\nToday I have to write each access and modification function.\nOr I can generate it,\nbut either way I end up with hundreds of functions in many modules. \nOr I could use records, and have one line per sub-record per \nmodification function I write.\nThat's not <em>easy</em> nor <em>practical</em>.\nEasy and practical is:</p>\n\n<p>Character.weapon.ability.cost</p>\n\n<p>for access, and:</p>\n\n<p>Character.weapon.ability.cost = 123</p>\n\n<p>for modification.</p>\n</blockquote>\n\n<p>I don't propose to give him that, but</p>\n\n<pre><code>C = cost(ability(Character#cinfo.weapon)),\ncost(ability(Character#cinfo.weapon)) := C + 123\n</code></pre>\n\n<p>he can have, where all functions might be inlined, or</p>\n\n<pre><code>C = ~cost ~ability ~weapon Character,\n~cost ~ability ~weapon Character := C + 123\n</code></pre>\n\n<p>in that bright future when we have frames.</p>\n\n<p>The good part, from my point of view, is that this brief\nsyntax can be had without introducing mutable data structures.\nThis is <em>pseudo</em>-assignment.  And it is a proven technique\nthat has been used for over 25 years.</p>\n\n<p>The bad part, for die-hard assignment fans, is that updating\ndeep paths this way requires allocating modified copies of\nrecords along the way, but we can't change that without\naltering fundamental properties of Erlang.</p>\n\n<h1>Rationale</h1>\n\n<p>The questions are: what kind of \"assignment\" should be offered,\nwhat syntax should be used for assignment and what targets should`\nbe allowed.</p>\n\n<p>Without adding a type system that would permit Haskell-style\nmonads or Clean/Mercury-style uniqueness tracking,\nthere are two ways to add assignment to Erlang: the Lisp way\nand the S way.  The Lisp way is to offer the real thing in\nall its destructive power.  That would have the huge benefit\nof making Erlang much more comfortable for C/Java/JavaScript\nprogrammers, and we could look forward to the day when Erlang\nsyntax is finally reformed to be JavaScript with threads.  It\nwould also have the huge price of requiring major changes to\nthe Erlang compiler and runtime system and of voiding one of\nthe major guarantees (\"your data is safe with us\") cherished\nby Erlang programmers.  It would make Erlang programs harder\nto get right.  Frankly, if we want JavaScript with threads,\nwe'd do much better to add threads to JavaScript.</p>\n\n<p>The other way is the S way.  S is a programming language\ndevised by John Chambers at AT&amp;T for programming statistics\nalgorithms.  The revised language definition was published\nin 1988.  The syntax of S looks like slightly deranged\nC, but the semantics is astonishingly functional.  In particular,\nat least up to S3, S values did not detectably share mutable\nparts.  An S assignment like</p>\n\n<pre><code>a[i,j] &lt;- 0\n</code></pre>\n\n<p>is equivalent to</p>\n\n<pre><code>\"[\"(a, i, j) &lt;- 0\n</code></pre>\n\n<p>which is in turn equivalent to</p>\n\n<pre><code>a &lt;- \"[&lt;-\"(a, i, j, value = 0)\n</code></pre>\n\n<p>and this is not merely a fashion of speaking, there really is a\nfunction named \"[&lt;-\" which is really called.   With its C-like\nsyntax, immutable data structures, and lazily evaluated\nfunction arguments, the S language is is definitely strange.\nBut it is highly <em>practical</em>.  The R repository has a huge\nrange of packages doing amazing and useful things; it is used\nin Statistics courses around the world; and there is an\nabundance of excellent books teaching and using S/R.  So while\nthe idea of \"assignment\" being syntactic sugar for computing\na new whole value and rebinding it to a value may seem unfamiliar,\nit is demonstrably both <em>workable</em> and <em>usable</em>.</p>\n\n<p>Since there is a battle-tested form of \"assignment\" that does\nnot require mutable data structures, that's clearly the way for\nErlang to go.</p>\n\n<p>As for syntax, I am familiar with</p>\n\n<ul>\n<li>Lhs = Rhs (Fortran, COBOL, BASIC, C)</li>\n<li>Lhs := Rhs (Algol, Pascal, Modula, Ada, ANSI Smalltalk)</li>\n<li>Lhs left-arrow Rhs (APL, classic Smalltalk)</li>\n<li>Lhs &lt;- Rhs (S)</li>\n<li>Rhs -> Lhs (S, Pop-2)</li>\n<li>(set! Lhs Rhs) (Scheme)</li>\n<li>(setf Lhs Rhs) (Lisp)</li>\n</ul>\n\n<p>Of these, Erlang already uses =, &lt;-, and -> for other purposes,\nand the Unicode left arrow remains difficult to type.  Erlang\nsyntax is not Lisp syntax, and while LFE has Lispy macros,\nplain Erlang does not.  This leaves := as the sole credible contender.</p>\n\n<p>As for the targets of pseudo-assignments, we could simply allow\nErlang variables.  The ability to do renaming-style assignments\nhas been frequently requested in the Erlang mailing list.  It is\nimportant to understand that the renaming approach to variable\n\"assignment\" does not require the ability to rewrite a memory\ncell: different \"versions\" of a variable may well occupy different\ncells, and whether they do or not is up to the register allocator.</p>\n\n<p>We have also seen Erlang criticised for being unable to express\nchained record updates clearly.  Instead of</p>\n\n<pre><code>X1 = X#r{f = X#r.f#s{g = X#r.f#s.g#t{h = 42}}}\n</code></pre>\n\n<p>many people would rather write</p>\n\n<pre><code>X#r.f#s.g#t.h := 42\n</code></pre>\n\n<p>and who can blame them?  (Well, <em>me</em>.  I think they should not\nbe writing code like that whatever the syntax, and found in my\nown C code that purging it of pointer chains uncovered a\nscary number of present and potential bugs.  The basic nature\nof the problem is excessive coupling.)  So we want to allow\nfield references as targets.</p>\n\n<p>The ~f(L) syntax comes from the frames proposal.  If record\nfields are pseudo-assignable, so should frame slots be.</p>\n\n<p>If we want to pseudo-assign to elements of hash tables or\narray-like structures, we have to allow function calls.\nThe example of S shows that we <em>can</em> include function calls on\nthe left of assignments, meaning that we can do</p>\n\n<pre><code>at(Dict, Key) -&gt;\n    case dict:find(Dict, Key)\n      of {ok,V} -&gt; V\n       ; error  -&gt; 0\n    end.\n\n'at:='(Dict, Key, Value) -&gt;\n    dict:store(Key, Value, Dict).\n\n...\n\n    at(D, K) := at(D, K) + 1\n...\n'element:='(N, Tuple, V) -&gt;\n    setelement(N, Tuple, V).\n...\n   A := {0,0,0}, \n   element(1, A) := 3,\n   element(2, A) := 1,\n   element(3, A) := 4\n</code></pre>\n\n<p>Some languages let you assign to substrings.\nIf we can pseudo-assign to function calls, we need no\nextra machinery for that:</p>\n\n<pre><code>'substr:='(String, Start, New) -&gt;\n    string:substr(String, 1, Start - 1) ++ New.\n\n'substr:='(String, Start, Length, New) -&gt;\n    string:substr(String, 1, Start - 1) ++ New ++\n    string:substr(String, Start + Length - 1).\n</code></pre>\n\n<p>The next step in generality would be to follow Algol 68 and\nallow</p>\n\n<pre><code>if G1 -&gt; B1, L1\n ; ...\n ; Gn -&gt; Bn, Ln\nend := E\n</code></pre>\n\n<p>meaning</p>\n\n<pre><code>if G1 -&gt; B1, L1 := E\n ; ...\n ; Gn -&gt; Bn, Ln := E\nend\n</code></pre>\n\n<p>with similar definitions for 'case' &amp;c.  I can't see a\nstraightforward way to implement that without either\nduplicating E or doing computations out of order, so it\nseemed like a good idea to stop just before this point.</p>\n\n<p>The 'expansion' step above says that importing or exporting\nf/n does not automatically import or export 'f:='/(n+1).\nThis could be a source of unimportant but annoying errors.\nI expect using assignment functions to be more common than\ndefining them, and you can write a remote call to a function\nwithout explicitly importing it, so <em>writing</em></p>\n\n<pre><code>string:substr(Line, Comment_Start) := \"\"\n</code></pre>\n\n<p>does not require any special declaration.  The possible\nmistake, then, is to define f/n and 'f:='/(n+1) in a module\nand export the first without exporting the second.  If this\ndoes turn out to be a problem, it will be easy enough to add\na rule that if f/n is exported and 'f:='/(n+1) is defined,\nthe assignment form is exported too.  Let's wait and see if\nit's really needed.</p>\n\n<p>Should pseudo-assignment syntax be allowed for a variable's\ninitial binding?  There does not seem to be any compelling\nreason to forbid it.</p>\n\n<p>There <em>is</em> a compelling reason to forbid variables being\npseudo-assigned inside a list comprehension that are used\noutside it.  List comprehensions could be compiled inline\ninstead of generating out-of-line recursive functions, as\nthey currently do.  And variable assignment by actual\nhonest-to-goodness smash-that-memory-cell assignment could\nbe used to implement such assignments.  And the formal\nsemantics could remain renaming.  But the code generator\nwould have to know about it.  The renaming semantics\n<em>could</em> be implemented with the out-of-line approach, but\nthe current values of such variables would have to be\npassed in and returned, creating overheads that would\nsurprise me, let alone other programmers.  Simpler by far\njust to forbid it.  This is not entirely unlike the\nsomewhat fiddly scope rules for variables in anonymous\nfunctions.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The token ':=' and the token sequence ':' '=' are not currently\nlegal anywhere in Erlang source code, so no existing code is\ndirectly affected.</p>\n\n<p>Pseudo-assignment is defined as a source to source transformation.\nThis transformation is local to the function clause affected and\ncan done entirely within the parser.</p>\n\n<p>This means that anything in the Erlang tool chain downstream from\nthe parser is unaffected by this change.  In particular, profiling,\nmonitoring, and debugging tools just see plain old Erlang.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None in this draft, though implementation hints are given.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}