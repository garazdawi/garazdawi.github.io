{"pageProps":{"index":{"id":"0049","content":"<pre><code>Author: Fred Hebert &lt;mononcqc(at)ferd(dot)ca&gt;\nStatus: Draft\nType: Standards Track\nCreated: 31-Aug-2018\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 49: <a href=\"eep-0049.md\" title=\"EEP Source\"> Value-Based Error Handling Mechanisms</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP adds a contextual <code>&lt;~</code> operator to <code>begin ... end</code> expressions,\nwhich allows them to be usable for value-based error handling, based on\nstandard <code>{ok, term()} | {error, term()}</code> return value types.</p>\n\n<p>This lets <code>begin ... end</code> become a control flow construct to replace or\nsimplify deeply-nested <code>case ... end</code> expressions, and prevent using\nexceptions for control flow.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n\n<h1>Specification</h1>\n\n<p>The current syntax for a <code>begin ... end</code> expression is:</p>\n\n<pre><code>begin\n    Exprs\nend\n</code></pre>\n\n<p>The expression does not have a restricted scope, and is mostly used to\ngroup multiple distinct expressions as a single block. We propose a new\ntype of expressions (denoted <code>UnwrapExprs</code>), only valid within a\n<code>begin ... end</code> expression:</p>\n\n<pre><code>begin\n    Exprs | UnwrapExprs\nend\n</code></pre>\n\n<p><code>UnwrapExprs</code> are defined as having the following form:</p>\n\n<pre><code>Pattern &lt;~ Expr\n</code></pre>\n\n<p>This definition means that <code>UnwrapExprs</code> are only allowed at the\ntop-level of <code>begin ... end</code> expressions.</p>\n\n<p>The <code>&lt;~</code> operator takes the value return by <code>Expr</code> and inspects it.\nIf the value is a tuple of the form <code>{ok, Val}</code>, it unwraps <code>Val</code> from\nthe tuple, and matches it against <code>Pattern</code>.</p>\n\n<p>If the pattern matches, all variables from <code>Pattern</code> are bound in the\nlocal environment, and the full value <code>{ok, Val}</code> is returned by the\n<code>UnwrapExpr</code>. If the value does not match, a <code>{badunwrap, Val}</code> error\nis raised.</p>\n\n<p>A special case exists when <code>Pattern</code> is the match-all\nvariable (<code>_</code>), which on top of allowing the value to be considered a successful\nunwrapping if the returned value from <code>Expression</code> is <code>{ok, term()}</code>,\nit also considers the atom <code>ok</code> to be valid as well.</p>\n\n<p>If the value is a tuple of the form <code>{error, Reason}</code>, then the entire\n<code>begin ... end</code> expression is short-circuited and returns <code>{error,\nReason}</code>. The variables that were bound in there remain bound, the\nrest are undefined.</p>\n\n<p>The compiler should warn about any variable that is used after the\n<code>begin ... end</code> expression that was bound in or after the first\n<code>UnwrapExpr</code> encountered within the block.</p>\n\n<p>If the value returned does not match any of <code>{ok | error, term()}</code> as a\ntype, a <code>{badunwrap, Val}</code> error is raised.</p>\n\n<p>Given the structure described here, the final expression may look like:</p>\n\n<pre><code>begin\n    Foo = bar(),\n    X &lt;~ id({ok, 5}),\n    [H|T] &lt;~ id({ok, [1,2,3]}),\n    ...\nend\n</code></pre>\n\n<p>Do note that to allow easier pattern matching and more intuitive usage,\nthe <code>&lt;~</code> operator should have associativity rules lower than <code>=</code>, such that:</p>\n\n<pre><code>begin\n    X = [H|T] &lt;~ exp()\nend\n</code></pre>\n\n<p>is a valid <code>UnwrapExp</code> equivalent to the non-infix form <code>'&lt;~'('='(X, [H|T]),\nexp())</code>, since reversing the priorities would give <code>'='('&lt;~'(X, [H|T]),\nexp())</code>, which would create an <code>UnwrapExp</code> out of context and be invalid.</p>\n\n<h1>Motivation</h1>\n\n<p>Erlang has some of the most flexible error handling available across a\nlarge number of programming languages. The language supports:</p>\n\n<ol>\n<li>three types of exceptions (<code>throw</code>, <code>error</code>, <code>exit</code>)\n<ul>\n<li>handled by <code>catch Exp</code></li>\n<li>handled by <code>try ... [of ...] catch ... [after ...] end</code></li>\n</ul></li>\n<li>links, <code>exit/2</code>, and <code>trap_exit</code></li>\n<li>monitors</li>\n<li>return values such as <code>{ok, Val} | {error, Term}</code>, <code>{ok, Val} |\nfalse</code>, or <code>ok | {error, Val}</code></li>\n<li>A combination of one or more of the above</li>\n</ol>\n\n<p>So why should we look to add more? There are various reasons for this,\nincuding trying to reduce deeply nested conditional expressions,\ncleaning up some messy patterns found in the wild, providing a better\nseparation of concern when implementing functions, and encouraging more\nstandard and idiomatic interfaces.</p>\n\n<h2>Reducing Nesting</h2>\n\n<p>One common pattern that can be seen in Erlang is deep nesting of <code>case\n... end</code> expressions, to check complex conditionals.</p>\n\n<p>Take the following code taken from\n<a href=\"https://github.com/erlang/otp/blob/a0ae44f324576104760a63fe6cf63e0ca31756fc/lib/mnesia/src/mnesia_backup.erl#L106-L126\">Mnesia</a>,\nfor example:</p>\n\n<pre><code>commit_write(OpaqueData) -&gt;\n    B = OpaqueData,\n    case disk_log:sync(B#backup.file_desc) of\n        ok -&gt;\n            case disk_log:close(B#backup.file_desc) of\n                ok -&gt;\n                    case file:rename(B#backup.tmp_file, B#backup.file) of\n                       ok -&gt;\n                            {ok, B#backup.file};\n                       {error, Reason} -&gt;\n                            {error, Reason}\n                    end;\n                {error, Reason} -&gt;\n                    {error, Reason}\n            end;\n        {error, Reason} -&gt;\n            {error, Reason}\nend.\n</code></pre>\n\n<p>The code is nested to the extent that shorter aliases must be introduced\nfor variables (<code>OpaqueData</code> renamed to <code>B</code>), and half of the code just\ntransparently returns the exact values each function was given.</p>\n\n<p>By comparison, the same code could be written as follows with the new\nconstruct:</p>\n\n<pre><code>commit_write(OpaqueData) -&gt;\n    begin\n        _ &lt;~ disk_log:sync(OpaqueData#backup.file_desc),\n        _ &lt;~ disk_log:close(OpaqueData#backup.file_desc),\n        _ &lt;~ file:rename(OpaqueData#backup.tmp_file, OpaqueData#backup.file),\n        {ok, OpaqueData#backup.file}\n    end.\n</code></pre>\n\n<p>The semantics of this call are entirely identical, except that it is now\nmuch easier to focus on the flow of individual operations.</p>\n\n<h2>Obsoleting Messy Patterns</h2>\n\n<p>Frequent ways in which people work with sequences of failable operations\ninclude folds over lists of functions, and abusing list comprehensions.\nBoth patterns have heavy weaknesses that makes them less than ideal.</p>\n\n<p>Folds over list of functions use patterns such as those defined in\n<a href=\"http://erlang.org/pipermail/erlang-questions/2017-September/093575.html\">posts from the\nmailing</a>:</p>\n\n<pre><code>pre_check(Action, User, Context, ExternalThingy) -&gt;\n    Checks =\n        [fun check_request/1,\n         fun check_permission/1,\n         fun check_dispatch_target/1,\n         fun check_condition/1],\n    Args = {Action, User, Context, ExternalThingy},\n    Harness =\n        fun\n            (Check, ok)    -&gt; Check(Args);\n            (_,     Error) -&gt; Error\n        end,\n    case lists:foldl(Harness, ok, Checks) of\n        ok    -&gt; dispatch(Action, User, Context);\n        Error -&gt; Error\n    end.\n</code></pre>\n\n<p>This code requires declaring the functions one by one, ensuring the\nentire context is carried from function to function. Since there is no\nshared scope between functions, all functions must operate on all\narguments.</p>\n\n<p>By comparison, the same code could be implemented with the new construct\nas:</p>\n\n<pre><code>pre_check(Action, User, Context, ExternalThingy) -&gt;\n    begin\n        _ &lt;~ check_request(Context, User),\n        _ &lt;~ check_permissions(Action, User),\n        _ &lt;~ check_dispatch_target(ExternalThingy),\n        _ &lt;~ check_condition(Action, Context),\n        dispatch(Action, User, Context)\n    end\n</code></pre>\n\n<p>And if there was a need for derived state between any two steps, it\nwould be easy to weave it in:</p>\n\n<pre><code>pre_check(Action, User, Context, ExternalThingy) -&gt;\n    begin\n        _ &lt;~ check_request(Context, User),\n        _ &lt;~ check_permissions(Action, User),\n        _ &lt;~ check_dispatch_target(ExternalThingy),\n        DispatchData &lt;~ dispatch_target(ExternalThingy),\n        _ &lt;~ check_condition(Action, Context),\n        dispatch(Action, User, Context)\n    end\n</code></pre>\n\n<p>The list comprehension <em>hack</em>, by comparison, is a bit more rare. In\nfact, it is mostly theoretical. Some things that hint at how it could\nwork can be found in <a href=\"https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/diameter/test/diameter_examples_SUITE.erl#L254-L266\">Diameter test\ncases</a>\nor the <a href=\"https://github.com/ferd/rebar3_proper/blob/e7eb96498a9d31f41c919474ec6800df62e237e1/src/rebar3_proper_prv.erl#L298-L308\">PropEr plugin for\nRebar3</a>.</p>\n\n<p>Its overal form uses generators in list comprehensions to tunnel a happy\npath:</p>\n\n<pre><code>[Res] =\n    [f(Z) || {ok, W} &lt;- [b()],\n             {ok, X} &lt;- [c(W)],\n             {ok, Y} &lt;- [d(X)],\n             Z &lt;- [e(Y)]],\nRes.\n</code></pre>\n\n<p>This form doesn't see too much usage since it is fairly obtuse and I\nsuspect most people have either been reasonable enough not to use it, or\ndid not think about it. Obviously the new form would be cleaner:</p>\n\n<pre><code>begin\n    W &lt;~ b(),\n    X &lt;~ c(W),\n    Y &lt;~ d(X),\n    Z = e(Y),\n    f(Z)\nend\n</code></pre>\n\n<p>which on top of it, has the benefit of returning an error value if one\nis found.</p>\n\n<h2>Better Separation of Concerns</h2>\n\n<p>This form is not necessarily obvious at a first glance. To better\nexpose it, let's take a look at some functions defined in the\n<a href=\"https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/sasl/src/release_handler.erl#L1894-L1923\"><code>release_handler</code> module in\nOTP</a>:</p>\n\n<pre><code>write_releases_m(Dir, NewReleases, Masters) -&gt;\n    RelFile = filename:join(Dir, \"RELEASES\"),\n    Backup = filename:join(Dir, \"RELEASES.backup\"),\n    Change = filename:join(Dir, \"RELEASES.change\"),\n    ensure_RELEASES_exists(Masters, RelFile),\n    case at_all_masters(Masters, ?MODULE, do_copy_files,\n                        [RelFile, [Backup, Change]]) of\n        ok -&gt;\n            case at_all_masters(Masters, ?MODULE, do_write_release,\n                                [Dir, \"RELEASES.change\", NewReleases]) of\n                ok -&gt;\n                    case at_all_masters(Masters, file, rename,\n                                        [Change, RelFile]) of\n                        ok -&gt;\n                            remove_files(all, [Backup, Change], Masters),\n                            ok;\n                        {error, {Master, R}} -&gt;\n                            takewhile(Master, Masters, file, rename,\n                                      [Backup, RelFile]),\n                            remove_files(all, [Backup, Change], Masters),\n                            throw({error, {Master, R, move_releases}})\n                    end;\n                {error, {Master, R}} -&gt;\n                    remove_files(all, [Backup, Change], Masters),\n                    throw({error, {Master, R, update_releases}})\n            end;\n        {error, {Master, R}} -&gt;\n            remove_files(Master, [Backup, Change], Masters),\n            throw({error, {Master, R, backup_releases}})\n    end.\n</code></pre>\n\n<p>At a glance, it is very difficult to clean up this code: there are 3\nmulti-node operations (backing up, updating, and moving release data),\neach of which relies on the previous one to succeed.</p>\n\n<p>You'll also notice that each error requires special handling, reverting\nor removing specific operations on success or on failure. This is not a\nsimple question of tunnelling values in and out of a narrow scope.</p>\n\n<p>Another thing to note is that this module, as a whole (and not just the\nsnippet presented here) uses <code>throw</code> expressions to operate non-local\nreturn. The actual point of return handling these is spread through\nvarious locations in the file:\n<a href=\"https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/sasl/src/release_handler.erl#L381-L388\"><code>create_RELEASES/4</code></a>,\nand\n<a href=\"https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/sasl/src/release_handler.erl#L1864-L1881\"><code>write_releases_1/3</code></a>\nfor example.</p>\n\n<p>The <code>case catch Exp of</code> form is used throughout the file because\nvalue-based error flow is painful in nested structures.</p>\n\n<p>So let's take a look at how we could refactor this with the new\nconstruct:</p>\n\n<pre><code>write_releases_m(Dir, NewReleases, Masters) -&gt;\n    RelFile = filename:join(Dir, \"RELEASES\"),\n    Backup = filename:join(Dir, \"RELEASES.backup\"),\n    Change = filename:join(Dir, \"RELEASES.change\"),\n    begin\n        _ &lt;~ backup_releases(Dir, NewReleases, Masters, Backup, Change,\n                             RelFile),\n        _ &lt;~ update_releases(Dir, NewReleases, Masters, Backup, Change),\n        _ &lt;~ move_releases(Dir, NewReleases, Masters, Backup, Change, RelFile)\n    end.\n\nbackup_releases(Dir, NewReleases, Masters, Backup, Change, RelFile) -&gt;\n    case at_all_masters(Masters, ?MODULE, do_copy_files,\n                        [RelFile, [Backup, Change]]) of\n        ok -&gt;\n            ok;\n        {error, {Master, R}} -&gt;\n            remove_files(Master, [Backup, Change], Masters)\n            {error, {Master, R, backup_releases}}\n    end.\n\nupdate_releases(Dir, NewReleases, Masters, Backup, Change) -&gt;\n    case at_all_masters(Masters, ?MODULE, do_write_release,\n                        [Dir, \"RELEASES.change\", NewReleases]) of\n        ok -&gt;\n            ok;\n        {error, {Master, R}} -&gt;\n            remove_files(all, [Backup, Change], Masters),\n            {error, {Master, R, update_releases}}\n    end.\n\nmove_releases(Dir, NewReleases, Masters, Backup, Change, RelFile) -&gt;\n    case at_all_masters(Masters, file, rename, [Change, RelFile]) of\n        ok -&gt;\n            remove_files(all, [Backup, Change], Masters),\n            ok;\n        {error, {Master, R}} -&gt;\n            takewhile(Master, Masters, file, rename, [Backup, RelFile]),\n            remove_files(all, [Backup, Change], Masters),\n            {error, {Master, R, move_releases}}\n    end.\n</code></pre>\n\n<p>The only reasonable way to rewrite the code was to extract all three\nmajor multi-node operations into distinct functions. The improvements\nare:</p>\n\n<ul>\n<li>The consequence of failing an operation is located near where the\noperation takes place</li>\n<li>The functions have return values that Dialyzer can more easily\ntypecheck</li>\n<li>The functions are inherently more testable independently</li>\n<li>Context can still be added and carried on the generalized workflow at\nthe parent level</li>\n<li>The chain of successful operations is very obvious and readable</li>\n<li>Exceptions are no longer required to make the code work, but if we\nneeded it, only one <code>throw()</code> would be needed in <code>write_release_m</code>,\ntherefore separating the flow control details from specific function\nimplementations.</li>\n</ul>\n\n<p>As a control experiment, let's try reusing our shorter functions with\nthe previous flow:</p>\n\n<pre><code>%% Here is the same done through exceptions:\nwrite_releases_m(Dir, NewReleases, Masters) -&gt;\n    RelFile = filename:join(Dir, \"RELEASES\"),\n    Backup = filename:join(Dir, \"RELEASES.backup\"),\n    Change = filename:join(Dir, \"RELEASES.change\"),\n    try\n        ok = backup_releases(Dir, NewReleases, Masters, Backup, Change,\n                             RelFile),\n        ok = update_releases(Dir, NewReleases, Masters, Backup, Change),\n        ok = move_releases(Dir, NewReleases, Masters, Backup, Change, RelFile)\n    catch\n        {error, Reason} -&gt; {error, Reason}\n    end.\n\nbackup_releases(Dir, NewReleases, Masters, Backup, Change, RelFile) -&gt;\n    case at_all_masters(Masters, ?MODULE, do_copy_files,\n                        [RelFile, [Backup, Change]]) of\n        ok -&gt;\n            ok;\n        {error, {Master, R}} -&gt;\n            remove_files(Master, [Backup, Change], Masters)\n            throw({error, {Master, R, backup_releases}})\n    end.\n\nupdate_releases(Dir, NewReleases, Masters, Backup, Change) -&gt;\n    case at_all_masters(Masters, ?MODULE, do_write_release,\n                        [Dir, \"RELEASES.change\", NewReleases]) of\n        ok -&gt;\n            ok;\n        {error, {Master, R}} -&gt;\n            remove_files(all, [Backup, Change], Masters),\n            throw({error, {Master, R, update_releases}})\n    end.\n\nmove_releases(Dir, NewReleases, Masters, Backup, Change, RelFile) -&gt;\n    case at_all_masters(Masters, file, rename, [Change, RelFile]) of\n        ok -&gt;\n            remove_files(all, [Backup, Change], Masters),\n            ok;\n        {error, {Master, R}} -&gt;\n            takewhile(Master, Masters, file, rename, [Backup, RelFile]),\n            remove_files(all, [Backup, Change], Masters),\n            throw({error, {Master, R, move_releases}})\n    end.\n</code></pre>\n\n<p>Very little changes in the three distributed functions. However, the weakness\nof this approach is that we have intimately tied implementation details of the\nsmall functions to their parent's context.  This makes it hard to reason about\nthese functions in isolation or to reuse them in a different context.\nFurthermore, the parent function may capture <code>throws</code> not intended for it.</p>\n\n<p>It is my opinion that using value-based flow control, through similar\nrefactorings, yields safer and cleaner code, which also happens to have\nfar more reduced levels of nesting. It should therefore be possible to\nexpress more complex sequences of operations without making them any\nharder to read, nor reason about in isolation.</p>\n\n<p>That is in part due to the nesting, but also because we take a more\ncompositional approach, where there is no need to tie local functions'\nimplementation details to the complexity of their overall pipeline and\nexecution context.</p>\n\n<p>It is also the best way to structure code in order to handle all\nexceptions and to provide the context they need as close as possible to\ntheir source, and as far as possible from the execution flow.</p>\n\n<h2>Encouraging Standards</h2>\n\n<p>In Erlang, <code>true</code> and <code>false</code> are regular atoms that only gained special\nstatus through usage in boolean expressions. It would be easy to think\nthat more functions would return <code>yes</code> and <code>no</code> were it not from control\nflow constructs.</p>\n\n<p>Similarly, <code>undefined</code> has over years of use become a kind of default\n\"not found\" value. Values such as <code>nil</code>, <code>null</code>, <code>unknown</code>, <code>undef</code>,\n<code>false</code> and so on have seen some use, but a strong consistency in format\nhas ended up aligning the community on one value.</p>\n\n<p>When it comes to return values for various functions, <code>{ok, Term}</code> is\nthe most common one for positive results that need to communicate a\nvalue, <code>ok</code> for positive results with no other value than their own\nsuccess, and <code>{error, Term}</code> is most often uses for errors. Pattern\nmatching and assertions have enforced that it is easy to know whether a\ncall worked or not by its own structure.</p>\n\n<p>However, many success values are still larger tuples: <code>{ok, Val,\nWarnings}</code>, <code>{ok, Code, Status, Headers, Body}</code>, and so on. Such\nvariations are not problematic on their own, but it would likely not\nhurt too much either to use <code>{ok, {Val, Warnings}}</code> or <code>{ok, {Code,\nStatus, Headers, Body}}</code>.</p>\n\n<p>In fact, using more standard forms could lead to easier generalizations\nand abstractions that can be applied to community-wide code. By choosing\nspecific formats for control flow on value-based error handling, we\nexplicitly encourage this form of standardization.</p>\n\n<h1>Rationale</h1>\n\n<p>This section will detail the decision-making behind this EEP, including:</p>\n\n<ul>\n<li>Prior Art in Other Languages</li>\n<li>The choice of <code>begin ... end</code> as a construct and its scope</li>\n<li>Why introduce a new operator</li>\n<li>Other disregarded approaches</li>\n<li>The choice of supported values</li>\n<li>The choice of <code>{badunwrap, Val}</code> as a default exception</li>\n</ul>\n\n<p>There's a lot of content to cover here.</p>\n\n<h2>Prior Art in Other Languages</h2>\n\n<p>Multiple languages have value-based exception handling, many of which\nhave a strong functional slant.</p>\n\n<h3>Haskell</h3>\n\n<p>The most famous case is possibly Haskell with the <code>Maybe</code> monad, which\nuses either <code>Nothing</code> (meaning the computation returned nothing) or\n<code>Just x</code> (their type-based equivalent of <code>{ok, X}</code>). The union of both\ntypes is denoted <code>Maybe x</code>. The following examples are taken from\n<a href=\"https://en.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe\">Haskell/Understanding\nmonads/Maybe</a>.</p>\n\n<p>Values for such errors are tagged in functions as follows:</p>\n\n<pre><code>safeLog :: (Floating a, Ord a) =&gt; a -&gt; Maybe a\nsafeLog x\n    | x &gt; 0     = Just (log x)\n    | otherwise = Nothing\n</code></pre>\n\n<p>Using the type annotations directly, it is possible to extract values\n(if any) through pattern matching:</p>\n\n<pre><code>zeroAsDefault :: Maybe Int -&gt; Int\nzeroAsDefault mx = case mx of\n    Nothing -&gt; 0\n    Just x -&gt; x\n</code></pre>\n\n<p>One thing to note here is that as long as you are not able to find a\nvalue to substitute for <code>Nothing</code> or that you cannot take a different\nbranch, you are forced to carry that uncertainty with you through all\nthe types in the system.</p>\n\n<p>This is usually where Erlang stops. You have the same possibilities\n(albeit dynamically checked), along with the possibility of transforming\ninvalid values into exceptions.</p>\n\n<p>Haskell, by comparison, offers monadic operations and its <em>do notation</em>\nto abstract over things:</p>\n\n<pre><code>getTaxOwed name = do\n  number       &lt;- lookup name phonebook\n  registration &lt;- lookup number governmentDatabase\n  lookup registration taxDatabase\n</code></pre>\n\n<p>In this snippet, even though the <code>lookup</code> function returns a <code>Maybe x</code>\ntype, the do notation abstracts away the <code>Nothing</code> values, letting the\nprogrammer focus on the <code>x</code> part of <code>Just x</code>. Even though the code is\nwritten as if we can operate on discrete value, the function\nautomatically re-wraps its result into <code>Just x</code> and any <code>Nothing</code> value\njust bypasses operations.</p>\n\n<p>As such, the developer is forced to acknowledge that the whole\nfunction's flow is conditional to values being in place, but they can\nnevertheless write it mostly as if everything were discrete.</p>\n\n<h3>OCaml</h3>\n\n<p>OCaml supports exceptions, with constructs such as <code>raise (Type\n\"value\")</code> to raise an exception, and <code>try ... with ...</code> to handle them.\nHowever, since exceptions wouldn't be tracked by the type system,\nmaintainers introduced a <code>Result</code> type.</p>\n\n<p>The type is defined as</p>\n\n<pre><code>type ('a, 'b) result =\n  | Ok of 'a\n  | Error of 'b\n</code></pre>\n\n<p>which is reminiscent of Erlang's <code>{ok, A}</code> and <code>{error, B}</code>. OCaml users\nappear to mostly use pattern matching, combinator libraries, and monadic\nbinding to deal with value-based error handling, something similar to\nHaskell's usage.</p>\n\n<h3>Rust</h3>\n\n<p>Rust defines two types of errors: unrecoverable ones (using <code>panic!</code>)\nand recoverable ones, using the <code>Error&lt;T, E&gt;</code> values. The latter is of\ninterest to us, and defined as:</p>\n\n<pre><code>enum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n</code></pre>\n\n<p>Which would intuitively translate to Erlang terms <code>{ok, T}</code> and <code>{error,\nE}</code>. The simple way to handle these in Rust is through pattern matching:</p>\n\n<pre><code>let f = File::open(\"eep.txt\");\nmatch f {\n    Ok(file) =&gt; do_something(file),\n    Err(error) =&gt; {\n        panic!(\"Error in file: {:?}\", error)\n    },\n};\n</code></pre>\n\n<p>Specific error values have to be well-typed, and it seems that the Rust\ncommunity is still debating implementation details about how to best get\ncomposability and annotations within a generic type.</p>\n\n<p>However, their workflow for handling these is well-defined already. This\npattern matching form has been judged too cumbersome. To automatically\npanic on error values, the <code>.unwrap()</code> method is added:</p>\n\n<pre><code>let f = File::open(\"eep.txt\").unwrap();\n</code></pre>\n\n<p>In Erlang, we could approximate this with:</p>\n\n<pre><code>unwrap({ok, X}) -&gt; X;\nunwrap({error, T}) -&gt; exit(T).\n\nF = unwrap(file:open(\"eep.txt\", Opts)).\n</code></pre>\n\n<p>Another construct exists to return errors to caller code more directly,\nwithout panics, with the <code>?</code> operator:</p>\n\n<pre><code>fn read_eep() -&gt; Result&lt;String, io::Error&gt; {\n    let mut h = File::open(\"eep.txt\")?;\n    let mut s = String::new();\n    h.read_to_string(&amp;mut s)?;\n    Ok(s)\n}\n</code></pre>\n\n<p>Any value <code>Ok(T)</code> encountering <code>?</code> is unwrapped. Any value <code>Err(E)</code>\nencountering <code>?</code> is returned to the caller as-is, as if a <code>match</code> with\n<code>return</code> had been used. This operator however requires that the\nfunction's type signature use the <code>Result&lt;T, E&gt;</code> type as a return value.</p>\n\n<p>Prior to version 1.13, Rust used the <code>try!(Exp)</code> macro to the same\neffect, but found it too cumbersome. Compare:</p>\n\n<pre><code>try!(try!(try!(foo()).bar()).baz())\nfoo()?.bar()?.baz()?\n</code></pre>\n\n<h3>Swift</h3>\n\n<p>Swift supports exceptions, along with type annotations declaring that a\nfunction may raise exceptions, and <code>do ... catch</code> blocks.</p>\n\n<p>There is a special operator <code>try?</code> which catches any thrown exception\nand turns it into <code>nil</code>:</p>\n\n<pre><code>func someThrowingFunction() throws -&gt; Int {\n    // ...\n}\nlet x = try? someThrowingFunction()\n</code></pre>\n\n<p>Here <code>x</code> can either have a value of <code>Int</code> or <code>nil</code>. The data flow is\noften simplified by using <code>let</code> assignments in a conditional expression:</p>\n\n<pre><code>func fetchEep() -&gt; Eep? {\n    if let x = try? fetchEepFromDisk() { return x }\n    if let x = try? fetchEepFromServer() { return x }\n    return nil\n}\n</code></pre>\n\n<h3>Go</h3>\n\n<p>Go has some fairly anemic error handling. It has panics, and error\nvalues. Error values must be assigned (or explicitly ignored) but they\ncan be left unchecked and cause all kinds of issues.</p>\n\n<p>Nevertheless, Go exposed <a href=\"https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md\">plans for new error\nhandling</a>\nin future versions, which can be interesting.</p>\n\n<p>Rather than changing semantics of their error handling, Go designers are\nmostly considering syntactic changes to reduce the cumbersome nature of\ntheir errors.</p>\n\n<p>Go programs typically handled errors as follows:</p>\n\n<pre><code>func main() {\n        hex, err := ioutil.ReadAll(os.Stdin)\n        if err != nil {\n                log.Fatal(err)\n        }\n\n        data, err := parseHexdump(string(hex))\n        if err != nil {\n                log.Fatal(err)\n        }\n\n        os.Stdout.Write(data)\n}\n</code></pre>\n\n<p>The new proposed mechanism looks as follows:</p>\n\n<pre><code>func main() {\n    handle err {\n        log.Fatal(err)\n    }\n\n    hex := check ioutil.ReadAll(os.Stdin)\n    data := check parseHexdump(string(hex))\n    os.Stdout.Write(data)\n}\n</code></pre>\n\n<p>The <code>check</code> keyword asks to implicitly check whether the second return\nvalue <code>err</code> is equal to <code>nil</code> or not. If it is not equal to <code>nil</code>, the\nlatest defined <code>handle</code> block is called. It can return the result out to\nexit the function, repair some values, or simply panic, to name a few\noptions.</p>\n\n<h3>Elixir</h3>\n\n<p>Elixir has a slightly different semantic approach to error handling compared\nto Erlang. Exceptions are discouraged for control flow (while Erlang\nspecifically uses <code>throw</code> for it), and the <code>with</code> macro is introduced:</p>\n\n<pre><code>with {:ok, var} &lt;- some_call(),\n     {:error, _} &lt;- fail(),\n     {:ok, x, y} &lt;- parse_name(var)\ndo\n    success(x, y, var)\nelse\n    {:error, err} -&gt; handle(err)\n    nil -&gt; {:error, nil}\nend\n</code></pre>\n\n<p>The macro allows a sequence of pattern matches, after which the ˋdo ...ˋ\nblock is called. If any of the pattern matches fails, the failing value\ngets re-matched in the optional ˋelse ... end` section.</p>\n\n<p>This is the most general control flow in this document, being fully\nflexible with regards to which values it can handle. This was done in\npart because there is not a strong norm regarding error or valid values\nin either the Erlang nor Elixir APIs, at least compared to other\nlanguages here.</p>\n\n<p>This high level of flexibility has been criticized in some instances as\nbeing a bit confusing: it is possible for users to make error-only\nflows, success-only flows, mixed flows, and consequently the ˋelseˋ\nclause can become convoluted.</p>\n\n<p>The <a href=\"https://github.com/CrowdHailer/OK\">OK library</a> was released to\nexplicitly narrow the workflow to well-defined errors. It supports three forms,\nthe first of which is the <code>for</code> block:</p>\n\n<pre><code>OK.for do\n  user &lt;- fetch_user(1)\n  cart &lt;- fetch_cart(1)\n  order = checkout(cart, user)\n  saved_order &lt;- save_order(order)\nafter\n  saved_order\nend\n</code></pre>\n\n<p>It works by <em>only</em> matching on <code>{:ok, val}</code> to keep moving forwards when\nusing the <code>&lt;-</code> operator: the <code>fetch_user/1</code> function above must return\n<code>{:ok, user}</code> in order for the code to proceed. The <code>=</code> operator is\nallowed for pattern matches the same way it usually does within Elixir.</p>\n\n<p>Any return value that matches <code>{:error, t}</code> ends up returning directly\nout of the expression. The <code>after ... end</code> section takes the last value\nreturned, and if it isn't already in a tuple of the form <code>{:ok val}</code>, it\nwraps it as such.</p>\n\n<p>The second variant is the <code>try</code> block:</p>\n\n<pre><code>OK.try do\n  user &lt;- fetch_user(1)\n  cart &lt;- fetch_cart(1)\n  order = checkout(cart, user)\n  saved_order &lt;- save_order(order)\nafter\n  saved_order\nrescue\n  :user_not_found -&gt; {:error, missing_user}\nend\n</code></pre>\n\n<p>This variant will capture exceptions as well (in the <code>rescue</code> block),\nand will not re-wrap the final return value in the <code>after</code> section.</p>\n\n<p>The last variant for the library is the pipe:</p>\n\n<pre><code>def get_employee_data(file, name) do\n  {:ok, file}\n  ~&gt;&gt; File.read\n  ~&gt; String.upcase\nend\n</code></pre>\n\n<p>The goal of this variant is to simply thread together operations that\ncould result in either a success or error. The <code>~&gt;&gt;</code> operator matches\nand returns an <code>{:ok, term}</code> tuple, and the <code>~&gt;</code> operator wraps a value\ninto an <code>{:ok, term}</code> tuple.</p>\n\n<h2>Choosing <code>begin ... end</code> Expressions</h2>\n\n<p>Abstractions over error flow requires to define a scope limiting the\nway flow is controlled. Before choosing the <code>begin ... end</code> expression,\nthe following items needed consideration:</p>\n\n<ol>\n<li>what is the scope we need to cover</li>\n<li>what is the format of the structure to use</li>\n<li>why ending up with <code>begin ... end</code></li>\n</ol>\n\n<h3>Scoping Limits</h3>\n\n<p>In the languages mentioned earlier, two big error handling categories\nseem to emerge.</p>\n\n<p>The first group of language seems to track their error handling at the\nfunction level. For example, Go uses <code>return</code> to return early from the\ncurrent function.  Swift and Rust also scope their error handling\nabstractions to the current function, but they also make use of their\ntype signatures to keep information about the control flow\ntransformations taking place. Rust uses the <code>Result&lt;T, E&gt;</code> type\nsignature to define what operations are valid, and Swift asks of\ndevelopers that they either handle the error locally, or annotate the\nfunction with <code>throws</code> to make things explicit.</p>\n\n<p>On the other hand, Haskell's do notation is restricted to specific\nexpressions, and so are all of Elixir's mechanisms.</p>\n\n<p>Erlang, Haskell, and Elixir all primarily use recursion as an iteration\nmechanism, and (outside of Haskell's monadic constructs) do not support\n<code>return</code> control flow; it is conceptually more difficult for a <code>return</code>\n(or <code>break</code>) to be useful when iteration requires recursion:\n\"returning\" by exiting the current flow may not bail you out of what the\nprogrammer might consider a loop, for example.</p>\n\n<p>Instead, Erlang would use <code>throw()</code> exceptions as a control flow\nmechanism for non-local return, along with a <code>catch</code> or a <code>try ...\ncatch</code>. Picking a value-based error handling construct that acts at the\nfunction level would not necessarily be very interesting since almost\nany recursive procedure would still require using exceptions.</p>\n\n<p>As such, it feels simpler to use a self-contained construct built to\nspecifically focus on sequences of operations that contain value-based\nerrors.</p>\n\n<h3>Format of Structure</h3>\n\n<p>Prior attempts at abstracting value-based error handling in Erlang\noverloaded special constructs with parse transforms in order to provide\nspecific workflows.</p>\n\n<p>For example, the <a href=\"https://github.com/ferd/fancyflow\"><code>fancyflow</code></a>\nlibrary tried to abstract the following code:</p>\n\n<pre><code>sans_maybe() -&gt;\n    case file:get_cwd() of\n        {ok, Dir} -&gt;\n            case\n                file:read_file(\n                  filename:join([Dir, \"demo\", \"data.txt\"]))\n            of\n                {ok, Bin} -&gt;\n                    {ok, {byte_size(Bin), Bin}};\n                {error, Reason} -&gt;\n                    {error, Reason}\n            end;\n        {error, Reason} -&gt;\n            {error, Reason}\n    end.\n</code></pre>\n\n<p>as:</p>\n\n<pre><code>-spec maybe() -&gt; {ok, non_neg_integer()} | {error, term()}.\nmaybe() -&gt;\n    [maybe](undefined,\n            file:get_cwd(),\n            file:read_file(filename:join([_, \"demo\", \"data.txt\"])),\n            {ok, {byte_size(_), _}}).\n</code></pre>\n\n<p>And Erlando would replace:</p>\n\n<pre><code>write_file(Path, Data, Modes) -&gt;\n    Modes1 = [binary, write | (Modes -- [binary, write])],\n    case make_binary(Data) of\n        Bin when is_binary(Bin) -&gt;\n            case file:open(Path, Modes1) of\n                {ok, Hdl} -&gt;\n                    case file:write(Hdl, Bin) of\n                        ok -&gt;\n                            case file:sync(Hdl) of\n                                ok -&gt;\n                                    file:close(Hdl);\n                                {error, _} = E -&gt;\n                                    file:close(Hdl),\n                                    E\n                            end;\n                        {error, _} = E -&gt;\n                            file:close(Hdl),\n                            E\n                    end;\n                {error, _} = E -&gt; E\n            end;\n        {error, _} = E -&gt; E\n    end.\n</code></pre>\n\n<p>With monadic constructs in list comprehensions:</p>\n\n<pre><code>write_file(Path, Data, Modes) -&gt;\n    Modes1 = [binary, write | (Modes -- [binary, write])],\n    do([error_m ||\n        Bin &lt;- make_binary(Data),\n        Hdl &lt;- file:open(Path, Modes1),\n        Result &lt;- return(do([error_m ||\n                             file:write(Hdl, Bin),\n                             file:sync(Hdl)])),\n        file:close(Hdl),\n        Result]).\n</code></pre>\n\n<p>Those cases specifically aimed for a way to write sequences of\noperations where pre-defined semantics are bound by a special context,\nbut are limited to overloading constructs rather than introducing new\nones.</p>\n\n<p>By comparison, most of Erlang's control flow expressions follow similar\nstructures. See the following most common ones:</p>\n\n<pre><code>case ... of\n    Pattern [when Guard] -&gt; Expressions\nend\n\nif\n   Guard -&gt; Expressions\nend\n\nbegin\n    Expressions\nend\n\nreceive\n    Pattern [when Guard] -&gt; Expressions\nafter                                               % optional\n    IntegerExp -&gt; Expressions\nend\n\ntry\n    Expressions\nof                                                  % optional\n    Pattern [when Guard] -&gt; Expressions\ncatch                                               % optional\n    ExceptionPattern [when Guard] -&gt; Expressions\nafter                                               % optional\n    Expressions\nend\n</code></pre>\n\n<p>It therefore logically follows that if we were to add a new construct,\nit should be of the form</p>\n\n<pre><code>&lt;keyword&gt;\n    ...\nend\n</code></pre>\n\n<p>The questions remaining are: which keyword to choose, and which clauses\nto support.</p>\n\n<h3>Choosing <code>begin ... end</code></h3>\n\n<p>Initially, a format similar to Elixir's <code>with</code> expression was being\nconsidered:</p>\n\n<pre><code>&lt;keyword&gt;\n    Expressions | UnwrapExpressions\nof                                              % optional\n    Pattern [when Guard] -&gt; Expressions\nend\n</code></pre>\n\n<p>With this construct, the basic <code>&lt;keyword&gt; ... end</code> form would follow the\ncurrently proposed semantics, but the <code>of ...</code> section would allow\npattern matching on any return value from the expression, whether\n<code>{error, Reason}</code> or any non-exception value returned by the last\nexpression in the main section.</p>\n\n<p>This form would be in line with what <code>try ... of ... catch ... end</code>\nallows: once the main section is covered, more work can be done within\nthe same construct.</p>\n\n<p>However, <code>try ... of ... catch ... end</code> has a specific reason for\nintroducing the patterns and guards: protected code impacting tail\nrecursion.</p>\n\n<p>In a loop such as:</p>\n\n<pre><code>map_nocrash(_, []) -&gt; [];\nmap_nocrash(F, [H|T]) -&gt;\n    try\n        F(H)\n    of\n        Val -&gt; [Val | map_nocrash(F, T)]\n    catch\n        _:_ -&gt; map_nocrash(F, T)\n    end.\n</code></pre>\n\n<p>The <code>of</code> section allows to continue doing work in the case no exception\nhas happened, <em>without</em> having to protect more than the current scope of\nthe function, nor preventing tail-recursion by forcing a presence of\neach iteration on the stack.</p>\n\n<p>No such concerns exist for value-based error handling, and while the\n <code>of ... end</code> section might be convenient at times, it is strictly not\nnecessary for the construct to be useful.</p>\n\n<p>What was left was to choose a name. Initially, the <code>&lt;keyword&gt;</code> value\nchosen was <code>maybe</code>, based on the Maybe monad. The problem is that\nintroducing any new keyword carries severe risks to backwards\ncompatibility.</p>\n\n<p>For example, all of the following words were considered:</p>\n\n<pre><code>======= ================= =========================================\nKeyword Times used in OTP Rationale\n         as a function\n======= ================= =========================================\nmaybe   0                 can clash with existing used words,\n                           otherwise respects the spirit\noption  88                definitely clashes with existing code\nopt     68                definitely clashes with existing code\ncheck   49                definitely clashes with existing code\nlet     0                 word is already reserved and free, but\n                           makes no sense in context\ncond    0                 word is already reserved and free, may\n                           make sense, but would prevent the\n                           addition of a conditional expression\ngiven   0                 could work, kind of respects the context\nwhen    0                 reserved for guards, could hijack in new\n                          context but may be confusing\nbegin   0                 carries no conditional meaning, mostly\n                          free for overrides\n</code></pre>\n\n<p>Initially, this proposal expected to use the <code>maybe</code> keyword:</p>\n\n<pre><code>maybe\n    Pattern &lt;op&gt; Exp,\n    ...\nof\n    Pattern -&gt; Exp  % optional\nend\n</code></pre>\n\n<p>but for the reasons mentioned in the previous section, the <code>of ...</code>\nsection became non-essential.</p>\n\n<p>Then, with the strong requirements for backwards compatibility making it\ndifficult to introduce new keywords, along with the possibility to reuse\n<code>begin</code> without changing any of its current behavior, this form became the\nmost interesting one.</p>\n\n<p>The term <code>begin</code> is also reminiscent of transactions and abortive\ncontexts, which means that although not an ideal fit for value-based\nerror flow, it is also not entirely outlandish and could accept the new\nadded optional semantics without being too out of place.</p>\n\n<h2>A New Infix Operator</h2>\n\n<p>In order to form <code>UnwrapExpr</code>, there is a need for a mechanism to\nintroduce pattern matching with distinct semantics from regular pattern\nmatching.</p>\n\n<p>A naive parse transform approach with fake function calls would be the\nmost basic way to go:</p>\n\n<pre><code>begin\n    unwrap(Pattern, Exp),\n    % variables bound in Pattern are available in scope\nend\n</code></pre>\n\n<p>However, this would introduce pattern matches in non-left-hand-side\npositions and make nesting really weird to deal with without exposing\nparse transform details and knowing how the code is translated.</p>\n\n<p>A prefix keyword such <code>let &lt;Pattern&gt; = &lt;Exp&gt;</code> could also be used.\nSuch keywords unfortunately suffer the same issues as <code>maybe</code> would\nhave, and <code>let</code> typically has different implications.</p>\n\n<p>An infix operator seems like a good fit since pattern matching already\nuses them in multiple forms:</p>\n\n<ul>\n<li><code>=</code> is used for pattern matches. Overloading it in error flow would\nprevent regular matching from being used</li>\n<li><code>:=</code> is used for maps; using it could work, but would certainly be\nconfusing when handling nested maps in a pattern</li>\n<li><code>&lt;-</code> could make sense. It is already restricted in scope to list and\nbinary comprehensions and would therefore not clash nor be confused.\nHowever, the existing semantics of the operator imply a literal\npattern match working like a filter. We're looking for the filter-like\napproach, but want to introduce implicit elements (<code>{ok|error, ...}</code>)</li>\n<li><code>&lt;=</code> same as <code>&lt;-</code> but for binary generators</li>\n</ul>\n\n<p>It would make sense to check for new operators specifically for this\ncontext given the semantics:</p>\n\n<pre><code>=======  ===========================================================\nOperator Description\n=======  ===========================================================\n#=       no clash with other syntax (maps, records, integers), no\n         clash with abstract patterns EEP either.\n!=       No clash with message passing, but is sure to annone used\n         to C-style inequality checks\n&lt;~       Works with no known conflict; shouldn't clash with ROK's\n         frame proposals (uses infix ~ and &lt; &gt; as delimiters).\n&lt;|       reverse pipe operator. No obvious clash either\n</code></pre>\n\n<p>There is no strong argument for or against most of these. The choice of\n<code>&lt;~</code> mostly comes down to having similarity to list comprehensions' <code>&lt;-</code>\noperator both in semantics and appearance, although being different\noverall.</p>\n\n<h3>Operator Priority</h3>\n\n<p>Within the expected usage of the unwrap expressions, the <code>&lt;~</code> operator\nneeds to have a precedence rule such that:</p>\n\n<pre><code>X = {Y,X} &lt;~ &lt;Exp&gt;\n</code></pre>\n\n<p>Is considered a valid pattern match operation with <code>X = {Y,X}</code> being the\nwhole left-hand-side pattern, such that operation priorities are:</p>\n\n<pre><code>lhs &lt;~ rhs\n</code></pre>\n\n<p>Instead of</p>\n\n<pre><code>lhs = rhs &lt;~ &lt;...&gt;\n</code></pre>\n\n<p>In all other regards, the precedence rules should be the same as <code>=</code> in\norder to provide the most unsurprising experience possible.</p>\n\n<h2>Other Disregarded Approaches and Variations</h2>\n\n<p>Other approaches were considered in making this proposal, and ultimately\ndisregarded.</p>\n\n<h3>Elixir-Like Patterns in <code>with</code></h3>\n\n<p>The Elixir approach is fairly comprehensive, and rather powerful. Rather\nthan handling success or errors, it generalizes over pattern matching as\na whole.</p>\n\n<p>To explore bringing these semantics into the current proposed construct,\nwe will use the <code>&lt;-</code> operator from list comprehensions to mean \"match\nthe whole pattern or exit the block\". So instead of</p>\n\n<pre><code>begin\n    {X,Y} &lt;~ id({ok, {X,Y}})\n    ...\nend\n</code></pre>\n\n<p>We would have to write:</p>\n\n<pre><code>begin\n    {ok, {X,Y}} &lt;- id({ok, {X,Y}})\n    ...\nend\n</code></pre>\n\n<p>While this mechanism is fine to handle skipping pattern, it has some\nproblematic weaknesses in the context of error handling.</p>\n\n<p>One example of this could be taken from the OTP pull request that adds\nnew return value to packet reading based on inet options:\n<a href=\"https://github.com/erlang/otp/pull/1950\">#1950</a>.</p>\n\n<p>This PR adds a possible value for packet reception to the current form:</p>\n\n<pre><code>{ok, {PeerIP, PeerPort, Data}}\n</code></pre>\n\n<p>To ask make it possible to alternatively get:</p>\n\n<pre><code>{ok, {PeerIP, PeerPort, AncData, Data}}\n</code></pre>\n\n<p>Based on socket options set earlier. So let’s put it in context for the\ncurrent proposal:</p>\n\n<pre><code>begin\n    {X,Y} &lt;~ id({ok, {X,Y}}),\n    {PeerIP, PeerPort, Data} &lt;~ gen_udp:recv(...),\n    ...\nend\n</code></pre>\n\n<p>If <code>AncData</code> is received, an exception is raised: the value was not an\nerror but didn’t have the shape or type expected for the successful\npattern to match. Errors are still returned properly by exiting the\n<code>begin ... end</code> block, and we ensure correctness in what we handle and\nreturn.</p>\n\n<p>However, had we used this generalized form:</p>\n\n<pre><code>begin\n    {ok, {X,Y}} &lt;- id({ok, {X,Y}}),\n    {ok, {PeerIP, PeerPort, Data}} &lt;- gen_udp:recv(...),\n    ...\nend\n</code></pre>\n\n<p>Since the <code>&lt;-</code> operator would force a return on any non-matching value,\nthe whole expression, if the socket is misconfigured to return\n<code>AncData</code>, would return <code>{ok, {PeerIP, PeerPort, AncData, Data}}</code> on a\nfailure to match.</p>\n\n<p>Basically, an unexpected but good result could be returned from a\nfunction using the <code>begin ... end</code> construct, which would look like a\nsuccess while it was actually a complete failure to match and handle the\ninformation given.  This is made even more ambiguous when data has the\nright shape and type, but a set of bound variables ultimately define\nwhether the match succeeds or fails (in the case of a UDP socket,\nreturning values that comes from the wrong peer, for example).</p>\n\n<p>In worst cases, It could let raw unformatted data exit a conditional\npipeline with no way to detect it after the fact, particularly if later\nfunctions in <code>begin ... end</code> apply transformations to text, such as\nanonymizing or sanitizing data. This could be pretty unsafe\nand near impossible to debug well.</p>\n\n<p>Think for example of:</p>\n\n<pre><code>-spec fetch() -&gt; iodata().\nfetch() -&gt;\n    begin\n        {ok, B = &lt;&lt;_/binary&gt;&gt;} &lt;- f(),\n        true &lt;- validate(B),\n        {ok, sanitize(B)}\n    end.\n</code></pre>\n\n<p>If the value returned from <code>f()</code> turns out to be a list (say it’s a\nmisconfigured socket using <code>list</code> instead of <code>binary</code> as an option), the\nexpression will return early, the <code>fetch()</code> function will still return\n<code>{ok, iodata()}</code> but you couldn’t know as a caller whether it is the\ntransformed data or non-matching content. It would not be obvious to\nmost developers either that this could represent a major security risk\nby allowing unexpected data to be seen as clean data.</p>\n\n<p>This specific type of error is in fact possible in Elixir, but no such\nwarning appears to have been circulating within its community so far.</p>\n\n<p>It is basically a risky pattern if you want your code to be strict or\nfuture-proof in the context of error handling. The current proposal, by\ncomparison, would raise an exception on unexpected good values, therefore\npreventing ways to sneak such data into your control flow:</p>\n\n<pre><code>-spec fetch() -&gt; iodata().\nfetch() -&gt;\n    begin\n        B = &lt;&lt;_/binary&gt;&gt; &lt;~ f(),\n        _ &lt;~ validate(B), % returns ok if valid\n        {ok, sanitize(B)}\n    end.\n</code></pre>\n\n<p>Here misconfigured sockets won’t result in unchecked data passing trough\nyour app.</p>\n\n<p>The only way to give a similar amount of safety to the general pattern\napproach is through an <code>else</code> clause which handles all known patterns to\nimplicitly exclude all unknown patterns:</p>\n\n<pre><code>-spec fetch() -&gt; iodata().\nfetch() -&gt;\n    begin\n        {ok, B = &lt;&lt;_/binary&gt;&gt;} &lt;- f(),\n        true &lt;- validate(B),\n        {ok, sanitize(B)}\n    else\n        {error, _} = E -&gt; E;\n        false -&gt; false\n    end.\n</code></pre>\n\n<p>This is the solution Elixir uses as well. Unless the clause is mandatory\n(it is not in Elixir), this level of additional matching is purely\noptional; the developer has no obvious incentive to go and handle these\nerrors, and if they do, the exception raised will be through a missing\nclause in the <code>else</code> section, which will obscure its origin and line\nnubmer.</p>\n\n<p>It would also allow some functions to return unexpected values from\nother ones. In the previous example, <code>f()</code> must be allowed to return\n<code>false</code> if <code>validate(B)</code> may return it. There is no way to separate such\nclauses.</p>\n\n<p>None of these problems exist as long as we normalize the matching\nmechanism on well-defined \"good\" and \"bad\" values (<code>ok | {ok, Term}</code> and\n<code>{error, Term}</code>). This separation between good and bad values allows to\nknow what needs to return early without conflicts with what is a valid\nor invalid pattern.</p>\n\n<p>From the moment we decide to pick such values, unwrapping them in\npatterns can make code clearer: <code>{error, X} &lt;- exp()</code> would be a pattern\nthat can never match by definition, since only good values are allowed\nto go through and all errors return early. Automatically unwrapping good\nvalues prevents such nonsensical expressions.</p>\n\n<p>These tricky corner cases explain why the <code>&lt;~</code> pattern is preferred to\nthe general <code>&lt;-</code> pattern's semantics in this proposal.</p>\n\n<h3>Simplifying Chaining an Pipelining</h3>\n\n<p>One approach or pain point frequently brough up about Erlang concern\npipelining of operations. Could it be possible to make some\noperations easier to chain?</p>\n\n<p>If we take a set of functions <code>f()</code>, <code>g()</code>, and <code>h()</code> that all return\n<code>{ok | error, _}</code> tuples, current day Erlang requires:</p>\n\n<pre><code>{ok, X} = f(),\n{ok, Y} = g(X),\n{ok, Z} = h(Y),\nZ\n</code></pre>\n\n<p>Could there be an easier way to handle this type of chaining, based on\nsay, an <code>unwrap</code> function:</p>\n\n<pre><code>unwrap({ok, X}) -&gt; X.\n\nmain() -&gt;\n    unwrap(h(unwrap(g(unwrap(f()))))).\n</code></pre>\n\n<p>And it appeared that generally, this turns out to be simple enough to do\nwith the earlier fold approach we had mentioned.</p>\n\n<p>Overall, the various existing mechanisms appeared slightly inconvenient,\nbut not inconvenient enough to be worth adding a whole new language\nmechanism just for it.</p>\n\n<h3><code>cond</code> and <code>cond let</code></h3>\n\n<p>Anthony Ramine recommended looking into reusing the already reserved\n<code>cond</code> and <code>let</code> keywords. He mentioned Rust planning something based on\nthese and how it could be ported to Erlang based on his prior work on\nsupporting the <code>cond</code> construct within the language.</p>\n\n<p>The proposed mechanism would look like:</p>\n\n<pre><code>cond\n    X &gt; 5 -&gt; % regular guard\n        Exp;\n    f() &lt; 18 -&gt; % function used in guard, as originally planned\n        Exp;\n    let {ok, Y} = exp(), Y &lt; 5 -&gt;\n        Exp\nend\n</code></pre>\n\n<p>The last clause would allow <code>Y</code> to be used in its own branch only if it\nmatches and all guards succeed; if the binding fails, a switch is\nautomatically made to the next branch.</p>\n\n<p>As such, more complex sequences of operations could be covered as:</p>\n\n<pre><code>cond\n    let {ok, _} = call1(),\n    let {ok, _} = call2(),\n    let Res = call3() -&gt;\n        Res;\n    true -&gt;\n        AlternativeBranch\nend\n</code></pre>\n\n<p>This mechanism is, in my opinion, worth exploring and maybe adding to\nthe language, but on its own does not adequately solve error handling\nflow issues since errors cannot be exracted easily from failing\noperations.</p>\n\n<h3>Auto-Wrapping Return Values</h3>\n\n<p>Auto-wrapping return values is something the Elixir's <code>OK</code> library does,\nas well as Haskell's do notation, but that neither Rust nor Swift does.</p>\n\n<p>It seems that there is no very clear consensus on what could be done.\nThus, for the simplicity of the implementation and backards\ncompatibility of the <code>begin ... end</code> expression, just returning the\nvalue as-is without auto-wrapping seems sensible.</p>\n\n<p>It would therefore be up to the developer to just return whatever value\nbest matches their function's type signature, making easier to still\nintegrate return values with the system they have.</p>\n\n<p>It also lets sequences of operations potentially return <code>ok</code> on success,\neven if their individual functions returned values such as <code>true</code>, for\nexample, rather than <code>{ok, true}</code>.</p>\n\n<h2>The choice of supported match values</h2>\n\n<p>It is kind of straightforward why <code>{ok, V}</code> and <code>{error, T}</code> are used in\npattern matches as error values: they're the most standard way to\ncommunicate a value and an error in non-overlapping patterns whichever\nway you want to match.</p>\n\n<p>On the other hand, it is less obvious why <code>_ &lt;~ Exp</code> should positively\nmatch on <code>ok</code> alone, and why, for example, <code>error</code> as an atom would\nraise an exception as not matching any patterns.</p>\n\n<p>The reason <code>ok</code> is considered valid can be found in comparing common\nErlang return values with their matches in other languages.</p>\n\n<p>The following functions return <code>ok</code> when everything went well but\nnothing is worth reporting. The list is not exhaustive:</p>\n\n<ul>\n<li><code>lists:foreach/2</code></li>\n<li>over 25 functions in the <code>file</code> module</li>\n<li>most functions in <code>disk_log</code></li>\n<li>most functions sending data or handling control of sockets and ports</li>\n<li>most output functions from the <code>io</code> module</li>\n<li>logging functions in the <code>logger</code> module</li>\n<li>functions from the <code>applications</code> module interacting with config and\nstarting or loading applications</li>\n</ul>\n\n<p>The pattern is fully entrenched as a core pattern in Erlang and OTP, and\nvery attached to side-effectful operations.</p>\n\n<p>The interesting aspect comes from seeing what Rust does for similar\nfunctions, which is just return their own unit type, denoted as <code>()</code>.\nWhen used with the <code>Result</code> types, it is to be returned a <code>OK(())</code>.</p>\n\n<p>The Erlang equivalent would probably be <code>{ok, undefined}</code>, but <code>ok</code> as a\nsingle atom currently plays that role fine, and so it was decided to\nsupport it; it will let error flow integrate well with side-effectful\nfunctions.</p>\n\n<p>The same cannot be said of <code>error</code> as an atom result. Most errors can\nand should return context with them that qualifies the error result,\nsince they often have more than one reason to fail. As evidence for this\nline of thought, it is currently not possible to raise exceptions\nwithout a <code>Reason</code>, whether done through <code>throw/1</code>, <code>error/1</code>,\n<code>exit/1-2</code>, or <code>raise/3</code>.</p>\n\n<p>Aligning with the standard practices in the Erlang language validate\nusing <code>_ &lt;~ Exp</code> as a pattern suitable for <code>ok</code>, and only this pattern\nsince it allows to basically match on what would be a non-existing value\nthat wouldn't need to be bound in further contexts.</p>\n\n<p>Discussions on earlier drafts of this proposal asked whether it would\nmake sense to choose all good values to be those in a tuple starting\nwith <code>ok</code> (<code>ok | {ok, _} | {ok, _, _} | ...</code>), and all error values all\nthose starting with error (<code>{error, _} | {error, _, _} | ...</code>).</p>\n\n<p>This approach would allow more flexibility on possible error values, but\nwould make composition more difficult. Let's take the following three\nfunction signatures as an example:</p>\n\n<pre><code>-spec f() -&gt; ok | {error, term()}.\n-spec g() -&gt; {ok, term()} | {error, term(), term()}.\n-spec h() -&gt; {ok, term(), [warning()]} | {error, term()}.\n</code></pre>\n\n<p>If a single <code>begin ... end</code> block calls to these as the potential return\nvalue of a function, the caller now has to have the following type\nspecification:</p>\n\n<pre><code>-spec caller() -&gt; ok | {ok, term()} | {ok, term(), [warning()]}\n                | {error, term()} | {error, term(), term()}.\n</code></pre>\n\n<p>As you call more and more functions and compose them together, the\ncross-section of what is a valid returning function grows in complexity\nand may even end up giving more trouble to tools such as Dialyzer.</p>\n\n<p>By comparison, the currently suggested mechanism can never get more\ncomplex than:</p>\n\n<pre><code>-spec caller() -&gt; ok | {ok, term()} | {error, term()}.\n</code></pre>\n\n<p>Or, if we prefer parametrized types:</p>\n\n<pre><code>-type result(E) :: ok | {error, E}.\n-type result(R, E) :: {ok, R} | {error, E}.\n\n-spec caller() -&gt; result(term()) | result(term(), term()).\n</code></pre>\n\n<p>By restricting the possible patterns (and therefore return values), we\ncan ensure better long-term composability and easier understanding of\nvarious such expressions.</p>\n\n<h2>Choosing Exceptions Raised</h2>\n\n<p>The exception format proposed here is <code>{badunwrap, Value}</code>. This format\nis chosen following Erlang/OTP standards:</p>\n\n<ul>\n<li><code>badarg</code></li>\n<li><code>badarith</code></li>\n<li><code>badfun</code></li>\n<li><code>{badmatch, Val}</code></li>\n</ul>\n\n<p>Since \"unwrapping\" is how the kind of operation where <code>X</code> is extracted\nfrom <code>{ok, X}</code>, the name <code>badunwrap</code> was chosen, along with the\nmismatching value being borrowed from <code>{badmatch, _}</code>.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The possibility of an early exit from a <code>begin ... end</code> expression\nmeans that variables declared within its scope are now potentially\nunsafe to use outside of it.</p>\n\n<p>This is a change of behaviour that brings <code>begin</code> in line with the\nvariables bound within a <code>case ... end</code> branch, a <code>try/catch</code> clause, or\na <code>receive ... end</code> branch.</p>\n\n<p>This lack of safety only needs to be started at the first <code>UnwrapExpr</code>\nencountered, since all variables bound before respect the same semantics\nas the existing <code>begin ... end</code> expression. If this analysis is done\nrather than just declaring all variables as unsafe wholesale, then there\nis no backwards compatibility concern to be had.</p>\n\n<p>The need for a new operator means code built with support for the new\nexpressions won't be portable to older Erlang releases.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>No reference implementation is usually required at this step, but one is\nnevertheless provided in the original repository for this EEP draft,\nat <a href=\"https://bitbucket.org/ferd/unwrap/\">bitbucket.org/ferd/unwrap/</a>.\nThe implementation uses parse transforms rather than an operator,\nsince it would be difficult to add custom operators at this point of the process.</p>\n"}},"__N_SSG":true}