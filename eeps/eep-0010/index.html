<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;
Status: Draft
Type: Standards Track
Created: 07-may-2008
Erlang-Version: R12B-4
Post-History: 01-jan-1970
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 10: <a href="eep-0010.md" title="EEP Source"> Representing Unicode characters in Erlang</a></h2>

<h1>Abstract</h1>

<p>This EEP suggest a standard representation of <a href="http://www.unicode.org/" title="The Unicode homepage, containing downloadable versions of the standard(s)">Unicode</a> characters in
Erlang, as well as the basic functionality to deal with them.</p>

<h1>Motivation</h1>

<p>As Unicode characters are more widely used, the need for a common
representation of Unicode characters in Erlang arise. Up until now,
the Erlang programmer writing Unicode programs has to decide on
his or her own representation and has little or no help from the
standard libraries. </p>

<p>Implementing functions in the libraries dealing with all possible
combinations and variants of Unicode representation in Erlang is
considered both extremely time consuming and confusing to the future
user of the standard library.</p>

<p>One common representation, dealing both with binaries and lists is
therefore desirable, making Unicode handling in the standard libraries
easier to implement and giving a more stringent result.</p>

<p>Once the representation is agreed upon, implementation can be done
incrementally. This EEP only outlines the most basic functionality the
system should provide. The Unicode support is by no means complete if
this EEP is implemented, but implementation will be feasible.</p>

<p>The EEP also suggests library functions and bit syntax to deal with
alternative encodings. However, one <em>standard</em> encoding is suggested,
which will be what library functions in Erlang are expected to
support, while other representations are supported only in terms of
conversion.</p>

<h1>Rationale</h1>

<h2>Preconditions</h2>

<p>Erlang traditionally represents text strings as lists of bytes (8bit
entities),  where the characters are encoded in ISO-8859-1 (latin1). </p>

<p>As the use of Unicode characters gets more widely spread, the demand
for a common view of how to represent Unicode characters in Erlang
arise.</p>

<p>Unicode is a character encoding standard where all known, living and
historical written languages are represented in one single character
set, which of course results in characters demanding more than eight
bits each for representation.</p>

<h2>Lists</h2>

<p>Regardless of the representation, the Unicode character set is a
super-set of the latin1 ditto, while latin1 in it's turn is a super-set
of the traditional 7-bit US-ASCII character set. Representing Unicode
characters in Erlang lists is therefore quite naturally done by
allowing characters in lists to take on values higher than 255.</p>

<p>Therefore a Unicode string can, in Erlang, be conveniently stored
as a list where each element represents one single Unicode
character. The following list:</p>

<pre><code>_ex1:

[1050,1072,1082,1074,
 1086,32,1077,32,85,110,105,99,111,100,101,32,63]
</code></pre>

<p>- would represent the Bulgarian translation of "What is Unicode ?" (which
looks something like like "KAKBO e Unicode ?" with only the last part
in latin letters). The last part
(<code>[32,85,110,105,99,111,100,101,32,63]</code>) is plain latin1 as the string
"Unicode ?" is written in latin letters, while the first part contains
characters not to be represented in a single byte. In essence, the
string is encoded in the Unicode encoding standard UTF-32, one
32bit entity for each character, which is more than sufficient for one
Unicode character per position.</p>

<p>However, the currently most common representation of Unicode
characters is <a href="http://www.ietf.org/rfc/rfc3629.txt" title="The UTF-8 RFC">UTF-8</a>, in which the characters are stored in one to
four 8-bit entities organized in such way that plain 7-bit US ASCII is
untouched, while characters 128 and upwards are split over more than
one byte. The advantage of this coding is that e.g. characters having
a meaning to the file/operating system are kept intact and that many
strings in western languages do not occupy more space when transformed
into Unicode. In such an encoding, the above mentioned Bulgarian
string (ex1_) would be represented as the list
<code>[208,154,208,176,208,186,208,178,208,
190,32,208,181,32,85,110,105,99,111,100,101,32,63]</code>, where the first
part, containing the Bulgarian script letters occupy more bytes per
character, while the trailing part "Unicode ?" is identical to the
plain and more intuitive encoding of one character per list element.</p>

<p>In spite of being less intuitive, the UTF-8 encoding is the one most
widely spread and supported by operating systems and terminal
emulators. UTF-8 is therefore the most convenient way to communicate
text to external entities (files, drivers, terminals and so on).</p>

<p>When dealing with lists in Erlang, the advantages of using one list
element per character seems to be greater than the advantage of not
having to convert a UTF-8 character string before e.g. printing
it on a terminal. This is especially true as the current Erlang
implementation allows for all current Unicode characters to
occupy the same memory space as a latin1 character would (bearing in
mind that each character is represented as an integer and the list
element can contain integers up to 16#7ffffff on 32-bit
implementations, which is far larger than the largest current Unicode
character 16#10ffff). A further advantage is that routines like
io:format can easily cope with latin1 characters and Unicode
characters alike, as the eight-bit characters of Unicode happen
to correspond exactly to the latin1 character set. It would seem as
lists have a very natural way of dealing with Unicode characters.</p>

<h2>Binaries</h2>

<p>Binaries on the other hand would suffer greatly from a scheme where
every character is encoded with a fixed width capable of representing
numbers up to 16#10ffff. The standardized way of doing this would be
what's commonly referred to as UTF-32, i.e. one 32-bit word for each
character. Even a UTF-16 representation would guarantee to double the
memory requirements for all text strings encoded in binaries, while
UTF-8 would for most common cases be the most space-saving
representation. </p>

<p>Binaries are often used to represent data to be sent
to external programs, which also speaks in favor of the UTF-8
representation. </p>

<p>There are however problems with the UTF-8 representation, most
obviously the fact that characters occupy a variable number of
positions (bytes) in the binary, so that traversal is somewhat more
tedious. An extension to the bit syntax where UTF-8 characters can be
matched in the head of a string conveniently would ease up the
situation, but as of today, no such primitives are present. UTF-8
encoded characters are also only backward compatible with 7-bit US-ASCII,
and there are only probabilistic approaches to determining if a
sequence of bytes represent Unicode characters encoded as UTF-8 or
plain latin1. A library function in Erlang therefore needs to be
informed about the way characters are encoded in a binary to be able
to interpret them correctly. A latin1 character above 128 will be
displayed incorrectly if written to a terminal set for displaying
UTF-8 encoded Unicode and v.v. As a common example
io:format("~s~n",[MyBinaryString]), would need to be informed about
the fact that the string is encoded in UTF-8 or latin1 to display it
correctly on a terminal. 
The formatting functions actually present a whole set of challenges
regarding Unicode characters. New formatting controls will be needed
to inform the formatting functions in the io and io_lib modules that 
strings are in Unicode or that input is in UTF-8. This is however
solvable, as discussed below.</p>

<p>My conclusion so far is that as binaries are often used to save space
and commonly utilized when communicating with external entities, the
UTF-8 advantages seem to supersede the disadvantages in the
binary case. It therefore seems sensible to commonly encode Unicode
characters in binaries as UTF-8. Of course any
representation is possible, but UTF-8 would be the most common
case and can therefore be regarded as the Erlang standard
representation.</p>

<h2>Combinations of lists and binaries</h2>

<p>To furthermore complicate things, Erlang has the concept of
iolist's (or iodata). An io_list is any (or almost any) combination of integers
and binaries representing a sequence of bytes, like i.e
<code>[[85],110,[105,[99]],111,&lt;&lt;100,101&gt;&gt;]</code> as a
representation of the string "Unicode". When sending data to drivers
and in many BIFs this rather convenient representation is accepted
(convenient when constructing, less convenient when traversing).</p>

<p>When dealing with Unicode strings, a similar abstraction would be
desirable, and with the above suggested conventions, that would mean
that a Unicode character string could be a list with any combination
of integers ranging from 0 to 16#10ffff and binaries with Unicode
characters encoded as UTF-8. Converting such data to a plain list or a
plain UTF-8 binary would be easily done as long as one knows how the
characters are encoded to begin with. It would however not necessarily
be an iolist. Furthermore conversion functions need to be aware of
the original intention of the list to behave correctly. If one wants
to convert an iolist containing latin1 characters in both list part
and binary part to UTF-8, the list part cannot be misinterpreted, as
latin1 and Unicode are alike for all latin1 characters, but the binary
part can, as latin1 characters above 127 are encoded in two bytes if
the binary contains UTF-8 encoded characters, but only one byte when
latin1 encoding is used. The same of course holds for other encodings,
if a binary encoded in UTF-32 would be converted to UTF-8, the process
also would differ from the process of converting latin1 characters.</p>

<p>If we stick with the idea of representing Unicode as one character per
list element in lists and as UTF-8 in binaries, we could have the
following definitions:</p>

<ul>
<li>A latin1 list: a list containing characters in the range 0..255</li>
<li>A latin1 binary: a binary consisting of bytes each representing one
           letter in the ISO-8859-1 character set.</li>
<li>A Unicode list: a list consisting solely of integers in the range
              0..16#10ffff.</li>
<li>A Unicode binary: a binary with Unicode characters encoded
                     as UTF-8</li>
<li>A mixed latin1 list: a possibly deep list containing any combination
                   of integers in the range 0..255 and latin1 binaries.</li>
<li>A mixed Unicode list: a possibly deep list containing integers in the
                    range 0..16#10ffff and Unicode binaries.</li>
</ul>

<h2>Conversion routines</h2>

<p>Conversion functions between latin1 lists and latin1 binaries as well
as from mixed latin1 lists to latin1 binaries are already present in
the system as list<em>to</em>binary, binary<em>to</em>list, and iolist<em>to</em>binary.</p>

<p>Conversion between Unicode lists, Unicode binaries, and from
mixed Unicode lists could in a similar way be provided by functions like:</p>

<pre><code>unicode:list_to_utf8(UM) -&gt; Bin
</code></pre>

<p>Where UM is a mixed Unicode list and the result is a UTF-8 binary, and:</p>

<pre><code>unicode:utf8_to_list(Bin) -&gt; UL
</code></pre>

<p>Where Bin is a binary consisting of Unicode characters encoded as
UTF-8 and UL is a plain list of Unicode characters.</p>

<p>To allow for conversion to and from latin1 the functions:</p>

<pre><code>unicode:latin1_list_to_utf8(LM) -&gt; Bin
</code></pre>

<p>and:</p>

<pre><code>unicode:latin1_list_to_unicode_list(LM) -&gt; UL
</code></pre>

<p>would do the same job. Actually latin1<em>list</em>to_list is not necessary
in this context, as it is more of an iolist-function, but should be 
present for completeness.</p>

<p>The fact that lists of integers representing latin1 characters are a
subset of the lists containing Unicode characters might however be more
confusing than useful to utilize when converting from mixed lists to
UTF-8 coded binaries. I think a good approach would be to
differentiate the functions dealing with latin1 characters and Unicode
so that mixed lists are expected to contain only numbers 0..255 if the
binaries are expected to contain latin1 bytes. For functions like
io:format, the same thing should be true i.e. ~s means latin1 mixed
lists and ~ts means Unicode mixed lists (with binaries in
UTF-8). Passing a list with an integer > 255 to ~s would be an error
with this approach, just like passing the same thing to
<code>latin1_list_to_utf8/1</code>. See below for more discussions about the io system. </p>

<p>The <code>unicode_list_to_utf8/1</code> and <code>latin1_list_to_utf8/1</code> functions can be 
combined into the single function <code>list_to_utf8/2</code> like this:</p>

<pre><code>unicode:characters_to_binary(ML,InEncoding) -&gt; binary()
  ML := A mixed Unicode list or a mixed latin1 list
  InEncoding := {latin1 | unicode}
</code></pre>

<p>The word "characters" is used to denote a possibly complex
representation of characters in the encoding concerned, like a short
word for "a possibly mixed and deep list of characters and/or binaries
in either latin1 representation or Unicode".</p>

<p>Giving latin1 as the encoding would mean that all of ML should be
interpreted as latin1 characters, implying that integers > 255 in the
list would be an error. Giving Unicode as the encoding would mean that
all integers 0..16#10ffff are accepted and the binaries are expected
to already be UTF-8 coded.</p>

<p>In the same way, conversion to lists of Unicode characters could be done with a function::</p>

<pre><code>unicode:characters_to_list(ML, InEncoding) -&gt; list() 
    ML := A mixed Unicode list or a mixed latin1 list
    InEncoding := {latin1 | unicode}
</code></pre>

<p>I think the approach of two simple conversion functions
characters<em>to</em>binary/2 and characters<em>to</em>list/2 is attractive, despite the fact
that certain combinations of in-data would be somewhat harder to
convert (e.g. combinations of Unicode characters > 255 in a list with
binaries in latin1). Extending the bit syntax to cope with UTF-8 would
make it easy to write special conversion functions to handle those
rare situations where the above mentioned functions cannot do the job.</p>

<p>To accommodate other encodings, the characters<em>to</em>binary functionality
could be extended to handle other encodings as well. A more general
functionality could be provided with the following functions
(preferably placed in their own module, the module name 'unicode'
being a good name-candidate):</p>

<p><strong>characters<em>to</em>binary(ML) -> binary() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}</strong></p>

<p>Same as characters<em>to</em>binary(ML,unicode,unicode).</p>

<p><strong>characters<em>to</em>binary(ML,InEncoding) -> binary() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}</strong></p>

<p>Same as characters<em>to</em>binary(ML,InEncoding,unicode).</p>

<p><strong>characters<em>to</em>binary(ML,InEncoding, OutEncoding) -> binary() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}</strong></p>

<p>Types:</p>

<ul>
<li>ML := A mixed list of integers or binaries corresponding to the
    InEncoding or a binary in the InEncoding</li>
<li>InEncoding := { latin1 | unicode | utf8 | utf16 | utf32 }</li>
<li>OutEncoding := { latin1 | unicode | utf8 | utf16 | utf32 }</li>
<li>Encoded := binary()</li>
<li>Rest := Mixed list as specified for ML.</li>
</ul>

<p>The option 'unicode' is an alias for utf8, as this is the
preferred encoding for Unicode characters in binaries. Error tuples
are returned when the data cannot be encoded/decoded due to errors
in indata and incomplete tuples when the indata is possibly correct
but truncated.</p>

<p><strong>characters<em>to</em>list(ML) -> list() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}</strong></p>

<p>Same as characters<em>to</em>list(ML,unicode).</p>

<p><strong>characters<em>to</em>list(ML,InEncoding) -> list() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}</strong></p>

<p>Types:  </p>

<ul>
<li>ML := A mixed list of integers or binaries corresponding to the
    InEncoding or a binary in the InEncoding</li>
<li>InEncoding := { latin1 | unicode | utf8 | utf16 | utf32 }</li>
<li>Encoded := list()</li>
<li>Rest := Mixed list as specified for ML.</li>
</ul>

<p>Here also the option 'unicode' denotes the default Erlang encoding
of utf8 in binaries and is therefore an alias for utf8. Error- and
incomplete-tuples are returned in the same way as for
characters<em>to</em>binary.</p>

<p>Note that as the datatypes returned upon success are well defined,
guard tests exist (is<em>list/1 and is</em>binary/1), why i suggest not
returning the clunky {ok, Data} tuples even though the error and
incomplete tuples can be returned. This makes the functions simpler to
use when the encoding is known to be correct while return values can
still be checked easily.</p>

<h2>Bit syntax</h2>

<p>Using Erlang bit syntax on binaries containing Unicode characters
in UTF-8 could be facilitated by a new type. The type name utf8 would
be preferable to utf-8, as dashes ("-") have special meaning in bit
syntax separating type, signedness, endianess and units.</p>

<p>The utf8 type in bit syntax matching would convert a UTF-8
coded character in the binary to an integer regardless of how many bytes it
occupies, leaving the trailing part of the binary to be matched against the
rest of the bit syntax matching expression.</p>

<p>When constructing binaries, an integer converted to UTF-8 could
consequently occupy between one and four bytes in the resulting binary.</p>

<p>As bit syntax is often used to interpret data from various external
sources, it would be useful to have corresponding utf16 and utf32
types as well. While UTF-8, UTF-16 and UTF-32 are easily interpreted
with the current bit syntax implementation, the suggested specific
types would be convenient for the programmer. Also Unicode imposes
restrictions in terms of range and has some forbidden ranges which are best
handled using a built in bit syntax type.</p>

<p>The utf16 and utf32 types need to have an endianess option, as UTF-16
and UTF-32 can be stored as big or little endian entities.</p>

<h2>Formatting functions</h2>

<p>Given a default Unicode character representation in Erlang, let's dig
deeper into the formatting functions. I suggest the concept of
formatting control sequence modifiers, an extra character between the
"~" and the control character, denoting Unicode input/output. The
letter "t" (for translate) is not used in any formatting functions
today, making it a good candidate. The meaning of the modifier should
be such that e.g. the formatting control "~ts" means a string in
Unicode while "~s" means means a string in iso-latin-1. The reason for not
simply introducing a new single control character, is that the
suggested modifier can be applicable to various control characters,
like e.g. "p" or even "w", while a new single control character for
Unicode strings would only be a replacement for the current "s"
control character.</p>

<p>Although the io-protocol in Erlang from the beginning did not impose
any limit on what characters could be transferred between a client and
an io_server, demands for better performance
from the io-system in Erlang has made later
implementations use binaries for communication, which in practice has
made the io-protocol contain bytes, not general characters.</p>

<p>Furthermore has the fact that the io-system currently works with
characters that can be represented as bytes been utilized in numerous
applications, so that output from io-functions (i.e. io<em>lib:format)
has been sent directly to entities only accepting byte input (like
sockets) or that io</em>servers have been implemented assuming only
character ranges of 0 - 255. Of course this can be changed, but such a
change might include lower performance from the io-system as well as
large changes to code already in production (aka "customer code").</p>

<p>The io-system in Erlang currently works around an assumption that data
is always a stream of bytes. Although this was not the original
intention, this is how it's today used. This means that a latin1
string can be sent to a terminal or a file in much the same way, there
will never be any conversion needed. This might not always hold for
terminals, but in case of terminals there is always one single
conversion needed, namely that from the byte-stream to whatever the
terminal likes. A disk-file is a stream of bytes as well as a terminal
is, at least as far as the Erlang io-system is concerned. Furthermore
the io<em>lib formatting function always returns (possibly) deep lists of
integers, each representing one character, making it hard to
differentiate between different encodings. The result is then sent as
is by functions like io:format to the io</em>server where it is finally
put on the disk. The servers also accept binaries, but they are never
produced by io_lib:format.</p>

<p>When Erlang starts supporting Unicode characters, the world changes a
little. A file might contain text in UTF-8 or in iso-latin-1 and there is
no telling from the list produced by e.g io_lib:format
what the user originally intended. </p>

<p>Suggested solution
...................</p>

<p>To make a solution that as far as possible does not break current code
and also keeps (or reverts to) the original intention of the io-system
protocol, I suggest a scheme where the formatting functions that
return lists, keep to the current behavior as far as possible.</p>

<p>So the io<em>lib:format function returns a (possibly deep) list of
integers 0..255 (latin1, which can be viewed as a subset of Unicode)
if used without translation modifiers. If the translation modifiers
are used, it will however return a possibly deep list of integers in
the complete unicode range. Going back to the Bulgarian string (ex1</em>),
let's look at the following::</p>

<pre><code>1&gt; UniString = [1050,1072,1082,1074,
            1086,32,1077,32,85,110,105,99,111,100,101,32,63].
2&gt; io_lib:format("~s",[UniString]).
</code></pre>

<p>- here the Unicode string violates the mixed latin1 list property and a
badarg exception will be raised. This behavior should be retained. On
the other hand::</p>

<pre><code>3&gt; io_lib:format("~ts",[UniString]).
</code></pre>

<p>- would return a (deep) list with the Unicode string as a list of integers::</p>

<pre><code>[[1050,1072,1082,1074,1086,32,1077,32,85,110,105,99,111,100,
  101,32,63]]
</code></pre>

<p>The downside of introducing integers > 255 in the result list is of course
that the return value of the function is no longer valid iodata(), but on
the other hand, the following code::</p>

<pre><code>lists:flatten(io_lib:format("~ts",[UniString]))
</code></pre>

<p>will give a result similar to that of a non-Unicode version. </p>

<p>As the format modifier "t" is new, the possibility to get integers >
255 in the resulting deep list will not break old code. To get
iodata() in UTF-8, one could simply do::</p>

<pre><code>unicode:characters_to_binary(io_lib:format("~ts",[UniString]),
                             unicode, unicode)
</code></pre>

<p>As before, directly formatting (with ~s) a list of characters > 255
would be an error, but with the "t" modifier it would work.</p>

<p>When it comes to range checking and backward compatibility::  </p>

<pre><code>6&gt; io:format(File,"~s",[UniString]).
</code></pre>

<p>- would as before throw the badarg exception, while::</p>

<pre><code>7&gt; io:format(File,"~ts",[UniString]).
</code></pre>

<p>- would be accepted. </p>

<p>The corresponding behavior of io:fread/2,3 would be to expect Unicode data in this call::</p>

<pre><code>11&gt; io:fread(File,'',"~ts").
</code></pre>

<p>- but expect latin1 in this::</p>

<pre><code>12&gt; io:fread(File,'',"~s").
</code></pre>

<p>The actual io-protocol, on the other hand, should deal only with
Unicode, meaning that when data is converted to binaries for sending,
all data should be translated into UTF-8. When lists of integers are
used in communication, the latin1 and Unicode representations are the
same, why no conversion or restrictions apply. Recall that the
io-system is built so that characters should have one interpretation
regardless of the io-server. The only possible encoding would be a
Unicode one.</p>

<p>As we are communicating heavily between processes (the client and
server processes in the io-system), converting the data to Unicode
binaries (UTF-8) is the most efficient strategy for larger amounts of
data.</p>

<p>Generally, writing
to an io-server using the file-module will only be possible with
byte-oriented data, while using the io-module will work on Unicode
characters. Calling the function file\:write/2 will send the bytes to
the file as is, as files are byte-oriented, but when writing on a file
using the io-module, Unicode characters are expected and handled.</p>

<p>The io-protocol will make conversions of bytes into Unicode when
sending to io-servers, but if the file is byte-oriented, the
conversion back will make this transparent to the user. All bytes are
representable in UTF-8 and can be converted back and forth without hassle.</p>

<p>The incompatible change will have to be to the put_chars function in
io. It should only allow Unicode data, not iodata() as it is
documented to do now. The big change being that any binaries provided
to the function need to be in UTF-8. However, most usage of this
function is restricted to lists, why this incompatible change is
expected not to cause trouble for users.</p>

<p>To handle possible Unicode text data on a file, one should be able to
provide encoding parameters when opening a file. A file should by
default be opened for byte (or latin1) encoding, while the option to
open it for i.e. utf8 translation should be available.</p>

<p>Lets look at some examples:</p>

<p>Example 1 - common byte-oriented writing
........................................</p>

<p>A file is opened as usual with file\:open. We then want to write bytes
to it:</p>

<ul>
<li><p>Using file\:write with iodata() (bytes), the data is converted into
UTF-8 by the io-protocol, but the io-server will convert it back to
latin1 before actually putting the bytes on file. For better
performance, the file could be opened in raw mode, avoiding all
conversion.</p></li>
<li><p>Using file\:write with data already converted to UTF-8 by the user,
the io-protocol will embed this in yet another layer of UTF-8
encoding, the file-server will unpack it and we will end up with the
UTF-8 bytes written to the file as expected.</p></li>
<li><p>Using io:put<em>chars, the io-server will return an error if any of the
Unicode characters sent are not possible to represent in one
byte. Characters representable in latin1 will however be written
nicely even though they might be encoded as UTF-8 in binaries sent
to io:put</em>chars. As long as the io<em>lib:format function is used
without the translation-modifier, everything will be valid latin1
and all return values will be lists, why it is both valid Unicode *and*
possible to write on a default file. Old code will function as
before, except when feeding io:put</em>chars with latin1 binaries, in
that case the call should be replaced with a file\:write call.</p></li>
</ul>

<p>Example 2 - Unicode-oriented writing
....................................</p>

<p>A file is opened using a parameter telling that Unicode data should be
written in a defined encoding, in this case we'll select UTF-16/bigendian to
avoid mix-ups with the native UTF-8 encoding. We open the file with
file\:open(Name,[write,{encoding,utf16,bigendian}]). </p>

<ul>
<li><p>Using file\:write with iodata(), the io-protocol will convert into
the default Unicode representation (UTF-8) and send the data to the
io-server, which will in turn convert the data to UTF-16 and put it
on the file. The file is to be regarded as a text file and all
iodata() sent to it will be regarded as text.</p></li>
<li><p>If the data is already in Unicode representation (say UTF-8) it
should not be written to this type of file using file\:write,
io:put_chars is expected to be used (which is not a problem as
Unicode data should not exist in old code and this is only a problem
when the file is opened to translate).</p></li>
<li><p>If the data is in the Erlang default Unicode format, it can be
written to the file using io:put<em>chars. This works for all types of
lists with integers and for binaries in UTF-8, for other
representations (most notably latin1 in binaries) the data should be
converted using Unicode:characters</em>to_XXX(Data,latin1) prior to
sending. For latin1 mixed lists (iodata()), file\:write can also be
used directly.</p></li>
</ul>

<p>To sum up this case - Unicode strings (including latin1 lists) are
written to a converting file using io:put_chars, but pure iodata() can
also be implicitly converted to the encoding by using file\:write.</p>

<p>Example 3 - raw writing
.......................</p>

<p>A file opened for raw access will only handle bytes, it cannot be used
together with io:put_chars.</p>

<ul>
<li><p>Data formatted with io<em>lib:format can still be written to a raw file
using file\:write. The data will end up being written as is. If the
translation modifier is consistently used when formatting, the file
will get the native UTF-8 encoding, if no translation modifiers are
used, the file will have latin1 encoding (each character in the list
returned from io</em>lib:format will be representable as a latin1
byte). If data is generated in different ways, the conversion
functions will have to be used.</p></li>
<li><p>Data written with file\:write will be put on the file directly, no
conversion to and from Unicode representation will happen.</p></li>
</ul>

<p>Example 4 - byte-oriented reading
.................................</p>

<p>When a file is opened for reading, much the same things apply as for
writing.</p>

<ul>
<li><p>file\:read on any file will expect the io-protocol to deliver data as
Unicode. Each byte will be converted to Unicode by the io_server and
turned back to a byte by file\:read</p></li>
<li><p>If the file actually contains Unicode characters, they will be byte-wise
converted to Unicode and then back, giving file\:read the
original encoding. If read as (or converted to) binaries they can
then easily be converted back to the Erlang default representation
by means of the conversion routines.</p></li>
<li><p>If the file is read with io:get<em>chars, all characters will be
returned in a list as expected. All characters will be latin1, but
that is a subset of Unicode and there will be no difference to
reading a translating file. If the file however contains Unicode
converted characters and is read in this way, the return value from
io:get</em>chars will be hard to interpret, but that is to be
expected. If such a functionality is desired, the list can be
converted to a binary with list<em>to</em>binary and then explored as a
Unicode entity in the encoding the file actually has.</p></li>
</ul>

<p>Example 5 - Unicode file reading
................................</p>

<p>As when writing, reading Unicode converting files is best done with
the io-module. Let's once again assume UTF-16 on the file.</p>

<ul>
<li><p>When reading using file\:read, the UTF-16 data will be converted into
a Unicode representation native to Erlang and sent to the
client. If the client is using file\:read, it will translate the data
back to bytes in the same way as bytes were translated to Unicode
for the protocol when writing. Is everything representable as bytes,
the function will succeed, but if any Unicode character larger than
255 is present, the function will fail with a decoding error.</p></li>
<li><p>Unicode data in the range over code-point 255 can not be retrieved by
use of the file-module. The io-module should be used instead.</p></li>
<li><p>io:get<em>chars and io:get</em>line will work on the Unicode data provided
by the io-protocol. All Unicode returns will be as Unicode lists as
expected. The fread function will return lists with integers > 255 only
when the translation modifier is supplied.</p></li>
</ul>

<p>Example 6 - raw reading
.......................</p>

<p>As with writing, only the file module can be used and only byte
oriented data is read. If encoded, the encoding will remain when
reading and writing raw files.</p>

<p>Conclusions from the examples
.............................</p>

<p>With this solution, the file module is consistent with latin1
io<em>servers (aka common files) and raw files. A file type, a translating
file, is added for the io-module to be able to get implicit conversion
of its Unicode data (another example of such an io</em>server with
implicit conversion would of course be the
terminal). Interface-wise,common files behave as before and we only
get added functionality. </p>

<p>The downsides are the subtly changed behavior of io:put_chars and the
performance impact by the conversion to and from Unicode
representations when using the file module on non-raw files with
default (latin1/byte) encoding. The latter may be possible to change
by extending the io-protocol to tag whole chunks of data as bytes
(latin1) or Unicode, but using raw files for writing large amounts of
data is often the better solution in those cases.</p>

<h1>Specification</h1>

<h2>Convention</h2>

<p>I suggest the convention of letting the Unicode representation in
lists be one character per element, in binaries UTF-8 and in mixed
Unicode entities a combination of those.</p>

<h2>Conversion to and from latin1 and UTF-8</h2>

<p>I also suggest a module 'unicode', containing functions for
converting between representations of Unicode. The default format for
all functions should be utf8 in binaries to point out this as the
preferred internal representation of Unicode characters in binaries. </p>

<p>The two main conversion functions should be characters<em>to</em>binary/3 and
characters<em>to</em>list/2 as described above.</p>

<h2>Bit syntax</h2>

<p>I suggest an extension to the bit syntax, allowing matching and
construction in UTF-8 coding, e.g::</p>

<pre><code>&lt;&lt;Ch/utf8,_/binary&gt;&gt; = BinString
</code></pre>

<p>as well as::</p>

<pre><code>MyBin = &lt;&lt;Ch/utf8,More/binary&gt;&gt;
</code></pre>

<p>Optionally UTF-16 could be supported in a similar way for binaries, e.g::</p>

<pre><code>&lt;&lt;Ch/utf16-little,_/binary&gt;&gt; = BinString
</code></pre>

<p>UTF-32 will need to be supported in a similar way as UTF-16, both for
completeness and for the range-checking that will be involved when
converting Unicode characters.</p>

<h2>Formatting</h2>

<p>I finally suggest the "t" modifier to control sequence in the
formatting function, which expects mixed lists of integers
0..16#10ffff and binaries with UTF-8 coded Unicode characters. The
functions in  io and io_lib will retain their current
functionality for code not using the translation modifier, but will
return Unicode characters when ordered to.  </p>

<p>The fread function should in the same way accept Unicode data only
when the "t" modifier is used.</p>

<p>The io-protocol need to be changed to always handle Unicode characters.
Options given when opening a file will allow for implicit conversion of
text files.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0010","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Patrik Nyblom \u0026lt;pan(at)erlang(dot)org\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 07-may-2008\nErlang-Version: R12B-4\nPost-History: 01-jan-1970\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 10: \u003ca href=\"eep-0010.md\" title=\"EEP Source\"\u003e Representing Unicode characters in Erlang\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP suggest a standard representation of \u003ca href=\"http://www.unicode.org/\" title=\"The Unicode homepage, containing downloadable versions of the standard(s)\"\u003eUnicode\u003c/a\u003e characters in\nErlang, as well as the basic functionality to deal with them.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eAs Unicode characters are more widely used, the need for a common\nrepresentation of Unicode characters in Erlang arise. Up until now,\nthe Erlang programmer writing Unicode programs has to decide on\nhis or her own representation and has little or no help from the\nstandard libraries. \u003c/p\u003e\n\n\u003cp\u003eImplementing functions in the libraries dealing with all possible\ncombinations and variants of Unicode representation in Erlang is\nconsidered both extremely time consuming and confusing to the future\nuser of the standard library.\u003c/p\u003e\n\n\u003cp\u003eOne common representation, dealing both with binaries and lists is\ntherefore desirable, making Unicode handling in the standard libraries\neasier to implement and giving a more stringent result.\u003c/p\u003e\n\n\u003cp\u003eOnce the representation is agreed upon, implementation can be done\nincrementally. This EEP only outlines the most basic functionality the\nsystem should provide. The Unicode support is by no means complete if\nthis EEP is implemented, but implementation will be feasible.\u003c/p\u003e\n\n\u003cp\u003eThe EEP also suggests library functions and bit syntax to deal with\nalternative encodings. However, one \u003cem\u003estandard\u003c/em\u003e encoding is suggested,\nwhich will be what library functions in Erlang are expected to\nsupport, while other representations are supported only in terms of\nconversion.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003ch2\u003ePreconditions\u003c/h2\u003e\n\n\u003cp\u003eErlang traditionally represents text strings as lists of bytes (8bit\nentities),  where the characters are encoded in ISO-8859-1 (latin1). \u003c/p\u003e\n\n\u003cp\u003eAs the use of Unicode characters gets more widely spread, the demand\nfor a common view of how to represent Unicode characters in Erlang\narise.\u003c/p\u003e\n\n\u003cp\u003eUnicode is a character encoding standard where all known, living and\nhistorical written languages are represented in one single character\nset, which of course results in characters demanding more than eight\nbits each for representation.\u003c/p\u003e\n\n\u003ch2\u003eLists\u003c/h2\u003e\n\n\u003cp\u003eRegardless of the representation, the Unicode character set is a\nsuper-set of the latin1 ditto, while latin1 in it's turn is a super-set\nof the traditional 7-bit US-ASCII character set. Representing Unicode\ncharacters in Erlang lists is therefore quite naturally done by\nallowing characters in lists to take on values higher than 255.\u003c/p\u003e\n\n\u003cp\u003eTherefore a Unicode string can, in Erlang, be conveniently stored\nas a list where each element represents one single Unicode\ncharacter. The following list:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e_ex1:\n\n[1050,1072,1082,1074,\n 1086,32,1077,32,85,110,105,99,111,100,101,32,63]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e- would represent the Bulgarian translation of \"What is Unicode ?\" (which\nlooks something like like \"KAKBO e Unicode ?\" with only the last part\nin latin letters). The last part\n(\u003ccode\u003e[32,85,110,105,99,111,100,101,32,63]\u003c/code\u003e) is plain latin1 as the string\n\"Unicode ?\" is written in latin letters, while the first part contains\ncharacters not to be represented in a single byte. In essence, the\nstring is encoded in the Unicode encoding standard UTF-32, one\n32bit entity for each character, which is more than sufficient for one\nUnicode character per position.\u003c/p\u003e\n\n\u003cp\u003eHowever, the currently most common representation of Unicode\ncharacters is \u003ca href=\"http://www.ietf.org/rfc/rfc3629.txt\" title=\"The UTF-8 RFC\"\u003eUTF-8\u003c/a\u003e, in which the characters are stored in one to\nfour 8-bit entities organized in such way that plain 7-bit US ASCII is\nuntouched, while characters 128 and upwards are split over more than\none byte. The advantage of this coding is that e.g. characters having\na meaning to the file/operating system are kept intact and that many\nstrings in western languages do not occupy more space when transformed\ninto Unicode. In such an encoding, the above mentioned Bulgarian\nstring (ex1_) would be represented as the list\n\u003ccode\u003e[208,154,208,176,208,186,208,178,208,\n190,32,208,181,32,85,110,105,99,111,100,101,32,63]\u003c/code\u003e, where the first\npart, containing the Bulgarian script letters occupy more bytes per\ncharacter, while the trailing part \"Unicode ?\" is identical to the\nplain and more intuitive encoding of one character per list element.\u003c/p\u003e\n\n\u003cp\u003eIn spite of being less intuitive, the UTF-8 encoding is the one most\nwidely spread and supported by operating systems and terminal\nemulators. UTF-8 is therefore the most convenient way to communicate\ntext to external entities (files, drivers, terminals and so on).\u003c/p\u003e\n\n\u003cp\u003eWhen dealing with lists in Erlang, the advantages of using one list\nelement per character seems to be greater than the advantage of not\nhaving to convert a UTF-8 character string before e.g. printing\nit on a terminal. This is especially true as the current Erlang\nimplementation allows for all current Unicode characters to\noccupy the same memory space as a latin1 character would (bearing in\nmind that each character is represented as an integer and the list\nelement can contain integers up to 16#7ffffff on 32-bit\nimplementations, which is far larger than the largest current Unicode\ncharacter 16#10ffff). A further advantage is that routines like\nio:format can easily cope with latin1 characters and Unicode\ncharacters alike, as the eight-bit characters of Unicode happen\nto correspond exactly to the latin1 character set. It would seem as\nlists have a very natural way of dealing with Unicode characters.\u003c/p\u003e\n\n\u003ch2\u003eBinaries\u003c/h2\u003e\n\n\u003cp\u003eBinaries on the other hand would suffer greatly from a scheme where\nevery character is encoded with a fixed width capable of representing\nnumbers up to 16#10ffff. The standardized way of doing this would be\nwhat's commonly referred to as UTF-32, i.e. one 32-bit word for each\ncharacter. Even a UTF-16 representation would guarantee to double the\nmemory requirements for all text strings encoded in binaries, while\nUTF-8 would for most common cases be the most space-saving\nrepresentation. \u003c/p\u003e\n\n\u003cp\u003eBinaries are often used to represent data to be sent\nto external programs, which also speaks in favor of the UTF-8\nrepresentation. \u003c/p\u003e\n\n\u003cp\u003eThere are however problems with the UTF-8 representation, most\nobviously the fact that characters occupy a variable number of\npositions (bytes) in the binary, so that traversal is somewhat more\ntedious. An extension to the bit syntax where UTF-8 characters can be\nmatched in the head of a string conveniently would ease up the\nsituation, but as of today, no such primitives are present. UTF-8\nencoded characters are also only backward compatible with 7-bit US-ASCII,\nand there are only probabilistic approaches to determining if a\nsequence of bytes represent Unicode characters encoded as UTF-8 or\nplain latin1. A library function in Erlang therefore needs to be\ninformed about the way characters are encoded in a binary to be able\nto interpret them correctly. A latin1 character above 128 will be\ndisplayed incorrectly if written to a terminal set for displaying\nUTF-8 encoded Unicode and v.v. As a common example\nio:format(\"~s~n\",[MyBinaryString]), would need to be informed about\nthe fact that the string is encoded in UTF-8 or latin1 to display it\ncorrectly on a terminal. \nThe formatting functions actually present a whole set of challenges\nregarding Unicode characters. New formatting controls will be needed\nto inform the formatting functions in the io and io_lib modules that \nstrings are in Unicode or that input is in UTF-8. This is however\nsolvable, as discussed below.\u003c/p\u003e\n\n\u003cp\u003eMy conclusion so far is that as binaries are often used to save space\nand commonly utilized when communicating with external entities, the\nUTF-8 advantages seem to supersede the disadvantages in the\nbinary case. It therefore seems sensible to commonly encode Unicode\ncharacters in binaries as UTF-8. Of course any\nrepresentation is possible, but UTF-8 would be the most common\ncase and can therefore be regarded as the Erlang standard\nrepresentation.\u003c/p\u003e\n\n\u003ch2\u003eCombinations of lists and binaries\u003c/h2\u003e\n\n\u003cp\u003eTo furthermore complicate things, Erlang has the concept of\niolist's (or iodata). An io_list is any (or almost any) combination of integers\nand binaries representing a sequence of bytes, like i.e\n\u003ccode\u003e[[85],110,[105,[99]],111,\u0026lt;\u0026lt;100,101\u0026gt;\u0026gt;]\u003c/code\u003e as a\nrepresentation of the string \"Unicode\". When sending data to drivers\nand in many BIFs this rather convenient representation is accepted\n(convenient when constructing, less convenient when traversing).\u003c/p\u003e\n\n\u003cp\u003eWhen dealing with Unicode strings, a similar abstraction would be\ndesirable, and with the above suggested conventions, that would mean\nthat a Unicode character string could be a list with any combination\nof integers ranging from 0 to 16#10ffff and binaries with Unicode\ncharacters encoded as UTF-8. Converting such data to a plain list or a\nplain UTF-8 binary would be easily done as long as one knows how the\ncharacters are encoded to begin with. It would however not necessarily\nbe an iolist. Furthermore conversion functions need to be aware of\nthe original intention of the list to behave correctly. If one wants\nto convert an iolist containing latin1 characters in both list part\nand binary part to UTF-8, the list part cannot be misinterpreted, as\nlatin1 and Unicode are alike for all latin1 characters, but the binary\npart can, as latin1 characters above 127 are encoded in two bytes if\nthe binary contains UTF-8 encoded characters, but only one byte when\nlatin1 encoding is used. The same of course holds for other encodings,\nif a binary encoded in UTF-32 would be converted to UTF-8, the process\nalso would differ from the process of converting latin1 characters.\u003c/p\u003e\n\n\u003cp\u003eIf we stick with the idea of representing Unicode as one character per\nlist element in lists and as UTF-8 in binaries, we could have the\nfollowing definitions:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eA latin1 list: a list containing characters in the range 0..255\u003c/li\u003e\n\u003cli\u003eA latin1 binary: a binary consisting of bytes each representing one\n           letter in the ISO-8859-1 character set.\u003c/li\u003e\n\u003cli\u003eA Unicode list: a list consisting solely of integers in the range\n              0..16#10ffff.\u003c/li\u003e\n\u003cli\u003eA Unicode binary: a binary with Unicode characters encoded\n                     as UTF-8\u003c/li\u003e\n\u003cli\u003eA mixed latin1 list: a possibly deep list containing any combination\n                   of integers in the range 0..255 and latin1 binaries.\u003c/li\u003e\n\u003cli\u003eA mixed Unicode list: a possibly deep list containing integers in the\n                    range 0..16#10ffff and Unicode binaries.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eConversion routines\u003c/h2\u003e\n\n\u003cp\u003eConversion functions between latin1 lists and latin1 binaries as well\nas from mixed latin1 lists to latin1 binaries are already present in\nthe system as list\u003cem\u003eto\u003c/em\u003ebinary, binary\u003cem\u003eto\u003c/em\u003elist, and iolist\u003cem\u003eto\u003c/em\u003ebinary.\u003c/p\u003e\n\n\u003cp\u003eConversion between Unicode lists, Unicode binaries, and from\nmixed Unicode lists could in a similar way be provided by functions like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:list_to_utf8(UM) -\u0026gt; Bin\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhere UM is a mixed Unicode list and the result is a UTF-8 binary, and:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:utf8_to_list(Bin) -\u0026gt; UL\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhere Bin is a binary consisting of Unicode characters encoded as\nUTF-8 and UL is a plain list of Unicode characters.\u003c/p\u003e\n\n\u003cp\u003eTo allow for conversion to and from latin1 the functions:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:latin1_list_to_utf8(LM) -\u0026gt; Bin\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:latin1_list_to_unicode_list(LM) -\u0026gt; UL\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewould do the same job. Actually latin1\u003cem\u003elist\u003c/em\u003eto_list is not necessary\nin this context, as it is more of an iolist-function, but should be \npresent for completeness.\u003c/p\u003e\n\n\u003cp\u003eThe fact that lists of integers representing latin1 characters are a\nsubset of the lists containing Unicode characters might however be more\nconfusing than useful to utilize when converting from mixed lists to\nUTF-8 coded binaries. I think a good approach would be to\ndifferentiate the functions dealing with latin1 characters and Unicode\nso that mixed lists are expected to contain only numbers 0..255 if the\nbinaries are expected to contain latin1 bytes. For functions like\nio:format, the same thing should be true i.e. ~s means latin1 mixed\nlists and ~ts means Unicode mixed lists (with binaries in\nUTF-8). Passing a list with an integer \u003e 255 to ~s would be an error\nwith this approach, just like passing the same thing to\n\u003ccode\u003elatin1_list_to_utf8/1\u003c/code\u003e. See below for more discussions about the io system. \u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eunicode_list_to_utf8/1\u003c/code\u003e and \u003ccode\u003elatin1_list_to_utf8/1\u003c/code\u003e functions can be \ncombined into the single function \u003ccode\u003elist_to_utf8/2\u003c/code\u003e like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:characters_to_binary(ML,InEncoding) -\u0026gt; binary()\n  ML := A mixed Unicode list or a mixed latin1 list\n  InEncoding := {latin1 | unicode}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe word \"characters\" is used to denote a possibly complex\nrepresentation of characters in the encoding concerned, like a short\nword for \"a possibly mixed and deep list of characters and/or binaries\nin either latin1 representation or Unicode\".\u003c/p\u003e\n\n\u003cp\u003eGiving latin1 as the encoding would mean that all of ML should be\ninterpreted as latin1 characters, implying that integers \u003e 255 in the\nlist would be an error. Giving Unicode as the encoding would mean that\nall integers 0..16#10ffff are accepted and the binaries are expected\nto already be UTF-8 coded.\u003c/p\u003e\n\n\u003cp\u003eIn the same way, conversion to lists of Unicode characters could be done with a function::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:characters_to_list(ML, InEncoding) -\u0026gt; list() \n    ML := A mixed Unicode list or a mixed latin1 list\n    InEncoding := {latin1 | unicode}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eI think the approach of two simple conversion functions\ncharacters\u003cem\u003eto\u003c/em\u003ebinary/2 and characters\u003cem\u003eto\u003c/em\u003elist/2 is attractive, despite the fact\nthat certain combinations of in-data would be somewhat harder to\nconvert (e.g. combinations of Unicode characters \u003e 255 in a list with\nbinaries in latin1). Extending the bit syntax to cope with UTF-8 would\nmake it easy to write special conversion functions to handle those\nrare situations where the above mentioned functions cannot do the job.\u003c/p\u003e\n\n\u003cp\u003eTo accommodate other encodings, the characters\u003cem\u003eto\u003c/em\u003ebinary functionality\ncould be extended to handle other encodings as well. A more general\nfunctionality could be provided with the following functions\n(preferably placed in their own module, the module name 'unicode'\nbeing a good name-candidate):\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003echaracters\u003cem\u003eto\u003c/em\u003ebinary(ML) -\u003e binary() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eSame as characters\u003cem\u003eto\u003c/em\u003ebinary(ML,unicode,unicode).\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003echaracters\u003cem\u003eto\u003c/em\u003ebinary(ML,InEncoding) -\u003e binary() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eSame as characters\u003cem\u003eto\u003c/em\u003ebinary(ML,InEncoding,unicode).\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003echaracters\u003cem\u003eto\u003c/em\u003ebinary(ML,InEncoding, OutEncoding) -\u003e binary() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eML := A mixed list of integers or binaries corresponding to the\n    InEncoding or a binary in the InEncoding\u003c/li\u003e\n\u003cli\u003eInEncoding := { latin1 | unicode | utf8 | utf16 | utf32 }\u003c/li\u003e\n\u003cli\u003eOutEncoding := { latin1 | unicode | utf8 | utf16 | utf32 }\u003c/li\u003e\n\u003cli\u003eEncoded := binary()\u003c/li\u003e\n\u003cli\u003eRest := Mixed list as specified for ML.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe option 'unicode' is an alias for utf8, as this is the\npreferred encoding for Unicode characters in binaries. Error tuples\nare returned when the data cannot be encoded/decoded due to errors\nin indata and incomplete tuples when the indata is possibly correct\nbut truncated.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003echaracters\u003cem\u003eto\u003c/em\u003elist(ML) -\u003e list() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eSame as characters\u003cem\u003eto\u003c/em\u003elist(ML,unicode).\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003echaracters\u003cem\u003eto\u003c/em\u003elist(ML,InEncoding) -\u003e list() | {error, Encoded, Rest} | {incomplete, Encoded, Rest}\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eTypes:  \u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eML := A mixed list of integers or binaries corresponding to the\n    InEncoding or a binary in the InEncoding\u003c/li\u003e\n\u003cli\u003eInEncoding := { latin1 | unicode | utf8 | utf16 | utf32 }\u003c/li\u003e\n\u003cli\u003eEncoded := list()\u003c/li\u003e\n\u003cli\u003eRest := Mixed list as specified for ML.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eHere also the option 'unicode' denotes the default Erlang encoding\nof utf8 in binaries and is therefore an alias for utf8. Error- and\nincomplete-tuples are returned in the same way as for\ncharacters\u003cem\u003eto\u003c/em\u003ebinary.\u003c/p\u003e\n\n\u003cp\u003eNote that as the datatypes returned upon success are well defined,\nguard tests exist (is\u003cem\u003elist/1 and is\u003c/em\u003ebinary/1), why i suggest not\nreturning the clunky {ok, Data} tuples even though the error and\nincomplete tuples can be returned. This makes the functions simpler to\nuse when the encoding is known to be correct while return values can\nstill be checked easily.\u003c/p\u003e\n\n\u003ch2\u003eBit syntax\u003c/h2\u003e\n\n\u003cp\u003eUsing Erlang bit syntax on binaries containing Unicode characters\nin UTF-8 could be facilitated by a new type. The type name utf8 would\nbe preferable to utf-8, as dashes (\"-\") have special meaning in bit\nsyntax separating type, signedness, endianess and units.\u003c/p\u003e\n\n\u003cp\u003eThe utf8 type in bit syntax matching would convert a UTF-8\ncoded character in the binary to an integer regardless of how many bytes it\noccupies, leaving the trailing part of the binary to be matched against the\nrest of the bit syntax matching expression.\u003c/p\u003e\n\n\u003cp\u003eWhen constructing binaries, an integer converted to UTF-8 could\nconsequently occupy between one and four bytes in the resulting binary.\u003c/p\u003e\n\n\u003cp\u003eAs bit syntax is often used to interpret data from various external\nsources, it would be useful to have corresponding utf16 and utf32\ntypes as well. While UTF-8, UTF-16 and UTF-32 are easily interpreted\nwith the current bit syntax implementation, the suggested specific\ntypes would be convenient for the programmer. Also Unicode imposes\nrestrictions in terms of range and has some forbidden ranges which are best\nhandled using a built in bit syntax type.\u003c/p\u003e\n\n\u003cp\u003eThe utf16 and utf32 types need to have an endianess option, as UTF-16\nand UTF-32 can be stored as big or little endian entities.\u003c/p\u003e\n\n\u003ch2\u003eFormatting functions\u003c/h2\u003e\n\n\u003cp\u003eGiven a default Unicode character representation in Erlang, let's dig\ndeeper into the formatting functions. I suggest the concept of\nformatting control sequence modifiers, an extra character between the\n\"~\" and the control character, denoting Unicode input/output. The\nletter \"t\" (for translate) is not used in any formatting functions\ntoday, making it a good candidate. The meaning of the modifier should\nbe such that e.g. the formatting control \"~ts\" means a string in\nUnicode while \"~s\" means means a string in iso-latin-1. The reason for not\nsimply introducing a new single control character, is that the\nsuggested modifier can be applicable to various control characters,\nlike e.g. \"p\" or even \"w\", while a new single control character for\nUnicode strings would only be a replacement for the current \"s\"\ncontrol character.\u003c/p\u003e\n\n\u003cp\u003eAlthough the io-protocol in Erlang from the beginning did not impose\nany limit on what characters could be transferred between a client and\nan io_server, demands for better performance\nfrom the io-system in Erlang has made later\nimplementations use binaries for communication, which in practice has\nmade the io-protocol contain bytes, not general characters.\u003c/p\u003e\n\n\u003cp\u003eFurthermore has the fact that the io-system currently works with\ncharacters that can be represented as bytes been utilized in numerous\napplications, so that output from io-functions (i.e. io\u003cem\u003elib:format)\nhas been sent directly to entities only accepting byte input (like\nsockets) or that io\u003c/em\u003eservers have been implemented assuming only\ncharacter ranges of 0 - 255. Of course this can be changed, but such a\nchange might include lower performance from the io-system as well as\nlarge changes to code already in production (aka \"customer code\").\u003c/p\u003e\n\n\u003cp\u003eThe io-system in Erlang currently works around an assumption that data\nis always a stream of bytes. Although this was not the original\nintention, this is how it's today used. This means that a latin1\nstring can be sent to a terminal or a file in much the same way, there\nwill never be any conversion needed. This might not always hold for\nterminals, but in case of terminals there is always one single\nconversion needed, namely that from the byte-stream to whatever the\nterminal likes. A disk-file is a stream of bytes as well as a terminal\nis, at least as far as the Erlang io-system is concerned. Furthermore\nthe io\u003cem\u003elib formatting function always returns (possibly) deep lists of\nintegers, each representing one character, making it hard to\ndifferentiate between different encodings. The result is then sent as\nis by functions like io:format to the io\u003c/em\u003eserver where it is finally\nput on the disk. The servers also accept binaries, but they are never\nproduced by io_lib:format.\u003c/p\u003e\n\n\u003cp\u003eWhen Erlang starts supporting Unicode characters, the world changes a\nlittle. A file might contain text in UTF-8 or in iso-latin-1 and there is\nno telling from the list produced by e.g io_lib:format\nwhat the user originally intended. \u003c/p\u003e\n\n\u003cp\u003eSuggested solution\n...................\u003c/p\u003e\n\n\u003cp\u003eTo make a solution that as far as possible does not break current code\nand also keeps (or reverts to) the original intention of the io-system\nprotocol, I suggest a scheme where the formatting functions that\nreturn lists, keep to the current behavior as far as possible.\u003c/p\u003e\n\n\u003cp\u003eSo the io\u003cem\u003elib:format function returns a (possibly deep) list of\nintegers 0..255 (latin1, which can be viewed as a subset of Unicode)\nif used without translation modifiers. If the translation modifiers\nare used, it will however return a possibly deep list of integers in\nthe complete unicode range. Going back to the Bulgarian string (ex1\u003c/em\u003e),\nlet's look at the following::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; UniString = [1050,1072,1082,1074,\n            1086,32,1077,32,85,110,105,99,111,100,101,32,63].\n2\u0026gt; io_lib:format(\"~s\",[UniString]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e- here the Unicode string violates the mixed latin1 list property and a\nbadarg exception will be raised. This behavior should be retained. On\nthe other hand::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e3\u0026gt; io_lib:format(\"~ts\",[UniString]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e- would return a (deep) list with the Unicode string as a list of integers::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[[1050,1072,1082,1074,1086,32,1077,32,85,110,105,99,111,100,\n  101,32,63]]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe downside of introducing integers \u003e 255 in the result list is of course\nthat the return value of the function is no longer valid iodata(), but on\nthe other hand, the following code::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003elists:flatten(io_lib:format(\"~ts\",[UniString]))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewill give a result similar to that of a non-Unicode version. \u003c/p\u003e\n\n\u003cp\u003eAs the format modifier \"t\" is new, the possibility to get integers \u003e\n255 in the resulting deep list will not break old code. To get\niodata() in UTF-8, one could simply do::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eunicode:characters_to_binary(io_lib:format(\"~ts\",[UniString]),\n                             unicode, unicode)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs before, directly formatting (with ~s) a list of characters \u003e 255\nwould be an error, but with the \"t\" modifier it would work.\u003c/p\u003e\n\n\u003cp\u003eWhen it comes to range checking and backward compatibility::  \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e6\u0026gt; io:format(File,\"~s\",[UniString]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e- would as before throw the badarg exception, while::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e7\u0026gt; io:format(File,\"~ts\",[UniString]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e- would be accepted. \u003c/p\u003e\n\n\u003cp\u003eThe corresponding behavior of io:fread/2,3 would be to expect Unicode data in this call::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e11\u0026gt; io:fread(File,'',\"~ts\").\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e- but expect latin1 in this::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e12\u0026gt; io:fread(File,'',\"~s\").\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe actual io-protocol, on the other hand, should deal only with\nUnicode, meaning that when data is converted to binaries for sending,\nall data should be translated into UTF-8. When lists of integers are\nused in communication, the latin1 and Unicode representations are the\nsame, why no conversion or restrictions apply. Recall that the\nio-system is built so that characters should have one interpretation\nregardless of the io-server. The only possible encoding would be a\nUnicode one.\u003c/p\u003e\n\n\u003cp\u003eAs we are communicating heavily between processes (the client and\nserver processes in the io-system), converting the data to Unicode\nbinaries (UTF-8) is the most efficient strategy for larger amounts of\ndata.\u003c/p\u003e\n\n\u003cp\u003eGenerally, writing\nto an io-server using the file-module will only be possible with\nbyte-oriented data, while using the io-module will work on Unicode\ncharacters. Calling the function file\\:write/2 will send the bytes to\nthe file as is, as files are byte-oriented, but when writing on a file\nusing the io-module, Unicode characters are expected and handled.\u003c/p\u003e\n\n\u003cp\u003eThe io-protocol will make conversions of bytes into Unicode when\nsending to io-servers, but if the file is byte-oriented, the\nconversion back will make this transparent to the user. All bytes are\nrepresentable in UTF-8 and can be converted back and forth without hassle.\u003c/p\u003e\n\n\u003cp\u003eThe incompatible change will have to be to the put_chars function in\nio. It should only allow Unicode data, not iodata() as it is\ndocumented to do now. The big change being that any binaries provided\nto the function need to be in UTF-8. However, most usage of this\nfunction is restricted to lists, why this incompatible change is\nexpected not to cause trouble for users.\u003c/p\u003e\n\n\u003cp\u003eTo handle possible Unicode text data on a file, one should be able to\nprovide encoding parameters when opening a file. A file should by\ndefault be opened for byte (or latin1) encoding, while the option to\nopen it for i.e. utf8 translation should be available.\u003c/p\u003e\n\n\u003cp\u003eLets look at some examples:\u003c/p\u003e\n\n\u003cp\u003eExample 1 - common byte-oriented writing\n........................................\u003c/p\u003e\n\n\u003cp\u003eA file is opened as usual with file\\:open. We then want to write bytes\nto it:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eUsing file\\:write with iodata() (bytes), the data is converted into\nUTF-8 by the io-protocol, but the io-server will convert it back to\nlatin1 before actually putting the bytes on file. For better\nperformance, the file could be opened in raw mode, avoiding all\nconversion.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUsing file\\:write with data already converted to UTF-8 by the user,\nthe io-protocol will embed this in yet another layer of UTF-8\nencoding, the file-server will unpack it and we will end up with the\nUTF-8 bytes written to the file as expected.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUsing io:put\u003cem\u003echars, the io-server will return an error if any of the\nUnicode characters sent are not possible to represent in one\nbyte. Characters representable in latin1 will however be written\nnicely even though they might be encoded as UTF-8 in binaries sent\nto io:put\u003c/em\u003echars. As long as the io\u003cem\u003elib:format function is used\nwithout the translation-modifier, everything will be valid latin1\nand all return values will be lists, why it is both valid Unicode *and*\npossible to write on a default file. Old code will function as\nbefore, except when feeding io:put\u003c/em\u003echars with latin1 binaries, in\nthat case the call should be replaced with a file\\:write call.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample 2 - Unicode-oriented writing\n....................................\u003c/p\u003e\n\n\u003cp\u003eA file is opened using a parameter telling that Unicode data should be\nwritten in a defined encoding, in this case we'll select UTF-16/bigendian to\navoid mix-ups with the native UTF-8 encoding. We open the file with\nfile\\:open(Name,[write,{encoding,utf16,bigendian}]). \u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eUsing file\\:write with iodata(), the io-protocol will convert into\nthe default Unicode representation (UTF-8) and send the data to the\nio-server, which will in turn convert the data to UTF-16 and put it\non the file. The file is to be regarded as a text file and all\niodata() sent to it will be regarded as text.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf the data is already in Unicode representation (say UTF-8) it\nshould not be written to this type of file using file\\:write,\nio:put_chars is expected to be used (which is not a problem as\nUnicode data should not exist in old code and this is only a problem\nwhen the file is opened to translate).\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf the data is in the Erlang default Unicode format, it can be\nwritten to the file using io:put\u003cem\u003echars. This works for all types of\nlists with integers and for binaries in UTF-8, for other\nrepresentations (most notably latin1 in binaries) the data should be\nconverted using Unicode:characters\u003c/em\u003eto_XXX(Data,latin1) prior to\nsending. For latin1 mixed lists (iodata()), file\\:write can also be\nused directly.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTo sum up this case - Unicode strings (including latin1 lists) are\nwritten to a converting file using io:put_chars, but pure iodata() can\nalso be implicitly converted to the encoding by using file\\:write.\u003c/p\u003e\n\n\u003cp\u003eExample 3 - raw writing\n.......................\u003c/p\u003e\n\n\u003cp\u003eA file opened for raw access will only handle bytes, it cannot be used\ntogether with io:put_chars.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eData formatted with io\u003cem\u003elib:format can still be written to a raw file\nusing file\\:write. The data will end up being written as is. If the\ntranslation modifier is consistently used when formatting, the file\nwill get the native UTF-8 encoding, if no translation modifiers are\nused, the file will have latin1 encoding (each character in the list\nreturned from io\u003c/em\u003elib:format will be representable as a latin1\nbyte). If data is generated in different ways, the conversion\nfunctions will have to be used.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eData written with file\\:write will be put on the file directly, no\nconversion to and from Unicode representation will happen.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample 4 - byte-oriented reading\n.................................\u003c/p\u003e\n\n\u003cp\u003eWhen a file is opened for reading, much the same things apply as for\nwriting.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003efile\\:read on any file will expect the io-protocol to deliver data as\nUnicode. Each byte will be converted to Unicode by the io_server and\nturned back to a byte by file\\:read\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf the file actually contains Unicode characters, they will be byte-wise\nconverted to Unicode and then back, giving file\\:read the\noriginal encoding. If read as (or converted to) binaries they can\nthen easily be converted back to the Erlang default representation\nby means of the conversion routines.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf the file is read with io:get\u003cem\u003echars, all characters will be\nreturned in a list as expected. All characters will be latin1, but\nthat is a subset of Unicode and there will be no difference to\nreading a translating file. If the file however contains Unicode\nconverted characters and is read in this way, the return value from\nio:get\u003c/em\u003echars will be hard to interpret, but that is to be\nexpected. If such a functionality is desired, the list can be\nconverted to a binary with list\u003cem\u003eto\u003c/em\u003ebinary and then explored as a\nUnicode entity in the encoding the file actually has.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample 5 - Unicode file reading\n................................\u003c/p\u003e\n\n\u003cp\u003eAs when writing, reading Unicode converting files is best done with\nthe io-module. Let's once again assume UTF-16 on the file.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eWhen reading using file\\:read, the UTF-16 data will be converted into\na Unicode representation native to Erlang and sent to the\nclient. If the client is using file\\:read, it will translate the data\nback to bytes in the same way as bytes were translated to Unicode\nfor the protocol when writing. Is everything representable as bytes,\nthe function will succeed, but if any Unicode character larger than\n255 is present, the function will fail with a decoding error.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUnicode data in the range over code-point 255 can not be retrieved by\nuse of the file-module. The io-module should be used instead.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eio:get\u003cem\u003echars and io:get\u003c/em\u003eline will work on the Unicode data provided\nby the io-protocol. All Unicode returns will be as Unicode lists as\nexpected. The fread function will return lists with integers \u003e 255 only\nwhen the translation modifier is supplied.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample 6 - raw reading\n.......................\u003c/p\u003e\n\n\u003cp\u003eAs with writing, only the file module can be used and only byte\noriented data is read. If encoded, the encoding will remain when\nreading and writing raw files.\u003c/p\u003e\n\n\u003cp\u003eConclusions from the examples\n.............................\u003c/p\u003e\n\n\u003cp\u003eWith this solution, the file module is consistent with latin1\nio\u003cem\u003eservers (aka common files) and raw files. A file type, a translating\nfile, is added for the io-module to be able to get implicit conversion\nof its Unicode data (another example of such an io\u003c/em\u003eserver with\nimplicit conversion would of course be the\nterminal). Interface-wise,common files behave as before and we only\nget added functionality. \u003c/p\u003e\n\n\u003cp\u003eThe downsides are the subtly changed behavior of io:put_chars and the\nperformance impact by the conversion to and from Unicode\nrepresentations when using the file module on non-raw files with\ndefault (latin1/byte) encoding. The latter may be possible to change\nby extending the io-protocol to tag whole chunks of data as bytes\n(latin1) or Unicode, but using raw files for writing large amounts of\ndata is often the better solution in those cases.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003ch2\u003eConvention\u003c/h2\u003e\n\n\u003cp\u003eI suggest the convention of letting the Unicode representation in\nlists be one character per element, in binaries UTF-8 and in mixed\nUnicode entities a combination of those.\u003c/p\u003e\n\n\u003ch2\u003eConversion to and from latin1 and UTF-8\u003c/h2\u003e\n\n\u003cp\u003eI also suggest a module 'unicode', containing functions for\nconverting between representations of Unicode. The default format for\nall functions should be utf8 in binaries to point out this as the\npreferred internal representation of Unicode characters in binaries. \u003c/p\u003e\n\n\u003cp\u003eThe two main conversion functions should be characters\u003cem\u003eto\u003c/em\u003ebinary/3 and\ncharacters\u003cem\u003eto\u003c/em\u003elist/2 as described above.\u003c/p\u003e\n\n\u003ch2\u003eBit syntax\u003c/h2\u003e\n\n\u003cp\u003eI suggest an extension to the bit syntax, allowing matching and\nconstruction in UTF-8 coding, e.g::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;Ch/utf8,_/binary\u0026gt;\u0026gt; = BinString\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eas well as::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eMyBin = \u0026lt;\u0026lt;Ch/utf8,More/binary\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOptionally UTF-16 could be supported in a similar way for binaries, e.g::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;Ch/utf16-little,_/binary\u0026gt;\u0026gt; = BinString\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUTF-32 will need to be supported in a similar way as UTF-16, both for\ncompleteness and for the range-checking that will be involved when\nconverting Unicode characters.\u003c/p\u003e\n\n\u003ch2\u003eFormatting\u003c/h2\u003e\n\n\u003cp\u003eI finally suggest the \"t\" modifier to control sequence in the\nformatting function, which expects mixed lists of integers\n0..16#10ffff and binaries with UTF-8 coded Unicode characters. The\nfunctions in  io and io_lib will retain their current\nfunctionality for code not using the translation modifier, but will\nreturn Unicode characters when ordered to.  \u003c/p\u003e\n\n\u003cp\u003eThe fread function should in the same way accept Unicode data only\nwhen the \"t\" modifier is used.\u003c/p\u003e\n\n\u003cp\u003eThe io-protocol need to be changed to always handle Unicode characters.\nOptions given when opening a file will allow for implicit conversion of\ntext files.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0010"},"buildId":"aoeL97fiGQMaunPBLLCoJ","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_buildManifest.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_ssgManifest.js" async=""></script></body></html>