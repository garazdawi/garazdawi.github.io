{"pageProps":{"item":{"id":"core-erlang-wrapup","title":"Core Erlang Wrap Up","author":"Björn Gustavsson","excerpt":"\nThis blog post wraps up the exploration of Core Erlang started in the\nprevious two blog posts. The remaining default Core Erlang\npasses are described, followed by a look at how Core Erlang is\nrepresented internally in the compiler.","article_date":1527638400000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Core Erlang Wrap Up","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post wraps up the exploration of Core Erlang started in the\nprevious two blog posts. The remaining default Core Erlang\npasses are described, followed by a look at how Core Erlang is\nrepresented internally in the compiler.\n\nHere are the Core Erlang passes that will be run when using\nOTP 21 RC1 or the `master` branch in the git repository:\n\n```\n$ erlc +time core_wrapup.erl\nCompiling \"core_wrapup\"\n     .\n     .\n     .\n core                          :      0.000 s      15.7 kB\n sys_core_fold                 :      0.000 s       9.0 kB\n sys_core_alias                :      0.000 s       9.0 kB\n core_transforms               :      0.000 s       9.0 kB\n sys_core_bsm                  :      0.000 s       9.0 kB\n sys_core_dsetel               :      0.000 s       9.0 kB\n     .\n     .\n     .\n```\n\nWe have covered `core` and `sys_core_fold` in the two previous\nblog posts about Core Erlang.\n\n## The other Core Erlang passes\n\n### sys_core_alias\n\nIn the upcoming OTP 21 release, there is a new `sys_core_alias` pass\ncontributed by [José Valim](https://github.com/josevalim).\n\nThe purpose of the pass is to avoid rebuilding terms that\nhave been matched, such as in this example:\n\n```erlang\nremove_even([{Key,Val}|T]) ->\n    case Val rem 2 =:= 0 of\n        true -> remove_even(T);\n        false ->  [{Key,Val}|remove_even(T)]\n    end;\nremove_even([]) -> [].\n```\n\nIn the function head, the pattern `{Key,Val}` binds two elements of a\ntuple to the variables `Key` and `Val`, but the original tuple is not\ncaptured. In the `false` clause of the `case`, a new tuple will be\nconstructed from `Key` and `Val`.\n\nIt is possible to avoid creating a new tuple by using the `=` operator\nto bind the complete tuple to a variable:\n\n```erlang\nremove_even([{Key,Val}=Tuple|T]) ->\n    case Val rem 2 =:= 0 of\n        true -> remove_even(T);\n        false ->  [Tuple|remove_even(T)]\n    end;\nremove_even([]) -> [].\n```\n\nEssentially, the new `sys_core_alias` pass does that transformation\nautomatically. Here is the Core Erlang code before applying this\noptimization:\n\n```\n'remove_even'/1 =\n    fun (_0) ->\n\tcase _0 of\n\t  <[{Key,Val}|T]> when 'true' ->\n\t      let <_1> =\n\t\t  call\n\t\t       'erlang':'rem'(Val, 2)\n\t      in\n\t\t  case <> of\n\t\t    <>\n\t\t\twhen call 'erlang':'=:='(_1, 0) ->\n\t\t\t    apply 'remove_even'/1(T)\n\t\t    <> when 'true' ->\n\t\t\tlet <_2> =\n\t\t\t    apply 'remove_even'/1(T)\n\t\t\tin\n                            [{Key,Val}|_2]      % BUILDING TUPLE\n\t\t  end\n\t  <[]> when 'true' ->\n\t      []\n\t  <_4> when 'true' ->\n\t\tprimop 'match_fail'({'function_clause',_4})\n\tend\n```\n\nHere is the code after running the `sys_core_alias` pass:\n\n```\n'remove_even'/1 =\n    fun (_0) ->\n\tcase _0 of\n\t  <[_@r0 = {Key,Val}|T]> when 'true' ->\n\t      let <_1> =\n\t\t  call 'erlang':'rem'(Val, 2)\n\t      in\n\t\t  case <> of\n\t\t    <>\n\t\t\twhen call 'erlang':'=:='(_1, 0) ->\n\t\t\t    apply 'remove_even'/1(T)\n\t\t    <> when 'true' ->\n\t\t\tlet <_2> =\n\t\t\t    apply 'remove_even'/1(T)\n\t\t\tin\n\t\t\t    [_@r0|_2]          % REUSING EXISTING TUPLE\n\t\t  end\n\t  <[]> when 'true' ->\n\t      []\n\t  <_4> when 'true' ->\n\t\tprimop 'match_fail'({'function_clause',_4})\n\tend\n```\n\n### core_transforms\n\nSimilar to parse transforms, the `core_transforms` pass makes it possible to\nadd compiler passes that transform the Core Erlang code without modifying\nthe compiler.\n\nAs an example, here is a simple core transform module:\n\n```erlang\n-module(my_core_transform).\n-export([core_transform/2]).\n\ncore_transform(Core, _Options) ->\n    Module = cerl:concrete(cerl:module_name(Core)),\n    io:format(\"Module name: ~p\\n\", [Module]),\n    io:format(\"Number of nodes in Core Erlang tree: ~p\\n\",\n              [cerl_trees:size(Core)]),\n    Core.\n```\n\nBefore explaining the code, let's see it in action:\n\n```\n$ erlc my_core_transform\n$ erlc -pa . '+{core_transform,my_core_transform}' core_wrapup.erl\nModule name: core_wrapup\nNumber of nodes in Core Erlang tree: 220\n$\n```\n\nThe `{core_transform,Name}` option instructs the compiler to run a\ncore transformation. In this case, the core transform module is\n`my_core_transform`. After doing the standard optimizing passes,\nthe compiler will call `my_core_transform:core_transform/2`, passing\nthe Core Erlang code as the first argument and the compiler options\nas the second argument.\n\nThe first line in the `core_transform/2` functions calls\n`cerl:module_name(Core)` to retrieve the module name. The return value\nof `cerl:module_name/1` is a record representing any literal term. To\nretrieve the actual term (an atom in this case), `cerl:concrete/1`\nis called.\n\nIn the second `io:format/2` call, we call `cerl_trees:size/1` to\ncount the number of nodes in the tree that represents the Core Erlang\ncode for the module.\n\nThis core transform does not do any real transforming, since the last\nline returns the Core Erlang code without any modifications.\n\n### sys_core_bsm\n\n`sys_core_bsm` is the first of three passes that implement the delayed\nsub binary optimization described in the [Efficiency\nGuide][efficiency_guide].  `sys_core_bsm` adds annotations that are\nlater used by `v3_codegen` and `beam_bsm` to optimize matching of\nbinaries.\n\n[efficiency_guide]: http://erlang.org/doc/efficiency_guide/binaryhandling.html\n\n### sys_core_dsetel\n\nThe `sys_core_dsetel` pass will optimize chained or nested\napplications of `setelement/3` as in this example:\n\n```erlang\nupdate_tuple(T0) ->\n    T = setelement(3, T0, y),\n    setelement(2, T, x).\n```\n\nTranslated to Core Erlang it looks like this:\n\n```\n'update_tuple'/1 =\n    fun (_0) ->\n\tlet <T> =\n\t    call 'erlang':'setelement'(3, _0, 'y')\n\tin\n\t    call 'erlang':'setelement'(2, T, 'x')\n```\n\nThe `sys_core_dsetel` pass replaces the second call to `setelement/3`\nwith the primop `dsetelement/3`, which destructively updates a tuple:\n\n```\n'update_tuple'/1 =\n    fun (_0) ->\n\tlet <T> =\n\t    call 'erlang':'setelement'(3, _0, 'y')\n\tin  do\n\t\tprimop 'dsetelement'(2, T, 'x')\n\t\tT\n```\n\n`do` evalutes two expressions in sequence, ignoring the value of the\nfirst expression. It is used here because the primop `dsetelement/3`\nupdates its tuple argument without returning a value.\n\nThe `sys_core_dsetel` pass is intentionally run as the very last\nCore Erlang pass. Doing other optimizations might render the optimization\nunsafe. For example, there must not occur a garbage collection between\nthe call to `setelement/3` and `dsetelement/3`.\n\nWhy is this optimization useful? Surely a sequence of `setelement/3`\ncalls must be rare?\n\nConsider this function that updates two elements in a record:\n\n```\n-record(rec, {a,b,c,d,e,f,g,h}).\n\nupdate_record(R) ->\n    R#rec{a=x,b=y}.\n```\n\nIn [a previous blog post][lost in translation] we saw that the `-E` option\nwill produce an `.E` file with the code after records have been translated\nto tuple operations:\n\n[lost in translation]: http://blog.erlang.org/compiler-lost-in-translation/\n\n```\n$ erlc -E core_wrapup.erl\n```\n\nHere is the code for `update_record/1` after record translation:\n\n```\nupdate_record(R) ->\n    begin\n        rec0 = R,\n        case rec0 of\n            {rec,_,_,_,_,_,_,_,_} ->\n                setelement(2, setelement(3, rec0, y), x);\n            _ ->\n                error({badrecord,rec})\n        end\n    end.\n```\n\nAfter verifying that `R` is indeed a record of the correct type (that is,\nthat the size and first element of the tuple are correct), nested calls\nto `setelement/3` is used to update two elements of the tuple.\n\nThe optimized Core Erlang code for `update_record/1` will look like\nthis:\n\n```\n'update_record'/1 =\n    fun (_0) ->\n\tcase _0 of\n\t  <{'rec',_5,_6,_7,_8,_9,_10,_11,_12}> when 'true' ->\n\t      let <_2> =\n\t\t  call 'erlang':'setelement'(3, _0, 'y')\n\t      in  do  primop 'dsetelement'(2, _2, 'x')\n\t\t      _2\n\t  <_13> when 'true' ->\n\t\tcall 'erlang':'error'({'badrecord','rec'})\n\tend\n```\n\n## The representation of Core Erlang code\n\nSo far we have looked at the external (pretty-printed) representation of\nCore Erlang. Before leaving Core Erlang, we will take a brief look at\nthe internal representation of Core Erlang that the compiler uses.\n\nThere are ~~two~~ three ways to work with Core Erlang within an\noptimizer pass:\n\n* Using the API functions in the `cerl` module\n\n* Using the `c_*` records defined in `core_parse.hrl`\n\n* Mixing use of records with use of the API functions\n\n### Using the cerl module and friends\n\nThe `cerl` module provides API functions to construct, deconstruct, update,\nand query each of the constructs in Core Erlang.\n\nHere are some examples:\n\n* `cerl:c_var(Name)` constructs the Core Erlang representation\nof a variable with the name `Name`.\n\n* `cerl:is_c_var(Core)` returns `true` if the `Core` represents a Core\nErlang variable, and `false` otherwise.\n\n* `cerl:var_name(Core)` returns the name of a variable (and crashes if\n`Core` does not represent a Core Erlang variable).\n\nThere are also the `cerl_trees` and `cerl_clauses` modules that provide\nuseful utility functions for manipulating Core Erlang code.\n\n### Using the records\n\nIn `core_parse.hrl`, there is one record for each kind of Core Erlang\nconstruct. All record names start with the prefix `c_`.\n\nFor example, the record `#c_var{}` represents a variable, the record\n`#c_call{}` the `call` expression, the record `c_tuple{}` a tuple, and\nso on.\n\nAs a complete example, we can rewrite our previous core transform\nto use record matching instead of `cerl` to retrieve the module name:\n\n```\n-module(my_core_transform).\n-export([core_transform/2]).\n\n-include_lib(\"compiler/src/core_parse.hrl\").\n\ncore_transform(Core, _Options) ->\n    #c_module{name=#c_literal{val=Module}} = Core,\n    io:format(\"Module name: ~p\\n\", [Module]),\n    io:format(\"Number of nodes in Core Erlang tree: ~p\\n\",\n              [cerl_trees:size(Core)]),\n    Core.\n```\n\n### Mixing the `cerl` API with records\n\nThe `cerl` module internally use the records in `core_parse.hrl`, so\nthe two approaches can be mixed. For example, `sys_core_fold` mostly\nuse the records, but sometimes uses `cerl` when it is more convenient.\n\n## Wrapping up the wrap up\n\nIt seems that there is enough material for several more blog posts\nabout Core Erlang. For instance, I haven't even mentioned the inliners\n(not a typo, there are *two* inliners). That means that there might be\nmore blog posts about Core Erlang in the future.\n\nBut in the very near future, it is time to explore the compiler passes\nthat follow Core Erlang, and perhaps answer the eternal question about\nthe `v3_` prefix. Was there ever a `v2_kernel` (spoiler: yes) or a\n`v1_kernel` (spoiler: no)?\n"}},"__N_SSG":true}