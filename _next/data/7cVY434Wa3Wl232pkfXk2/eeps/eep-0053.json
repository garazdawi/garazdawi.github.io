{"pageProps":{"index":{"id":"0053","content":"<pre><code>Author: Rickard Green &lt;rickard(at)erlang(dot)org&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: 24.0\nCreated: 01-Sept-2019\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 53: <a href=\"eep-0053.md\" title=\"EEP Source\"> Process aliases preventing late replies reaching clients</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Currently there exists no lightweight mechanism for preventing late replies\nfrom a server to a client after a timeout or connection loss has occurred.\nThe only way to prevent late replies today is to make the request via\na proxy process.</p>\n\n<p>The proposed process alias feature is a lightweight mechanism that solves\nthe above problem. A process alias is similar to a registered name that\nis used temporarily while a request is outstanding. If the request times\nout or the connection to the server is lost, the alias is deactivated which\nprevents a late reply from reaching the client.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n\n<h1>Specification</h1>\n\n<p>An alias is of the Erlang type <code>reference()</code> and can be used as destination\nwhen sending using the <code>!</code> operator, or when sending using the <code>erlang:send()</code>\nand <code>erlang:send_nosuspend()</code> BIFs. An alias can be used both on local\nnode and on remote nodes in a distributed system. The alias identifies a\nprocess that exist, or has existed, on the node with the node name returned\nby <code>node(Alias)</code>.</p>\n\n<p>All references will, as of this, be accepted as destination in the message send\noperations listed above. If the reference is not an alias or a previous alias\nthat has been deactivated, the message will silently be dropped.</p>\n\n<p>These new BIFs are introduced:</p>\n\n<ul>\n<li><p><code>alias/0</code>, <code>alias/1</code>. The <code>alias()</code> BIF creates and returns an alias which\ncan be used when sending messages to the process that called the <code>alias()</code>\nBIF.</p></li>\n<li><p><code>unalias/1</code>. The <code>unalias(Alias)</code> BIF deactivates an alias that identifies\nthe calling process. The BIF returns <code>true</code> if the alias <code>Alias</code> identified\nthe calling process and thus was deactivated; otherwise, no change of the\nalias state was made and <code>false</code> is returned.</p></li>\n<li><p><code>monitor/3</code>. The <code>monitor/3</code> BIF is an extension of the <code>monitor/2</code> BIF\nwhere the third argument is an option list. As of its introduction it\naccepts two options:</p>\n\n<ul>\n<li><p>'{alias, unalias | demonitor | reply_demonitor}'. The first element of\nthe two tuple indicates that we want the returned monitor reference to\nalso work as an alias. The second element determines how the alias should\nbe deactivated:</p>\n\n<ul>\n<li><code>unalias</code> - The alias will remain until it has been deactivated by the\n<code>unalias/1</code> BIF</li>\n<li><code>demonitor</code> - The alias will be deactivated when the monitor is\ndeactivated. That is, either when the <code>demonitor()</code> BIF is called on\nthe monitor, or when the monitor is automatically deactivated by the\nreception of a <code>'DOWN'</code> message. The alias can still be deactivated\nbefore this happens by calling the <code>unalias/1</code> BIF.</li>\n<li><code>reply_demonitor</code> - The alias will be deactivated when either the\nmonitor is deactivated or a message that has been passed using the\nalias is received. If the alias is deactivated due to a message passed\nusing the alias, the monitor is also deactivated as if the <code>demonitor()</code>\nBIF had been called.</li>\n</ul></li>\n<li><p><code>{tag, UserDefinedTag}</code>. This will replace the default <code>Tag</code> with\n<code>UserDefinedTag</code> in the monitor message delivered when the monitor is\ntriggered. For example, when monitoring a process, the <code>'DOWN'</code> tag in\nthe down message will be replaced by <code>UserDefinedTag</code>. </p></li>\n</ul></li>\n</ul>\n\n<p>The <code>spawn_opt()</code> and <code>spawn_request()</code> BIFs have also been extended to\naccept an option <code>{monitor, MonitorOpts}</code> where <code>MonitorOpts</code> correspond to\nthe option list of the <code>monitor/3</code> BIF.</p>\n\n<p>Full documentation of these BIFs and options can be found via\n<a href=\"https://github.com/erlang/otp/pull/2735\">pull request #2735</a>\ncontaining the reference implementation.</p>\n\n<p>It is not possible to retrieve the process identifier of the process\nidentified by an alias, and it is not possible to test if a reference is an\nalias or not.</p>\n\n<h1>Motivation</h1>\n\n<p>As previously stated it is possible to prevent late replies by using a\nproxy process that forwards the reply to the client. By spawning the proxy\nprocess and send its process identifier to the server instead of the\nclients own process identifier, the proxy can be terminated when the\noperation times out or the connection is lost. Since the proxy process\nis not alive, a reply will be silently dropped and no stray message\nwill reach the previous client of the request. This however both makes\nthe code more complicated and less efficient than it needs to be. The\ninefficiency comes from both the need to create, schedule, execute, and\nterminate the proxy process and the extra copying of data over the proxy\nprocess.</p>\n\n<p>When the author of the client code has full control over the client process\nsuch late replies can be handled without a proxy since the code can be\naware of these potential stray messages and drop them when received. This\nis, however, not possible when implementing library code. You then either\nneed to use a proxy process, as done by the <code>gen_statem</code> behavior, or\naccept that the client process may get stray messages after a call, as\ndone by the <code>gen_server</code> behavior.</p>\n\n<p>Process aliases solves these issues with a very small overhead.</p>\n\n<h1>Rationale</h1>\n\n<h2>Why use the reference data type for alias?</h2>\n\n<p>This is more or less what the reference data type is there for. A data type\nthat can identify a huge amount of different entities. References are unique\nand contain a node identifier identifying the the node it originates from.\nThis makes it easy to identify a specific process on a specific node while\nalso identifying different aliases created by the same process. The embedded\nnode identifier makes it easy to provide distribution transparency.</p>\n\n<h2>Why not make alias an opaque data type?</h2>\n\n<p>The expected most common use case is in a client server request. Such as\n<code>gen_server:call()</code>. Client server requests in Erlang are typically made\nwhile monitoring the server from the client. In order to minimize the data\nproduced and sent in the request we want to reuse the reference created for\nidentification of the monitor to also function as an alias. Since the monitor\nidentifier is documented as a reference and is not opaque (which one can\nargue was a design mistake when introducing monitors), it becomes hard not\nto document the type of an alias as a reference as well.</p>\n\n<h2>Why not allow references as registered names in the already existing API?</h2>\n\n<p>There are two reasons. Distribution transparency and scalability.</p>\n\n<p>Distribution transparency is really desirable since the user can use the\nfunctionality the same way regardless of whether it is a node local operation\nor node remote operation. The name registration API is not distribution\ntransparent.</p>\n\n<p>Regarding scalability. Due to how the name registration API has been designed\nwe need some sort of table in order to implement the API. This table will be\nwritten to and read from by processes that are executing in parallel. In the\nuse case we are focusing on, names (aliases) are expected to be temporary and\ncreated in huge amounts. That is, there will be large amounts of modifications\nof this table from processes executing on different processors. This will\nmake it challenging to implement such a table that scales well.</p>\n\n<p>In the proposed solution the information needed to route the message to the\ncorrect place is saved in the alias itself, the reference. The information\nneeded to determine if the message passed via the alias should be dropped or\npassed along is saved in the process identified by the alias. That is, all\ninformation needed is distributed to where it is needed instead of being\ncentralized in a node global table. This approach of distributed information\nintroduce no new synchronization points at all when it has been fully\nimplemented (more on that below) which will scale extremely well. An\nimplementation based on a node global table can <em>never</em> compete scalability\nwise with that.</p>\n\n<p>The already existing functionality for registered names cannot be implemented\nusing this distributed information approach, but needs this centralized\nstorage of names. That is, the already existing API cannot be used.</p>\n\n<p>Besides node identifier a reference today contains three 32-bit words of data\nor in other words 96-bits of data. Of these 96 bits only 82 bits are allowed\nto be passed over the distribution to another node. This for historical\nreasons. While a reference resides locally it can however contain more or\nless unlimited amount of data. 82-bits are not enough to make a reference\nunique on the local node and at the same time uniquely identify a node local\nprocess. In order to be able to store all information needed in alias, the\nreference data type needs to be extended.</p>\n\n<p>In the proposed solution references used as aliases are extended to use\nfive 32-bit words on 64-bit architectures and four 32-bit words on 32-bit\narchitectures. Since that much data in a reference cannot be passed over\nthe distribution today, the reference implementation saves aliases that\nare alive in a node global table. When a node local alias enters the local\nnode over the distribution one needs to look it up in this table in order to\nbe able to restore it to its actual value. While aliases are passed around\nlocally there is no need for look-ups in this table.</p>\n\n<p>The reference implementation also modifies the distribution protocol to\nallow references with up to five 32-bit values. For backwards compatibility\nreasons this modification of the distribution protocol cannot be used at once\nwhen aliases are introduced. This since we need to be able to communicate with\nolder nodes from previous releases for a while. When this has been living in\nthe system for enough time (expected to be OTP 26) we can begin sending\nreferences with up to five 32-bit words and remove the usage of the table\nmapping references over the distribution to aliases. That is, it is not until\nthis happens that the alias implementation is fully complete.</p>\n\n<h2>Why is it not possible to get the PID of the process that an alias refers to?</h2>\n\n<p>Most importantly there is no need to know the PID of the process that an\nalias refers to in order to solve the problems that alias are intended\nto solve. The user is expected to utilize alias in a protocol where one knows\nwhether a reference is an alias or not and should not need to know the PID of\nthe process that it refers to.</p>\n\n<p>Besides the above there are also other issues with such functionality. The\ncontent of a reference is just a large integer. In order to keep distribution\ntransparency one would either have to specify how this integer should be\ninterpreted or require synchronous signaling with the node where the\nidentified process resides. The synchronous signal-ling will be very\nexpensive. By specifying how the reference integer should be interpreted we\nwould prevent future changes to how the integer of the reference should be\ninterpreted which might prevent future optimizations, improvements and new\nfeatures. Up until the time when large references with five 32-bit words can\nbe passed over the distribution, synchronous communication is also the only\noption on how to implement such functionality.</p>\n\n<p>If we should mimic the <code>whereis()</code> function of the registered name API where\nyou also can see if a name is currently registered, no other option than\nsynchronous signaling with the process identified by the alias is possible.</p>\n\n<h2>Why is it not possible to test if a reference is an alias?</h2>\n\n<p>The same reason as to why it is not possible to get the PID of the\nprocess that is referred to by an alias.</p>\n\n<h2>Why not allow registration of arbitrary Erlang terms instead?</h2>\n\n<p>Such a feature could solve the same issue that aliases are intended to\nsolve, but there are problems with such an approach.</p>\n\n<p>Terms other than pids, ports, and references do not have a node identifier\nembedded into the data type. For such data types you need some other way\nto identify the node of where the name is registered. In the current case\nof atoms as registered names, this is done by wrapping the name in a\ntwo-tuple that contains the node name. Something like this is needed for\nall other terms than just plain pids, ports, and references. This also\nintroduce a problem. Is a two-tuple just a name or a name plus a node\nidentifier?</p>\n\n<p>Should it be possible to register a PID as a name for another process?\nThis would force all send operations to first lookup the PID in the\ntable of registered names before performing the operation. This will\ncost performance in all send operations. The same is true for ports.</p>\n\n<p>We don't think registration of arbitrary terms should be implemented\ndue to the problems that arise. Current registration feature that only\nallows atoms can however be a bit too limiting when you need to register\na number of processes for the same service. An option could be to allow\nregistration of two-tuples containing an atom and an integer. Perhaps\nother terms such as strings should also be allowed, but arbitrary terms\nshould not be allowed.</p>\n\n<p>Allowing references as registered names implies scalability bottlenecks\nnot present in the alias API. That is, this would be an inferior solution\nto the problem we set out to solve.</p>\n\n<p>One probably wants to extend name registration with more allowed terms\nthan just atoms, but this for solving other problems than what aliases\nare intended to solve. The name registration API does not fit aliases\nso we don't see that aliases should be combined with such an extension\nof the registration API. The alias solution solves the problem we set out\nto solve, so this eep is limited to that.</p>\n\n<h2>Why is the tag option of monitor/3 introduced?</h2>\n\n<p>When using the monitor option <code>alias</code> in a <code>spawn_request()</code> call you\nget unnecessary delays since you cannot share the alias with the\nchild process until you have gotten the spawn reply with the process\nidentifier of the child process. You instead typically want to\nexplicitly create the alias before the <code>spawn_request()</code> call and pass\nit as an argument to the child process.</p>\n\n<p>In a typical scenario you want to receive a response or an error\nof the operation. However, if you explicitly create an alias before\nthe <code>spawn_request()</code> operation, the monitor reference and the alias\nwill be different references. This will prevent the compiler from\noptimizing the receive (to skip messages present in the message queue\nwhen the reference was created) since not all receive clauses will\nmatch on the same reference.</p>\n\n<p>We solve this by using the <code>tag</code> monitor option as well as the\n<code>reply_tag</code> spawn request. The following is a fully functional rpc\nimplementation using this method on a system with the prototype\nimplementation of aliases:</p>\n\n<pre><code>rpc(Node, M, F, A) -&gt;\n    Alias = alias([once]),\n    ReqId = spawn_request(Node,\n                          fun () -&gt;\n                                  Result = apply(M, F, A),\n                                  Alias ! {{result, Alias}, Result}\n                          end,\n                          [{monitor, [{tag, {'DOWN', Alias}}]},\n                           {reply_tag, {spawn_reply, Alias}},\n                           {reply, error_only}]),\n    receive\n        {{result, Alias}, Result} -&gt;\n            demonitor(ReqId, [flush]),\n            Result;\n        {{'DOWN', Alias}, ReqId, process, _, Error} -&gt;\n            rpc_error_cleanup(Alias, Error);\n        {{spawn_reply, Alias}, ReqId, error, Error} -&gt;\n            rpc_error_cleanup(Alias, Error)\n    end.\n\nrpc_error_cleanup(Alias, Error) -&gt;\n    case unalias(Alias) of\n        true -&gt;\n            %% No flush needed since we used the once option\n            %% to alias(), and the alias was still active...\n            error({rpc_error, Error});\n        false -&gt;\n            %% Flush a possible result message...\n            receive {{result, Alias}, Result} -&gt; Result\n            after 0 -&gt; error({rpc_error, Error})\n            end\n    end.\n</code></pre>\n\n<p>The <code>tag</code> monitor option can be used in other situations as\nwell in order to get a single reference that is present in\nall types of responses from a group of processes. The processes\nmay be pre-existing or not. This reference can then be utilized\nto determine if a message corresponds to a specific operation\nmade to a specific group of processes.</p>\n\n<p>There are plans to extend the receive optimization so that multiple\nreceives matching on the same reference in all clauses can utilize\nthe optimization. This will also improve performance for such\nimplementations receiving multiple messages matching on the same\nreference.</p>\n\n<p>The tag to use in the monitor message is stored locally in the\nprocess that sets up the monitor and does not have to be\ncommunicated between processes. Most importantly it does not\nhave to be sent over the wire in the distributed case. This also\nmeans that it can also be used when monitoring processes on older\nnodes which does not support this functionality.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The alias feature is a pure extension, so there are no real backwards\ncompatibility issues.</p>\n\n<p>In order to be able to communicate aliases over Erlang nodes from\nprevious releases we cannot pass large references over the distribution\nand therefore need to keep information about aliases in a node global\ntable. The implementation benefits from being able to pass larger\nreferences over the distribution, but will not do so until we can make\nit mandatory to be able to handle such large references. Both OTP 24\nand OTP 25 will be able to handle large references over the distribution\nand since we only guarantee distribution compatibility with the two\nclosest releases backwards and forwards we can then make large\nreferences mandatory in OTP 26.</p>\n\n<p>This node global table for alias introduce an overhead when utilizing\naliases compared to sending using the PID of the process. This due\nto allocation and manipulation of table structures. Comparing to the\nexisting solution of utilizing a proxy process in order to\nprevent stray messages the overhead of this node global table for\naliases is small. Fortunately this node global table also only need to\nbe present temporarily and can be removed in OTP 26.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>The reference implementation is provided by\n<a href=\"https://github.com/erlang/otp/pull/2735\">pull request #2735</a>.</p>\n\n<p>Beside implementation of the alias feature. The pull request also contain\nusage of aliases in the gen behaviors such as gen_server. Due to this it is\nnow also possible to implement <code>receive_response()</code> functionality similar to\n<code>erpc:receive_response()</code> which also have been implemented:</p>\n\n<ul>\n<li><code>gen_server:receive_response/2</code></li>\n<li><code>gen_statem:receive_response/2</code></li>\n<li><code>gen_event:receive_response/2</code></li>\n</ul>\n"}},"__N_SSG":true}