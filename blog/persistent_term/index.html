<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/persistent_term/">Clever use of persistent_term</a></h3><p><em>Monday, 9 September 2019<!-- --> - <!-- -->Lukas Larsson</em></p><p>This blog post will go through three different uses of <a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>
that I have used since its release and explain a bit why they work so well with
<a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>.</p><h1>Global counters</h1><p>Let&#x27;s say you want to have some global counters in your system. For example the number
of times an http request has been made. If the system is very busy that counter
will be incremented many many times per second by many different processes. Before
OTP-22 the best way that I know of to get the best performance is by using a striped
ets tables. i.e. something like the code below:</p><p>{% raw %}</p><pre><code class="language-erlang">incr(Counter) -&gt;
  ets:update_counter(?MODULE,{Counter,erlang:system_info(scheduler_id)},1).

read(Counter) -&gt;
  lists:sum(ets:select(?MODULE,[{{{Counter,&#x27;_&#x27;},&#x27;$1&#x27;},[],[&#x27;$1&#x27;]}])).</code></pre><p>{% endraw %}</p><p>The code above would make sure that there is very little contention on the ets table
as each scheduler will get a separate slot in the table to update. This comes at the
cost of more memory usage and that when reading the value you may not get an exact
value.</p><p>In OTP-22 the same can be achieved by using <a href="http://erlang.org/doc/man/counters.html">counters</a>.
<a href="http://erlang.org/doc/man/counters.html">Counters</a> have built-in
support for striping by using the <code>write_concurrency</code> option, so we don&#x27;t have
to write our own implementation for that. They are also faster and use less memory
than ets tables, so lots of wins.</p><p>The remaining problem then is finding the reference to the counter. We could put it
into ets and then do an <a href="http://erlang.org/doc/man/ets.html#lookup_element-3">ets:lookup_element/3</a>
when updating a counter.</p><pre><code class="language-erlang">cnt_incr(Counter) -&gt;
    counters:add(ets:lookup_element(?MODULE,Counter,2),1,1).

cnt_read(Counter) -&gt;
    counters:get(ets:lookup_element(?MODULE,Counter,2),1).</code></pre><p>This gives a performance degradation of about 20%, so not really what we want.
However, if we place the counter in <a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>
like the code below we get a performance increase by about 140%, which is much
more in line with what we wanted.</p><pre><code class="language-erlang">cnt_pt_incr(Counter) -&gt;
    counters:add(persistent_term:get({?MODULE,Counter}),1,1).

cnt_pt_read(Counter) -&gt;
    counters:get(persistent_term:get({?MODULE,Counter}),1).</code></pre><p>The reason for this huge difference is because when the <a href="http://erlang.org/doc/man/counters.html">counters</a>
are placed into <a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>
they are placed there as literals which means that at each increment we not longer
have to make a copy of the <a href="http://erlang.org/doc/man/counters.html">counters</a> reference.
This is good for two reasons:</p><ol><li><p>The amount of garbage will decrease. In my benchmarks the amount of garbage generated
by <code>cnt_incr</code> is 6 words while both <code>ets_incr</code> and <code>cnt_pt_incr</code> create 3 words.</p></li><li><p>No reference counts have to be modified. What I mean by this is that the
<a href="http://erlang.org/doc/man/counters.html">counters</a> reference
is what is called a magic reference or nif resource. These references work much in the same
way as reference counted binaries in that they are not copied when sent to different
processes. Instead only a reference count is incremented at copy and then decremented later
by the GC. This means that for <code>cnt_incr</code> we actually have 3 counters that are modified for
each call. First we increment the reference count on the counter when copying from ets, then
we update the actual counter and then eventually we decrement the reference counter. If we
use <a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>, the term is never
copied so we don&#x27;t have to update any reference counters, instead we just have to update the
actual counter.</p></li></ol><p>However, placing the counter in <a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>
is not trouble free. In order to delete or replace the counter reference in
<a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a> we have to do a global
GC which depending on the system could be very very expensive.</p><p>So this method is best to only be used by global persistent counters that will never be deleted.</p><p>You can find the code for all the above examples and the benchmark I ran
<a href="https://gist.github.com/garazdawi/17cdb5914b950f0acae21d9fcf7e8d41">here</a>.</p><h1>Logger level check</h1><p>In <a href="http://erlang.org/doc/man/logger.html">logger</a> there is a primary logging
level that is the first test to be done for each potential log message to be generated.
This check can be done many times per second and needs to be very quick. At the
moment of writing (OTP-22) logger uses an ets table to keep all its configuration which
includes the primary logging level.</p><p>This is not really ideal as doing a lookup from the ets table means that we have to take
a read-lock to protect against parallel writes to the value. Taking such a read lock is not
terribly expensive, but when done thousands of times per second it adds up.</p><p>So in <a href="https://github.com/erlang/otp/pull/2356">this PR</a> I&#x27;ve used
<a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a> as
a cache for the primary logging level. Now when reading the value from the hot path
logger will instead use <a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>.
This removes all locks from the hot path and we only need to do a lookup in the
<a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a> hash table.</p><p>But what if we need to update the primary logger level? Don&#x27;t we force a global GC then?
No, because the small integer representing the primary logger level is an immediate.
This means that the value fits in one machine word and is always copied in its
entirety to the calling process. Which in turn means that we don&#x27;t have to do a global
GC when replacing the value.</p><p>When doing this we have to be very careful so that the value does not become a heap value
as the cost of doing an update would explode. However, it works great for logger and
has reduced the overhead of a ?LOG_INFO call by about 65% when no logging should be done.</p><h1>Large constant data</h1><p>We use an internal tool here at the OTP-team called the &quot;ticket tool&quot;. It basically
manages all of the OTP-XYZ tickets that you see in the release notes that comes with
each release of Erlang/OTP. It is an ancient tool from late 90&#x27;s or early 00&#x27;s that
no one really wants to touch.</p><p>One part of it is a server that contains a cache of all the 17000 or so tickets that
have been created through the years. In that server there is a single process that
has each ticket and its state in order to speed up searching in the tickets. The state
of this process is quite large and when it is doing a GC it takes somewhere around 10
seconds for it to finish. This means that about every 10 minutes the server freezes for
10 seconds and we get to experience the joy of being Java programmers for a while.</p><p>Being a VM developer I&#x27;ve always thought the solution to this problem is to implement
either an incremental GC or at least a mark and sweep GC for large heaps. However, the
ticket tool server has never been of high enough priority to make me spend a year or two
rewriting the GC.</p><p>So, two weeks ago I decided to take a look and instead I used
<a href="http://erlang.org/doc/man/persistent_term.html">persistent_term</a>
to move the data from the heap into the literal area instead. This was possible to do because
I know that the majority of tickets are only searched and never changed, so they will
remain in the literal area forever, while the tickets that do get edited move onto the
heap of the ticket server. Basically my code change was this:</p><pre><code class="language-erlang">handle_info(timeout, State) -&gt;
  persistent_term:put(?MODULE,State),
  erlang:start_timer(60 * 60 * 1000, self(), timeout),
  {noreply,persistent_term:get(?MODULE)}.</code></pre><p>This small change puts the entire gen_server state into the literal area and then
any changes done to it will pull the data into the heap. This dropped the GC pauses
down to be non-noticeable and took considerable less time to implement than a new GC
algorithm.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"persistent_term","title":"Clever use of persistent_term","author":"Lukas Larsson","excerpt":"\nThis blog post will go through three different uses of [persistent_term](http://erlang.org/doc/man/persistent_term.html)\nthat I have used since its release and explain a bit why they work so well with\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html).","article_date":1567987200000,"tags":["persistent_term","literal"],"frontmatter":{"layout":"post","title":"Clever use of persistent_term","tags":"persistent_term literal","author":"Lukas Larsson"},"content":"\nThis blog post will go through three different uses of [persistent_term](http://erlang.org/doc/man/persistent_term.html)\nthat I have used since its release and explain a bit why they work so well with\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html).\n\n# Global counters\n\nLet's say you want to have some global counters in your system. For example the number\nof times an http request has been made. If the system is very busy that counter\nwill be incremented many many times per second by many different processes. Before\nOTP-22 the best way that I know of to get the best performance is by using a striped\nets tables. i.e. something like the code below:\n\n{% raw %}\n```erlang\nincr(Counter) -\u003e\n  ets:update_counter(?MODULE,{Counter,erlang:system_info(scheduler_id)},1).\n\nread(Counter) -\u003e\n  lists:sum(ets:select(?MODULE,[{{{Counter,'_'},'$1'},[],['$1']}])).\n```\n{% endraw %}\n\nThe code above would make sure that there is very little contention on the ets table\nas each scheduler will get a separate slot in the table to update. This comes at the\ncost of more memory usage and that when reading the value you may not get an exact\nvalue.\n\nIn OTP-22 the same can be achieved by using [counters](http://erlang.org/doc/man/counters.html).\n[Counters](http://erlang.org/doc/man/counters.html) have built-in\nsupport for striping by using the `write_concurrency` option, so we don't have\nto write our own implementation for that. They are also faster and use less memory\nthan ets tables, so lots of wins.\n\nThe remaining problem then is finding the reference to the counter. We could put it\ninto ets and then do an [ets:lookup\\_element/3](http://erlang.org/doc/man/ets.html#lookup_element-3)\nwhen updating a counter.\n\n```erlang\ncnt_incr(Counter) -\u003e\n    counters:add(ets:lookup_element(?MODULE,Counter,2),1,1).\n\ncnt_read(Counter) -\u003e\n    counters:get(ets:lookup_element(?MODULE,Counter,2),1).\n```\n\nThis gives a performance degradation of about 20%, so not really what we want.\nHowever, if we place the counter in [persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nlike the code below we get a performance increase by about 140%, which is much\nmore in line with what we wanted.\n\n```erlang\ncnt_pt_incr(Counter) -\u003e\n    counters:add(persistent_term:get({?MODULE,Counter}),1,1).\n\ncnt_pt_read(Counter) -\u003e\n    counters:get(persistent_term:get({?MODULE,Counter}),1).\n```\n\nThe reason for this huge difference is because when the [counters](http://erlang.org/doc/man/counters.html)\nare placed into [persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nthey are placed there as literals which means that at each increment we not longer\nhave to make a copy of the [counters](http://erlang.org/doc/man/counters.html) reference.\nThis is good for two reasons:\n\n1) The amount of garbage will decrease. In my benchmarks the amount of garbage generated\nby `cnt_incr` is 6 words while both `ets_incr` and `cnt_pt_incr` create 3 words.\n\n2) No reference counts have to be modified. What I mean by this is that the\n[counters](http://erlang.org/doc/man/counters.html) reference\nis what is called a magic reference or nif resource. These references work much in the same\nway as reference counted binaries in that they are not copied when sent to different\nprocesses. Instead only a reference count is incremented at copy and then decremented later\nby the GC. This means that for `cnt_incr` we actually have 3 counters that are modified for\neach call. First we increment the reference count on the counter when copying from ets, then\nwe update the actual counter and then eventually we decrement the reference counter. If we\nuse [persistent\\_term](http://erlang.org/doc/man/persistent_term.html), the term is never\ncopied so we don't have to update any reference counters, instead we just have to update the\nactual counter.\n\nHowever, placing the counter in [persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nis not trouble free. In order to delete or replace the counter reference in\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html) we have to do a global\nGC which depending on the system could be very very expensive.\n\nSo this method is best to only be used by global persistent counters that will never be deleted.\n\nYou can find the code for all the above examples and the benchmark I ran\n[here](https://gist.github.com/garazdawi/17cdb5914b950f0acae21d9fcf7e8d41).\n\n# Logger level check\n\nIn [logger](http://erlang.org/doc/man/logger.html) there is a primary logging\nlevel that is the first test to be done for each potential log message to be generated.\nThis check can be done many times per second and needs to be very quick. At the\nmoment of writing (OTP-22) logger uses an ets table to keep all its configuration which\nincludes the primary logging level.\n\nThis is not really ideal as doing a lookup from the ets table means that we have to take\na read-lock to protect against parallel writes to the value. Taking such a read lock is not\nterribly expensive, but when done thousands of times per second it adds up.\n\nSo in [this PR](https://github.com/erlang/otp/pull/2356) I've used\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html) as\na cache for the primary logging level. Now when reading the value from the hot path\nlogger will instead use [persistent\\_term](http://erlang.org/doc/man/persistent_term.html).\nThis removes all locks from the hot path and we only need to do a lookup in the\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html) hash table.\n\nBut what if we need to update the primary logger level? Don't we force a global GC then?\nNo, because the small integer representing the primary logger level is an immediate.\nThis means that the value fits in one machine word and is always copied in its\nentirety to the calling process. Which in turn means that we don't have to do a global\nGC when replacing the value.\n\nWhen doing this we have to be very careful so that the value does not become a heap value\nas the cost of doing an update would explode. However, it works great for logger and\nhas reduced the overhead of a ?LOG_INFO call by about 65% when no logging should be done.\n\n# Large constant data\n\nWe use an internal tool here at the OTP-team called the \"ticket tool\". It basically\nmanages all of the OTP-XYZ tickets that you see in the release notes that comes with\neach release of Erlang/OTP. It is an ancient tool from late 90's or early 00's that\nno one really wants to touch.\n\nOne part of it is a server that contains a cache of all the 17000 or so tickets that\nhave been created through the years. In that server there is a single process that\nhas each ticket and its state in order to speed up searching in the tickets. The state\nof this process is quite large and when it is doing a GC it takes somewhere around 10\nseconds for it to finish. This means that about every 10 minutes the server freezes for\n10 seconds and we get to experience the joy of being Java programmers for a while.\n\nBeing a VM developer I've always thought the solution to this problem is to implement\neither an incremental GC or at least a mark and sweep GC for large heaps. However, the\nticket tool server has never been of high enough priority to make me spend a year or two\nrewriting the GC.\n\nSo, two weeks ago I decided to take a look and instead I used\n[persistent\\_term](http://erlang.org/doc/man/persistent_term.html)\nto move the data from the heap into the literal area instead. This was possible to do because\nI know that the majority of tickets are only searched and never changed, so they will\nremain in the literal area forever, while the tickets that do get edited move onto the\nheap of the ticket server. Basically my code change was this:\n\n```erlang\nhandle_info(timeout, State) -\u003e\n  persistent_term:put(?MODULE,State),\n  erlang:start_timer(60 * 60 * 1000, self(), timeout),\n  {noreply,persistent_term:get(?MODULE)}.\n```\n\nThis small change puts the entire gen_server state into the literal area and then\nany changes done to it will pull the data into the heap. This dropped the GC pauses\ndown to be non-noticeable and took considerable less time to implement than a new GC\nalgorithm.\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"persistent_term"},"buildId":"mwcz5f45UeFOBiRtaG40v","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_buildManifest.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_ssgManifest.js" async=""></script></body></html>