{"pageProps":{"index":{"id":"0012","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nCreated: 10-Jul-2008\nErlang-Version: R12B-4\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 12: <a href=\"eep-0012.md\" title=\"EEP Source\"> Extensions to comprehensions</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Add tuple-valued comprehensions to go with list and binary\ncomprehensions.</p>\n\n<p>Add tuple generators to go with list and binary generators.</p>\n\n<p>Fix a syntax botch in comprehension qualifiers by explicitly\nrecognising pattern = value bindings and treating them in a\nway that makes sense.</p>\n\n<h1>Specification</h1>\n\n<p>Currently, Erlang has</p>\n\n<pre><code>    '['  Expr '||' Generators-And-Tests ']'\n    '&lt;&lt;' Expr '||' Generators-And-Tests '&gt;&gt;'\n</code></pre>\n\n<p>for generating lists and binaries, but there is no corresponding\nform for generating tuples.  We add</p>\n\n<pre><code>    '{' Expr '||' Generators-And-Tests '}'\n</code></pre>\n\n<p>with the meaning that <code>{ E || G }</code> has the same behaviour as\n<code>erlang:list_to_tuple([E || G])</code> except that it need not call\n<code>erlang:list_to_tuple/1</code>.</p>\n\n<p>Currently, Erlang comprehensions allow</p>\n\n<pre><code>    Pattern '&lt;-' Expr\n</code></pre>\n\n<p>to enumerate over list and</p>\n\n<pre><code>    Pattern '&lt;=' Expr\n</code></pre>\n\n<p>to enumerate over binaries.  The second of these forms is,\nI must say, not just asking for trouble, but screaming for it.\nThis proposal adds three new forms:</p>\n\n<pre><code>    Pattern '['  '&lt;-' ']'  Expr\n    Pattern '{'  '&lt;-' '}'  Expr\n    Pattern '&lt;&lt;' '&lt;-' '&gt;&gt;' Expr\n</code></pre>\n\n<p>for enumerating over lists, tuples, and binaries respectively,\nproviding an iconic representation of what Expr should be.\n<code>[&lt;-]</code> and <code>&lt;&lt; &lt;- &gt;&gt;</code> have exactly the same semantics as the\nexisting <code>&lt;-</code> and <code>&lt;=</code> do.  The semantics of Pattern <code>{&lt;=}</code> Expr\nis that of <code>Pattern &lt;- erlang:tuple_to_list(Expr)</code>, except that\n<code>erlang:tuple_to_list/1</code> need not be called.</p>\n\n<p>Currently the Generators-And-Tests part allows a sequence of\ngenerators and tests, where a test is any expression.  A test\nmust evaluate to either 'false' or 'true'.  The form <code>Pattern = Expr</code>\nis syntactically an expression, so is allowed as a test.\nHowever, in context, this makes no sense.  For a given Expr,\nthere are four possible outcomes:\n1. Expr raises an exception => an exception is raised.\n2. Expr does not yield false or true => an exception is raised.\n3. Expr yields false => the test fails;\n   this might as well have been Expr without Pattern.\n4. Expr yields true => the test succeeds;\n   this might as well have been Expr without Pattern,</p>\n\n<h1>   and Pattern = true beforehand.</h1>\n\n<p>This proposal changes part of the description of comprehensions to\neach Qualifier is either a generator, a binder, or a filter.</p>\n\n<p>A generator is a list generator, a tuple generator,\nor a bit string generator.</p>\n\n<p>A list generator is written as\n        Pattern &lt;- List<em>Expr\nor as\n        Pattern [&lt;-] List</em>Expr\nwhere List_Expr is an expression which must evaluate to\na list of terms.</p>\n\n<p>A tuple generator is written as\n        Pattern {&lt;-} Tuple<em>Expr\nwhere Tuple</em>Expr is an expression which must evaluate to\na tuple of terms.</p>\n\n<p>A bit string generator is written as\n        Bit<em>String</em>Pattern &lt;= Bit<em>String</em>Expr\nor as\n        Bit<em>String</em>Pattern &lt;&lt; &lt;- >> Bit<em>String</em>Expr\nwhere Bit<em>String</em>Expr is an expression which must\nevaluate to a bit string.</p>\n\n<p>The variables in the generator patterns shadow variables in the\nfunction clause surrounding the comprehension.  These variables\nare not visible outside the comprehension.</p>\n\n<p>A binder has the form\n    Pattern = Expr\nor\n    Pattern = Binder\nThis evaluates the Expr and matches the result against the\nPattern, binding variables in it.\nThe variables in the binder patterns shadow variables in the\nfunction clause surrounding the comprehension.  These variables\nare not visible outside the comprehension.</p>\n\n<p>A filter is an expression which evaluates to 'true' or 'false'.\nThey are not limited to being guard tests.</p>\n\n<h1>Motivation</h1>\n\n<p>Using Clean as well as Erlang, the lack of tuple comprehensions\nand tuple generators is an irritation.  It is possible to get the\ndesired effect in the existing language, but especially since\nbit string comprehensions were added to the language, the\nomission seems utterly pointless.  The new forms are easier to\nthink of and easier to read than forms that go through list\ncomprehensions.</p>\n\n<p>Haskell list comprehensions allow generators, filters, and\n'let' bindings.  The lack of let bindings in Erlang list\ncomprehensions is difficult to understand; the fact that what\nLOOKS like Erlang's equivalent of let bindings is allowed but\nmisbehaves at run time is difficult to forgive.</p>\n\n<h1>Rationale</h1>\n\n<p>The syntax for tuple comprehensions is obvious; no other syntax\nwould be tolerable.</p>\n\n<p>The syntax for tuple generators has a certain gawky charm;\nperhaps only a mother could love it.  I tried &lt;-[] &lt;-{} &lt;-&lt;&lt;>>\nbut had trouble getting Yecc to like those.  If it can be\nsqueezed past Yecc's limited lookahead somehow, the forms with\nthe arrow outside the brackets would be prettier.  Contrast\n    { X+1 || X {&lt;-} Xs }\n    { X+1 || X &lt;-{} Xs }</p>\n\n<p>The way Erlang currently allows Pattern = Expr in comprehension\nqualifiers but gives it a completely useless meaning is a syntax\nbug that needs urgent correction.  One approach is to recognise\nattempts to use the form and report them as syntax errors; to me\nit seems better to implement it so that it works as expected.</p>\n\n<p>All three of these extensions can be implemented by mapping to\nthe current language:</p>\n\n<pre><code>{ E || GT }  =&gt; erlang:list_to_tuple([E || GT])\nP {&lt;-} E     =&gt; P &lt;- erlang:tuple_to_list(E)\nP = E        =&gt; P &lt;- [E]\n</code></pre>\n\n<p>and the reference implementation does exactly that.  However,\nbetter implementations are possible, as for that matter are\nbetter implementations of list comprehension, and in the mean\ntime at least the code will be no less efficient than what the\nprogrammer could have written and the source will be more\nintention-revealing.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The new comprehension and generator forms are currently syntax\nerrors, so no existing code can be affected by them.</p>\n\n<p>The new binder form (or rather, the newly correct recognition\nof binder forms) is currently allowed by the Erlang compiler.\nHowever, as explained above, it cannot possibly be USEFUL with\nits current reading.  It is conceivable that there might be\ntest programs designed to elicit the bug which will stop working\nonce the syntax bug is fixed, but it is not likely that any real\ncode will be affected.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>The auxiliary file <a href=\"eep-0012-1.diff\" title=\"Patch file to be applied to erl_parse.yrl\"><code>eep-0012-1.diff</code></a> is a patch file to be\napplied to <code>erl_parse.yrl</code>. The patched file has been checked by <code>yecc</code>,\nwhich is happy with it. However, that's all the testing that has been done.</p>\n\n<p>This implementation does the three source to source rewrites\ndescribed in the previous section, entirely in the parser.\nThe rest of the Erlang system needs no changes whatever.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}