{"pageProps":{"item":{"id":"a-brief-BEAM-primer","title":"A brief introduction to BEAM","author":"John Högberg","excerpt":"\nThis post is a brief primer on BEAM, the virtual machine that executes user\ncode in the Erlang Runtime System (ERTS). It's intended to help those new to\nBEAM follow an upcoming series of posts about the JIT in OTP 24, leaving\nimplementation details for later.\n\n[genop.tab]: https://github.com/erlang/otp/blob/master/lib/compiler/src/genop.tab,\n[consing]: https://en.wikipedia.org/wiki/Cons,\n[PR 2765]: https://github.com/erlang/otp/pull/2765","article_date":1603152000000,"tags":["BEAM","compiler","erts"],"frontmatter":{"layout":"post","title":"A brief introduction to BEAM","tags":"BEAM compiler erts","author":"John Högberg"},"content":"\nThis post is a brief primer on BEAM, the virtual machine that executes user\ncode in the Erlang Runtime System (ERTS). It's intended to help those new to\nBEAM follow an upcoming series of posts about the JIT in OTP 24, leaving\nimplementation details for later.\n\nBEAM is often confused with ERTS and it's important to distinguish between the\ntwo; BEAM is just the virtual machine and it has no notion of processes, ports,\nETS tables, and so on. It merely executes instructions and while ERTS has\ninfluenced their design, it doesn't affect what they do when the code is\nrunning, so you don't need to understand ERTS to understand BEAM.\n\nBEAM is a register machine, where all instructions operate on named registers.\nEach register can contain any Erlang term such as an integer or a tuple, and it\nhelps to think of them as simple variables. The two most important kinds of\nregisters are:\n\n- `X`: these are used for temporary data and passing data between functions.\n  They don't require a stack frame and can be freely used in any function, but\n  there are certain limitations which we'll expand on later.\n- `Y`: these are local to each stack frame and have no special\n  limitations beyond needing a stack frame.\n\nControl flow is handled by instructions that test a certain condition and\neither move on to the next instruction or branch to its _fail label_, noted by\n`{f,Index}`. For example `{test,is_integer,{f,7},[{x,0}]}.` checks if `{x,0}`\ncontains an integer and jumps to label 7 if it doesn't.\n\nFunction arguments are passed from left to right in `X` registers, starting at\n`{x,0}`, and the result is returned in `{x,0}`.\n\nIt's easier to explain how this fits together through example, so let's walk\nthrough a few:\n\n```erlang\nsum_tail(List) ->\n    sum_tail(List, 0).\n\nsum_tail([Head | Tail], Acc) ->\n    sum_tail(Tail, Head + Acc);\nsum_tail([], Acc) ->\n    Acc.\n```\n\nLet's use `erlc -S` to look at the instructions one by one:\n\n<pre class=\"highlight\">\n<em>%% sum_tail/1, entry label is 2</em>\n{function, sum_tail, 1, 2}.\n\n  <em>%% Marks a jump target with the label 1.</em>\n  {label,1}.\n\n    <em>%% Special instruction that raises a function_clause\n    %% exception. Unused in this function.</em>\n    {func_info,{atom,primer},{atom,sum_tail},1}.\n\n  {label,2}.\n    <em>%% The meat of the function starts here.\n    %%\n    %% Our only argument - <b>List</b> - is in <b>{x,0}</b> and\n    %% since sum_tail/2 expects it to be the first\n    %% argument we can leave it be. We'll pass the\n    %% integer 0 as the second argument in <b>{x,1}</b>.</em>\n    {move,{integer,0},{x,1}}.\n\n    <em>%% Tail call sum_tail/2, whose entry label is 4.</em>\n    {call_only,2,{f,4}}.\n\n<em>%% sum_tail/2, entry label is 4</em>\n{function, sum_tail, 2, 4}.\n  {label,3}.\n    {func_info,{atom,primer},{atom,sum_tail},2}.\n  {label,4}.\n\n    <em>%% Test whether we have a non-empty list, and jump to\n    %% the base case at label 5 if we don't.</em>\n    {test,is_nonempty_list,{f,5},[{x,0}]}.\n\n    <em>%% Unpack the list in the first argument, placing the\n    %% head in <b>{x,2}</b> and the tail in <b>{x,0}</b>.</em>\n    {get_list,{x,0},{x,2},{x,0}}.\n\n    <em>%% Add the head and our accumulator (remember that the\n    %% second function argument is in <b>{x,1}</b>), and place\n    %% the result in <b>{x,1}</b>.\n    %%\n    %% A fail label of 0 means that we want the\n    %% instruction to throw an exception on error, rather\n    %% than jump to a given label.</em>\n    {gc_bif,'+',{f,0},3,[{x,2},{x,1}],{x,1}}.\n\n    <em>%% Tail-call ourselves to handle the rest of the list,\n    %% the arguments are already in the right registers.</em>\n    {call_only,2,{f,4}}.\n\n  {label,5}.\n    <em>%% Test whether our argument was the empty list. If\n    %% not, we jump to label 3 to raise a function_clause\n    %% exception.</em>\n    {test,is_nil,{f,3},[{x,0}]}.\n\n    <em>%% Return our accumulator.</em>\n    {move,{x,1},{x,0}}.\n    return.\n</pre>\n\nSimple enough, isn't it?\n\nI glossed over one little detail though; the mysterious number `3` in the\naddition instruction. This number tells us how many `X` registers hold live\ndata in case we need more memory, so they can be preserved while the rest are\ndiscarded as garbage. As a consequence, it's unsafe to refer to higher `X`\nregisters after this instruction as their contents may be invalid (in this case\n`{x,3}` and above).\n\nFunction calls are similar; we may schedule ourselves out whenever we call or\nreturn from a function, and we'll only preserve the function arguments/return\nvalue when we do so. This means that all `X` registers except for `{x,0}` are\ninvalid after a call even if you knew for certain that the called function\ndidn't touch a certain register.\n\nThis is where `Y` registers enter the picture. Let's take the previous example\nand make it body-recursive instead:\n\n```erlang\nsum_body([Head | Tail]) ->\n    Head + sum_body(Tail);\nsum_body([]) ->\n    0.\n```\n.\n<pre class=\"highlight\">\n{function, sum_body, 1, 7}.\n  {label,6}.\n    {func_info,{atom,primer},{atom,sum_body},1}.\n  {label,7}.\n    {test,is_nonempty_list,{f,8},[{x,0}]}.\n\n    <em>%% Allocate a stack frame with a single Y register.\n    %% Since this instruction may need more memory, we\n    %% tell the garbage collector that we currently have\n    %% one live X register (our list argument in <b>{x,0}</b>).</em>\n    {allocate,1,1}.\n\n    <em>%% Unpack the list, placing the head in <b>{y,0}</b> and\n    %% the tail in <b>{x,0}</b>.</em>\n    {get_list,{x,0},{y,0},{x,0}}.\n\n    <em>%% Body-call ourselves. Note that while this kills all\n    %% X registers, it leaves Y registers alone so our\n    %% head is still valid.</em>\n    {call,1,{f,7}}.\n\n    <em>%% Add the head to our return value and store the\n    %% result in <b>{x,0}</b>.</em>\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\n    <em>%% Deallocate our stack frame and return.</em>\n    {deallocate,1}.\n    return.\n\n  {label,8}.\n    {test,is_nil,{f,6},[{x,0}]}.\n\n    <em>%% Return the integer 0.</em>\n    {move,{integer,0},{x,0}}.\n    return.\n</pre>\n\nNotice how the call instruction changed now that we're in a stack frame? There\nare three different call instructions:\n\n- `call`: ordinary call as in the example. Control flow will resume at\n  the next instruction when the called function returns.\n- `call_last`: tail call when there is a stack frame. The current frame will\n  be deallocated before the call.\n- `call_only`: tail call when there is no stack frame.\n\nEach of these have a variant for calling functions in other modules (e.g.\n`call_ext`), but they're otherwise identical.\n\nSo far we've only looked at using terms, but what about creating them? Let's\nhave a look:\n\n```erlang\ncreate_tuple(Term) ->\n    {hello, Term}.\n```\n.\n<pre class=\"highlight\">\n{function, create_tuple, 1, 10}.\n  {label,9}.\n    {func_info,{atom,primer},{atom,create_tuple},1}.\n  {label,10}.\n    <em>%% Allocate the three words needed for a 2-tuple, with\n    %% a liveness annotation of 1 indicating that <b>{x,0}</b>\n    %% is alive in case we need to GC.</em>\n    {test_heap,3,1}.\n\n    <em>%% Create the tuple and place the result in <b>{x,0}</b></em>\n    {put_tuple2,{x,0},{list,[{atom,hello},{x,0}]}}.\n  \n    return.\n</pre>\n\nThis is a bit magical in the sense that there's an unseen register for memory\nallocations, but allocation is rarely far apart from use and it's usually\npretty easy to follow. The same principle applies for lists ([consing]),\nfloats, and funs as well following [PR 2765].\n\nMore complicated types like maps, big integers, references, and so on are\ncreated by special instructions that may GC on their own (or allocate outside\nthe heap in a \"heap fragment\") as their size can't be statically determined in\nadvance.\n\nNow let's look at something more uncommon: exceptions.\n\n```erlang\nexception() ->\n    try\n        external:call()\n    catch\n        throw:example -> hello\n    end.\n```\n.\n<pre class=\"highlight\">\n{function, exception, 0, 12}.\n  {label,11}.\n    {func_info,{atom,primer},{atom,exception},0}.\n  {label,12}.\n    {allocate,1,0}.\n  \n    <em>%% Place a catch tag in <b>{y,0}</b>. If an exception is\n    %% raised while this tag is the most current one,\n    %% the control flow will resume at <b>{f,13}</b> in this\n    %% stack frame.</em>\n    {'try',{y,0},{f,13}}.\n\n    {call_ext,0,{extfunc,external,call,0}}.\n\n    <em>%% Deactivate the catch tag before returning with the\n    %% result from the call.</em>\n    {try_end,{y,0}}.\n\n    {deallocate,1}.\n    return.\n\n  {label,13}.\n    <em>%% Uh oh, we've got an exception. Kill the catch tag\n    %% and place the exception class in <b>{x,0}</b>, the error\n    %% reason/thrown value in <b>{x,1}</b>, and the stack trace\n    %% in <b>{x,2}</b>.</em>\n    {try_case,{y,0}}.\n\n    <em>%% Return 'hello' if the user threw 'example'</em>\n    {test,is_eq_exact,{f,14},[{x,0},{atom,throw}]}.\n    {test,is_eq_exact,{f,14},[{x,1},{atom,example}]}.\n    {move,{atom,hello},{x,0}}.\n    {deallocate,1}.\n    return.\n\n  {label,14}.\n    <em>%% Otherwise, rethrow the exception since no catch\n    %% clause matched.</em>\n    {bif,raise,{f,0},[{x,2},{x,1}],{x,0}}.\n</pre>\n\nBy now you've probably noticed how the control flow only moves forward; just\nlike Erlang itself the only way to loop is through recursion. The one exception\nto this is the receive construct, which may loop until a matching message has\nbeen received:\n\n```erlang\nselective_receive(Ref) ->\n    receive\n        {Ref, Result} -> Result\n    end.\n```\n.\n<pre class=\"highlight\">\n{function, selective_receive, 1, 16}.\n  {label,15}.\n    {func_info,{atom,primer},{atom,selective_receive},1}.\n  {label,16}.\n    {allocate,1,1}.\n\n    <em>%% We may be scheduled out while waiting for a\n    %% message, so we'll preserve our <b>Ref</b> in <b>{y,0}</b>.</em>\n    {move,{x,0},{y,0}}.\n\n  {label,17}.\n    <em>%% Pick the next message from the process' message box\n    %% and place it in <b>{x,0}</b>, jumping to label 19 if the\n    %% message box is empty.</em>\n    {loop_rec,{f,19},{x,0}}.\n  \n    <em>%% Does it match our pattern? If not, jump to label 18\n    %% and try the next message.</em>\n    {test,is_tuple,{f,18},[{x,0}]}.\n    {test,test_arity,{f,18},[{x,0},2]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {test,is_eq_exact,{f,18},[{x,1},{y,0}]}.\n\n    <em>%% We've got a match, extract the result and remove\n    %% the message from the mailbox.</em>\n    {get_tuple_element,{x,0},1,{x,0}}.\n    remove_message.\n    {deallocate,1}.\n    return.\n\n  {label,18}.\n    <em>%% The message didn't match, loop back to handle our\n    %% next message. Note that the current message remains\n    %% in the inbox since a different receive may be\n    %% interested in it.</em>\n    {loop_rec_end,{f,17}}.\n\n  {label,19}.\n    <em>%% Wait until the next message arrives, returning to\n    %% the start of the loop when it does. If there's a\n    %% timeout involved, it will be handled here.</em>\n    {wait,{f,17}}.\n</pre>\n\nThere's not much more to it, and if you feel comfortable following the examples\nabove you should have no problems with the JIT series.\n\nIf you're curious about which instructions there are, you can find a brief\ndescription of every instruction in [genop.tab].\n\n[genop.tab]: https://github.com/erlang/otp/blob/master/lib/compiler/src/genop.tab\n[consing]: https://en.wikipedia.org/wiki/Cons\n[PR 2765]: https://github.com/erlang/otp/pull/2765\n"}},"__N_SSG":true}