{"pageProps":{"index":{"id":"0028","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 08-Aug-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 28: <a href=\"eep-0028.md\" title=\"EEP Source\"> Optional leading semicolons for choices</a></h2>\n\n<h1>Abstract</h1>\n\n<p>'If', 'case', 'receive', and 'try' clauses may begin with a semicolon.</p>\n\n<h1>Specification</h1>\n\n<p>A semicolon is allowed after the keywords 'if', 'of',\n'receive' (provided the next word is not 'after'),\nand 'catch' (in a 'try' expression).</p>\n\n<p>The semicolon has no effect; it is merely there to allow\na layout style which makes it easier to see the semicolons,\neasier to ensure that commas are commas and semicolons are\nsemicolons, and easier to change the order of choices.</p>\n\n<h1>Motivation</h1>\n\n<p>In his PhD thesis on compiling Prolog, Peter van Roy complained\nthat commas and semicolons were hard to distinguish.  In response,\nI developed a Prolog layout style where commas go at the end of\nlines and semicolons go at the beginner, so that a human being\nreading the text is never in doubt about which is intended.</p>\n\n<p>Commas and semicolons remain hard to distinguish in Erlang.\nIt turns out that a semicolons-at-the-front style works well\nfor Erlang too.</p>\n\n<pre><code>do_load_driver(Path, Driver, DriverFlags) -&gt;\n    case erl_ddll:try_load(Path, Driver,\n           [{monitor,pending_driver}]++DriverFlags) of\n    {error, inconsistent} -&gt;\n        {error,bad_driver_name};\n    {error, What} -&gt;\n        {error,What};\n    {ok, already_loaded} -&gt;\n        ok;\n    {ok,loaded} -&gt;\n        ok;\n    {ok, pending_driver, Ref} -&gt;\n        receive\n        {'DOWN', Ref, driver, _, load_cancelled} -&gt;\n            {error, load_cancelled};\n        {'UP', Ref, driver, _, permanent} -&gt;\n            {error, permanent};\n        {'DOWN', Ref, driver, _,\n                {load_failure, Failure}} -&gt;\n            {error, Failure};\n        {'UP', Ref, driver, _, loaded} -&gt;\n            ok\n        end\n    end.\n</code></pre>\n\n<p>In this layout style, the visually most salient part is the\nbeginning of the line, and except for 'case', 'receive', and\n'end', <em>every</em> line could be <em>any</em> line.  Indentation alone\nis not a reliable guide, because some logical lines have to\nbe split across multiple physical lines.</p>\n\n<p>My current style is</p>\n\n<pre><code>do_load_driver(Path, Driver, DriverFlags) -&gt;\n    case erl_ddll:try_load(Path, Driver,\n           [{monitor,pending_driver}]++DriverFlags)\n     of {error, inconsistent} -&gt;\n        {error,bad_driver_name}\n      ; {error, What} -&gt;\n        {error,What}\n      ; {ok, already_loaded} -&gt;\n        ok\n      ; {ok,loaded} -&gt;\n        ok\n      ; {ok, pending_driver, Ref} -&gt;\n        receive\n        {'DOWN', Ref, driver, _, load_cancelled} -&gt;\n            {error, load_cancelled}\n          ; {'UP', Ref, driver, _, permanent} -&gt;\n            {error, permanent}\n          ; {'DOWN', Ref, driver, _,\n                {load_failure, Failure}} -&gt;\n            {error, Failure}\n          ; {'UP', Ref, driver, _, loaded} -&gt;\n            ok\n        end\n    end.\n</code></pre>\n\n<p>Here the leading semicolons make it <em>obvious</em> with even half\nan eye where each choice begins, and the line of semicolons\n(lining up with the 'd' of 'end') makes it easy to see the\nstructure without a ruler.  There is only one snag:  the\nfirst choice has to be different.  It would be more consistent\nto write</p>\n\n<pre><code>do_load_driver(Path, Driver, DriverFlags) -&gt;\n    case erl_ddll:try_load(Path, Driver,\n           [{monitor,pending_driver}]++DriverFlags) of\n      ; {error, inconsistent} -&gt;\n        {error,bad_driver_name}\n      ; {error, What} -&gt;\n        {error,What}\n      ; {ok, already_loaded} -&gt;\n        ok\n      ; {ok,loaded} -&gt;\n        ok\n      ; {ok, pending_driver, Ref} -&gt;\n        receive\n          ; {'DOWN', Ref, driver, _, load_cancelled} -&gt;\n            {error, load_cancelled}\n          ; {'UP', Ref, driver, _, permanent} -&gt;\n            {error, permanent}\n          ; {'DOWN', Ref, driver, _,\n                {load_failure, Failure}} -&gt;\n            {error, Failure}\n          ; {'UP', Ref, driver, _, loaded} -&gt;\n            ok\n        end\n    end.\n</code></pre>\n\n<p>Now each choice has the same structure, and if we wished to\nreorder the choices, we could easily do so without adding,\nremoving, or changing any punctuation.</p>\n\n<p>It is relevant to see what case statements look like in some other\nprogramming languages, to see that this style is quite general.</p>\n\n<ul>\n<li><p>Fortran:</p>\n\n<pre><code>SELECT CASE (expression)\nCASE (values and ranges)\n    statements\nCASE (values and ranges)\n    statements\nCASE DEFAULT\n    statements\nEND CASE\n</code></pre></li>\n<li><p>Ada:</p>\n\n<pre><code>case Expression is\nwhen Discrete_Choice_List =&gt;\n    Statements;\nwhen Discrete_Choice_List =&gt;\n    Statements;\nwhen others =&gt;\n    Statements;\nend case;\n</code></pre></li>\n<li><p>PL/I:</p>\n\n<pre><code>select (Expression);\n  when (Values) Statement;\n  when (Values) Statement;\n  otherwise     Statement;\nend;\n</code></pre></li>\n</ul>\n\n<p>These all exhibit \"comb style\", the ability to rearrange choices\nwithout adding, removing, or changing punctuation or keywords,\nand a clear indication at the <em>beginning</em> of each choice.</p>\n\n<h1>Rationale</h1>\n\n<p>People who like the usual Erlang style should not be forced to\nchange.  This means that the leading semicolon must be optional,\nnot required.</p>\n\n<p>Some of the benefits claimed above could be had by allowing\noptional trailing semicolons instead of optional leading ones.\nHowever, in Erlang as it stands, the semicolon is an operator,\nnot a terminator.  There is nothing unusual about allowing an\noperator to have a prefix version as well as an infix version.\nThere isn't even anything unusual about a prefix operator that\ndoesn't do much except clarify things: '+' is the obvious\nexample.  So allowing a \"do-nothing\" prefix use of semicolons\nin certain contexts is still within the spirit of Erlang.</p>\n\n<p>That apart, the change is about as simple as it could be.\nThe only doubtful point is whether a semicolon should be\nallowed before 'after'.  But 'after' is already a keyword\nexplaining what comes next, and it can't be moved around\nfreely anyway.  Since there seems to be nothing to gain,\nlet's not do it.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All existing Erlang code remains acceptable with unchanged\nsemantics.  The leading semicolons are dealt with entirely in\nthe parser; other language manipulation tools never know that\nthe semicolons were ever there, so work perfectly with code\nusing the new style.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>The auxiliary file <a href=\"eep-0028-1.diff\" title=\"Diff to apply to erl_parse.yrl\">eep-0028-1.diff</a>\nis a patch file to be applied to <code>erl_parse.yrl</code>.\nThe patched file has been checked by yecc, which is happy\nwith it, and the resulting .erl file compiles cleanly.\nHowever, that's all the testing that has been done.</p>\n\n<p>All that the implementation does is to change</p>\n\n<pre><code>.... 'thingy' .....\n</code></pre>\n\n<p>to</p>\n\n<pre><code>.... thingy_kw .....\n\nthingy_kw -&gt; 'thingy'.\nthingy_kw -&gt; 'thingy' ';'.\n</code></pre>\n\n<p>in several places.  This form of change, rather than</p>\n\n<pre><code>.... 'thingy' optional_semicolon ....,\n</code></pre>\n\n<p>was chosen so that the '$n' forms in the existing rules would\nneed no revision, so I am confident that no errors were\nintroduced by this change.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}