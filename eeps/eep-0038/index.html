<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R14B04
Created: 27-May-2011
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 38: <a href="eep-0038.md" title="EEP Source"> -discontiguous directive</a></h2>

<h1>Abstract</h1>

<p>A <code>-discontiguous</code> directive is to be added so that specified
functions may be presented as more than one group of clauses,
possibly separated by other directives and function clause
groups.</p>

<h1>Specification</h1>

<p>A new directive</p>

<pre><code>-discontiguous( Name_And_Arity_List ).
</code></pre>

<p>is added.  Each function named in such a list must have at
least one clause group in that module, and may have more.
It remains an error for any function not named in such a
list to have more than one clause group.</p>

<p>A function named in a <code>-discontiguous</code> directive need not
have more than one clause group.  If it does, it is if
the clause groups were moved together without reordering
and the full stop of each group but the last changed to
a semicolon.  The compiler should make no comment about
the existence of multiple clause groups or their fusion
into single clause groups.</p>

<p>The parser stage would do the regrouping and would not
include any representation of the <code>-discontiguous</code> directive
in its output, so that downstream tools would never know
that <code>-discontiguous</code> had been there.</p>

<h1>Motivation</h1>

<p>There are three problems which a single mechanism can solve.</p>

<p>The first is that Erlang has conditional compilation, but
there is no really satisfactory to use it to select some
but not all of the clauses of a function.</p>

<p>The <code>-discontiguous</code> directive allows you to write</p>

<pre><code>-discontiguous([f/3]).

f(a, X, Y) -&gt; .... .
-if(Cond).
f(b, X, Y) -&gt; .... .
-endif.
f(c, X, T) -&gt; .... .
</code></pre>

<p>The second may be called "topic-oriented programming".
It relates to human structuring of code around the
data values computed on rather than the code they compute.
I have found this in dealing with a virtual machine:  I've
wanted to place the code that assembles an instruction,
the code that peephole optimises it, the code that encodes
it into memory, and the code that interprets it into one
place (involving different function), rather than organising
it by function, thus scattering related information the
length and breadth of the module.</p>

<p>It may be clearest to start with an example.  The code
in <code>erl_syntax.erl</code> reads:</p>

<pre><code>-type syntaxTree() :: #tree{} | #wrapper{} | tuple().

%% All `erl_parse' tree nodes are represented by tuples
%% whose second field is the position information (usually
%% an integer), *with the exceptions of*
%% `{error, ...}' (type `error_marker') and
%% `{warning, ...}' (type `warning_marker'),
%% which only contain the associated line number *of the
%% error descriptor*; this is all handled transparently
%% by `get_pos' and `set_pos'.

    get_pos(#tree{attr = Attr}) -&gt;
        Attr#attr.pos;
    get_pos(#wrapper{attr = Attr}) -&gt;
        Attr#attr.pos;
    get_pos({error, {Pos, _, _}}) -&gt;
        Pos;
    get_pos({warning, {Pos, _, _}}) -&gt;
        Pos;
    get_pos(Node) -&gt;
        %% Here, we assume that we have an `erl_parse' node
        %% with position information in element 2.
        element(2, Node).

    set_pos(Node, Pos) -&gt;
        case Node of
            #tree{attr = Attr} -&gt;
                Node#tree{attr = Attr#attr{pos = Pos}};
            #wrapper{attr = Attr} -&gt;
                Node#wrapper{attr = Attr#attr{pos = Pos}};
            _ -&gt;
                %% We then assume we have an `erl_parse' node,
                %% and create a wrapper around it to make
                %% things more uniform.
                set_pos(wrap(Node), Pos)
        end.
</code></pre>

<p>The type here is a little vague.  The additional tuples appear
to be <code>{error,{Pos,_,_}}, {warning,{Pos,_,_}}</code>, and the
<code>{Tag,Pos...}</code> tuples returned by <code>erl_parse</code>.  The thing here is
that there are five different cases.  For some purposes,
it would be better to write</p>

<pre><code>-discontiguous([get_pos/1,set_pos/2]).

get_pos(#tree{attr = Attr}) -&gt; Attr#attr.pos.
set_pos(#tree{attr = Attr} = Node, Pos) -&gt;
    Node#tree{attr = Attr#attr{pos = Pos}}.

get_pos(#wrapper{attr = Attr}) -&gt; Attr#attr.pos.
set_pos(#wrapper{attr = Attr} = Node, Pos) -&gt;
    Node#wrapper{attr = Attr#attr{pos = Pos}}.

get_pos({error, {Pos,_,_}}) -&gt; Pos.
% What should set_pos/2 do in this case?

get_pos({warning, {Pos,_,_}}) -&gt; Pos.
% What should set_pos/2 do in this case?

get_pos(Node) -&gt; element(2, Node).  % assume erl_parse node
set_pos(Node, Pos) -&gt;               % assume erl_parse node
    set_pos(wrap(Node), Pos).       % wrap it for uniformity
</code></pre>

<p>This brings out the parallel between the two functions,
and the way the parallel fails, more clearly than any other
possible layout.  It nags at you to either finish the
parallel with the obvious</p>

<pre><code>set_pos({error, {_,X,Y}}, Pos) -&gt;
    {error, {Pos,X,Y}}.
</code></pre>

<p>and</p>

<pre><code>set_pos({warning, {_,X,Y}), Pos) -&gt;
    {warning, {Pos,X,Y}}.
</code></pre>

<p>clauses or to at least change the comments to</p>

<pre><code>% set_pos/2 falls through to the last case.
</code></pre>

<p>comments.</p>

<p>We have the same pattern, without the failure of parallelism,
in two more functions from that file:</p>

<pre><code>get_com(#tree{attr = Attr}) -&gt; Attr#attr.com;
get_com(#wrapper{attr = Attr}) -&gt; Attr#attr.com;
get_com(_) -&gt; none.

set_com(Node, Com) -&gt;
    case Node of
        #tree{attr = Attr} -&gt;
            Node#tree{attr = Attr#attr{com = Com}};
        #wrapper{attr = Attr} -&gt;
            Node#wrapper{attr = Attr#attr{com = Com}};
        _ -&gt;
            set_com(wrap(Node), Com)
    end.
</code></pre>

<p>These could be</p>

<pre><code>-discontiguous([get_com/1,set_com/1]).

get_com(#tree{attr = Attr}) -&gt; Attr#attr.com.
set_com(#tree{attr = Attr} = Node, Com) -&gt;
    Node#tree{attr = Attr#attr{com = Com}}.

get_com(#wrapper{attr = Attr}) -&gt; Attr#attr.com.
set_com(#wrapper{attr = Attr} = Node, Com) -&gt;
    Node#wrapper{attr = Attr#attr{com = Com}}.

get_com(_) -&gt; none.  % error, warning, erl_parse.
set_com(Node, Com) -&gt;
    set_com(wrap(Node), Com).
</code></pre>

<p>Well, once again the parallel is not quite perfect.
The documentation for <code>wrap/1</code> says that it assumes
its argument is a class <code>erl_parse</code> tuple, which here
means that it appears that it should NOT be an error
or warning.</p>

<p>The point of interest here is that just looking at the
existing functions didn't ring any alarms; it was not
until I said "these seem to be about the same data
structure; I wonder if interleaving can make the
connection clearer and make it easier to ensure that
getters and setters are properly related?" that my
attention was properly drawn to the differences.</p>

<p>It's particularly interesting that the very first Erlang/OTP
source file I looked at provided examples.
The third is like the second, but relates to code
written by a computer, not a human.  For example, if
generating a functional representation of some sort
of state machine, it can be convenient to organise
the output around the states, but the present scheme
requires it to be organised around the functions that
deal with the states.</p>

<h1>Rationale</h1>

<p>Prolog systems have supported a <code>:- discontiguous</code> declaration
for 20+ years.  The approach is a proven one.  It is a simple
generalisation of the language which can be hidden from all
"downstream" tools.  Only tools that try to deal with Erlang
syntax without fully parsing it could notice the difference,
and they should largely ignore it.</p>

<h1>Backwards Compatibility</h1>

<p>All existing Erlang code remains acceptable with unchanged
semantics.  Existing language-processing tools are unaffected
if they rely on <code>erl_parse</code>.</p>

<h1>Reference Implementation</h1>

<p>None in this draft.</p>

<h1>References</h1>

<p>None.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0038","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R14B04\nCreated: 27-May-2011\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 38: \u003ca href=\"eep-0038.md\" title=\"EEP Source\"\u003e -discontiguous directive\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eA \u003ccode\u003e-discontiguous\u003c/code\u003e directive is to be added so that specified\nfunctions may be presented as more than one group of clauses,\npossibly separated by other directives and function clause\ngroups.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eA new directive\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-discontiguous( Name_And_Arity_List ).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis added.  Each function named in such a list must have at\nleast one clause group in that module, and may have more.\nIt remains an error for any function not named in such a\nlist to have more than one clause group.\u003c/p\u003e\n\n\u003cp\u003eA function named in a \u003ccode\u003e-discontiguous\u003c/code\u003e directive need not\nhave more than one clause group.  If it does, it is if\nthe clause groups were moved together without reordering\nand the full stop of each group but the last changed to\na semicolon.  The compiler should make no comment about\nthe existence of multiple clause groups or their fusion\ninto single clause groups.\u003c/p\u003e\n\n\u003cp\u003eThe parser stage would do the regrouping and would not\ninclude any representation of the \u003ccode\u003e-discontiguous\u003c/code\u003e directive\nin its output, so that downstream tools would never know\nthat \u003ccode\u003e-discontiguous\u003c/code\u003e had been there.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThere are three problems which a single mechanism can solve.\u003c/p\u003e\n\n\u003cp\u003eThe first is that Erlang has conditional compilation, but\nthere is no really satisfactory to use it to select some\nbut not all of the clauses of a function.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003e-discontiguous\u003c/code\u003e directive allows you to write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-discontiguous([f/3]).\n\nf(a, X, Y) -\u0026gt; .... .\n-if(Cond).\nf(b, X, Y) -\u0026gt; .... .\n-endif.\nf(c, X, T) -\u0026gt; .... .\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe second may be called \"topic-oriented programming\".\nIt relates to human structuring of code around the\ndata values computed on rather than the code they compute.\nI have found this in dealing with a virtual machine:  I've\nwanted to place the code that assembles an instruction,\nthe code that peephole optimises it, the code that encodes\nit into memory, and the code that interprets it into one\nplace (involving different function), rather than organising\nit by function, thus scattering related information the\nlength and breadth of the module.\u003c/p\u003e\n\n\u003cp\u003eIt may be clearest to start with an example.  The code\nin \u003ccode\u003eerl_syntax.erl\u003c/code\u003e reads:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-type syntaxTree() :: #tree{} | #wrapper{} | tuple().\n\n%% All `erl_parse' tree nodes are represented by tuples\n%% whose second field is the position information (usually\n%% an integer), *with the exceptions of*\n%% `{error, ...}' (type `error_marker') and\n%% `{warning, ...}' (type `warning_marker'),\n%% which only contain the associated line number *of the\n%% error descriptor*; this is all handled transparently\n%% by `get_pos' and `set_pos'.\n\n    get_pos(#tree{attr = Attr}) -\u0026gt;\n        Attr#attr.pos;\n    get_pos(#wrapper{attr = Attr}) -\u0026gt;\n        Attr#attr.pos;\n    get_pos({error, {Pos, _, _}}) -\u0026gt;\n        Pos;\n    get_pos({warning, {Pos, _, _}}) -\u0026gt;\n        Pos;\n    get_pos(Node) -\u0026gt;\n        %% Here, we assume that we have an `erl_parse' node\n        %% with position information in element 2.\n        element(2, Node).\n\n    set_pos(Node, Pos) -\u0026gt;\n        case Node of\n            #tree{attr = Attr} -\u0026gt;\n                Node#tree{attr = Attr#attr{pos = Pos}};\n            #wrapper{attr = Attr} -\u0026gt;\n                Node#wrapper{attr = Attr#attr{pos = Pos}};\n            _ -\u0026gt;\n                %% We then assume we have an `erl_parse' node,\n                %% and create a wrapper around it to make\n                %% things more uniform.\n                set_pos(wrap(Node), Pos)\n        end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe type here is a little vague.  The additional tuples appear\nto be \u003ccode\u003e{error,{Pos,_,_}}, {warning,{Pos,_,_}}\u003c/code\u003e, and the\n\u003ccode\u003e{Tag,Pos...}\u003c/code\u003e tuples returned by \u003ccode\u003eerl_parse\u003c/code\u003e.  The thing here is\nthat there are five different cases.  For some purposes,\nit would be better to write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-discontiguous([get_pos/1,set_pos/2]).\n\nget_pos(#tree{attr = Attr}) -\u0026gt; Attr#attr.pos.\nset_pos(#tree{attr = Attr} = Node, Pos) -\u0026gt;\n    Node#tree{attr = Attr#attr{pos = Pos}}.\n\nget_pos(#wrapper{attr = Attr}) -\u0026gt; Attr#attr.pos.\nset_pos(#wrapper{attr = Attr} = Node, Pos) -\u0026gt;\n    Node#wrapper{attr = Attr#attr{pos = Pos}}.\n\nget_pos({error, {Pos,_,_}}) -\u0026gt; Pos.\n% What should set_pos/2 do in this case?\n\nget_pos({warning, {Pos,_,_}}) -\u0026gt; Pos.\n% What should set_pos/2 do in this case?\n\nget_pos(Node) -\u0026gt; element(2, Node).  % assume erl_parse node\nset_pos(Node, Pos) -\u0026gt;               % assume erl_parse node\n    set_pos(wrap(Node), Pos).       % wrap it for uniformity\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis brings out the parallel between the two functions,\nand the way the parallel fails, more clearly than any other\npossible layout.  It nags at you to either finish the\nparallel with the obvious\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eset_pos({error, {_,X,Y}}, Pos) -\u0026gt;\n    {error, {Pos,X,Y}}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eset_pos({warning, {_,X,Y}), Pos) -\u0026gt;\n    {warning, {Pos,X,Y}}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eclauses or to at least change the comments to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e% set_pos/2 falls through to the last case.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecomments.\u003c/p\u003e\n\n\u003cp\u003eWe have the same pattern, without the failure of parallelism,\nin two more functions from that file:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eget_com(#tree{attr = Attr}) -\u0026gt; Attr#attr.com;\nget_com(#wrapper{attr = Attr}) -\u0026gt; Attr#attr.com;\nget_com(_) -\u0026gt; none.\n\nset_com(Node, Com) -\u0026gt;\n    case Node of\n        #tree{attr = Attr} -\u0026gt;\n            Node#tree{attr = Attr#attr{com = Com}};\n        #wrapper{attr = Attr} -\u0026gt;\n            Node#wrapper{attr = Attr#attr{com = Com}};\n        _ -\u0026gt;\n            set_com(wrap(Node), Com)\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThese could be\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-discontiguous([get_com/1,set_com/1]).\n\nget_com(#tree{attr = Attr}) -\u0026gt; Attr#attr.com.\nset_com(#tree{attr = Attr} = Node, Com) -\u0026gt;\n    Node#tree{attr = Attr#attr{com = Com}}.\n\nget_com(#wrapper{attr = Attr}) -\u0026gt; Attr#attr.com.\nset_com(#wrapper{attr = Attr} = Node, Com) -\u0026gt;\n    Node#wrapper{attr = Attr#attr{com = Com}}.\n\nget_com(_) -\u0026gt; none.  % error, warning, erl_parse.\nset_com(Node, Com) -\u0026gt;\n    set_com(wrap(Node), Com).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWell, once again the parallel is not quite perfect.\nThe documentation for \u003ccode\u003ewrap/1\u003c/code\u003e says that it assumes\nits argument is a class \u003ccode\u003eerl_parse\u003c/code\u003e tuple, which here\nmeans that it appears that it should NOT be an error\nor warning.\u003c/p\u003e\n\n\u003cp\u003eThe point of interest here is that just looking at the\nexisting functions didn't ring any alarms; it was not\nuntil I said \"these seem to be about the same data\nstructure; I wonder if interleaving can make the\nconnection clearer and make it easier to ensure that\ngetters and setters are properly related?\" that my\nattention was properly drawn to the differences.\u003c/p\u003e\n\n\u003cp\u003eIt's particularly interesting that the very first Erlang/OTP\nsource file I looked at provided examples.\nThe third is like the second, but relates to code\nwritten by a computer, not a human.  For example, if\ngenerating a functional representation of some sort\nof state machine, it can be convenient to organise\nthe output around the states, but the present scheme\nrequires it to be organised around the functions that\ndeal with the states.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eProlog systems have supported a \u003ccode\u003e:- discontiguous\u003c/code\u003e declaration\nfor 20+ years.  The approach is a proven one.  It is a simple\ngeneralisation of the language which can be hidden from all\n\"downstream\" tools.  Only tools that try to deal with Erlang\nsyntax without fully parsing it could notice the difference,\nand they should largely ignore it.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eAll existing Erlang code remains acceptable with unchanged\nsemantics.  Existing language-processing tools are unaffected\nif they rely on \u003ccode\u003eerl_parse\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone in this draft.\u003c/p\u003e\n\n\u003ch1\u003eReferences\u003c/h1\u003e\n\n\u003cp\u003eNone.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0038"},"buildId":"NPm6cMGILpqRmaNHZXj9d","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/NPm6cMGILpqRmaNHZXj9d/_buildManifest.js" async=""></script><script src="/_next/static/NPm6cMGILpqRmaNHZXj9d/_ssgManifest.js" async=""></script></body></html>