<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Rickard Green &lt;rickard(at)erlang(dot)org&gt;
Status: Draft
Type: Standards Track
Erlang-Version: 24.0
Created: 01-Sept-2019
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 53: <a href="eep-0053.md" title="EEP Source"> Process aliases preventing late replies reaching clients</a></h2>

<h1>Abstract</h1>

<p>Currently there exists no lightweight mechanism for preventing late replies
from a server to a client after a timeout or connection loss has occurred.
The only way to prevent late replies today is to make the request via
a proxy process.</p>

<p>The proposed process alias feature is a lightweight mechanism that solves
the above problem. A process alias is similar to a registered name that
is used temporarily while a request is outstanding. If the request times
out or the connection to the server is lost, the alias is deactivated which
prevents a late reply from reaching the client.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>

<h1>Specification</h1>

<p>An alias is of the Erlang type <code>reference()</code> and can be used as destination
when sending using the <code>!</code> operator, or when sending using the <code>erlang:send()</code>
and <code>erlang:send_nosuspend()</code> BIFs. An alias can be used both on local
node and on remote nodes in a distributed system. The alias identifies a
process that exist, or has existed, on the node with the node name returned
by <code>node(Alias)</code>.</p>

<p>All references will, as of this, be accepted as destination in the message send
operations listed above. If the reference is not an alias or a previous alias
that has been deactivated, the message will silently be dropped.</p>

<p>These new BIFs are introduced:</p>

<ul>
<li><p><code>alias/0</code>, <code>alias/1</code>. The <code>alias()</code> BIF creates and returns an alias which
can be used when sending messages to the process that called the <code>alias()</code>
BIF.</p></li>
<li><p><code>unalias/1</code>. The <code>unalias(Alias)</code> BIF deactivates an alias that identifies
the calling process. The BIF returns <code>true</code> if the alias <code>Alias</code> identified
the calling process and thus was deactivated; otherwise, no change of the
alias state was made and <code>false</code> is returned.</p></li>
<li><p><code>monitor/3</code>. The <code>monitor/3</code> BIF is an extension of the <code>monitor/2</code> BIF
where the third argument is an option list. As of its introduction it
accepts two options:</p>

<ul>
<li><p>'{alias, unalias | demonitor | reply_demonitor}'. The first element of
the two tuple indicates that we want the returned monitor reference to
also work as an alias. The second element determines how the alias should
be deactivated:</p>

<ul>
<li><code>unalias</code> - The alias will remain until it has been deactivated by the
<code>unalias/1</code> BIF</li>
<li><code>demonitor</code> - The alias will be deactivated when the monitor is
deactivated. That is, either when the <code>demonitor()</code> BIF is called on
the monitor, or when the monitor is automatically deactivated by the
reception of a <code>'DOWN'</code> message. The alias can still be deactivated
before this happens by calling the <code>unalias/1</code> BIF.</li>
<li><code>reply_demonitor</code> - The alias will be deactivated when either the
monitor is deactivated or a message that has been passed using the
alias is received. If the alias is deactivated due to a message passed
using the alias, the monitor is also deactivated as if the <code>demonitor()</code>
BIF had been called.</li>
</ul></li>
<li><p><code>{tag, UserDefinedTag}</code>. This will replace the default <code>Tag</code> with
<code>UserDefinedTag</code> in the monitor message delivered when the monitor is
triggered. For example, when monitoring a process, the <code>'DOWN'</code> tag in
the down message will be replaced by <code>UserDefinedTag</code>. </p></li>
</ul></li>
</ul>

<p>The <code>spawn_opt()</code> and <code>spawn_request()</code> BIFs have also been extended to
accept an option <code>{monitor, MonitorOpts}</code> where <code>MonitorOpts</code> correspond to
the option list of the <code>monitor/3</code> BIF.</p>

<p>Full documentation of these BIFs and options can be found via
<a href="https://github.com/erlang/otp/pull/2735">pull request #2735</a>
containing the reference implementation.</p>

<p>It is not possible to retrieve the process identifier of the process
identified by an alias, and it is not possible to test if a reference is an
alias or not.</p>

<h1>Motivation</h1>

<p>As previously stated it is possible to prevent late replies by using a
proxy process that forwards the reply to the client. By spawning the proxy
process and send its process identifier to the server instead of the
clients own process identifier, the proxy can be terminated when the
operation times out or the connection is lost. Since the proxy process
is not alive, a reply will be silently dropped and no stray message
will reach the previous client of the request. This however both makes
the code more complicated and less efficient than it needs to be. The
inefficiency comes from both the need to create, schedule, execute, and
terminate the proxy process and the extra copying of data over the proxy
process.</p>

<p>When the author of the client code has full control over the client process
such late replies can be handled without a proxy since the code can be
aware of these potential stray messages and drop them when received. This
is, however, not possible when implementing library code. You then either
need to use a proxy process, as done by the <code>gen_statem</code> behavior, or
accept that the client process may get stray messages after a call, as
done by the <code>gen_server</code> behavior.</p>

<p>Process aliases solves these issues with a very small overhead.</p>

<h1>Rationale</h1>

<h2>Why use the reference data type for alias?</h2>

<p>This is more or less what the reference data type is there for. A data type
that can identify a huge amount of different entities. References are unique
and contain a node identifier identifying the the node it originates from.
This makes it easy to identify a specific process on a specific node while
also identifying different aliases created by the same process. The embedded
node identifier makes it easy to provide distribution transparency.</p>

<h2>Why not make alias an opaque data type?</h2>

<p>The expected most common use case is in a client server request. Such as
<code>gen_server:call()</code>. Client server requests in Erlang are typically made
while monitoring the server from the client. In order to minimize the data
produced and sent in the request we want to reuse the reference created for
identification of the monitor to also function as an alias. Since the monitor
identifier is documented as a reference and is not opaque (which one can
argue was a design mistake when introducing monitors), it becomes hard not
to document the type of an alias as a reference as well.</p>

<h2>Why not allow references as registered names in the already existing API?</h2>

<p>There are two reasons. Distribution transparency and scalability.</p>

<p>Distribution transparency is really desirable since the user can use the
functionality the same way regardless of whether it is a node local operation
or node remote operation. The name registration API is not distribution
transparent.</p>

<p>Regarding scalability. Due to how the name registration API has been designed
we need some sort of table in order to implement the API. This table will be
written to and read from by processes that are executing in parallel. In the
use case we are focusing on, names (aliases) are expected to be temporary and
created in huge amounts. That is, there will be large amounts of modifications
of this table from processes executing on different processors. This will
make it challenging to implement such a table that scales well.</p>

<p>In the proposed solution the information needed to route the message to the
correct place is saved in the alias itself, the reference. The information
needed to determine if the message passed via the alias should be dropped or
passed along is saved in the process identified by the alias. That is, all
information needed is distributed to where it is needed instead of being
centralized in a node global table. This approach of distributed information
introduce no new synchronization points at all when it has been fully
implemented (more on that below) which will scale extremely well. An
implementation based on a node global table can <em>never</em> compete scalability
wise with that.</p>

<p>The already existing functionality for registered names cannot be implemented
using this distributed information approach, but needs this centralized
storage of names. That is, the already existing API cannot be used.</p>

<p>Besides node identifier a reference today contains three 32-bit words of data
or in other words 96-bits of data. Of these 96 bits only 82 bits are allowed
to be passed over the distribution to another node. This for historical
reasons. While a reference resides locally it can however contain more or
less unlimited amount of data. 82-bits are not enough to make a reference
unique on the local node and at the same time uniquely identify a node local
process. In order to be able to store all information needed in alias, the
reference data type needs to be extended.</p>

<p>In the proposed solution references used as aliases are extended to use
five 32-bit words on 64-bit architectures and four 32-bit words on 32-bit
architectures. Since that much data in a reference cannot be passed over
the distribution today, the reference implementation saves aliases that
are alive in a node global table. When a node local alias enters the local
node over the distribution one needs to look it up in this table in order to
be able to restore it to its actual value. While aliases are passed around
locally there is no need for look-ups in this table.</p>

<p>The reference implementation also modifies the distribution protocol to
allow references with up to five 32-bit values. For backwards compatibility
reasons this modification of the distribution protocol cannot be used at once
when aliases are introduced. This since we need to be able to communicate with
older nodes from previous releases for a while. When this has been living in
the system for enough time (expected to be OTP 26) we can begin sending
references with up to five 32-bit words and remove the usage of the table
mapping references over the distribution to aliases. That is, it is not until
this happens that the alias implementation is fully complete.</p>

<h2>Why is it not possible to get the PID of the process that an alias refers to?</h2>

<p>Most importantly there is no need to know the PID of the process that an
alias refers to in order to solve the problems that alias are intended
to solve. The user is expected to utilize alias in a protocol where one knows
whether a reference is an alias or not and should not need to know the PID of
the process that it refers to.</p>

<p>Besides the above there are also other issues with such functionality. The
content of a reference is just a large integer. In order to keep distribution
transparency one would either have to specify how this integer should be
interpreted or require synchronous signaling with the node where the
identified process resides. The synchronous signal-ling will be very
expensive. By specifying how the reference integer should be interpreted we
would prevent future changes to how the integer of the reference should be
interpreted which might prevent future optimizations, improvements and new
features. Up until the time when large references with five 32-bit words can
be passed over the distribution, synchronous communication is also the only
option on how to implement such functionality.</p>

<p>If we should mimic the <code>whereis()</code> function of the registered name API where
you also can see if a name is currently registered, no other option than
synchronous signaling with the process identified by the alias is possible.</p>

<h2>Why is it not possible to test if a reference is an alias?</h2>

<p>The same reason as to why it is not possible to get the PID of the
process that is referred to by an alias.</p>

<h2>Why not allow registration of arbitrary Erlang terms instead?</h2>

<p>Such a feature could solve the same issue that aliases are intended to
solve, but there are problems with such an approach.</p>

<p>Terms other than pids, ports, and references do not have a node identifier
embedded into the data type. For such data types you need some other way
to identify the node of where the name is registered. In the current case
of atoms as registered names, this is done by wrapping the name in a
two-tuple that contains the node name. Something like this is needed for
all other terms than just plain pids, ports, and references. This also
introduce a problem. Is a two-tuple just a name or a name plus a node
identifier?</p>

<p>Should it be possible to register a PID as a name for another process?
This would force all send operations to first lookup the PID in the
table of registered names before performing the operation. This will
cost performance in all send operations. The same is true for ports.</p>

<p>We don't think registration of arbitrary terms should be implemented
due to the problems that arise. Current registration feature that only
allows atoms can however be a bit too limiting when you need to register
a number of processes for the same service. An option could be to allow
registration of two-tuples containing an atom and an integer. Perhaps
other terms such as strings should also be allowed, but arbitrary terms
should not be allowed.</p>

<p>Allowing references as registered names implies scalability bottlenecks
not present in the alias API. That is, this would be an inferior solution
to the problem we set out to solve.</p>

<p>One probably wants to extend name registration with more allowed terms
than just atoms, but this for solving other problems than what aliases
are intended to solve. The name registration API does not fit aliases
so we don't see that aliases should be combined with such an extension
of the registration API. The alias solution solves the problem we set out
to solve, so this eep is limited to that.</p>

<h2>Why is the tag option of monitor/3 introduced?</h2>

<p>When using the monitor option <code>alias</code> in a <code>spawn_request()</code> call you
get unnecessary delays since you cannot share the alias with the
child process until you have gotten the spawn reply with the process
identifier of the child process. You instead typically want to
explicitly create the alias before the <code>spawn_request()</code> call and pass
it as an argument to the child process.</p>

<p>In a typical scenario you want to receive a response or an error
of the operation. However, if you explicitly create an alias before
the <code>spawn_request()</code> operation, the monitor reference and the alias
will be different references. This will prevent the compiler from
optimizing the receive (to skip messages present in the message queue
when the reference was created) since not all receive clauses will
match on the same reference.</p>

<p>We solve this by using the <code>tag</code> monitor option as well as the
<code>reply_tag</code> spawn request. The following is a fully functional rpc
implementation using this method on a system with the prototype
implementation of aliases:</p>

<pre><code>rpc(Node, M, F, A) -&gt;
    Alias = alias([once]),
    ReqId = spawn_request(Node,
                          fun () -&gt;
                                  Result = apply(M, F, A),
                                  Alias ! {{result, Alias}, Result}
                          end,
                          [{monitor, [{tag, {'DOWN', Alias}}]},
                           {reply_tag, {spawn_reply, Alias}},
                           {reply, error_only}]),
    receive
        {{result, Alias}, Result} -&gt;
            demonitor(ReqId, [flush]),
            Result;
        {{'DOWN', Alias}, ReqId, process, _, Error} -&gt;
            rpc_error_cleanup(Alias, Error);
        {{spawn_reply, Alias}, ReqId, error, Error} -&gt;
            rpc_error_cleanup(Alias, Error)
    end.

rpc_error_cleanup(Alias, Error) -&gt;
    case unalias(Alias) of
        true -&gt;
            %% No flush needed since we used the once option
            %% to alias(), and the alias was still active...
            error({rpc_error, Error});
        false -&gt;
            %% Flush a possible result message...
            receive {{result, Alias}, Result} -&gt; Result
            after 0 -&gt; error({rpc_error, Error})
            end
    end.
</code></pre>

<p>The <code>tag</code> monitor option can be used in other situations as
well in order to get a single reference that is present in
all types of responses from a group of processes. The processes
may be pre-existing or not. This reference can then be utilized
to determine if a message corresponds to a specific operation
made to a specific group of processes.</p>

<p>There are plans to extend the receive optimization so that multiple
receives matching on the same reference in all clauses can utilize
the optimization. This will also improve performance for such
implementations receiving multiple messages matching on the same
reference.</p>

<p>The tag to use in the monitor message is stored locally in the
process that sets up the monitor and does not have to be
communicated between processes. Most importantly it does not
have to be sent over the wire in the distributed case. This also
means that it can also be used when monitoring processes on older
nodes which does not support this functionality.</p>

<h1>Backwards Compatibility</h1>

<p>The alias feature is a pure extension, so there are no real backwards
compatibility issues.</p>

<p>In order to be able to communicate aliases over Erlang nodes from
previous releases we cannot pass large references over the distribution
and therefore need to keep information about aliases in a node global
table. The implementation benefits from being able to pass larger
references over the distribution, but will not do so until we can make
it mandatory to be able to handle such large references. Both OTP 24
and OTP 25 will be able to handle large references over the distribution
and since we only guarantee distribution compatibility with the two
closest releases backwards and forwards we can then make large
references mandatory in OTP 26.</p>

<p>This node global table for alias introduce an overhead when utilizing
aliases compared to sending using the PID of the process. This due
to allocation and manipulation of table structures. Comparing to the
existing solution of utilizing a proxy process in order to
prevent stray messages the overhead of this node global table for
aliases is small. Fortunately this node global table also only need to
be present temporarily and can be removed in OTP 26.</p>

<h1>Reference Implementation</h1>

<p>The reference implementation is provided by
<a href="https://github.com/erlang/otp/pull/2735">pull request #2735</a>.</p>

<p>Beside implementation of the alias feature. The pull request also contain
usage of aliases in the gen behaviors such as gen_server. Due to this it is
now also possible to implement <code>receive_response()</code> functionality similar to
<code>erpc:receive_response()</code> which also have been implemented:</p>

<ul>
<li><code>gen_server:receive_response/2</code></li>
<li><code>gen_statem:receive_response/2</code></li>
<li><code>gen_event:receive_response/2</code></li>
</ul>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0053","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Rickard Green \u0026lt;rickard(at)erlang(dot)org\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: 24.0\nCreated: 01-Sept-2019\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 53: \u003ca href=\"eep-0053.md\" title=\"EEP Source\"\u003e Process aliases preventing late replies reaching clients\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eCurrently there exists no lightweight mechanism for preventing late replies\nfrom a server to a client after a timeout or connection loss has occurred.\nThe only way to prevent late replies today is to make the request via\na proxy process.\u003c/p\u003e\n\n\u003cp\u003eThe proposed process alias feature is a lightweight mechanism that solves\nthe above problem. A process alias is similar to a registered name that\nis used temporarily while a request is outstanding. If the request times\nout or the connection to the server is lost, the alias is deactivated which\nprevents a late reply from reaching the client.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eAn alias is of the Erlang type \u003ccode\u003ereference()\u003c/code\u003e and can be used as destination\nwhen sending using the \u003ccode\u003e!\u003c/code\u003e operator, or when sending using the \u003ccode\u003eerlang:send()\u003c/code\u003e\nand \u003ccode\u003eerlang:send_nosuspend()\u003c/code\u003e BIFs. An alias can be used both on local\nnode and on remote nodes in a distributed system. The alias identifies a\nprocess that exist, or has existed, on the node with the node name returned\nby \u003ccode\u003enode(Alias)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAll references will, as of this, be accepted as destination in the message send\noperations listed above. If the reference is not an alias or a previous alias\nthat has been deactivated, the message will silently be dropped.\u003c/p\u003e\n\n\u003cp\u003eThese new BIFs are introduced:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ealias/0\u003c/code\u003e, \u003ccode\u003ealias/1\u003c/code\u003e. The \u003ccode\u003ealias()\u003c/code\u003e BIF creates and returns an alias which\ncan be used when sending messages to the process that called the \u003ccode\u003ealias()\u003c/code\u003e\nBIF.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eunalias/1\u003c/code\u003e. The \u003ccode\u003eunalias(Alias)\u003c/code\u003e BIF deactivates an alias that identifies\nthe calling process. The BIF returns \u003ccode\u003etrue\u003c/code\u003e if the alias \u003ccode\u003eAlias\u003c/code\u003e identified\nthe calling process and thus was deactivated; otherwise, no change of the\nalias state was made and \u003ccode\u003efalse\u003c/code\u003e is returned.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003emonitor/3\u003c/code\u003e. The \u003ccode\u003emonitor/3\u003c/code\u003e BIF is an extension of the \u003ccode\u003emonitor/2\u003c/code\u003e BIF\nwhere the third argument is an option list. As of its introduction it\naccepts two options:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e'{alias, unalias | demonitor | reply_demonitor}'. The first element of\nthe two tuple indicates that we want the returned monitor reference to\nalso work as an alias. The second element determines how the alias should\nbe deactivated:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunalias\u003c/code\u003e - The alias will remain until it has been deactivated by the\n\u003ccode\u003eunalias/1\u003c/code\u003e BIF\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edemonitor\u003c/code\u003e - The alias will be deactivated when the monitor is\ndeactivated. That is, either when the \u003ccode\u003edemonitor()\u003c/code\u003e BIF is called on\nthe monitor, or when the monitor is automatically deactivated by the\nreception of a \u003ccode\u003e'DOWN'\u003c/code\u003e message. The alias can still be deactivated\nbefore this happens by calling the \u003ccode\u003eunalias/1\u003c/code\u003e BIF.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ereply_demonitor\u003c/code\u003e - The alias will be deactivated when either the\nmonitor is deactivated or a message that has been passed using the\nalias is received. If the alias is deactivated due to a message passed\nusing the alias, the monitor is also deactivated as if the \u003ccode\u003edemonitor()\u003c/code\u003e\nBIF had been called.\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{tag, UserDefinedTag}\u003c/code\u003e. This will replace the default \u003ccode\u003eTag\u003c/code\u003e with\n\u003ccode\u003eUserDefinedTag\u003c/code\u003e in the monitor message delivered when the monitor is\ntriggered. For example, when monitoring a process, the \u003ccode\u003e'DOWN'\u003c/code\u003e tag in\nthe down message will be replaced by \u003ccode\u003eUserDefinedTag\u003c/code\u003e. \u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe \u003ccode\u003espawn_opt()\u003c/code\u003e and \u003ccode\u003espawn_request()\u003c/code\u003e BIFs have also been extended to\naccept an option \u003ccode\u003e{monitor, MonitorOpts}\u003c/code\u003e where \u003ccode\u003eMonitorOpts\u003c/code\u003e correspond to\nthe option list of the \u003ccode\u003emonitor/3\u003c/code\u003e BIF.\u003c/p\u003e\n\n\u003cp\u003eFull documentation of these BIFs and options can be found via\n\u003ca href=\"https://github.com/erlang/otp/pull/2735\"\u003epull request #2735\u003c/a\u003e\ncontaining the reference implementation.\u003c/p\u003e\n\n\u003cp\u003eIt is not possible to retrieve the process identifier of the process\nidentified by an alias, and it is not possible to test if a reference is an\nalias or not.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eAs previously stated it is possible to prevent late replies by using a\nproxy process that forwards the reply to the client. By spawning the proxy\nprocess and send its process identifier to the server instead of the\nclients own process identifier, the proxy can be terminated when the\noperation times out or the connection is lost. Since the proxy process\nis not alive, a reply will be silently dropped and no stray message\nwill reach the previous client of the request. This however both makes\nthe code more complicated and less efficient than it needs to be. The\ninefficiency comes from both the need to create, schedule, execute, and\nterminate the proxy process and the extra copying of data over the proxy\nprocess.\u003c/p\u003e\n\n\u003cp\u003eWhen the author of the client code has full control over the client process\nsuch late replies can be handled without a proxy since the code can be\naware of these potential stray messages and drop them when received. This\nis, however, not possible when implementing library code. You then either\nneed to use a proxy process, as done by the \u003ccode\u003egen_statem\u003c/code\u003e behavior, or\naccept that the client process may get stray messages after a call, as\ndone by the \u003ccode\u003egen_server\u003c/code\u003e behavior.\u003c/p\u003e\n\n\u003cp\u003eProcess aliases solves these issues with a very small overhead.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003ch2\u003eWhy use the reference data type for alias?\u003c/h2\u003e\n\n\u003cp\u003eThis is more or less what the reference data type is there for. A data type\nthat can identify a huge amount of different entities. References are unique\nand contain a node identifier identifying the the node it originates from.\nThis makes it easy to identify a specific process on a specific node while\nalso identifying different aliases created by the same process. The embedded\nnode identifier makes it easy to provide distribution transparency.\u003c/p\u003e\n\n\u003ch2\u003eWhy not make alias an opaque data type?\u003c/h2\u003e\n\n\u003cp\u003eThe expected most common use case is in a client server request. Such as\n\u003ccode\u003egen_server:call()\u003c/code\u003e. Client server requests in Erlang are typically made\nwhile monitoring the server from the client. In order to minimize the data\nproduced and sent in the request we want to reuse the reference created for\nidentification of the monitor to also function as an alias. Since the monitor\nidentifier is documented as a reference and is not opaque (which one can\nargue was a design mistake when introducing monitors), it becomes hard not\nto document the type of an alias as a reference as well.\u003c/p\u003e\n\n\u003ch2\u003eWhy not allow references as registered names in the already existing API?\u003c/h2\u003e\n\n\u003cp\u003eThere are two reasons. Distribution transparency and scalability.\u003c/p\u003e\n\n\u003cp\u003eDistribution transparency is really desirable since the user can use the\nfunctionality the same way regardless of whether it is a node local operation\nor node remote operation. The name registration API is not distribution\ntransparent.\u003c/p\u003e\n\n\u003cp\u003eRegarding scalability. Due to how the name registration API has been designed\nwe need some sort of table in order to implement the API. This table will be\nwritten to and read from by processes that are executing in parallel. In the\nuse case we are focusing on, names (aliases) are expected to be temporary and\ncreated in huge amounts. That is, there will be large amounts of modifications\nof this table from processes executing on different processors. This will\nmake it challenging to implement such a table that scales well.\u003c/p\u003e\n\n\u003cp\u003eIn the proposed solution the information needed to route the message to the\ncorrect place is saved in the alias itself, the reference. The information\nneeded to determine if the message passed via the alias should be dropped or\npassed along is saved in the process identified by the alias. That is, all\ninformation needed is distributed to where it is needed instead of being\ncentralized in a node global table. This approach of distributed information\nintroduce no new synchronization points at all when it has been fully\nimplemented (more on that below) which will scale extremely well. An\nimplementation based on a node global table can \u003cem\u003enever\u003c/em\u003e compete scalability\nwise with that.\u003c/p\u003e\n\n\u003cp\u003eThe already existing functionality for registered names cannot be implemented\nusing this distributed information approach, but needs this centralized\nstorage of names. That is, the already existing API cannot be used.\u003c/p\u003e\n\n\u003cp\u003eBesides node identifier a reference today contains three 32-bit words of data\nor in other words 96-bits of data. Of these 96 bits only 82 bits are allowed\nto be passed over the distribution to another node. This for historical\nreasons. While a reference resides locally it can however contain more or\nless unlimited amount of data. 82-bits are not enough to make a reference\nunique on the local node and at the same time uniquely identify a node local\nprocess. In order to be able to store all information needed in alias, the\nreference data type needs to be extended.\u003c/p\u003e\n\n\u003cp\u003eIn the proposed solution references used as aliases are extended to use\nfive 32-bit words on 64-bit architectures and four 32-bit words on 32-bit\narchitectures. Since that much data in a reference cannot be passed over\nthe distribution today, the reference implementation saves aliases that\nare alive in a node global table. When a node local alias enters the local\nnode over the distribution one needs to look it up in this table in order to\nbe able to restore it to its actual value. While aliases are passed around\nlocally there is no need for look-ups in this table.\u003c/p\u003e\n\n\u003cp\u003eThe reference implementation also modifies the distribution protocol to\nallow references with up to five 32-bit values. For backwards compatibility\nreasons this modification of the distribution protocol cannot be used at once\nwhen aliases are introduced. This since we need to be able to communicate with\nolder nodes from previous releases for a while. When this has been living in\nthe system for enough time (expected to be OTP 26) we can begin sending\nreferences with up to five 32-bit words and remove the usage of the table\nmapping references over the distribution to aliases. That is, it is not until\nthis happens that the alias implementation is fully complete.\u003c/p\u003e\n\n\u003ch2\u003eWhy is it not possible to get the PID of the process that an alias refers to?\u003c/h2\u003e\n\n\u003cp\u003eMost importantly there is no need to know the PID of the process that an\nalias refers to in order to solve the problems that alias are intended\nto solve. The user is expected to utilize alias in a protocol where one knows\nwhether a reference is an alias or not and should not need to know the PID of\nthe process that it refers to.\u003c/p\u003e\n\n\u003cp\u003eBesides the above there are also other issues with such functionality. The\ncontent of a reference is just a large integer. In order to keep distribution\ntransparency one would either have to specify how this integer should be\ninterpreted or require synchronous signaling with the node where the\nidentified process resides. The synchronous signal-ling will be very\nexpensive. By specifying how the reference integer should be interpreted we\nwould prevent future changes to how the integer of the reference should be\ninterpreted which might prevent future optimizations, improvements and new\nfeatures. Up until the time when large references with five 32-bit words can\nbe passed over the distribution, synchronous communication is also the only\noption on how to implement such functionality.\u003c/p\u003e\n\n\u003cp\u003eIf we should mimic the \u003ccode\u003ewhereis()\u003c/code\u003e function of the registered name API where\nyou also can see if a name is currently registered, no other option than\nsynchronous signaling with the process identified by the alias is possible.\u003c/p\u003e\n\n\u003ch2\u003eWhy is it not possible to test if a reference is an alias?\u003c/h2\u003e\n\n\u003cp\u003eThe same reason as to why it is not possible to get the PID of the\nprocess that is referred to by an alias.\u003c/p\u003e\n\n\u003ch2\u003eWhy not allow registration of arbitrary Erlang terms instead?\u003c/h2\u003e\n\n\u003cp\u003eSuch a feature could solve the same issue that aliases are intended to\nsolve, but there are problems with such an approach.\u003c/p\u003e\n\n\u003cp\u003eTerms other than pids, ports, and references do not have a node identifier\nembedded into the data type. For such data types you need some other way\nto identify the node of where the name is registered. In the current case\nof atoms as registered names, this is done by wrapping the name in a\ntwo-tuple that contains the node name. Something like this is needed for\nall other terms than just plain pids, ports, and references. This also\nintroduce a problem. Is a two-tuple just a name or a name plus a node\nidentifier?\u003c/p\u003e\n\n\u003cp\u003eShould it be possible to register a PID as a name for another process?\nThis would force all send operations to first lookup the PID in the\ntable of registered names before performing the operation. This will\ncost performance in all send operations. The same is true for ports.\u003c/p\u003e\n\n\u003cp\u003eWe don't think registration of arbitrary terms should be implemented\ndue to the problems that arise. Current registration feature that only\nallows atoms can however be a bit too limiting when you need to register\na number of processes for the same service. An option could be to allow\nregistration of two-tuples containing an atom and an integer. Perhaps\nother terms such as strings should also be allowed, but arbitrary terms\nshould not be allowed.\u003c/p\u003e\n\n\u003cp\u003eAllowing references as registered names implies scalability bottlenecks\nnot present in the alias API. That is, this would be an inferior solution\nto the problem we set out to solve.\u003c/p\u003e\n\n\u003cp\u003eOne probably wants to extend name registration with more allowed terms\nthan just atoms, but this for solving other problems than what aliases\nare intended to solve. The name registration API does not fit aliases\nso we don't see that aliases should be combined with such an extension\nof the registration API. The alias solution solves the problem we set out\nto solve, so this eep is limited to that.\u003c/p\u003e\n\n\u003ch2\u003eWhy is the tag option of monitor/3 introduced?\u003c/h2\u003e\n\n\u003cp\u003eWhen using the monitor option \u003ccode\u003ealias\u003c/code\u003e in a \u003ccode\u003espawn_request()\u003c/code\u003e call you\nget unnecessary delays since you cannot share the alias with the\nchild process until you have gotten the spawn reply with the process\nidentifier of the child process. You instead typically want to\nexplicitly create the alias before the \u003ccode\u003espawn_request()\u003c/code\u003e call and pass\nit as an argument to the child process.\u003c/p\u003e\n\n\u003cp\u003eIn a typical scenario you want to receive a response or an error\nof the operation. However, if you explicitly create an alias before\nthe \u003ccode\u003espawn_request()\u003c/code\u003e operation, the monitor reference and the alias\nwill be different references. This will prevent the compiler from\noptimizing the receive (to skip messages present in the message queue\nwhen the reference was created) since not all receive clauses will\nmatch on the same reference.\u003c/p\u003e\n\n\u003cp\u003eWe solve this by using the \u003ccode\u003etag\u003c/code\u003e monitor option as well as the\n\u003ccode\u003ereply_tag\u003c/code\u003e spawn request. The following is a fully functional rpc\nimplementation using this method on a system with the prototype\nimplementation of aliases:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003erpc(Node, M, F, A) -\u0026gt;\n    Alias = alias([once]),\n    ReqId = spawn_request(Node,\n                          fun () -\u0026gt;\n                                  Result = apply(M, F, A),\n                                  Alias ! {{result, Alias}, Result}\n                          end,\n                          [{monitor, [{tag, {'DOWN', Alias}}]},\n                           {reply_tag, {spawn_reply, Alias}},\n                           {reply, error_only}]),\n    receive\n        {{result, Alias}, Result} -\u0026gt;\n            demonitor(ReqId, [flush]),\n            Result;\n        {{'DOWN', Alias}, ReqId, process, _, Error} -\u0026gt;\n            rpc_error_cleanup(Alias, Error);\n        {{spawn_reply, Alias}, ReqId, error, Error} -\u0026gt;\n            rpc_error_cleanup(Alias, Error)\n    end.\n\nrpc_error_cleanup(Alias, Error) -\u0026gt;\n    case unalias(Alias) of\n        true -\u0026gt;\n            %% No flush needed since we used the once option\n            %% to alias(), and the alias was still active...\n            error({rpc_error, Error});\n        false -\u0026gt;\n            %% Flush a possible result message...\n            receive {{result, Alias}, Result} -\u0026gt; Result\n            after 0 -\u0026gt; error({rpc_error, Error})\n            end\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003etag\u003c/code\u003e monitor option can be used in other situations as\nwell in order to get a single reference that is present in\nall types of responses from a group of processes. The processes\nmay be pre-existing or not. This reference can then be utilized\nto determine if a message corresponds to a specific operation\nmade to a specific group of processes.\u003c/p\u003e\n\n\u003cp\u003eThere are plans to extend the receive optimization so that multiple\nreceives matching on the same reference in all clauses can utilize\nthe optimization. This will also improve performance for such\nimplementations receiving multiple messages matching on the same\nreference.\u003c/p\u003e\n\n\u003cp\u003eThe tag to use in the monitor message is stored locally in the\nprocess that sets up the monitor and does not have to be\ncommunicated between processes. Most importantly it does not\nhave to be sent over the wire in the distributed case. This also\nmeans that it can also be used when monitoring processes on older\nnodes which does not support this functionality.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThe alias feature is a pure extension, so there are no real backwards\ncompatibility issues.\u003c/p\u003e\n\n\u003cp\u003eIn order to be able to communicate aliases over Erlang nodes from\nprevious releases we cannot pass large references over the distribution\nand therefore need to keep information about aliases in a node global\ntable. The implementation benefits from being able to pass larger\nreferences over the distribution, but will not do so until we can make\nit mandatory to be able to handle such large references. Both OTP 24\nand OTP 25 will be able to handle large references over the distribution\nand since we only guarantee distribution compatibility with the two\nclosest releases backwards and forwards we can then make large\nreferences mandatory in OTP 26.\u003c/p\u003e\n\n\u003cp\u003eThis node global table for alias introduce an overhead when utilizing\naliases compared to sending using the PID of the process. This due\nto allocation and manipulation of table structures. Comparing to the\nexisting solution of utilizing a proxy process in order to\nprevent stray messages the overhead of this node global table for\naliases is small. Fortunately this node global table also only need to\nbe present temporarily and can be removed in OTP 26.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eThe reference implementation is provided by\n\u003ca href=\"https://github.com/erlang/otp/pull/2735\"\u003epull request #2735\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eBeside implementation of the alias feature. The pull request also contain\nusage of aliases in the gen behaviors such as gen_server. Due to this it is\nnow also possible to implement \u003ccode\u003ereceive_response()\u003c/code\u003e functionality similar to\n\u003ccode\u003eerpc:receive_response()\u003c/code\u003e which also have been implemented:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egen_server:receive_response/2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egen_statem:receive_response/2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egen_event:receive_response/2\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0053"},"buildId":"mwcz5f45UeFOBiRtaG40v","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_buildManifest.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_ssgManifest.js" async=""></script></body></html>