<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Accepted
Type: Standards Track
Erlang-Version: R14B04
Content-Type: text/plain
Created: 27-May-2011
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 37: <a href="eep-0037.md" title="EEP Source"> Funs with names</a></h2>

<h1>Abstract</h1>

<p>The syntax of funs is extended to allow a variable name to
be consistently present before each argument list.  This
allows funs to be recursive.  The knot is tied in the
opcodes that apply a fun to its arguments, so no change to
the garbage collector design is required.</p>

<h1>Specification</h1>

<p>Currently, there are three forms for a fun:</p>

<pre><code>fun Name/Arity
fun Module:Name/Arity
</code></pre>

<p>and</p>

<pre><code>fun Fun_Clause {; Fun_Clause}... end
</code></pre>

<p>We add another form:</p>

<pre><code>fun Variable Fun_Clause {; Variable Fun_Clause}... end
</code></pre>

<p>If any <code>Fun_Clause</code> has a <code>Variable</code>, all must, and they must all
be the same variable.  Like the variables in the argument list(s),
this variable is local to the fun, not shared with its context.
Within the fun, the variable is bound to the value of the fun
expression.</p>

<p>There are several possible ways to implement this.  One is
rather neat because it preserves the cycle-freedom of the
data structures the garbage collector has to deal with.</p>

<p>One way to implement existing funs is this:</p>

<ul>
<li><p><strong>a</strong> Create an auxiliary function with a generated name</p>

<pre><code>&lt;foo&gt;(...,X1,...,Xk) ...;
...
&lt;foo&gt;(...,X1,...,Xk) ....
</code></pre>

<p>having the same argument lists, guards, and clause bodies
as the fun, except that each variable shared with the context
appears as an extra argument.</p></li>
<li><p><strong>b</strong> Translate the fun expression as</p>

<pre><code>'%mk-fun'({fun &lt;foo&gt;/n+k, X1, ..., Xk})
</code></pre>

<p>which gives the tuple a special tag to say that it represents
a fun value.</p></li>
<li><p><strong>c</strong> Translate  <code>Foo(E1,...,Em)</code>
as <code>A1 := E1, ..., Am := Em; funcall_m(Foo)</code>
where the <code>funcall_m</code> instruction checks that its argument is
a closure expecting <code>m</code> arguments, moves the <code>X1,...,Xk</code> fields
of the tuple to argument registers <code>A&lt;m+1&gt;..A&lt;m+k&gt;</code>, and then
jumps to the address in the first field.</p></li>
</ul>

<p>All it takes to implement recursive funs is</p>

<ul>
<li><p><strong>a'</strong> Create an auxiliary function</p>

<pre><code>&lt;foo&gt;(...,X1,...,Xk,Variable) ...;
...
&lt;foo&gt;(...,X1,...,Xk,Variable) ....
</code></pre></li>
<li><p><strong>b'</strong> Translate the fun expression as</p>

<pre><code>'%mk-rec-fun'({fun &lt;foo&gt;/&lt;n+k+1&gt;, X1, ..., Xk})
</code></pre>

<p>which simply applies a second special tag.</p></li>
<li><p><strong>c'</strong> The <code>funcall_m</code> opcode acts the same for both old and
recursive funs, except that just before jumping, it
adds tne fun value <code>Foo</code> itself as argument <code>A&lt;m+k+1&gt;</code>.
This "ties the knot".</p></li>
</ul>

<p>So a recursive fun takes no more space or time to create than
an existing one, and does not involve creating any cycles of
pointers.  Its code can be inserted into the failure path for
the <code>funcall_m</code> instructions, whatever their form.</p>

<h1>Motivation</h1>

<p>Fun names can serve three purposes.</p>

<p>First, they can simply be documentation.  For example,</p>

<pre><code>cfun_files(CFun) -&gt;
    fun(F1, F2) -&gt;
        [[?OBJ(T1,_) | _] | _] = F1,
        [[?OBJ(T2,_) | _] | _] = F2,
        CFun(T1, T2)
    end.
</code></pre>

<p>can be written as</p>

<pre><code>cfun_files(CFun) -&gt;
    fun Compare([[?OBJ(T1,_)|_]|_], [[?OBJ(T2,_)|_]|_]) -&gt;
    CFun(T1, T2)
    end.
</code></pre>

<p>A named fun whose name is not used can be implemented as if
the name were not there.</p>

<p>Second, the fun's name can be built into its generated name.
At the time of writing, we might have</p>

<pre><code>'-F/N-fun-K-'
</code></pre>

<p>where <code>F/N</code> is the name of the function that includes the fun
and <code>K</code> is the number of earlier funs in <code>F/N</code>.  We could build
the name in instead, using</p>

<pre><code>'-F/N-fun-Name-[K-]'
</code></pre>

<p>where <code>K</code> is present only if the outer function contains more
than one fun with the same name.  The point of this is that
such names are more likely to be useful after hot loading.
For example, if we start with</p>

<pre><code>f(...Xs, Ys, ...) -&gt;
    ...
    sort(Xs, fun X_Key({_,N,_}) -&gt; N end),
    sort(Ys, fun Y_Key({N,_,_}) -&gt; N end),
    ...
</code></pre>

<p>and then we revise it, swapping the two calls to <code>sort/2</code>.
With named funs, the two funs retain their generated names,
and the module is safe.  With anonymous functions, the
chances are that the two funs with swap names; oops!</p>

<p>Third, a frequently asked question in the Erlang mailing
list is "why can't I have recursive funs?" to which we
will now be able to rely, "you can; here is what they
look like."</p>

<p>This still does not permit mutually recursive funs, but
people do not seem to ask for that much.</p>

<p>Finally, the next time someone argues that Erlang syntax
is inconsistent because function clauses have repeated
names and fun clauses do not, we shall be able to reply
"but fun clauses CAN have repeated names and probably
should."</p>

<h1>Rationale</h1>

<p>There really seemed to be only two main questions.</p>

<p>What should the scope of the fun name variable be?
Some variables in a fun are shared between the fun
and its context.  Doing that would let us write</p>

<pre><code>f(...) -&gt;
    fun G(...) -&gt; ... end,
    fun H(...) -&gt; ... end,
    ... use G and H ...
</code></pre>

<p>rather like using nested "define" in Scheme, except that
while <code>H</code> could use <code>G</code>, <code>G</code> couldn't use <code>H</code>.</p>

<p>Since you do not get mutual recursion this way, you should
not be tricked into thinking you might.  It's better that
you have to write</p>

<pre><code>f(...) -&gt;
    GG = fun G(...) -&gt; ... end,
    HH = fun H(...) -&gt; ... end,
    ... use GG and HH ...
</code></pre>

<p>so that you understand clearly what you are getting.</p>

<p>While variables in the body of a fun clause may be shared
with the context, variables in the arguments are not,
something I have found confusing.  At least this way the
fun name follows the same scope rule as the variables in
the argument list right next to it.</p>

<p>The other main question was whether recursive fun values
should be exactly the same representation as existing
fun values, but with a cycle in it (tying the knot at
construction time), or whether to introduce a new tag
(tying the knot at call time).  The lack of cycles in
Erlang heaps has been a major factor in the design of
several garbage collectors.  I would expect changing
that to be an order of magnitude harder than the
changes required for this proposal.  It was seeing that
the knot could be tied at call with (without slowing
down calls to existing funs) that made me dare to hope
that this proposal might some day be accepted.</p>

<p>The main issue now is that this does not let us define
a group of mutually recursive local functions.
Adopting this proposal now might get in the way of a
better proposal that handles mutual recursion as well.</p>

<p>I don't see such a proposal as being likely to arrive soon.</p>

<p>There is a special case of this where the fun name is used
only in tail call positions, which can be handled entirely
by the compiler generating a jump back to the beginning.
This need not have any consequences for the run time system
at all.</p>

<h1>Backwards Compatibility</h1>

<p>Code that does not use the new feature does not change its
meaning.  There may be code that relies on the form of
generated function names; that would need changing.</p>

<p>All syntax tools would need to be revised to handle the new form.
Existing parse transforms might well fail on code containing the
new form, but would work unchanged on code that does not.</p>

<p>At least one new instruction is needed to create suitably
distinguished closures.  Existing programs that analyse BEAM
files will not understand this until they are revised.</p>

<p>As described under 'motivation', naming functions is
useful even if you do not use the name in any clause body.
This means that we can have a staged delivery of the feature.</p>

<ol>
<li><p>Make the parser recognise fun names and check their identity.
Have it report an error if the fun name is used in a body.
Have it erase the fun names from the AST before any
downstream tool sees it.</p>

<p>At this stage, fun names may serve as documentation.</p></li>
<li><p>Upgrade the downstream tools to recognise an extended <code>'fun'</code>
AST node with two extra fields:  the fun name as an atom and
a flag saying whether it is not used, used only in tail
position, or used more generally.</p>

<p>Upgrade the parser to report fun names, but retain the
check that they are not used.  Test the down stream tools.</p></li>
<li><p>Modify the compiler to use the new, safer, form of generated
name.  Ensure that the generated names are accessed only
through an interface, so all is consistent.</p>

<p>At this stage, fun names help to reduce the danger from
code revisions that add, remove, or re-order funs; a
change that does not alter the number of funs with a
particular name in a function should not change its name.</p></li>
<li><p>(Optional.)  Revise the code generator to accept the fun
name in tail call position and generate a jump.  Modify
the parser to allow this.</p>

<p>At this point, it is possible to pass a loop as a parameter,
like a list traversal or a binary search.  No changes to the
representation of Erlang terms or the BEAM engine have been
required yet.</p></li>
<li><p>Add a new tag.  Revise the funcall instructions to check for
it if the existing check fails, and push the closure itself.
Add a new instruction to make a new closure.  Revise the
Erlang term representation to encode recursive funs.  Revise
the type test instructions to recognise the new values.
Teach HiPE what to do.</p>

<p>This is the last stage.</p></li>
</ol>

<h1>Reference Implementation</h1>

<p>None in this draft.  Stage 1 can be done fairly easily.
Stage 2 would be hard for me because I'm not even sure what
all the relevant modules are.</p>

<h1>References</h1>

<p>None.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0037","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Accepted\nType: Standards Track\nErlang-Version: R14B04\nContent-Type: text/plain\nCreated: 27-May-2011\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 37: \u003ca href=\"eep-0037.md\" title=\"EEP Source\"\u003e Funs with names\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThe syntax of funs is extended to allow a variable name to\nbe consistently present before each argument list.  This\nallows funs to be recursive.  The knot is tied in the\nopcodes that apply a fun to its arguments, so no change to\nthe garbage collector design is required.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eCurrently, there are three forms for a fun:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun Name/Arity\nfun Module:Name/Arity\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun Fun_Clause {; Fun_Clause}... end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe add another form:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efun Variable Fun_Clause {; Variable Fun_Clause}... end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf any \u003ccode\u003eFun_Clause\u003c/code\u003e has a \u003ccode\u003eVariable\u003c/code\u003e, all must, and they must all\nbe the same variable.  Like the variables in the argument list(s),\nthis variable is local to the fun, not shared with its context.\nWithin the fun, the variable is bound to the value of the fun\nexpression.\u003c/p\u003e\n\n\u003cp\u003eThere are several possible ways to implement this.  One is\nrather neat because it preserves the cycle-freedom of the\ndata structures the garbage collector has to deal with.\u003c/p\u003e\n\n\u003cp\u003eOne way to implement existing funs is this:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ea\u003c/strong\u003e Create an auxiliary function with a generated name\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;foo\u0026gt;(...,X1,...,Xk) ...;\n...\n\u0026lt;foo\u0026gt;(...,X1,...,Xk) ....\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ehaving the same argument lists, guards, and clause bodies\nas the fun, except that each variable shared with the context\nappears as an extra argument.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eb\u003c/strong\u003e Translate the fun expression as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'%mk-fun'({fun \u0026lt;foo\u0026gt;/n+k, X1, ..., Xk})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhich gives the tuple a special tag to say that it represents\na fun value.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ec\u003c/strong\u003e Translate  \u003ccode\u003eFoo(E1,...,Em)\u003c/code\u003e\nas \u003ccode\u003eA1 := E1, ..., Am := Em; funcall_m(Foo)\u003c/code\u003e\nwhere the \u003ccode\u003efuncall_m\u003c/code\u003e instruction checks that its argument is\na closure expecting \u003ccode\u003em\u003c/code\u003e arguments, moves the \u003ccode\u003eX1,...,Xk\u003c/code\u003e fields\nof the tuple to argument registers \u003ccode\u003eA\u0026lt;m+1\u0026gt;..A\u0026lt;m+k\u0026gt;\u003c/code\u003e, and then\njumps to the address in the first field.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAll it takes to implement recursive funs is\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ea'\u003c/strong\u003e Create an auxiliary function\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;foo\u0026gt;(...,X1,...,Xk,Variable) ...;\n...\n\u0026lt;foo\u0026gt;(...,X1,...,Xk,Variable) ....\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eb'\u003c/strong\u003e Translate the fun expression as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'%mk-rec-fun'({fun \u0026lt;foo\u0026gt;/\u0026lt;n+k+1\u0026gt;, X1, ..., Xk})\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhich simply applies a second special tag.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003ec'\u003c/strong\u003e The \u003ccode\u003efuncall_m\u003c/code\u003e opcode acts the same for both old and\nrecursive funs, except that just before jumping, it\nadds tne fun value \u003ccode\u003eFoo\u003c/code\u003e itself as argument \u003ccode\u003eA\u0026lt;m+k+1\u0026gt;\u003c/code\u003e.\nThis \"ties the knot\".\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eSo a recursive fun takes no more space or time to create than\nan existing one, and does not involve creating any cycles of\npointers.  Its code can be inserted into the failure path for\nthe \u003ccode\u003efuncall_m\u003c/code\u003e instructions, whatever their form.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eFun names can serve three purposes.\u003c/p\u003e\n\n\u003cp\u003eFirst, they can simply be documentation.  For example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecfun_files(CFun) -\u0026gt;\n    fun(F1, F2) -\u0026gt;\n        [[?OBJ(T1,_) | _] | _] = F1,\n        [[?OBJ(T2,_) | _] | _] = F2,\n        CFun(T1, T2)\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecan be written as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecfun_files(CFun) -\u0026gt;\n    fun Compare([[?OBJ(T1,_)|_]|_], [[?OBJ(T2,_)|_]|_]) -\u0026gt;\n    CFun(T1, T2)\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA named fun whose name is not used can be implemented as if\nthe name were not there.\u003c/p\u003e\n\n\u003cp\u003eSecond, the fun's name can be built into its generated name.\nAt the time of writing, we might have\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'-F/N-fun-K-'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eF/N\u003c/code\u003e is the name of the function that includes the fun\nand \u003ccode\u003eK\u003c/code\u003e is the number of earlier funs in \u003ccode\u003eF/N\u003c/code\u003e.  We could build\nthe name in instead, using\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'-F/N-fun-Name-[K-]'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere \u003ccode\u003eK\u003c/code\u003e is present only if the outer function contains more\nthan one fun with the same name.  The point of this is that\nsuch names are more likely to be useful after hot loading.\nFor example, if we start with\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(...Xs, Ys, ...) -\u0026gt;\n    ...\n    sort(Xs, fun X_Key({_,N,_}) -\u0026gt; N end),\n    sort(Ys, fun Y_Key({N,_,_}) -\u0026gt; N end),\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand then we revise it, swapping the two calls to \u003ccode\u003esort/2\u003c/code\u003e.\nWith named funs, the two funs retain their generated names,\nand the module is safe.  With anonymous functions, the\nchances are that the two funs with swap names; oops!\u003c/p\u003e\n\n\u003cp\u003eThird, a frequently asked question in the Erlang mailing\nlist is \"why can't I have recursive funs?\" to which we\nwill now be able to rely, \"you can; here is what they\nlook like.\"\u003c/p\u003e\n\n\u003cp\u003eThis still does not permit mutually recursive funs, but\npeople do not seem to ask for that much.\u003c/p\u003e\n\n\u003cp\u003eFinally, the next time someone argues that Erlang syntax\nis inconsistent because function clauses have repeated\nnames and fun clauses do not, we shall be able to reply\n\"but fun clauses CAN have repeated names and probably\nshould.\"\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThere really seemed to be only two main questions.\u003c/p\u003e\n\n\u003cp\u003eWhat should the scope of the fun name variable be?\nSome variables in a fun are shared between the fun\nand its context.  Doing that would let us write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(...) -\u0026gt;\n    fun G(...) -\u0026gt; ... end,\n    fun H(...) -\u0026gt; ... end,\n    ... use G and H ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erather like using nested \"define\" in Scheme, except that\nwhile \u003ccode\u003eH\u003c/code\u003e could use \u003ccode\u003eG\u003c/code\u003e, \u003ccode\u003eG\u003c/code\u003e couldn't use \u003ccode\u003eH\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSince you do not get mutual recursion this way, you should\nnot be tricked into thinking you might.  It's better that\nyou have to write\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(...) -\u0026gt;\n    GG = fun G(...) -\u0026gt; ... end,\n    HH = fun H(...) -\u0026gt; ... end,\n    ... use GG and HH ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eso that you understand clearly what you are getting.\u003c/p\u003e\n\n\u003cp\u003eWhile variables in the body of a fun clause may be shared\nwith the context, variables in the arguments are not,\nsomething I have found confusing.  At least this way the\nfun name follows the same scope rule as the variables in\nthe argument list right next to it.\u003c/p\u003e\n\n\u003cp\u003eThe other main question was whether recursive fun values\nshould be exactly the same representation as existing\nfun values, but with a cycle in it (tying the knot at\nconstruction time), or whether to introduce a new tag\n(tying the knot at call time).  The lack of cycles in\nErlang heaps has been a major factor in the design of\nseveral garbage collectors.  I would expect changing\nthat to be an order of magnitude harder than the\nchanges required for this proposal.  It was seeing that\nthe knot could be tied at call with (without slowing\ndown calls to existing funs) that made me dare to hope\nthat this proposal might some day be accepted.\u003c/p\u003e\n\n\u003cp\u003eThe main issue now is that this does not let us define\na group of mutually recursive local functions.\nAdopting this proposal now might get in the way of a\nbetter proposal that handles mutual recursion as well.\u003c/p\u003e\n\n\u003cp\u003eI don't see such a proposal as being likely to arrive soon.\u003c/p\u003e\n\n\u003cp\u003eThere is a special case of this where the fun name is used\nonly in tail call positions, which can be handled entirely\nby the compiler generating a jump back to the beginning.\nThis need not have any consequences for the run time system\nat all.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eCode that does not use the new feature does not change its\nmeaning.  There may be code that relies on the form of\ngenerated function names; that would need changing.\u003c/p\u003e\n\n\u003cp\u003eAll syntax tools would need to be revised to handle the new form.\nExisting parse transforms might well fail on code containing the\nnew form, but would work unchanged on code that does not.\u003c/p\u003e\n\n\u003cp\u003eAt least one new instruction is needed to create suitably\ndistinguished closures.  Existing programs that analyse BEAM\nfiles will not understand this until they are revised.\u003c/p\u003e\n\n\u003cp\u003eAs described under 'motivation', naming functions is\nuseful even if you do not use the name in any clause body.\nThis means that we can have a staged delivery of the feature.\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eMake the parser recognise fun names and check their identity.\nHave it report an error if the fun name is used in a body.\nHave it erase the fun names from the AST before any\ndownstream tool sees it.\u003c/p\u003e\n\n\u003cp\u003eAt this stage, fun names may serve as documentation.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eUpgrade the downstream tools to recognise an extended \u003ccode\u003e'fun'\u003c/code\u003e\nAST node with two extra fields:  the fun name as an atom and\na flag saying whether it is not used, used only in tail\nposition, or used more generally.\u003c/p\u003e\n\n\u003cp\u003eUpgrade the parser to report fun names, but retain the\ncheck that they are not used.  Test the down stream tools.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eModify the compiler to use the new, safer, form of generated\nname.  Ensure that the generated names are accessed only\nthrough an interface, so all is consistent.\u003c/p\u003e\n\n\u003cp\u003eAt this stage, fun names help to reduce the danger from\ncode revisions that add, remove, or re-order funs; a\nchange that does not alter the number of funs with a\nparticular name in a function should not change its name.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e(Optional.)  Revise the code generator to accept the fun\nname in tail call position and generate a jump.  Modify\nthe parser to allow this.\u003c/p\u003e\n\n\u003cp\u003eAt this point, it is possible to pass a loop as a parameter,\nlike a list traversal or a binary search.  No changes to the\nrepresentation of Erlang terms or the BEAM engine have been\nrequired yet.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAdd a new tag.  Revise the funcall instructions to check for\nit if the existing check fails, and push the closure itself.\nAdd a new instruction to make a new closure.  Revise the\nErlang term representation to encode recursive funs.  Revise\nthe type test instructions to recognise the new values.\nTeach HiPE what to do.\u003c/p\u003e\n\n\u003cp\u003eThis is the last stage.\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone in this draft.  Stage 1 can be done fairly easily.\nStage 2 would be hard for me because I'm not even sure what\nall the relevant modules are.\u003c/p\u003e\n\n\u003ch1\u003eReferences\u003c/h1\u003e\n\n\u003cp\u003eNone.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0037"},"buildId":"7cVY434Wa3Wl232pkfXk2","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_buildManifest.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_ssgManifest.js" async=""></script></body></html>