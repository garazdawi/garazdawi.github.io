<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R16A
Created: 07-Feb-2013
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 42: <a href="eep-0042.md" title="EEP Source"> setrlimit(2) analogue for Erlang</a></h2>

<h1>Abstract</h1>

<p>A new function <code>erlang:set_process_info_limit/2</code> is added,
allowing a process to set limits on its own memory use.</p>

<h1>Specification</h1>

<pre><code>erlang:set_process_info_limit(Item, Limit :: integer()) -&gt;
    Old_Limit :: integer()
</code></pre>

<p>An <code>Old_Limit</code> of 0 means that no limit has been set.
A Limit of 0 means that no limit is to be set.</p>

<p>The Items that can be set are</p>

<ul>
<li><p><code>memory</code>, the number of bytes that may be used for stack, heap, and
internal structures.</p></li>
<li><p><code>memory_words</code>, the same value as <code>memory</code>, but expressed in
words to be consistent with <code>heap_size</code>, <code>total_heap_size</code>, and
<code>stack_size</code> in <code>erlang:process_info/[1,2]</code>.  Those functions should
also be revised to accept this Item.</p></li>
<li><p><code>message_queue_len</code>, the number of unprocessed messages.
(Aside.) The documentation refers to <code>message_queue_len</code>
but the system generates and recognises <code>message_queue_len</code>.
(End aside.)</p></li>
</ul>

<p>The values that are actually set may be less than Limit as
long as any physically realisable system in the node as
configured cannot exceed the value used.</p>

<p>A non-zero memory limit is checked after each garbage
collection or other memory restructuring; setting the memory
limit to a non-zero value less than the current
<code>process_info(self(), 'memory')</code> forces an immediate garbage
collection.</p>

<p>If the memory required by a process exceeds its limit, the
process is exited with reason <code>memory</code>.</p>

<p>A non-zero message queue length limit is checked whenever
the message queue length is about to be incremented, or
when such a limit is set.</p>

<p>If the message queue length limit is exceeded, the process
is exited with reason <code>message_queue_len</code>.</p>

<h1>Motivation</h1>

<p>It is currently possible for an Erlang process to grab
memory without limit and eventually take down the whole
node.  This problem is frequently reported in the Erlang
mailing list.</p>

<p>It is also possible for the message queue of an Erlang
process to grow without limit.  This problem too is
reported often enough to be recognised.</p>

<p>This is an EEP rather than a library change request because
it requires low level runtime system changes to support it.
For example, the limits have to be <em>stored</em> somewhere,
suggesting a change in the data structure holding information
about a process.  The limits have to be <em>checked</em>, meaning
that changes to the garbage collector and the message sending
core are required.  The limits have to be <em>enforced</em>,
meaning that two new exit reasons have to be supported.  And
the new exit reasons and the new function have to be
<em>documented</em>, requiring changes to more than one document.</p>

<p>The need is long-standing, and at least the presence of this
EEP may provoke discussion leading to <em>some</em> resolution.</p>

<h1>Rationale</h1>

<p>The function that sets a limit should have a name based
in the name of the function that reports current use.
That function is <code>process_info</code>, hence the name I've
chosen here is <code>set_process_info_limit</code>.</p>

<p>The <code>erlang:process_info/[1,2]</code> functions can report on
any Erlang process.  But it is clearly dangerous to let
a process set another process's limits.  All we actually
<em>need</em> is for a process to be able to set its own limits
in a startup phase.  That could be done by adding
<code>{'memory',Size}</code> and <code>{'message_queue_len',Count}</code> options
to <code>spawn_opt/[2,3]</code>.  However,</p>

<pre><code>spawn_opt(Fun, [{memory,128*1024}])
</code></pre>

<p>can be mimicked by</p>

<pre><code>spawn(fun () -&gt;
    erlang:set_process_info_limit(memory, 128*1024),
    Fun()
end)
</code></pre>

<p>and <code>set_process_info_limit/2</code> allows a process to set
different limits at different times.  If you are trying
to protect the system from <em>malice</em>, setting limits in
<code>spawn_opt/[2,3]</code> is the way to go.  If you are trying to
protect the system from <em>accident</em>, letting a process
set its own limits is the way to go.</p>

<p>The names for the Items to be set clearly must be identical
to the names used for the same thing elsewhere.</p>

<p>The <code>memory_words</code> item is introduced because in a world where
some of my programs run 32-bit and some run 64-bit it is just
too confusing to count bytes, especially as stack size and so
on are measured in words, not bytes.</p>

<p>I considered allowing <code>total_heap_size</code> and <code>stack_size</code> and so on
to be given their own limits, but on finding that <code>total_heap_size</code>
"currently includes the stack of the process", decided that it
was "currently" a bad idea.</p>

<p>I would have liked to allow setting a limit on the number
of reductions, so that a process that doesn't intend to
live forever can ensure its own eventual death.  However,
the documentation warns that <code>erlang:bump_reductions/1</code>
"might be removed", so presumably reduction counting
<em>per se</em> might well disappear.</p>

<p>The point of letting the value actually set for a limit
to be smaller is to allow an implementation to use only
values that will fit in a <code>size_t</code>, so that low level
code does not need to deal with bignums.  On a
POSIX-compliant operating system, an Erlang implementation
may use the <code>RLIMIT_DATA</code> value for the UNIX process
if the memory limit is bigger, and may use <code>RLIMIT_DATA</code>
divided by the minimum size of a message for the message
queue length.  Or it might use other appropriate system
limits.</p>

<p>The biggest question is "what happens if a limit is exceeded?"</p>

<p>For memory, we could exit with <code>system_limit</code> as reason, but
that wouldn't make clear <em>what</em> limit had been exceeded.  It
seems advisable to introduce a new reason, and making the
reason the same as the name of the limit seems the least
confusing approach.</p>

<p>For message queue length, I would prefer it if the process
that <em>sends</em> the message were the one to get a run time error.
However, the Erlang documentation guarantees that sending a
message to a pid always succeeds, whether the process is live
or dead, and I don't want to change too much.  A message queue
might build up because some process(es) is(are) sending junk;
we would prefer exiting junk senders to exiting junk receivers.
However, if the junk receiver isn't cleaning out the junk, that
junk is <em>never</em> going away, so it's <em>always</em> going to be costing
time to skip over as well as memory to store.  That argument
applies to another option that I considered: just discarding
messages that would make the queue too long.  The Erlang Way is
to let subsystems that get into trouble crash.  So let it be.</p>

<h1>Backwards Compatibility</h1>

<p>The new function is not exported by default
so it cannot be called accidentally.</p>

<h1>Reference Implementation</h1>

<p>None in this draft.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0042","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R16A\nCreated: 07-Feb-2013\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 42: \u003ca href=\"eep-0042.md\" title=\"EEP Source\"\u003e setrlimit(2) analogue for Erlang\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eA new function \u003ccode\u003eerlang:set_process_info_limit/2\u003c/code\u003e is added,\nallowing a process to set limits on its own memory use.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:set_process_info_limit(Item, Limit :: integer()) -\u0026gt;\n    Old_Limit :: integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAn \u003ccode\u003eOld_Limit\u003c/code\u003e of 0 means that no limit has been set.\nA Limit of 0 means that no limit is to be set.\u003c/p\u003e\n\n\u003cp\u003eThe Items that can be set are\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ememory\u003c/code\u003e, the number of bytes that may be used for stack, heap, and\ninternal structures.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ememory_words\u003c/code\u003e, the same value as \u003ccode\u003ememory\u003c/code\u003e, but expressed in\nwords to be consistent with \u003ccode\u003eheap_size\u003c/code\u003e, \u003ccode\u003etotal_heap_size\u003c/code\u003e, and\n\u003ccode\u003estack_size\u003c/code\u003e in \u003ccode\u003eerlang:process_info/[1,2]\u003c/code\u003e.  Those functions should\nalso be revised to accept this Item.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003emessage_queue_len\u003c/code\u003e, the number of unprocessed messages.\n(Aside.) The documentation refers to \u003ccode\u003emessage_queue_len\u003c/code\u003e\nbut the system generates and recognises \u003ccode\u003emessage_queue_len\u003c/code\u003e.\n(End aside.)\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe values that are actually set may be less than Limit as\nlong as any physically realisable system in the node as\nconfigured cannot exceed the value used.\u003c/p\u003e\n\n\u003cp\u003eA non-zero memory limit is checked after each garbage\ncollection or other memory restructuring; setting the memory\nlimit to a non-zero value less than the current\n\u003ccode\u003eprocess_info(self(), 'memory')\u003c/code\u003e forces an immediate garbage\ncollection.\u003c/p\u003e\n\n\u003cp\u003eIf the memory required by a process exceeds its limit, the\nprocess is exited with reason \u003ccode\u003ememory\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eA non-zero message queue length limit is checked whenever\nthe message queue length is about to be incremented, or\nwhen such a limit is set.\u003c/p\u003e\n\n\u003cp\u003eIf the message queue length limit is exceeded, the process\nis exited with reason \u003ccode\u003emessage_queue_len\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eIt is currently possible for an Erlang process to grab\nmemory without limit and eventually take down the whole\nnode.  This problem is frequently reported in the Erlang\nmailing list.\u003c/p\u003e\n\n\u003cp\u003eIt is also possible for the message queue of an Erlang\nprocess to grow without limit.  This problem too is\nreported often enough to be recognised.\u003c/p\u003e\n\n\u003cp\u003eThis is an EEP rather than a library change request because\nit requires low level runtime system changes to support it.\nFor example, the limits have to be \u003cem\u003estored\u003c/em\u003e somewhere,\nsuggesting a change in the data structure holding information\nabout a process.  The limits have to be \u003cem\u003echecked\u003c/em\u003e, meaning\nthat changes to the garbage collector and the message sending\ncore are required.  The limits have to be \u003cem\u003eenforced\u003c/em\u003e,\nmeaning that two new exit reasons have to be supported.  And\nthe new exit reasons and the new function have to be\n\u003cem\u003edocumented\u003c/em\u003e, requiring changes to more than one document.\u003c/p\u003e\n\n\u003cp\u003eThe need is long-standing, and at least the presence of this\nEEP may provoke discussion leading to \u003cem\u003esome\u003c/em\u003e resolution.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe function that sets a limit should have a name based\nin the name of the function that reports current use.\nThat function is \u003ccode\u003eprocess_info\u003c/code\u003e, hence the name I've\nchosen here is \u003ccode\u003eset_process_info_limit\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eerlang:process_info/[1,2]\u003c/code\u003e functions can report on\nany Erlang process.  But it is clearly dangerous to let\na process set another process's limits.  All we actually\n\u003cem\u003eneed\u003c/em\u003e is for a process to be able to set its own limits\nin a startup phase.  That could be done by adding\n\u003ccode\u003e{'memory',Size}\u003c/code\u003e and \u003ccode\u003e{'message_queue_len',Count}\u003c/code\u003e options\nto \u003ccode\u003espawn_opt/[2,3]\u003c/code\u003e.  However,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003espawn_opt(Fun, [{memory,128*1024}])\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecan be mimicked by\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003espawn(fun () -\u0026gt;\n    erlang:set_process_info_limit(memory, 128*1024),\n    Fun()\nend)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand \u003ccode\u003eset_process_info_limit/2\u003c/code\u003e allows a process to set\ndifferent limits at different times.  If you are trying\nto protect the system from \u003cem\u003emalice\u003c/em\u003e, setting limits in\n\u003ccode\u003espawn_opt/[2,3]\u003c/code\u003e is the way to go.  If you are trying to\nprotect the system from \u003cem\u003eaccident\u003c/em\u003e, letting a process\nset its own limits is the way to go.\u003c/p\u003e\n\n\u003cp\u003eThe names for the Items to be set clearly must be identical\nto the names used for the same thing elsewhere.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003ememory_words\u003c/code\u003e item is introduced because in a world where\nsome of my programs run 32-bit and some run 64-bit it is just\ntoo confusing to count bytes, especially as stack size and so\non are measured in words, not bytes.\u003c/p\u003e\n\n\u003cp\u003eI considered allowing \u003ccode\u003etotal_heap_size\u003c/code\u003e and \u003ccode\u003estack_size\u003c/code\u003e and so on\nto be given their own limits, but on finding that \u003ccode\u003etotal_heap_size\u003c/code\u003e\n\"currently includes the stack of the process\", decided that it\nwas \"currently\" a bad idea.\u003c/p\u003e\n\n\u003cp\u003eI would have liked to allow setting a limit on the number\nof reductions, so that a process that doesn't intend to\nlive forever can ensure its own eventual death.  However,\nthe documentation warns that \u003ccode\u003eerlang:bump_reductions/1\u003c/code\u003e\n\"might be removed\", so presumably reduction counting\n\u003cem\u003eper se\u003c/em\u003e might well disappear.\u003c/p\u003e\n\n\u003cp\u003eThe point of letting the value actually set for a limit\nto be smaller is to allow an implementation to use only\nvalues that will fit in a \u003ccode\u003esize_t\u003c/code\u003e, so that low level\ncode does not need to deal with bignums.  On a\nPOSIX-compliant operating system, an Erlang implementation\nmay use the \u003ccode\u003eRLIMIT_DATA\u003c/code\u003e value for the UNIX process\nif the memory limit is bigger, and may use \u003ccode\u003eRLIMIT_DATA\u003c/code\u003e\ndivided by the minimum size of a message for the message\nqueue length.  Or it might use other appropriate system\nlimits.\u003c/p\u003e\n\n\u003cp\u003eThe biggest question is \"what happens if a limit is exceeded?\"\u003c/p\u003e\n\n\u003cp\u003eFor memory, we could exit with \u003ccode\u003esystem_limit\u003c/code\u003e as reason, but\nthat wouldn't make clear \u003cem\u003ewhat\u003c/em\u003e limit had been exceeded.  It\nseems advisable to introduce a new reason, and making the\nreason the same as the name of the limit seems the least\nconfusing approach.\u003c/p\u003e\n\n\u003cp\u003eFor message queue length, I would prefer it if the process\nthat \u003cem\u003esends\u003c/em\u003e the message were the one to get a run time error.\nHowever, the Erlang documentation guarantees that sending a\nmessage to a pid always succeeds, whether the process is live\nor dead, and I don't want to change too much.  A message queue\nmight build up because some process(es) is(are) sending junk;\nwe would prefer exiting junk senders to exiting junk receivers.\nHowever, if the junk receiver isn't cleaning out the junk, that\njunk is \u003cem\u003enever\u003c/em\u003e going away, so it's \u003cem\u003ealways\u003c/em\u003e going to be costing\ntime to skip over as well as memory to store.  That argument\napplies to another option that I considered: just discarding\nmessages that would make the queue too long.  The Erlang Way is\nto let subsystems that get into trouble crash.  So let it be.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThe new function is not exported by default\nso it cannot be called accidentally.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eNone in this draft.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0042"},"buildId":"L68tPJnB-kPxrFxsY9AoN","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_buildManifest.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_ssgManifest.js" async=""></script></body></html>