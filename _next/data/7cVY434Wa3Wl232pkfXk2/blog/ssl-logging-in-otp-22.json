{"pageProps":{"item":{"id":"ssl-logging-in-otp-22","title":"TLS logging improvements in OTP 22","author":"Péter Dimitrov","excerpt":"Erlang/OTP 22 will be an important release for the ```ssl``` application. We are working on\nseveral new features and improvements such as support for TLS 1.3, some of those are already\non the master branch. This blog post presents the new ssl debug logging built on the new\nlogger API.","article_date":1538697600000,"tags":["ssl logger"],"frontmatter":{"layout":"post","title":"TLS logging improvements in OTP 22","tags":"ssl logger","author":"Péter Dimitrov"},"content":"Erlang/OTP 22 will be an important release for the ```ssl``` application. We are working on\nseveral new features and improvements such as support for TLS 1.3, some of those are already\non the master branch. This blog post presents the new ssl debug logging built on the new\nlogger API.\n\n## Usage\n\nAs the ```ssl``` application undergoes a lot of changes the release of the new logger API\npresented the opportunity to level up its debug logging capabilities to be on par with\nOpenSSL.\n\nWe have introduced a new option ```log_level``` that specifies the log level for the ```ssl```\napplication. It can take the following values (ordered by increasing verbosity level):\n```emergency```, ```alert```, ```critical```, ```error```, ```warning```, ```notice```,\n```info``` and ```debug```. At verbosity level ```notice``` and above error reports are\ndisplayed in TLS. The level ```debug``` triggers verbose logging of TLS protocol messages\nin a similar style as in OpenSSL.\n\nThe verbose debug logging can be turned on by two simple steps: the ```log_level``` shall\nbe set to ```debug``` and the logger shall be configured to enable ```debug``` logging\nfor the ssl application. The following code snippet is a sample module with a simple TLS server\nand client:\n\n```erlang\n-module(ssltest).\n\n-compile(export_all).\n\n-define(PORT, 11000).\n\nserver() ->\n    application:load(ssl),\n    logger:set_application_level(ssl, debug),\n    {ok, _} = application:ensure_all_started(ssl),\n    Port = ?PORT,\n    LOpts = [{certfile, \"server.pem\"},\n             {keyfile, \"server.key\"},\n             {versions, ['tlsv1.2']},\n             {log_level, debug}\n            ],\n    {ok, LSock} = ssl:listen(Port, LOpts),\n    {ok, CSock} = ssl:transport_accept(LSock),\n    {ok, _} = ssl:handshake(CSock).\n\nclient() ->\n    application:load(ssl),\n    logger:set_application_level(ssl, debug),\n    {ok, _} = application:ensure_all_started(ssl),\n    Port = ?PORT,\n    COpts = [{verify, verify_peer},\n             {cacertfile, \"ca.pem\"},\n             {versions, ['tlsv1.2']},\n             {log_level, debug}\n            ],\n    {ok, Sock} = ssl:connect(\"localhost\", Port, COpts).\n\n```\n\nStarting the server and client in their respective erlang shells produces the following\nverbose logging of TLS protocol messages:\n\n\n```\n1> ssltest:server().\nreading (238 bytes) TLS 1.2 Record Protocol, handshake\n0000 - 16 03 03 00 e9 01 00 00  e5 03 03 5b ab 42 7a ee    ...........[.Bz.\n0010 - 91 23 df 70 30 fb 41 b9  c5 14 79 d7 02 48 74 c9    .#.p0.A...y..Ht.\n0020 - b9 a9 8f e0 e9 04 1a f9  a8 21 49 00 00 4a 00 ff    .........!I..J..\n0030 - c0 2c c0 30 c0 24 c0 28  c0 2e c0 32 c0 26 c0 2a    .,.0.$.(...2.&.*\n0040 - 00 9f 00 a3 00 6b 00 6a  c0 2b c0 2f c0 23 c0 27    .....k.j.+./.#.'\n0050 - c0 2d c0 31 c0 25 c0 29  00 9e 00 a2 00 67 00 40    .-.1.%.).....g.@\n0060 - c0 0a c0 14 00 39 00 38  c0 05 c0 0f c0 09 c0 13    .....9.8........\n0070 - 00 33 00 32 c0 04 c0 0e  01 00 00 72 00 00 00 0e    .3.2.......r....\n0080 - 00 0c 00 00 09 6c 6f 63  61 6c 68 6f 73 74 00 0a    .....localhost..\n0090 - 00 3a 00 38 00 0e 00 0d  00 19 00 1c 00 0b 00 0c    .:.8............\n00a0 - 00 1b 00 18 00 09 00 0a  00 1a 00 16 00 17 00 08    ................\n00b0 - 00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13    ................\n00c0 - 00 01 00 02 00 03 00 0f  00 10 00 11 00 0b 00 02    ................\n00d0 - 01 00 00 0d 00 18 00 16  06 03 06 01 05 03 05 01    ................\n00e0 - 04 03 04 01 03 03 03 01  02 03 02 01 02 02          ..............\n<<< TLS 1.2 Handshake, ClientHello\n[{client_version,{3,3}},\n {random,\n     <<91,171,66,122,238,145,35,223,112,48,251,65,185,197,20,121,215,2,72,116,\n       201,185,169,143,224,233,4,26,249,168,33,73>>},\n {session_id,<<>>},\n {cipher_suites,\n     [<<0,255>>,\n      <<\"À,\">>,<<\"À0\">>,<<\"À$\">>,<<\"À(\">>,<<\"À.\">>,<<\"À2\">>,<<\"À&\">>,<<\"À*\">>,\n      <<0,159>>,\n      <<0,163>>,\n      <<0,107>>,\n      <<0,106>>,\n      <<\"À+\">>,<<\"À/\">>,<<\"À#\">>,<<\"À'\">>,<<\"À-\">>,<<\"À1\">>,<<\"À%\">>,<<\"À)\">>,\n      <<0,158>>,\n      <<0,162>>,\n      <<0,103>>,\n      <<0,64>>,\n      <<\"À\\n\">>,\n      <<192,20>>,\n      <<0,57>>,\n      <<0,56>>,\n      <<192,5>>,\n      <<192,15>>,\n      <<\"À\\t\">>,\n      <<192,19>>,\n      <<0,51>>,\n      <<0,50>>,\n      <<192,4>>,\n      <<192,14>>]},\n {compression_methods,[0]},\n...\n[Truncated for brevity]\n```\n\nThis is not the final format as there are many ways to further improve the representation\nof the handshake protocol messages such as converting the cipher suites to a human-readable\nerlang representation.\n\nAs a comparison this is the debug output from an OpenSSL server when the same erlang client\nconnects to it:\n\n\n```\n$ /usr/bin/openssl s_server -accept 11000 -tls1_2 -cert server.pem -key server.key -msg -debug\nUsing default temp DH parameters\nACCEPT\nread from 0x16f0040 [0x16f56b3] (5 bytes => 5 (0x5))\n0000 - 16 03 03 00 a1                                    .....\n<<< ??? [length 0005]\n    16 03 03 00 a1\nread from 0x16f0040 [0x16f56b8] (161 bytes => 161 (0xA1))\n0000 - 01 00 00 9d 03 03 5b ac-a1 cc 20 4c 4d 52 d0 d4   ......[... LMR..\n0010 - c8 fc dd 95 b0 fa 65 97-57 9e 44 aa dd 0e 46 10   ......e.W.D...F.\n0020 - 6c 14 57 9c ce a0 00 00-04 00 ff c0 14 01 00 00   l.W.............\n0030 - 70 00 2b 00 06 00 04 03-04 03 03 00 00 00 0e 00   p.+.............\n0040 - 0c 00 00 09 6c 6f 63 61-6c 68 6f 73 74 00 0a 00   ....localhost...\n0050 - 3a 00 38 00 0e 00 0d 00-19 00 1c 00 0b 00 0c 00   :.8.............\n0060 - 1b 00 18 00 09 00 0a 00-1a 00 16 00 17 00 08 00   ................\n0070 - 06 00 07 00 14 00 15 00-04 00 05 00 12 00 13 00   ................\n0080 - 01 00 02 00 03 00 0f 00-10 00 11 00 0b 00 02 01   ................\n0090 - 00 00 32 00 04 00 02 02-03 00 0d 00 04 00 02 02   ..2.............\n00a0 - 01                                                .\n<<< TLS 1.2 Handshake [length 00a1], ClientHello\n    01 00 00 9d 03 03 5b ac a1 cc 20 4c 4d 52 d0 d4\n    c8 fc dd 95 b0 fa 65 97 57 9e 44 aa dd 0e 46 10\n    6c 14 57 9c ce a0 00 00 04 00 ff c0 14 01 00 00\n    70 00 2b 00 06 00 04 03 04 03 03 00 00 00 0e 00\n    0c 00 00 09 6c 6f 63 61 6c 68 6f 73 74 00 0a 00\n    3a 00 38 00 0e 00 0d 00 19 00 1c 00 0b 00 0c 00\n    1b 00 18 00 09 00 0a 00 1a 00 16 00 17 00 08 00\n    06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00\n    01 00 02 00 03 00 0f 00 10 00 11 00 0b 00 02 01\n    00 00 32 00 04 00 02 02 03 00 0d 00 04 00 02 02\n    01\n...\n[Truncated for brevity]\n```\n\nThe verbose debug logging proved to be especially useful during the development of new\nextensions as previously we had to use wireshark captures to validate TLS protocol\nmessages.\n\n## Implementation\n\nIn the ```ssl``` application, we needed a way to handle two types of protocol\nmessages, tls_record and handshake, each with a custom formatter.\n\nThe most straightforward solution was to add a new handler instance to the logger with a\nspecial formatter function that filters out all the \"noise\" coming from other\nmodules of the system.\n\nThe handler itself could reuse the standard handler for logger, ```logger_std_h```, as it\ncould print logs to ```standard_io```. You can add multiple standard handler instances to\nlogger if your application requires it.\n\n```erlang\nlogger:add_handler(ssl_handler, logger_std_h, Config),\n```\n\nThe new ssl_handler is configured with a formatter that is implemented by the ```ssl_logger```\nmodule.\n\n```erlang\nConfig = #{level => debug,\n           filter_default => stop,\n           formatter => {ssl_logger, #{}}},\n```\n\nHandler filter level is set to ```debug``` with ```stop``` as the default filter action. We also\nneed a filter that lets the log events pass to the formatter if the source of the log event is the\nssl application. In other words, we need a domain filter with the action ```log``` on all sub-domains\nmatching ```[otp,ssl]```.\n\n```erlang\nFilter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},\n```\n\nPutting it all together we get the following function.\n\n```erlang\nstart_logger() ->\n    Config = #{level => debug,\n               filter_default => stop,\n               formatter => {ssl_logger, #{}}},\n    Filter = {fun logger_filters:domain/2,{log,sub,[otp,ssl]}},\n    logger:add_handler(ssl_handler, logger_std_h, Config),\n    logger:add_handler_filter(ssl_handler, filter_non_ssl, Filter).\n```\n\nThe function ```format``` is called in ssl_logger when an event gets through all the filters:\n\n```erlang\nformat(#{level:= _Level, msg:= {report, Msg}, meta:= _Meta},\n       _Config0) ->\n     #{direction := Direction,\n       protocol := Protocol,\n       message := BinMsg0} = Msg,\n    case Protocol of\n        'tls_record' ->\n            BinMsg = lists:flatten(BinMsg0),\n            format_tls_record(Direction, BinMsg);\n        'handshake' ->\n            format_handshake(Direction, BinMsg0);\n        _Other ->\n            []\n    end.\n```\n\nThere are two more helper functions that wrap around the logging macros. They were added in order\nto be able to set logging level per TLS session.\n\n```erlang\ndebug(Level, Report, Meta) ->\n    case logger:compare_levels(Level, debug) of\n        lt ->\n            ?LOG_DEBUG(Report, Meta);\n        eq ->\n            ?LOG_DEBUG(Report, Meta);\n        _ ->\n            ok\n    end.\n\nnotice(Level, Report) ->\n    case logger:compare_levels(Level, notice) of\n        lt ->\n            ?LOG_NOTICE(Report);\n        eq ->\n            ?LOG_NOTICE(Report);\n        _ ->\n            ok\n    end.\n```\n\nTo print a log event, the above functions are called with the configured ssl log level and\nthe domain parameter.\n\n```erlang\nssl_logger:debug(Opts#ssl_options.log_level,\n\t         Report,\n\t\t #{domain => [otp,ssl,handshake]}),\n```\n\nThose who are interested in the current state of development can already play with the\n```'tlsv1.3'``` atom in the ```versions``` option.\n"}},"__N_SSG":true}