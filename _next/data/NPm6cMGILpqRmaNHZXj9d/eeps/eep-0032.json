{"pageProps":{"index":{"id":"0032","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nCreated: 09-Feb-2010\nErlang-Version: R13B-3\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 32: <a href=\"eep-0032.md\" title=\"EEP Source\"> Module-local process names</a></h2>\n\n<h1>Abstract</h1>\n\n<p>The process registry in Erlang is convenient, but counts as\na global shared mutable variable, with two major defects:\nthe possibility of data races (shared mutable variable) and\nthe impossibility of encapsulation (global).  This EEP\nresurrects the old (1997 or earlier) proposal of module-\nlocal process-valued variables, providing a replacement for\nnode-local uses of the registry with encapsulation and without\nraces.</p>\n\n<h1>Specification</h1>\n\n<p>A module (or an instance of a parameterized module) may have\none or more top level pid-valued variables, and if so, has a\nlock associated with them.  The directive has the form</p>\n\n<pre><code>-pid_name(Atom).\n</code></pre>\n\n<p>where Atom is an atom.  To avoid confusing programmers who\nstill have to deal with the registry, this Atom may not be\n'undefined'.</p>\n\n<p>If there is at least one such directive in a module, the\ncompiler automatically generates a function called\n<code>pid_name/1</code>.  In the scope of directives</p>\n\n<pre><code>-pid_name(pn_1).\n...\n-pid_name(pn_k).\n</code></pre>\n\n<p>the <code>pid_name/1</code> function is rather like</p>\n\n<pre><code>pid_name(pn_1) -&gt;\n    with_module_lock(read) -&gt; X = *pn_1 end, X;\n...\npid_name(pn_k) -&gt;\n    with_module_lock(read) -&gt; X = *pn_k end, X.\n</code></pre>\n\n<p>except that we expect there to be a VM instruction\n<code>get_pid_safely(Address)</code>, and we expect the compiler to\ninline calls to pid_name(Atom) when Atom is known.\nOn a machine like the <code>X86</code> or <code>X86_64</code>, this could be a\nsingle locked load instruction.</p>\n\n<p>The value of a <code>-pid_name</code> is always a process id. <br />\nThere is a special process id value which at all times represents\na dead process.  So within a module,</p>\n\n<pre><code>pid_name(X) ! Message\n</code></pre>\n\n<p>is legal if and only if X is one of the pid-names declared in\nthe module, and whether or not the process it names has died.</p>\n\n<p>If there is a need to discover whether a <code>-pid_name</code> has within\nthe recent but unpredictable past been associated with a live\nprocess, that can be found out by combining <code>pid_name/1</code> with\n<code>process_info/2</code>.</p>\n\n<p>As with the registry, a process may have at most one <code>pid_name</code>.\nFor debugging purposes, I suppose that <code>process_info</code> could be\nextended to return a <code>{pid_name,{Module,Name}}</code> tuple.</p>\n\n<p>When a process exits, it is automatically unregistered.\nThat is, if it was bound to a <code>-pid_name</code>, that <code>-pid_name</code>\nnow refers to the conventional dead process.  This draft of\nthis EEP includes no other way for a process to be unregistered.</p>\n\n<p>The important thing about registering a process is that it\nshould be atomic.  So there are two new functions</p>\n\n<pre><code>pid_name_spawn(Name, Fun)\npid_name_spawn_link(Name, Fun)\n</code></pre>\n\n<p>We can understand them as</p>\n\n<pre><code>pid_name_spawn(Name, Fun)\n  when is_atom(Name), is_function(Fun, 0) -&gt;\n    with_module_lock(write) -&gt;\n    P = *Name,\n    if P is a live process -&gt;\n        P\n     ; P is a dead process -&gt;\n        Q = spawn(Fun),\n        *Name := Q,\n        Q\n    end\n    end.\n\npid_name_spawn_link(Name, Fun)\n  when is_atom(Name), is_function(Fun, 0) -&gt;\n    with_module_lock(write) -&gt;\n    P = *Name,\n    if P is a live process -&gt;\n        P\n     ; P is a dead process -&gt;\n        Q = spawn(Fun),\n        *Name := Q,\n        Q\n    end\n    end.\n</code></pre>\n\n<p>Here, as earlier, <code>with_module_lock</code> is pseudo-code, meant to\nsuggest some sort of reader-writer locking on a private lock,\nexisting only inside a module that has declared a <code>-pid_name</code>.</p>\n\n<p>These two functions are automatically declared inside the\nmodule, like <code>pid_name/1</code>.  The three functions are not functions\nautomatically inherited from the <code>erlang:</code> module but functions\nthat are logically inside the module, however they might be\nactually implemented.  There doesn't seem to be any good\nreason for a module to export any of these functions, and the\ncompiler should at least warn if that is attempted.</p>\n\n<h1>Motivation</h1>\n\n<ul>\n<li><p>Encapsulation.</p>\n\n<p>The process registry is often used when clients of a module\nneed to communicate with one or more servers managed by the\nmodule, but the interface code is inside the module.  There\nis no advantage, and much risk, in exposing the process.  A\nbig reason for this process is to get the benefit of having\nmutable process variables without the loss of encapsulation.</p></li>\n<li><p>Efficiency.</p>\n\n<p>As a shared mutable data structure, the registry has to be\naccessed within the scope of suitable locks.  With this\napproach, each module has its own lock, contention ought\nto be pretty nearly zero, and the commonest use case of\nthe registry can, I believe, be a simple load instruction.</p></li>\n<li><p>Safety.</p>\n\n<p>It is actually surprisingly hard to register a process\nsafely, and the use of registered names is oddly inconsistent\nwith the use of direct process ids.  This interface is meant\nto be simpler to use safely.</p></li>\n</ul>\n\n<h1>Rationale</h1>\n\n<p>The old Erlang book describes four functions for dealing with\nregistered process names.  There are two more main interfaces.</p>\n\n<pre><code>Name ! Message when is_atom(Name) -&gt;\n  % Also available as erlang:send(Name, Message).\n  % A 'badarg' exception results if Pid is an atom that is\n  % not the registered name of a live local process or port.\n    whereis(Name) ! Message.\n\nregister(Name, Pid) when is_atom(Name), is_pid(Pid) -&gt;\n  % A 'badarg' exception results if Pid is not a live local\n  % process or port, if Name is not an atom or is already in\n  % use, if Pid already has a registered name, or if Name is\n  % 'undefined'.\n    \"whereis(Name) := Pid\".\n\nunregister(Name) when is_atom(Name) -&gt;\n  % A 'badarg' exception results if Name is not an atom\n  % currently in use as the registered name of some process\n  % or port.  'undefined' is always an error.\n    \"whereis(Name) := undefined\".\n\nwhereis(Name) when is_atom(Name) -&gt;\n  % A 'badarg' exception results if Name is not a name.\n  % in effect, a global mutable hash table with\n  % atom keys and pid-or-'undefined' values.\n\nregistered() -&gt;\n    % yes, I know this is not executable Erlang.\n    [Name || is_atom(Name), is_pid(whereis(Name))].\n\nprocess_info(Pid, registered_name) when is_pid(Pid) -&gt;\n    % yes, I know this is not executable Erlang.\n    case [Name || is_atom(Name), whereis(Name) =:= Pid]\n      of [N] -&gt; {registered_name,N}\n       ; []  -&gt; []\n    end.\n</code></pre>\n\n<p>When a process terminates, for whatever reason, it does the\nequivalent of</p>\n\n<pre><code>case process_info(self(), registered_name)\n  of {_,Name} -&gt; unregister(Name)\n   ; []       -&gt; ok\nend.\n</code></pre>\n\n<p>This has an astonishing consequence.</p>\n\n<p>Suppose I do</p>\n\n<pre><code>Pid = spawn(Fun),\n...\nPid ! Message\n</code></pre>\n\n<p>and between the time the process was created and the time I send\nthe message to it, the process dies.  In Erlang this is\nperfectly ok, and the message just disappears.</p>\n\n<p>Now suppose I do</p>\n\n<pre><code>register(Name, spawn(Fun)),\n...\nName ! Message\n</code></pre>\n\n<p>and between the time the process was created and the time I send\nthe message to it, the process dies.  Anyone would expect the\nresult to be exactly the same: because the <code>Name</code> pointed to a\nprocess which has died, this amounts to sending a message to a\ndead process, which is perfectly ok, and the message just\ndisappears.  Most confusingly, that is not what happens, and\ninstead you get a 'badarg' exception.</p>\n\n<p>Now suppose I do</p>\n\n<pre><code>send(Pid, Message) when is_pid(Pid) -&gt;\n    Pid ! Message;\nsend(Name, Message) when is_atom(Name) -&gt;\n    case whereis(Name)\n      of undefined -&gt; ok\n       ; Pid when is_pid(Pid) -&gt; Pid ! Message\n    end.\n...\n    register(Name, spawn(Fun)),\n    ...\n    send(Name, Message)\n</code></pre>\n\n<p>This works the way we would expect, but why is it necessary?</p>\n\n<p>In Erlang as it stands, <code>Name ! Message</code> will raise an error if\n<code>Name</code> would have referred to the right process but that process\nhas died.  It might be argued that this is a useful debugging\naid, but nothing helps us if <code>Name</code> now refers to the WRONG\nprocess.  Right now, consider</p>\n\n<pre><code>whereis(Name) ! Message\n</code></pre>\n\n<p>This will raise an exception if the named process had died\nbefore whereis/1 was called, but consider this timing:</p>\n\n<pre><code>live           dies\n   whereis runs      message sent\n</code></pre>\n\n<p>A slight change in timing can unpredictably change the\nbehaviour from silence-on-late-death to error-on-early-death\nand vice versa.</p>\n\n<pre><code>pid_name(Name) ! Message\n</code></pre>\n\n<p>is <em>consistently</em> silent.</p>\n\n<p>The current process registry is also used for ports, which act in\nmany ways like processes.</p>\n\n<p>The old Erlang book is absolutely right that sometimes you\nneed a way to talk to a process you haven't been previously\nintroduced to.  However, it is not true that this must be\ndone by means of a global hash table.  You could always ask\na module for the information.</p>\n\n<p>Let's take program 5.5 from the book.</p>\n\n<pre><code>-module(number_analyser). \n-export([start/0,server/1]). \n-export([add_number/2,analyse/1]). \n\nstart() -&gt; \n    register(number_analyser, \n    spawn(number_analyser, server, [nil])). \n\n%% The interface functions. \n\nadd_number(Seq, Dest) -&gt; \n    request({add_number,Seq,Dest}). \n\nanalyse(Seq) -&gt; \n    request({analyse,Seq}). \n\nrequest(Req) -&gt; \n    number_analyser ! {self(), Req}, \n    receive \n    {number_analyser,Reply} -&gt; \n            Reply \n    end. \n\n%% The server. \n\nserver(Analyser_Table) -&gt; \n    receive \n        {From, {analyse, Seq}} -&gt; \n        Result = lookup(Seq, Analyser_Table), \n        From ! {number_analyser, Result}, \n        server(Analyser_Table)\n      ; {From, {add_number, Seq, Dest}} -&gt; \n        From ! {number_analyser, ack}, \n        server(insert(Seq, Dest, Analyser_Table)) \n    end.\n</code></pre>\n\n<p>The first thing we notice about this is that the registry is used\nto allow a process that is a client of this module to communicate\nwith a process managed by this module through interface functions\nin this module.  There is no reason why the process should be\ngiven a GLOBALLY visible name, and every reason why it should NOT.\nWe would like to ensure that all communication with the server\nprocess goes through the interface functions, and as long as the\nprocess is in a global registry, anything could happen.  The\nglobal process registry thus defeats its own purpose.</p>\n\n<p>Similarly, because the reply messages to the interface functions\nare tagged, not with the server's identity, but with its public\nname, they are easy to forge.  Both of these problems also apply\nto Program 5.6 in the old book.</p>\n\n<p>But there is worse.  It is NEVER safe to call <code>register/2</code> or\n<code>unregister/1</code>.  Recall that the precondition for <code>register/2</code>\nrequires that the <code>Name</code> not be in use.  But there is no way to\never be sure of that.  For example, you might try</p>\n\n<pre><code>spawn_if_necessary(Name, Fun) -&gt;\n    case whereis(Name)      % T1\n      of undefined -&gt;\n     Pid = spawn(Fun),  % T2\n     register(Name, Pid)    % T3\n       ; Pid when is_pid(Pid) -&gt;\n         ok\n    end,\n    Pid.\n</code></pre>\n\n<p>Unfortunately, between time T1, when <code>whereis/1</code> reports that the\n<code>Name</code> is not in use, and time T3, when we try to assign it, some\nother process might have been registered.  Also, between time T2,\nwhen the new process is created, and T3, when we use the <code>Pid</code>, the\nprocess might have died.</p>\n\n<p>Because the registry is global, it is no use searching existing\ncode to see whether the <code>Name</code> is clobbered; the bug might be\nintroduced in future code.</p>\n\n<p>There appears to be no way to protect against the possibility of a\nprocess dying between T2 and T3.  The obvious hack,</p>\n\n<pre><code>Pid = spawn(Fun),\nerlang:suspend_process(Pid),\nregister(Name, Pid),\nerlang:resume_process(Pid)\n</code></pre>\n\n<p>won't work because <code>erlang:suspend_process/1</code> is documented as\nhaving the same 'badarg if Pid is not the pid of a live local\nprocess' snafu as <code>register/2</code>.  The only really safe way around the\nissue would be for the new process to be born suspended, and\nthere's no way to do that.  There is no 'suspended' option allowed\nin the options list of <code>spawn_opt/[2-5]</code>.</p>\n\n<p>In practice, of course, the new process WON'T die, typically\nbecause it goes into a loop waiting for a message.  Even so, this\namount of fragility in a primitive is a bit worrying.</p>\n\n<p>Let's take a quick check to see how real all this is.</p>\n\n<p><code>sounder.erl</code> has</p>\n\n<pre><code>start() -&gt;\n    case whereis(sounder) of\n        undefined -&gt;\n        case file:read_file_info('/dev/audio') of\n            {ok, FI} when FI#file_info.access==read_write -&gt;\n            register(sounder, spawn(sounder,go,[])),\n            ok;\n            _Other -&gt;\n            register(sounder, spawn(sounder,nosound,[])),\n            silent\n        end;\n        _Pid -&gt;\n        ok\n    end.\n</code></pre>\n\n<p>Here's a curious thing:  the first time <code>sounder:start/0</code> is\ncalled, it will return different values (ok, silent) depending\non whether sound (is, is not) supported.  Later calls always\nreturn ok.  This contradicts the documentation.  Whoops!\nApart from that, it's a straightforward <code>spawn_if_necessary</code>.</p>\n\n<p><code>man.erl</code> has</p>\n\n<pre><code>start() -&gt;\n    case whereis(man) of\n        undefined -&gt;\n        register(man,Pid=spawn(man,init,[])),\n        Pid;\n        Pid -&gt;\n        Pid\n    end.\n</code></pre>\n\n<p>This is precisely</p>\n\n<pre><code>start() -&gt; spawn_if_necessary(fun () -&gt; man:init() end).\n</code></pre>\n\n<p><code>tv_table_owner</code> has</p>\n\n<pre><code>start() -&gt;\n    case whereis(?REGISTERED_NAME) of\n        undefined -&gt;\n        ServerPid = spawn(?MODULE, init, []),\n        case catch register(?REGISTERED_NAME, ServerPid) of\n            true -&gt;\n            ok;\n            {'EXIT', _Reason} -&gt;\n            exit(ServerPid, kill),\n            timer:sleep(500),\n            start()\n        end;\n        Pid when is_pid(Pid) -&gt;\n        ok\n    end.\n</code></pre>\n\n<p>Let's repackage that to see what's going on:</p>\n\n<pre><code>spawn_if_necessary(Name, Fun) -&gt;\n    case whereis(Name)\n      of undefined -&gt;\n         Pid = spawn(Fun),          \n         case catch register(Name, Pid)\n           of true -&gt;\n              Pid\n            ; {'EXIT', _} -&gt;\n              exit(Pid, kill),\n              timer:sleep(500),\n              spawn_if_necessary(Name, Fun)\n         end\n       ; Pid when is_pid(Pid) -&gt;\n     ok\n    end.\n</code></pre>\n\n<p>If there is a live local process registered under <code>Name</code>, return its\n<code>Pid</code>.  Of course, after the function returns to believe that there\nis STILL a live local process registered under Name, but that's\njust as true of <code>whereis/1</code>.</p>\n\n<p>If there is not, then create a new process, regardless of whether\nthat turns out to be useful.  Try to register it.  The <code>Pid</code> will be\nthe pid of a live local process that is not registered under any\nother name, and <code>Name</code> must be an atom other than 'undefined', or\n<code>whereis/1</code> would have crashed.  So it should be that the only thing\nthat can go wrong is that some other process has snuck in and\nswiped the registry slot.  In that case, kill the process, wait a\nlong time, and try again.</p>\n\n<p>In theory, it is possible for this to loop forever, with just the\nright malevolent timing by an adversary.  In practice, I'm sure it\nworks very well.</p>\n\n<p>The thing is, if the 'primitives' are this fragile, I would rather\nnot expose beginners to them.  Or for that matter, most people:\nthere are plenty of uses of <code>register/1</code> in the Erlang/OTP sources\nthat are not this well protected.</p>\n\n<p>The simplest fix to the 'registration race' problem would be to\nverify that <code>spawn_if_necessary/2</code> is sound, correct it if\nnecessary, and put it in a library.  However, that does nothing to\nfix the globality of the registry.</p>\n\n<p>There is no analogue of registered().  Inside a module, you can\nsee what names are available; outside the module, you have no\nright to know.</p>\n\n<p>This EEP does not propose abolishing the old registry.  There\nis a lot of code, and a lot of training material, that still\nuses or mentions it.  Above all, the old registry can do one\nthing that this EEP cannot do and isn't meant to, and that is\nto provide names that can be used in other nodes, in <code>{Node,Name}</code>\nform.  The aim of this proposal is to provide something that can\nreplace MOST uses of the registry with something safer, and in\nparticular to allow gradual migration to per-module registration.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>The only modules that are affected by the new feature are\nthose that visibly contain an explicit <code>-pid_name</code> directive.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None.</p>\n\n<h1>Example</h1>\n\n<p>Here is the old book's Program 5.5 again, brought up to date.</p>\n\n<pre><code>-module(number_analyser). \n-export([\n    add_number/2,\n    analyse/1,\n    start/0,\n    stop/0\n ]).\n-pid_name(server).\n\nstart() -&gt;\n    pid_name_spawn(server, fun () -&gt; server(nil) end).\n\nstop() -&gt;\n    pid_name(server) ! stop.\n\nadd_number(Seq, Dest) -&gt;\n    request({add_number,Seq,Dest}).\n\nanalyse(Seq) -&gt;\n    request({analyse,Seq}).\n\nrequest(Request) -&gt;\n    P = pid_name(server),\n    P ! {self(), Request},\n    receive {P,Reply} -&gt; Reply end.\n\nserver(Analyser_Table) -&gt;\n    receive \n        {From, {analyse, Seq}} -&gt; \n        From ! {self(), lookup(Seq, Analyser_Table)},\n        server(Analyser_Table)\n      ; {From, {add_number, Seq, Dest}} -&gt; \n        From ! {self(), ok}, \n        server(insert(Seq, Dest, Analyser_Table)) \n    end.\n</code></pre>\n\n<ul>\n<li><p>It is now possible to use a programming convention where the\n<code>-pid_name</code> of every server is 'server'.</p></li>\n<li><p>It is no longer possible for code outside the module to send\nmessages to the server process.</p></li>\n<li><p>It is no longer possible (well, no longer embarrassingly easy)\nfor an outsider to forge responses from the server.</p></li>\n</ul>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}