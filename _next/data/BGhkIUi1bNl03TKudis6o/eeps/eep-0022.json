{"pageProps":{"index":{"id":"0022","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 27-Aug-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 22: <a href=\"eep-0022.md\" title=\"EEP Source\"> Range checking for binaries</a></h2>\n\n<h1>Abstract</h1>\n\n<p>A module may request that bit fields be range checked.</p>\n\n<h1>Specification</h1>\n\n<p>A new directive is added.</p>\n\n<pre><code>-bit_range_check(Wanted).\n</code></pre>\n\n<p>where Wanted is 'false' or 'true'.</p>\n\n<p>Recall that a segment of a bit string (or binary) has the form</p>\n\n<pre><code>Value [':' Size] ['/' Type_Specifier_List]\n</code></pre>\n\n<p>where <code>Type_Specifier_List</code> includes such things as 'integer',\n'signed', and 'unsigned'.  Currently the documentation states\nthat</p>\n\n<pre><code>\"Signedness ... Only matters for matching and when the type\n is integer.  The default is unsigned.\"\n</code></pre>\n\n<p>Combining the <code>Size</code> with the <code>Unit</code> gives a <code>Size_In_Bits</code>.\nThe on-line Erlang manual does not state in section 6.16 that\nin constructing a bit string the bottom <code>Size_In_Bits</code> bits of\nan integer are used with the rest quietly ignored, but it is so.</p>\n\n<p>The directive <code>-bit_range_check(false)</code> makes explicit the\nprogrammer's intention that this C-like truncation should happen.</p>\n\n<p>The directive <code>-bit_range_check(true)</code> says that it is a checked\nrun-time error in</p>\n\n<pre><code>Value:Size/unsigned-integer-unit:1\n</code></pre>\n\n<p>or constructions otherwise equivalent to it if Value does not\nlie in the range <code>0 &lt;= Value &lt; 2**Size</code>, and it is a checked\nrun-time error in</p>\n\n<pre><code>Value:Size/signed-integer-unit:1\n</code></pre>\n\n<p>or constructions otherwise equivalent to it if Value does not\nlie in the range <code>-(2**(Size-1)) &lt;= Value &lt; 2**(Size-1)</code>.</p>\n\n<p>The error that is raised is like the error that would be raised\nfor <code>(1//0):Size/Type_Specifier_List</code> except for using 'badrange'\ninstead of 'badarith'.</p>\n\n<p>The behaviour of integer bit syntax segments in the absence of\na <code>-bit_range_check</code> directive is implementation defined and\nsubject to change.</p>\n\n<p>The BEAM system is extended with a new instruction or instructions\nsimilar to the existing instruction or instructions for integer\nsegments but checking the range.  The compiler is extended to\ngenerate them for <code>&lt;&lt;...&gt;&gt;</code> expressions in the range of a\n<code>-bit_range_check(true)</code> directive.</p>\n\n<p>A <code>-bit_range_check</code> directive may not appear after a bit syntax\npattern or expression or after another <code>-bit_range_check</code> directive.</p>\n\n<h1>Motivation</h1>\n\n<p>It keeps on coming as an unpleasant surprise to Erlang programmers\nthat this truncation happens.  Quiet destruction of information is\notherwise alien to Erlang:  integer arithmetic is unbounded, not\nwrapped as in some (but not all) C systems; element/2 doesn't take\nindices modulo tuple size but raises an exception if the index is\nout of range, and so on.</p>\n\n<p>In any case where the truncation is wanted, an Erlang programmer\ncan already write</p>\n\n<pre><code>(Value rem 256):unsigned-integer\n</code></pre>\n\n<p>and the Erlang compiler could notice this and optimise the 'rem'\noperation away, so the truncation is not only unusual in Erlang,\nit is also unexpected in this particular case.</p>\n\n<p>It is not only unexpected, it removes a chance to find mistakes,\nso it would seem to be undesirable.</p>\n\n<p>Edwin Fine asked \"How difficult could it be to add optional run-\ntime checking to detect this condition without a serious risk of\nadverse effects on the correctness of Erlang run-time execution?\"</p>\n\n<p>Bj√∂rn Gustavsson replied \"it would be better to add optional\nsupport in the compiler to turn on checks (either for an entire\nmodule, or for individual segments of a binary).  If someone\nwrites an EEP, we will consider implementing it.\"</p>\n\n<p>This is that EEP.</p>\n\n<h1>Rationale</h1>\n\n<p>The Erlang/OTP team regard the old behaviour as a feature,\nand wish to retain it.  In particular, they wish modules that\nwere written expecting the old behaviour to continue to work\n(for now) without modification.</p>\n\n<p>One alternative would be to add new syntax, such as having a\nnew 'checked' specifier, so that</p>\n\n<pre><code>Value/checked-unsigned-integer\n</code></pre>\n\n<p>would require a value in the range 0..255.\nBut many Erlang programmers will want to use this as the normal\ncase, and will not like the safe version being so much more effort\nto write than the unsafe version.</p>\n\n<p>It appears that \"truncation wanted/not wanted\" is not a matter\nof this expression or that, but of this programmer or that,\nand we can expect that each module will be written by someone\nexpecting only one behaviour or expecting only the other.</p>\n\n<p>Adding a</p>\n\n<pre><code>-bit_range_check(true).\n</code></pre>\n\n<p>directive to a module is more work than doing nothing at all,\nbut programmers who want this behaviour should be able to set up\ntheir editing environment to have this line in their template for\ncreating new Erlang modules.</p>\n\n<p>There are several questions:</p>\n\n<ul>\n<li>Should this apply to bit strings as well as integers?</li>\n<li>What should the name of the directive be?</li>\n<li>What should the argument(s) of the directive be?</li>\n<li>Should multiple instances of the directive be allowed in\na module?</li>\n</ul>\n\n<p>Bit strings:  <code>Assume X = &lt;&lt;5:3/unsigned-integer-unit:1&gt;&gt;</code>.\nCurrently, <code>&lt;&lt;X:2/bits&gt;&gt;</code> quietly truncates <code>X</code>.  This drops bits\nfrom the right of <code>X</code>, giving <code>&lt;&lt;2:2&gt;&gt;</code>.  If this worked the same\nas integers, you would expect <code>&lt;&lt;1:2&gt;&gt;</code>.  This is certainly\nvery odd.  Since we get truncation on the left and padding on\nthe left for integers, we naturally expect padding on the\nright for bit strings to go with truncation on the right.\nBut <code>&lt;&lt;X:4/bits&gt;&gt;</code> isn't <code>&lt;&lt;10:4&gt;&gt;</code>, it's a runtime exception.\nAll very odd indeed.  It would certainly be desirable to have\nan easy way for the programmer to indicate whether they wanted\ntruncation on the left or the right and padding on the left or\nthe right.  Perhaps a new built in function</p>\n\n<pre><code>set_bit_size(Bit_String, Desired_Width,\n             Truncation, Padding, Fill)\n\nBit_String : a bit string\nDesired_Width : a non-negative integer, the width wanted\nTruncation: 'left' | 'right' | 'error';\n    if bit_size(Bit_String) &gt; Desired_Width\n        truncate on the left/truncate on the right/\n        report an error\nPadding: 'left' | 'right' | 'error';\n    if bit_size(Bit_String) &lt; Desired_Width\n        pad on the left/pad on the right/report an error\nFill: 0 | 1 | 'copy';\n    pad with 0/pad with 1/pad with a copy of the\n    last bit at the end where padding is done.\n</code></pre>\n\n<p>However, that idea is only partly baked, and is not part of the\ncurrent proposal.  As things currently stand, using the bit\nsyntax and relying on implicit truncation is the simplest way\nto extract the leading bits of a bit string.</p>\n\n<p>As long as the name of the directive is intention-revealing,\nit doesn't matter very much what it is.\nI proposed <code>bit_range_check</code> because it is all about checking,\nranges in bit syntax, but since in this draft it does NOT apply\nto bit string segments, perhaps <code>bit_integer_range_check</code> would\nbe better.</p>\n\n<p>The arguments false and true seem clear enough.\nAlternatives would be something like</p>\n\n<pre><code>-bit_integer_range(check).\n-bit_integer_range(no_check).\n</code></pre>\n\n<p>That would be fine too.</p>\n\n<p>Classical Pascal compilers let you do things like</p>\n\n<pre><code>{$I-}   (* disable index checks *)\n(* code with no index checks *)\n{$I+}   (* re-enable index checks *)\n</code></pre>\n\n<p>Allowing multiple <code>-bit_range_check</code> directives in a module could\nlet you use code written for the old approach inside a module\nthat otherwise uses the new approach.  I don't believe that we\nwant to encourage that sort of thing:  it is MUCH easier when\nreading a module if all of it follows the same rule.</p>\n\n<p>It is also easier for an Erlang compiler that expects to be able\nto process function definitions in any order.  The compiler can\ncheck for one of these directives anywhere in a module before it\nhandles any bit syntax forms anywhere.  However, it is easier for\npeople reading a module if, when they first see a <code>&lt;&lt;...&gt;&gt;</code>\nconstruction, they have already seen any directive that might\naffect what it means.</p>\n\n<p>The restrictions on the number and placement of these directives\ncan always be relaxed later if necessary.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All existing Erlang code remains acceptable with unchanged semantics.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None, because I still can't find my way around the compiler.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}