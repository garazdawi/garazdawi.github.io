{"pageProps":{"index":{"id":"0040","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-version: R15B02\nCreated: 19-Oct-2012\nPost-History: 19-Oct-2012\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 40: <a href=\"eep-0040.md\" title=\"EEP Source\"> A proposal for Unicode variable and atom names in Erlang</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP proposes how to extend variable and atom names in Erlang\nto contain Unicode characters in a backwards compatible way.</p>\n\n<h1>Forces</h1>\n\n<ol>\n<li>Support for Unicode continues to increase, with\nminimal source code support about to arrive.</li>\n<li>Unicode variable names and unquoted atoms are not\nhere yet, so now is the time to settle on a design.</li>\n<li>They will need to come.  There may be legal or\ninstitutional reasons why unicode-capable languages\nare required.  Some people just want to use their\nown language and script.  Erlang's strength in\nnetwork applications means that being able to\nrepresent Internationalized Domain Names as unquoted\natoms would be just as much of a convenience as\nbeing able to represent ASCII domain names like\nwww.example.com (which needs no quotes in Erlang) is.</li>\n<li>There is a framework for Unicode identifiers in <a href=\"http://www.unicode.org/reports/tr31/\" title=\"Unicode Standard Annex 31\">UAX#31</a>,\nused by several programming languages, including Ada, Java,\nC++, C, C#, Javascript, and Python (section 2.3 of <a href=\"http://docs.python.org/release/3.1.5/reference/lexical_analysis.html\" title=\"Python Lexical Analysis\">Python Lexical</a>,\nand see also <a href=\"http://www.python.org/dev/peps/pep-3131/\" title=\"Python Enhancement Proposal 3131\">PEP 3131</a>).</li>\n<li>Existing Erlang identifiers should remain valid,\nincluding ones containing \"@\" and \".\".</li>\n<li>Existing Erlang support features, such as ignoring\nvariables that start with underscore when reporting\nsingleton variables, should not be broken.</li>\n<li>We should not \"steal\" any characters to use as \"magic\nmarkers\" for variables because they might be needed for\nother purposes.  A good (bad) example of this is \"?\", which\ncould be used for several things if it were not used for macros.</li>\n<li>Character sequences in Latin-1 that are not legal variable or\natom names now should not be made into such by this specification.</li>\n</ol>\n\n<h1>Reference</h1>\n\n<p>Names of sets of characters, XID_Start, XID_Continue, Lu, Lt, Lo, Pc,\nOther_Id_Start, are drawn from <a href=\"http://www.unicode.org/versions/Unicode6.2.0/\" title=\"The Unicode Standard version 6.2.0\">Unicode</a> and <a href=\"http://www.unicode.org/reports/tr31/\" title=\"Unicode Standard Annex 31\">UAX#31</a>.</p>\n\n<pre><code>    Lu = upper case letters\n    Lt = title case letters\n    Ll = lower case letters\n    Lo = non-case letters (Arabic, Chinese, and so on)\n    Pc = connector punctuators, including the low line (_) and\n         a number of other characters like undertie (‿).\n    Other_Id_Start = script capital p, estimated symbol,\n         katakana-hiragana voiced sound mark, and\n         katakana-hiragana semi-voiced sound mark.\n</code></pre>\n\n<h1>Specification</h1>\n\n<h2>Variables</h2>\n\n<pre><code>variable ::= var_start var_continue*\n\nvar_start ::= (XID_Start ∩ (Lu ∪ Lt ∪ Other_Id_Start)) ∪ Pc\n\nvar_continue ::= XID_Continue ∪ \"@\" \\ \"ªº\"\n</code></pre>\n\n<p>The choice of XID here follows Python.  It ensures that the normalisation\nof a variable is still a variable.  In fact Unicode variables should be\nnormalised.  Unicode has enough look-alike characters that we cannot hope\nfor \"look the same &lt;=> are the same\" to be true, but we should go <em>some</em>\nway in that direction.</p>\n\n<p>Variables in scripts that do not distinguish letter case have to\nbegin with <em>some</em> special character to ensure that they are not\nmistaken for unquoted atoms.  There are 10 Pc characters in the Basic\nMultilingual Plane.  The Erlang parser treats a variable beginning\nwith an underscore specially: there will be no complaint if it is a\nsingleton.  One approach would be to say that this special treatment\ndoes not apply to the other 9 Pc characters.\nUsing that approach, ‿ would not be a wild-card,\n_隠者 should be a singleton, and ‿隠者  should not.</p>\n\n<p>Of course, someone might be using fonts\nthat do include say Arabic letters but not say the undertie.  We can\ndeal with that by revising the underscore rule, which I recommend:</p>\n\n<pre><code>    Variable does not begin with a Pc character =&gt;\n             should not be a singleton.\n\n    Variable is just a Pc character and nothing else =&gt;\n             is a wild card.\n\n    Variable begins with a Pc character followed by an\n    Lu or Lt or Pc character =&gt;\n             may be a singleton.\n\n    Variable begins with a Pc character followed by\n    a legal character other than an Lu or Lt or Pc character =&gt;\n             should not be a singleton.\n</code></pre>\n\n<p>Thus ‿ is a wild-card, 隠者 is an atom, _隠者 should not be\na singleton, but __隠者 <em>may</em> be a singleton.  This rule is a\nconsistent generalisation of the existing rule.</p>\n\n<h2>Unquoted atoms</h2>\n\n<pre><code>    unquoted_atom ::= \".\"? atom_start atom_continue*\n\n    atom_start ::= XID_Start \\ (Lu ∪ Lt ∪ \"ªº\")\n\n    atom_continue ::= XID_Continue ∪ \"@\" \\ \"ªº\"\n                   |  \".\" atom_start\n</code></pre>\n\n<p>Again the choice of XID follows Python, and ensures that the\nnormalisation of an unquoted atom is still an unquoted atom.\nUnquoted atoms should be normalised.</p>\n\n<p>The details of Erlang unquoted atoms are somewhat subtle; I have\nchecked my understanding experimentally.  An initial dot is allowed,\nbut is always discarded.  That's odd, but it's the way it is now.</p>\n\n<h2>Keywords</h2>\n\n<p>Keywords have the form of unquoted atoms.  No new keywords are\nintroduced.</p>\n\n<h3>Specifics</h3>\n\n<ul>\n<li><p>Any Python identifier or keyword is\nan Erlang variable or unquoted atom or keyword\nunless it contains \"ª\" or \"º\".</p></li>\n<li><p>@ signs may occur freely in variables and unquoted atoms except as the\nfirst character, as now.</p></li>\n<li><p>Although they are in the Ll set, and so are technically lower case\nletters,  \"ª\" and \"º\" are not allowed in variable names or\nunquoted atoms in this proposal because they are not allowed in\nErlang now.</p></li>\n<li><p>dots may not be followed by capital letters, digits, or underscores,\nas now.</p></li>\n<li><p>I am not sure whether modifier letters should be allowed after a dot.</p></li>\n<li><p>I am not sure what to do with the Other_ID_Start characters.\nScript capital p <em>looks</em> like a capital p and even has \"capital\" in\nits name.  All other \"* SCRIPT CAPITAL *\" characters are upper case\nletters.  Surely it should be allowed to start a variable.\nThe estimated sign looks like an enlarged lower case e; other symbols\nthat look like letters are classified as letters.  You'd expect this\nto begin an atom.  As for the Katakana-Hiragana voicing marks, I have\nno intuition whatever.  Assigning the whole group to atoms seems\nsafest.</p></li>\n<li><p>All existing variable names and unquoted atoms remain legal, and no\nnew variable or atom forms using only Latin-1 characters have been\nintroduced.</p></li>\n</ul>\n\n<h1>Rationale</h1>\n\n<p>While Erlang files meant to be shared with a wide audience should\nstill be written in English, if people are working in a group fluent\nin some language on requirements also written in that language, it\nis desirable that they should be able to stay close to the terminology\nof the requirements lest they introduce translation errors.</p>\n\n<p>The whole design flows in the direction \"if someone wants to use their\nown script in an Erlang file, they should be able to do so comfortably\nin a way that is generally consistent with other programming\nlanguages.\"</p>\n\n<p>This <em>does</em> mean that there will be Erlang source files that a skilled\nErlang programmer is unable to decipher because of the unfamiliarity\nof the script.  With over 110,000 characters in Unicode 6, this is\njust going to happen no matter what we do.  Once Unicode strings are\navailable, can quoted Unicode atoms be far behind?  And once they are\npossible, refusing unquoted Unicode atoms does not salvage universal\nreadability.  All it would accomplish is to annoy people by requiring\nsingle quotation marks to be used liberally.  Old Algol programmers\nwill recall only too clearly how much of an impairment to readability\na hailstorm of single quotation marks was.  And if you can use\nγαμμα as an atom, does it make any sense to refuse Γαμμα?</p>\n\n<p>One of the goals for this EEP is that if an Erlang text contains only\nLatin-1 characters, then it should be legal under the new rules if and\nonly if it is legal under the old rules, and should have the same\nmeaning in either context.  During the transition period, there will\nbe people writing Erlang code for systems following the new rules, and\ngiving it to people using Latin-1 or at any rate old-rules systems.\nThey should not <em>accidentally</em> introduce incompatibilities.  This is\nwhy we have to ban  \"ª\" and \"º\" for now.  Later we may lift that ban.</p>\n\n<p>There are three ways we have to customize the UAX 31 definition.</p>\n\n<pre><code>    - We have to continue to support \"@\" in variables and\n      \"@\" and \".\" in unquoted atoms for backwards compatibility.\n\n    - We have to continue to forbid unquoted atoms containing\n      the Latin-1 masculine and feminine ordinal indicators.\n\n    - We have to distinguish between variables and unquoted atoms.\n</code></pre>\n\n<p>There is a fourth way we <em>might</em> customize it.  Ken Whistler of\nUnicode advises that he \"doesn't see much point\" in allowing Pc\ncharacters other than LOW LINE and FULLWIDTH LOW LINE, unless there\nare legacy reasons why something else has to be supported.  It seems\nlike a good idea that if s is a legal ASCII identifier, the full width\nversion of s should also be a legal identifier, so FULLWIDTH LOW LINE\ndefinitely ought to be allowed.  I find using UNDERTIE cool, but it's\nan editor's mark really.  If we reject the other Pc characters now, we\ncan always allow them later if we find a need; if we allow them now,\nit will be hard to reject them later.  Making this change <em>clearly</em> in\nthe definitions will take a little thought, so that's for the next revision.</p>\n\n<p>Dmitry Belyaev has raised the issue of localising keywords.  That is\noutside the scope of this EEP, which is concerned with which character\nsequences are variables and which are keywords-or-unquoted-atoms.\nThis has to be got right first before we can consider localised keywords.</p>\n\n<p>The leading underscore rule was revised on the 5th of November on\nthe advice of Ulrich Neumerkel to avoid the problem that _Œuvre\nwould not have been accepted as a singleton.  Now it will.  This was\nironic, as Māori variables like _Āporo would have been misclassified.</p>\n\n<h2>Trouble spot</h2>\n\n<p>It is highly desirable that a legal Erlang text should remain legal\neven as Unicode is revised.  <a href=\"http://www.unicode.org/reports/tr31/\" title=\"Unicode Standard Annex 31\">UAX#31</a> and <a href=\"http://www.unicode.org/policies/stability_policy.html\" title=\"Unicode Character Encoding Stability Policy\">Stability</a> very nearly\ngive us what we need.  The one problem that seems to be technically\npossible is that an upper or lower case letter without an opposite\ncase counterpart might change its General Category (while being given\nthe Other_ID_Start property if it ceased to be a letter at all),\nso an identifier beginning with such a cased orphan might switch from\nvariable to unquoted atom or vice versa.  Some cased orphans do exist,\nlike LATIN LETTER SMALL CAPITAL M, but what would a capital capital M\nbe?</p>\n\n<p>One possibility is to raise the issue with the Unicode consortium and\nleave this unresolved until they reply.  The issue <em>has</em> been raised,\nand the tentative reply \"you may not be able to rely on any given\nstandard property for special purposes.  Especially if that property is not\nformally stable.\" given.  The next step may well be to seek a revision\nto UAX#31, because Erlang is not alone in wanting a case distinction.</p>\n\n<p>Another possibility would be to say that an Lu character may only\nbegin a variable if it has a lower-case counterpart, and an Ll\ncharacter may only begin an unquoted atom if it has an upper-case\ncounterpart.  Since \"ß\" and \"ÿ\" have upper-case counterparts in\nUnicode, Latin-1 unquoted atoms would not be affected by such a rule.\nThe great mass of Lo characters would also be unaffected.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}