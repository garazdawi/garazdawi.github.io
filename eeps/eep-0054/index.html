<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Björn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
Status: Draft
Type: Standards Track
Created: 14-Sep-2020
Erlang-Version: 24
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 54: <a href="eep-0054.md" title="EEP Source"> Provide more information about errors</a></h2>

<h1>Abstract</h1>

<p>This EEP proposes a mechanism for reporting more human-readable
information about what went wrong when a BIF raises an exception.  The
same mechanism can be used by libraries or applications to provide
more detailed error messages.</p>

<h1>Specification</h1>

<p>In OTP 23 and earlier, the shell prints a terse message when a call
to a built-in function (BIF) fails:</p>

<pre><code>1&gt; element(a,b).
** exception error: bad argument
     in function  element/2
        called as element(a,b)
</code></pre>

<p>The <code>bad argument</code> message informs us that one or more of the
arguments to the call were incorrect in some way (in this example,
both arguments have wrong types).</p>

<p>We propose a mechanism that enables the shell to print more helpful
error messages.  Here is how the message would be printed with the
reference implementation of this EEP:</p>

<pre><code>1&gt; element(a, b).
** exception error: bad argument
     in function  element/2
        called as element(a,b)
        *** argument 1: not an integer
        *** argument 2: not a tuple
</code></pre>

<p>Note that the exact formatting and phrasing of the messages is an implementation
detail outside the scope of this EEP.  What will be specified here are the APIs
and conventions that make these messages possible.</p>

<h3>Proposals in this EEP</h3>

<ul>
<li><p>An extension of the format of the call-stack back trace (<strong>stacktrace</strong>) format
to indicate that there exists extended error information for that call, and
a convention for how extended error information can be provided.</p></li>
<li><p>A new <code>erlang:error/3</code> BIF to allow libraries and applications to
raise an exception with extended error information in the stacktrace.</p></li>
<li><p>New functions <code>erl_error:format_exception/3</code> and
<code>erl_error:format_exception/4</code> to allow libraries and applications to
format stacktraces in the same style as the shell.</p></li>
</ul>

<h3>Extending the stacktrace</h3>

<p>The stack back-trace (<strong>stacktrace</strong>) is currently a list of tuples.
For the purpose of this EEP we are only interested in the first entry
in the stacktrace.  It looks like
<code>{Module,Function,Arguments,ExtraInfo}</code>, where <code>ExtraInfo</code> is a list
of two-tuples.  As an indication that extended error info is available,
we propose adding an <code>{error_info,ErrorInfoMap}</code> tuple to <code>ExtraInfo</code>
in the first element in the stacktrace.</p>

<p>The map <code>ErrorInfoMap</code> contains further information about the error.
This should contain at least the key <code>reason</code>.  The corresponding
value could contain additional information about the error.  When there
is no additional information avaiable, the value is a dummy value such
as <code>none</code> or <code>[]</code>.</p>

<p>To obtain more information about the error, the <code>format_error/4</code>
function in module <code>Module</code> can be called to provide additional information about
the error.</p>

<p>The arguments for <code>format_error/4</code> are <code>Function</code>, <code>Arguments</code>, the
exception reason (usually <code>badarg</code> for BIF calls), and <code>ErrorInfoMap</code>.</p>

<p>Thus, if a call to <code>element/2</code> fails with a <code>badarg</code> exception and the
first entry in the stacktrace is:</p>

<pre><code>{erlang,element,[1,no_tuple],[{error_info,ErrorInfoMap}]}
</code></pre>

<p>the following call will provide provide additional information about
the error:</p>

<pre><code>erlang:format_error(element, [1,no_tuple], badarg, ErrorInfoMap)
</code></pre>

<p>The <code>format_error/4</code> function should return a map.  For each argument
that was in error, there should be a map element with the argument number
as the key (that is, <code>1</code> for the first argument, <code>2</code> for the second, and so on)
and a <code>unicode:chardata()</code> term as the value.</p>

<p>As an example:</p>

<pre><code>erlang:format_error(element, [1,no_tuple], badarg, ErrorInfoMap)
</code></pre>

<p>could return:</p>

<pre><code>#{2 =&gt; &lt;&lt;"not a tuple"&gt;&gt;}
</code></pre>

<p>And:</p>

<pre><code>erlang:format_error(element, [0, b], badarg, ErrorInfo)
</code></pre>

<p>could return:</p>

<pre><code>#{1 =&gt; &lt;&lt;"out of range"&gt;&gt;, 2 =&gt; &lt;&lt;"not a tuple"&gt;&gt;}
</code></pre>

<p>Note that the <code>ErrorInfoMap</code> term is only to be used by
<code>Module:format_error/4</code>.  It is not to be matched by code in other
modules.  The particular value for the key <code>reason</code> in the map
<code>ErrorInfoMap</code> for a particular error could change at any time.  Also
note that <code>Module:format_error/4</code> may choose not to use the <code>reason</code>
key at all.  For example, the reference implementation of
<code>erlang:format_error/4</code> only examines the arguments for <code>element/2</code>.</p>

<p>The value for the key <code>reason</code> term will typically have a meaningful
value when an error occurs in a BIF that depends on the internal state
in the runtime system (such as <code>register/2</code> or the ETS BIFs), or for
BIFs with complex arguments (such as <code>system_flag/2</code>) that would
make it tedious and error prone to figure out which argument was
in error.</p>

<p>Here is one way that <code>format_error/4</code> for the <code>erlang</code> module could
be implemented:</p>

<pre><code>format_error(F, As, ExceptionReason, ErrorInfoMap) -&gt;
    Reason = maps:get(reason, ErrorInfoMap, none),
    do_format_error(F, As, ExceptionReason, Reason).

do_format_error(_, _, system_limit, _) -&gt;
    %% The explanation for system_limit is clear enough, so we don't
    %% need any detailed explanations for the arguments.
    #{};
do_format_error(F, As, _, Reason) -&gt;
    do_format_error(F, As, Reason).

do_format_error(element, [Index, Tuple], _) -&gt;
    Arg1 = if
               not is_integer(Index) -&gt;
                   &lt;&lt;"not an integer"&gt;&gt;;
               Index =&lt; 0; Index &gt; tuple_size(Tuple) -&gt;
                   &lt;&lt;"out of range"&gt;&gt;;
               true -&gt;
                   []
           end,
    Arg2 = if
               not is_tuple(Tuple) -&gt; &lt;&lt;"not a tuple"&gt;&gt;;
               true -&gt; []
           end,
    PotentialErrors = [{1, Arg1}, {2, Arg2}],
    maps:from_list([{ArgNum, Err} ||
                       {ArgNum, Err} &lt;- PotentialErrors,
                       Err =/= []]);

do_format_error(list_to_atom, _, _) -&gt;
    #{1 =&gt; &lt;&lt;"not a flat list of characters"&gt;&gt;};

do_format_error(register, [Name,PidOrPort], Reason) -&gt;
    [Arg1, Arg2] =
    case Reason of
        registered_name -&gt;
            [[],&lt;&lt;"this process or port already has a name"&gt;&gt;];
        notalive -&gt;
            [[],&lt;&lt;"the pid does not refer to an existing process"&gt;&gt;];
        _ -&gt;
            Errors =
                [if
                     Name =:= undefined -&gt; &lt;&lt;"'undefined' is not a valid name"&gt;&gt;;
                     is_atom(Name) -&gt; [];
                     true -&gt; &lt;&lt;"not an atom"&gt;&gt;
                 end,
                 if
                     is_pid(PidOrPort) -&gt; [];
                     is_port(PidOrPort) -&gt; [];
                     true -&gt; &lt;&lt;"not a pid or a port"&gt;&gt;
                 end],
            case Errors of
                [[],[]] -&gt;
                    [&lt;&lt;"name is in use"&gt;&gt;];
                [_,_] -&gt;
                    Errors
            end,
    PotentialErrors = [{1, Arg1}, {2, Arg2}],
    maps:from_list([{ArgNum, Err} ||
                       {ArgNum, Err} &lt;- PotentialErrors,
                       Err =/= []]);
      .
      .
      .

do_format_error(_, _, _) -&gt;
    #{}.
</code></pre>

<p>The <code>register/2</code> BIF will provide specific error reasons for two of
the possible failure reasons.  If the reason is not one of the two,
<code>format_error/4</code> will figure out the other reasons based on the
arguments.</p>

<h3>Supplying extended error information using <code>erlang:error/3</code></h3>

<p>A library or application can raise an error exception with extended error
information by calling <code>erlang:error(Reason, Arguments, Options)</code>.
<code>Reason</code> should be the error reason (for example <code>badarg</code>), <code>Arguments</code>
should be arguments for the calling function, and <code>Options</code> should
be <code>[{error_info,ErrorInfoMap}]</code>, where <code>ErrorInfoMap</code> with at
least the key <code>reason</code>.</p>

<p>The module that raises the exception should export a <code>format_error/4</code>
function that behaves as described in the previous section.</p>

<h3>Formatting stacktraces</h3>

<p>To make it possible for applications and libraries to format
stacktraces in the same style as the shell, the functions
<code>erl_error:format_exception/3</code> and <code>erl_error:format_exception/4</code> are
provided.  Here is an example how <code>erl_error:format_exception/3</code> can
be used:</p>

<pre><code>try
    .
    .
    .
catch
    C:R:Stk -&gt;
        Message = erl_error:format_exception(C, R, Stk),
        io:format(LogFile, "~ts\n", [Message])
end.
</code></pre>

<p>The <code>erl_error:format_exception/4</code> function is similar but has a
fourth option argument to support customizing the message.  See the
documentation in the reference implementation for details.</p>

<h3>Possible future extensions</h3>

<p>Since the <code>error_info</code> tuple in the stacktrace contains a map, more
data could be added to the map.  For example, there could be <code>module</code>
and <code>function</code> keys to allow pointing out a <code>format_error/4</code> function
with an arbitrary name.  That could be useful if the compiler were to
generate extended error information for <code>badmatch</code> or
<code>function_clause</code> errors.</p>

<p>Since the return value of <code>format_error/4</code> is a map, additional keys
in the map could be assigned a meaning in the future.</p>

<p>For example, the value for the key <code>hint</code> could be a longer message
that gives more context or provides concrete advice on how to
investigate or avoid the error.</p>

<h3>Additional examples</h3>

<p>Let's look at some examples using ETS:</p>

<pre><code>1&gt; T = ets:new(table, []).
#Ref&lt;0.2290824696.4161404930.5168&gt;
2&gt; ets:update_counter(T, k, 1).
** exception error: bad argument
     in function  ets:update_counter/3
        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5168&gt;,k,1)
        *** argument 2: not a key that exists in the table
</code></pre>

<p>Note that when an error occurs while evaluating an expression entered in the
shell, the evaluator process terminates and any ETS tables created by that
process are deleted.  Thus, calling <code>update_counter</code> a second time with the
same arguments results in a different message:</p>

<pre><code>3&gt; ets:update_counter(T, k, 1).
** exception error: bad argument
     in function  ets:update_counter/3
        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5168&gt;,k,1)
        *** argument 1: the table identifier does not refer to an existing ETS table
</code></pre>

<p>Starting over, creating a new ETS table:</p>

<pre><code>4&gt; f(T), T = ets:new(table, []).
#Ref&lt;0.2290824696.4161404930.5205&gt;
5&gt; ets:insert(T, {k,a,0}).
true
6&gt; ets:update_counter(T, k, 1).
** exception error: bad argument
     in function  ets:update_counter/3
        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5205&gt;,k,1)
        *** argument 3: the value in the given position in the object is not an integer
7&gt; ets:update_counter(T, k, bad).
** exception error: bad argument
     in function  ets:update_counter/3
        called as ets:update_counter(#Ref&lt;0.2290824696.4161404930.5205&gt;,k,bad)
        *** argument 1: the table identifier does not refer to an existing ETS table
        *** argument 3: not a valid update operation
</code></pre>

<h1>Motivation</h1>

<p>When a call to a BIF fails with the reason <code>badarg</code> it is not always
obvious even to an experienced developer exactly which argument was
"bad" and in which way.  For a newcomer, having to figure out what a
<code>badarg</code> means is another stumbling block standing in the way of
mastering a new language.</p>

<p>Even for an experienced developer, figuring out the reason for a
<code>badarg</code> exception for some BIFs is hard or impossible.  For example,
<a href="http://erlang.org/doc/man/ets.html#update_counter-4">the documentation for <code>ets:update_counter/4</code></a> at the
time of writing lists 8 situations in which <code>ets:update_counter/4</code>
will fail. That number is too low.  Missing from list are, for
example, reasons such as the ETS table having been deleted or having
insufficient access right.</p>

<h1>Rationale</h1>

<h3>Why not change <code>badarg</code> to something more informational?</h3>

<p>An alternative way to provide more information about errors would be
to introduce additional exception reasons.  For example, the call:</p>

<pre><code>element(a, b)
</code></pre>

<p>could raise the exception:</p>

<pre><code>{badarg,[{1,not_integer},{2,not_tuple}]}
</code></pre>

<p>That change could break code that expects that BIFs should raise a
<code>badarg</code> exception.  It is less likely that existing code would match
the fourth entry in the stacktrace.</p>

<p>A related reason is the amount of work needed to revise the error
handling code for all built-in functions.  Implementing building of
Erlang terms in C is tedious and error prone.  There would always be a
risk that bugs in that code would crash the runtime system when an
error occurred.  The test suite would have to be extremely thorough
to ensure that all bugs were found, because error handling code is
typically infrequently executed.</p>

<h3>Why can't the stacktrace contain the complete error reason?</h3>

<p>We did consider modifying the implementation of all BIFs so that they
would produce complete error information in the stacktrace when they
failed.  However, as mentioned earlier, building Erlang terms in C is
tedious and error prone.</p>

<p>With the approach we have taken to let Erlang code do most of the
analysis of the error reason, there is a much lower risk that error
handling would crash the application or runtime system.</p>

<h3>Why are the the reasons in the <code>ErrorInfoMap</code> undocumented?</h3>

<p>The reason in the <code>ErrorInfoMap</code> is not meant to be used for
programmatically figure out why an error occurred, but only to be used
by <code>Module:format_error/4</code> to produce a human-readable message.</p>

<p>Also, for many BIFs the reason will not have a meaningful
value, as the <code>Module:format/4</code> function will produce the messages
based solely on the name of the BIF and its arguments.</p>

<h1>Backwards Compatibility</h1>

<p>All exceptions from BIFs will now have a <code>ExtraInfo</code> element (called
<code>Location</code> in the documentation for OTP 23) in the call-stack back
trace (stacktrace) that includes an <code>error_info</code> tuple.  In previous
releases the <code>ExtraInfo</code> element would be an empty list for a failed
BIF call.</p>

<p>Applications that explicitly do matching on the stacktrace and do
assumptions of the layout of the <code>ExtraInfo</code> element (for example,
assuming that <code>Location</code> is either an empty list or a list of <code>file</code>
and <code>line</code> tuples in a specific order) may need modifications.  Note
that such assumptions have never been safe and that the <a href="http://erlang.org/doc/reference_manual/errors.html#exceptions">documentation
for error handling</a> strongly discourages developers to rely on
stacktrace entries for purposes other than debugging.</p>

<h1>Implementation</h1>

<p>The reference implementation includes extended error information for
most BIFs implemented in C in the <code>erlang</code> and <code>ets</code> modules.
It can be found in <a href="https://github.com/erlang/otp/pull/2849">PR #2849</a>.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0054","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Björn Gustavsson \u0026lt;bjorn(at)erlang(dot)org\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 14-Sep-2020\nErlang-Version: 24\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 54: \u003ca href=\"eep-0054.md\" title=\"EEP Source\"\u003e Provide more information about errors\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes a mechanism for reporting more human-readable\ninformation about what went wrong when a BIF raises an exception.  The\nsame mechanism can be used by libraries or applications to provide\nmore detailed error messages.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eIn OTP 23 and earlier, the shell prints a terse message when a call\nto a built-in function (BIF) fails:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; element(a,b).\n** exception error: bad argument\n     in function  element/2\n        called as element(a,b)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003ebad argument\u003c/code\u003e message informs us that one or more of the\narguments to the call were incorrect in some way (in this example,\nboth arguments have wrong types).\u003c/p\u003e\n\n\u003cp\u003eWe propose a mechanism that enables the shell to print more helpful\nerror messages.  Here is how the message would be printed with the\nreference implementation of this EEP:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; element(a, b).\n** exception error: bad argument\n     in function  element/2\n        called as element(a,b)\n        *** argument 1: not an integer\n        *** argument 2: not a tuple\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that the exact formatting and phrasing of the messages is an implementation\ndetail outside the scope of this EEP.  What will be specified here are the APIs\nand conventions that make these messages possible.\u003c/p\u003e\n\n\u003ch3\u003eProposals in this EEP\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eAn extension of the format of the call-stack back trace (\u003cstrong\u003estacktrace\u003c/strong\u003e) format\nto indicate that there exists extended error information for that call, and\na convention for how extended error information can be provided.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eA new \u003ccode\u003eerlang:error/3\u003c/code\u003e BIF to allow libraries and applications to\nraise an exception with extended error information in the stacktrace.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eNew functions \u003ccode\u003eerl_error:format_exception/3\u003c/code\u003e and\n\u003ccode\u003eerl_error:format_exception/4\u003c/code\u003e to allow libraries and applications to\nformat stacktraces in the same style as the shell.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3\u003eExtending the stacktrace\u003c/h3\u003e\n\n\u003cp\u003eThe stack back-trace (\u003cstrong\u003estacktrace\u003c/strong\u003e) is currently a list of tuples.\nFor the purpose of this EEP we are only interested in the first entry\nin the stacktrace.  It looks like\n\u003ccode\u003e{Module,Function,Arguments,ExtraInfo}\u003c/code\u003e, where \u003ccode\u003eExtraInfo\u003c/code\u003e is a list\nof two-tuples.  As an indication that extended error info is available,\nwe propose adding an \u003ccode\u003e{error_info,ErrorInfoMap}\u003c/code\u003e tuple to \u003ccode\u003eExtraInfo\u003c/code\u003e\nin the first element in the stacktrace.\u003c/p\u003e\n\n\u003cp\u003eThe map \u003ccode\u003eErrorInfoMap\u003c/code\u003e contains further information about the error.\nThis should contain at least the key \u003ccode\u003ereason\u003c/code\u003e.  The corresponding\nvalue could contain additional information about the error.  When there\nis no additional information avaiable, the value is a dummy value such\nas \u003ccode\u003enone\u003c/code\u003e or \u003ccode\u003e[]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo obtain more information about the error, the \u003ccode\u003eformat_error/4\u003c/code\u003e\nfunction in module \u003ccode\u003eModule\u003c/code\u003e can be called to provide additional information about\nthe error.\u003c/p\u003e\n\n\u003cp\u003eThe arguments for \u003ccode\u003eformat_error/4\u003c/code\u003e are \u003ccode\u003eFunction\u003c/code\u003e, \u003ccode\u003eArguments\u003c/code\u003e, the\nexception reason (usually \u003ccode\u003ebadarg\u003c/code\u003e for BIF calls), and \u003ccode\u003eErrorInfoMap\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThus, if a call to \u003ccode\u003eelement/2\u003c/code\u003e fails with a \u003ccode\u003ebadarg\u003c/code\u003e exception and the\nfirst entry in the stacktrace is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{erlang,element,[1,no_tuple],[{error_info,ErrorInfoMap}]}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ethe following call will provide provide additional information about\nthe error:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:format_error(element, [1,no_tuple], badarg, ErrorInfoMap)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eformat_error/4\u003c/code\u003e function should return a map.  For each argument\nthat was in error, there should be a map element with the argument number\nas the key (that is, \u003ccode\u003e1\u003c/code\u003e for the first argument, \u003ccode\u003e2\u003c/code\u003e for the second, and so on)\nand a \u003ccode\u003eunicode:chardata()\u003c/code\u003e term as the value.\u003c/p\u003e\n\n\u003cp\u003eAs an example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:format_error(element, [1,no_tuple], badarg, ErrorInfoMap)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecould return:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{2 =\u0026gt; \u0026lt;\u0026lt;\"not a tuple\"\u0026gt;\u0026gt;}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAnd:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:format_error(element, [0, b], badarg, ErrorInfo)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecould return:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#{1 =\u0026gt; \u0026lt;\u0026lt;\"out of range\"\u0026gt;\u0026gt;, 2 =\u0026gt; \u0026lt;\u0026lt;\"not a tuple\"\u0026gt;\u0026gt;}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that the \u003ccode\u003eErrorInfoMap\u003c/code\u003e term is only to be used by\n\u003ccode\u003eModule:format_error/4\u003c/code\u003e.  It is not to be matched by code in other\nmodules.  The particular value for the key \u003ccode\u003ereason\u003c/code\u003e in the map\n\u003ccode\u003eErrorInfoMap\u003c/code\u003e for a particular error could change at any time.  Also\nnote that \u003ccode\u003eModule:format_error/4\u003c/code\u003e may choose not to use the \u003ccode\u003ereason\u003c/code\u003e\nkey at all.  For example, the reference implementation of\n\u003ccode\u003eerlang:format_error/4\u003c/code\u003e only examines the arguments for \u003ccode\u003eelement/2\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe value for the key \u003ccode\u003ereason\u003c/code\u003e term will typically have a meaningful\nvalue when an error occurs in a BIF that depends on the internal state\nin the runtime system (such as \u003ccode\u003eregister/2\u003c/code\u003e or the ETS BIFs), or for\nBIFs with complex arguments (such as \u003ccode\u003esystem_flag/2\u003c/code\u003e) that would\nmake it tedious and error prone to figure out which argument was\nin error.\u003c/p\u003e\n\n\u003cp\u003eHere is one way that \u003ccode\u003eformat_error/4\u003c/code\u003e for the \u003ccode\u003eerlang\u003c/code\u003e module could\nbe implemented:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eformat_error(F, As, ExceptionReason, ErrorInfoMap) -\u0026gt;\n    Reason = maps:get(reason, ErrorInfoMap, none),\n    do_format_error(F, As, ExceptionReason, Reason).\n\ndo_format_error(_, _, system_limit, _) -\u0026gt;\n    %% The explanation for system_limit is clear enough, so we don't\n    %% need any detailed explanations for the arguments.\n    #{};\ndo_format_error(F, As, _, Reason) -\u0026gt;\n    do_format_error(F, As, Reason).\n\ndo_format_error(element, [Index, Tuple], _) -\u0026gt;\n    Arg1 = if\n               not is_integer(Index) -\u0026gt;\n                   \u0026lt;\u0026lt;\"not an integer\"\u0026gt;\u0026gt;;\n               Index =\u0026lt; 0; Index \u0026gt; tuple_size(Tuple) -\u0026gt;\n                   \u0026lt;\u0026lt;\"out of range\"\u0026gt;\u0026gt;;\n               true -\u0026gt;\n                   []\n           end,\n    Arg2 = if\n               not is_tuple(Tuple) -\u0026gt; \u0026lt;\u0026lt;\"not a tuple\"\u0026gt;\u0026gt;;\n               true -\u0026gt; []\n           end,\n    PotentialErrors = [{1, Arg1}, {2, Arg2}],\n    maps:from_list([{ArgNum, Err} ||\n                       {ArgNum, Err} \u0026lt;- PotentialErrors,\n                       Err =/= []]);\n\ndo_format_error(list_to_atom, _, _) -\u0026gt;\n    #{1 =\u0026gt; \u0026lt;\u0026lt;\"not a flat list of characters\"\u0026gt;\u0026gt;};\n\ndo_format_error(register, [Name,PidOrPort], Reason) -\u0026gt;\n    [Arg1, Arg2] =\n    case Reason of\n        registered_name -\u0026gt;\n            [[],\u0026lt;\u0026lt;\"this process or port already has a name\"\u0026gt;\u0026gt;];\n        notalive -\u0026gt;\n            [[],\u0026lt;\u0026lt;\"the pid does not refer to an existing process\"\u0026gt;\u0026gt;];\n        _ -\u0026gt;\n            Errors =\n                [if\n                     Name =:= undefined -\u0026gt; \u0026lt;\u0026lt;\"'undefined' is not a valid name\"\u0026gt;\u0026gt;;\n                     is_atom(Name) -\u0026gt; [];\n                     true -\u0026gt; \u0026lt;\u0026lt;\"not an atom\"\u0026gt;\u0026gt;\n                 end,\n                 if\n                     is_pid(PidOrPort) -\u0026gt; [];\n                     is_port(PidOrPort) -\u0026gt; [];\n                     true -\u0026gt; \u0026lt;\u0026lt;\"not a pid or a port\"\u0026gt;\u0026gt;\n                 end],\n            case Errors of\n                [[],[]] -\u0026gt;\n                    [\u0026lt;\u0026lt;\"name is in use\"\u0026gt;\u0026gt;];\n                [_,_] -\u0026gt;\n                    Errors\n            end,\n    PotentialErrors = [{1, Arg1}, {2, Arg2}],\n    maps:from_list([{ArgNum, Err} ||\n                       {ArgNum, Err} \u0026lt;- PotentialErrors,\n                       Err =/= []]);\n      .\n      .\n      .\n\ndo_format_error(_, _, _) -\u0026gt;\n    #{}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eregister/2\u003c/code\u003e BIF will provide specific error reasons for two of\nthe possible failure reasons.  If the reason is not one of the two,\n\u003ccode\u003eformat_error/4\u003c/code\u003e will figure out the other reasons based on the\narguments.\u003c/p\u003e\n\n\u003ch3\u003eSupplying extended error information using \u003ccode\u003eerlang:error/3\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eA library or application can raise an error exception with extended error\ninformation by calling \u003ccode\u003eerlang:error(Reason, Arguments, Options)\u003c/code\u003e.\n\u003ccode\u003eReason\u003c/code\u003e should be the error reason (for example \u003ccode\u003ebadarg\u003c/code\u003e), \u003ccode\u003eArguments\u003c/code\u003e\nshould be arguments for the calling function, and \u003ccode\u003eOptions\u003c/code\u003e should\nbe \u003ccode\u003e[{error_info,ErrorInfoMap}]\u003c/code\u003e, where \u003ccode\u003eErrorInfoMap\u003c/code\u003e with at\nleast the key \u003ccode\u003ereason\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe module that raises the exception should export a \u003ccode\u003eformat_error/4\u003c/code\u003e\nfunction that behaves as described in the previous section.\u003c/p\u003e\n\n\u003ch3\u003eFormatting stacktraces\u003c/h3\u003e\n\n\u003cp\u003eTo make it possible for applications and libraries to format\nstacktraces in the same style as the shell, the functions\n\u003ccode\u003eerl_error:format_exception/3\u003c/code\u003e and \u003ccode\u003eerl_error:format_exception/4\u003c/code\u003e are\nprovided.  Here is an example how \u003ccode\u003eerl_error:format_exception/3\u003c/code\u003e can\nbe used:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry\n    .\n    .\n    .\ncatch\n    C:R:Stk -\u0026gt;\n        Message = erl_error:format_exception(C, R, Stk),\n        io:format(LogFile, \"~ts\\n\", [Message])\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe \u003ccode\u003eerl_error:format_exception/4\u003c/code\u003e function is similar but has a\nfourth option argument to support customizing the message.  See the\ndocumentation in the reference implementation for details.\u003c/p\u003e\n\n\u003ch3\u003ePossible future extensions\u003c/h3\u003e\n\n\u003cp\u003eSince the \u003ccode\u003eerror_info\u003c/code\u003e tuple in the stacktrace contains a map, more\ndata could be added to the map.  For example, there could be \u003ccode\u003emodule\u003c/code\u003e\nand \u003ccode\u003efunction\u003c/code\u003e keys to allow pointing out a \u003ccode\u003eformat_error/4\u003c/code\u003e function\nwith an arbitrary name.  That could be useful if the compiler were to\ngenerate extended error information for \u003ccode\u003ebadmatch\u003c/code\u003e or\n\u003ccode\u003efunction_clause\u003c/code\u003e errors.\u003c/p\u003e\n\n\u003cp\u003eSince the return value of \u003ccode\u003eformat_error/4\u003c/code\u003e is a map, additional keys\nin the map could be assigned a meaning in the future.\u003c/p\u003e\n\n\u003cp\u003eFor example, the value for the key \u003ccode\u003ehint\u003c/code\u003e could be a longer message\nthat gives more context or provides concrete advice on how to\ninvestigate or avoid the error.\u003c/p\u003e\n\n\u003ch3\u003eAdditional examples\u003c/h3\u003e\n\n\u003cp\u003eLet's look at some examples using ETS:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; T = ets:new(table, []).\n#Ref\u0026lt;0.2290824696.4161404930.5168\u0026gt;\n2\u0026gt; ets:update_counter(T, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref\u0026lt;0.2290824696.4161404930.5168\u0026gt;,k,1)\n        *** argument 2: not a key that exists in the table\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that when an error occurs while evaluating an expression entered in the\nshell, the evaluator process terminates and any ETS tables created by that\nprocess are deleted.  Thus, calling \u003ccode\u003eupdate_counter\u003c/code\u003e a second time with the\nsame arguments results in a different message:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e3\u0026gt; ets:update_counter(T, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref\u0026lt;0.2290824696.4161404930.5168\u0026gt;,k,1)\n        *** argument 1: the table identifier does not refer to an existing ETS table\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eStarting over, creating a new ETS table:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e4\u0026gt; f(T), T = ets:new(table, []).\n#Ref\u0026lt;0.2290824696.4161404930.5205\u0026gt;\n5\u0026gt; ets:insert(T, {k,a,0}).\ntrue\n6\u0026gt; ets:update_counter(T, k, 1).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref\u0026lt;0.2290824696.4161404930.5205\u0026gt;,k,1)\n        *** argument 3: the value in the given position in the object is not an integer\n7\u0026gt; ets:update_counter(T, k, bad).\n** exception error: bad argument\n     in function  ets:update_counter/3\n        called as ets:update_counter(#Ref\u0026lt;0.2290824696.4161404930.5205\u0026gt;,k,bad)\n        *** argument 1: the table identifier does not refer to an existing ETS table\n        *** argument 3: not a valid update operation\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eWhen a call to a BIF fails with the reason \u003ccode\u003ebadarg\u003c/code\u003e it is not always\nobvious even to an experienced developer exactly which argument was\n\"bad\" and in which way.  For a newcomer, having to figure out what a\n\u003ccode\u003ebadarg\u003c/code\u003e means is another stumbling block standing in the way of\nmastering a new language.\u003c/p\u003e\n\n\u003cp\u003eEven for an experienced developer, figuring out the reason for a\n\u003ccode\u003ebadarg\u003c/code\u003e exception for some BIFs is hard or impossible.  For example,\n\u003ca href=\"http://erlang.org/doc/man/ets.html#update_counter-4\"\u003ethe documentation for \u003ccode\u003eets:update_counter/4\u003c/code\u003e\u003c/a\u003e at the\ntime of writing lists 8 situations in which \u003ccode\u003eets:update_counter/4\u003c/code\u003e\nwill fail. That number is too low.  Missing from list are, for\nexample, reasons such as the ETS table having been deleted or having\ninsufficient access right.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003ch3\u003eWhy not change \u003ccode\u003ebadarg\u003c/code\u003e to something more informational?\u003c/h3\u003e\n\n\u003cp\u003eAn alternative way to provide more information about errors would be\nto introduce additional exception reasons.  For example, the call:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eelement(a, b)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecould raise the exception:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{badarg,[{1,not_integer},{2,not_tuple}]}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat change could break code that expects that BIFs should raise a\n\u003ccode\u003ebadarg\u003c/code\u003e exception.  It is less likely that existing code would match\nthe fourth entry in the stacktrace.\u003c/p\u003e\n\n\u003cp\u003eA related reason is the amount of work needed to revise the error\nhandling code for all built-in functions.  Implementing building of\nErlang terms in C is tedious and error prone.  There would always be a\nrisk that bugs in that code would crash the runtime system when an\nerror occurred.  The test suite would have to be extremely thorough\nto ensure that all bugs were found, because error handling code is\ntypically infrequently executed.\u003c/p\u003e\n\n\u003ch3\u003eWhy can't the stacktrace contain the complete error reason?\u003c/h3\u003e\n\n\u003cp\u003eWe did consider modifying the implementation of all BIFs so that they\nwould produce complete error information in the stacktrace when they\nfailed.  However, as mentioned earlier, building Erlang terms in C is\ntedious and error prone.\u003c/p\u003e\n\n\u003cp\u003eWith the approach we have taken to let Erlang code do most of the\nanalysis of the error reason, there is a much lower risk that error\nhandling would crash the application or runtime system.\u003c/p\u003e\n\n\u003ch3\u003eWhy are the the reasons in the \u003ccode\u003eErrorInfoMap\u003c/code\u003e undocumented?\u003c/h3\u003e\n\n\u003cp\u003eThe reason in the \u003ccode\u003eErrorInfoMap\u003c/code\u003e is not meant to be used for\nprogrammatically figure out why an error occurred, but only to be used\nby \u003ccode\u003eModule:format_error/4\u003c/code\u003e to produce a human-readable message.\u003c/p\u003e\n\n\u003cp\u003eAlso, for many BIFs the reason will not have a meaningful\nvalue, as the \u003ccode\u003eModule:format/4\u003c/code\u003e function will produce the messages\nbased solely on the name of the BIF and its arguments.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eAll exceptions from BIFs will now have a \u003ccode\u003eExtraInfo\u003c/code\u003e element (called\n\u003ccode\u003eLocation\u003c/code\u003e in the documentation for OTP 23) in the call-stack back\ntrace (stacktrace) that includes an \u003ccode\u003eerror_info\u003c/code\u003e tuple.  In previous\nreleases the \u003ccode\u003eExtraInfo\u003c/code\u003e element would be an empty list for a failed\nBIF call.\u003c/p\u003e\n\n\u003cp\u003eApplications that explicitly do matching on the stacktrace and do\nassumptions of the layout of the \u003ccode\u003eExtraInfo\u003c/code\u003e element (for example,\nassuming that \u003ccode\u003eLocation\u003c/code\u003e is either an empty list or a list of \u003ccode\u003efile\u003c/code\u003e\nand \u003ccode\u003eline\u003c/code\u003e tuples in a specific order) may need modifications.  Note\nthat such assumptions have never been safe and that the \u003ca href=\"http://erlang.org/doc/reference_manual/errors.html#exceptions\"\u003edocumentation\nfor error handling\u003c/a\u003e strongly discourages developers to rely on\nstacktrace entries for purposes other than debugging.\u003c/p\u003e\n\n\u003ch1\u003eImplementation\u003c/h1\u003e\n\n\u003cp\u003eThe reference implementation includes extended error information for\nmost BIFs implemented in C in the \u003ccode\u003eerlang\u003c/code\u003e and \u003ccode\u003eets\u003c/code\u003e modules.\nIt can be found in \u003ca href=\"https://github.com/erlang/otp/pull/2849\"\u003ePR #2849\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0054"},"buildId":"ob9V3f7Iet6syJeg0QYgd","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_buildManifest.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_ssgManifest.js" async=""></script></body></html>