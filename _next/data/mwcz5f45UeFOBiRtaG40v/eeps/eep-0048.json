{"pageProps":{"index":{"id":"0048","content":"<pre><code>Author: Jos√© Valim &lt;jose(dot)valim(at)gmail(dot)com&gt;, Eric Bailey, Radek Szymczyszyn\nStatus: Draft\nType: Standards Track\nCreated: 04-Jan-2018\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 48: <a href=\"eep-0048.md\" title=\"EEP Source\"> Documentation storage and format</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP proposes an official API documentation storage to be used by\nby BEAM languages.  By standardizing how API documentation is stored,\nit will be possible to write tools that work across languages.</p>\n\n<h1>Rationale</h1>\n\n<p>Currently, different programming languages and libraries running on\nBEAM devise their own schemas for storing and accessing documentation. <br />\nFor example, Elixir and LFE provide a <code>h</code> helper in their shell that\ncan print the documentation of any module:</p>\n\n<pre><code>iex&gt; h String\nA String in Elixir is a UTF-8 encoded binary.\n</code></pre>\n\n<p>However, Elixir is only able to show docs for Elixir modules.  LFE is\nonly able to show docs for LFE functions and so on.  If documentation\nis standardized, such features can be easily added to other languages\nin a way that works consistently across all BEAM languages.</p>\n\n<p>Furthermore, each language ends up building their own tools for\ngenerating, processing and converting documentation.  We hope a unified\napproach to documentation will improve the compatibility between tools.\nFor instance, an Erlang IDE will be able to show inline documentation\nfor any module and function, regardless if the function is part of OTP,\na library or even written in Elixir, LFE or Alpaca.</p>\n\n<p><strong>Note</strong>: in this document, the word \"documentation\" refers exclusively\nto the API documentation of modules and functions.  Guides, tutorials\nand others materials are also essential to projects but not the focus\nof this EEP.</p>\n\n<p><strong>Note</strong>: This EEP is not about documentation format.  It is about a\nmechanism for storing documentation to make it easier to produce other\nformats.  For example, a tool can read the documentation and produce man\npages from it.</p>\n\n<h1>Specification</h1>\n\n<p>This EEP is divided in three parts.  The first defines the two\nplaces the documentation can be stored, the second defines the shape of\nthe documentation and the third discusses integration with OTP.</p>\n\n<h2>Part 1: the \"Docs\"storage</h2>\n\n<p>There are two main mechanisms in which BEAM languages store documentation:\nin the filesystem (usually in the <code>/doc</code> directory) and inside <code>.beam</code>\nfiles. </p>\n\n<p>This EEP recognizes both options and aim to support both.  To look for\ndocumentation for a module name <code>example</code>, a tool should:</p>\n\n<ol>\n<li><p>Look for <code>example.beam</code> in the code path, parse the BEAM file and\n retrieve the <code>Docs</code> chunk</p></li>\n<li><p>If the chunk is not available, it should look for \"example.beam\"\n in the code path and find the <code>doc/chunks/example.chunk</code> file in\n the application that defines the <code>example</code> module</p></li>\n<li><p>If a <code>.chunk</code> file is not available, then documentation is not\n available</p></li>\n</ol>\n\n<p>The choice of using a chunk or the filesystem is completely up to the\nlanguage or library.  In both cases, the documentation can be added or\nremoved at any moment by stripping the <code>Docs</code> chunk or by removing the\n<code>doc/chunks</code> directory.</p>\n\n<p>For example, languages like Elixir and LFE attach the <code>Docs</code> chunk at\ncompilation time, which can be controlled via a compiler flag.  On the\nother hand, projects like OTP itself will likely generate the <code>doc/chunks</code>\nentries on a separate command, completely unrelated from code compilation.</p>\n\n<h2>Part 2: the \"Docs\" format</h2>\n\n<p>In both storages, the documentation is written in the exactly same\nformat: an Erlang term serialized to binary via <code>term_to_binary/1</code>.\nThe term may be optionally compressed when serialized and must follow\nthe type specification below:</p>\n\n<pre><code>{docs_v1,\n Anno :: erl_anno:anno(),\n BeamLanguage :: atom(),\n Format :: mime_type(),\n ModuleDoc :: #{optional(DocLanguage) := DocValue} | none | hidden,\n Metadata :: map(),\n Docs ::\n   [{{Kind, Name, Arity},\n     Anno :: erl_anno:anno(),\n     Signature :: [binary()],\n     Doc :: #{optional(DocLanguage) := DocValue} | none | hidden,\n     Metadata :: map()\n    }]} when DocLanguage :: binary(),\n             DocValue :: binary() | term()\n</code></pre>\n\n<p>where in the root tuple we have:</p>\n\n<ul>\n<li><p><code>Anno</code> - annotation (line, column, file) of the definition itself\n(see <code>erl_anno</code>)</p></li>\n<li><p><code>BeamLanguage</code> - an atom representing the language, for example:\n<code>erlang</code>, <code>elixir</code>, <code>lfe</code>, <code>alpaca</code>, etc</p></li>\n<li><p><code>Format</code> - the mime type of the documentation, such as \"text/markdown\"\nor \"application/erlang+html\" (see the FAQ for a discussion on this field)</p></li>\n<li><p><code>ModuleDoc</code> - a map with the documentation language as key, such as\n<code>&lt;&lt;\"en\"&gt;&gt;</code> or <code>&lt;&lt;\"pt_BR\"&gt;&gt;</code>, and the documentation as a binary value.\nIt may be the atom <code>none</code> in case there is no documentation or the\natom <code>hidden</code> if documentation has been explicitly disabled for this\nentry</p></li>\n<li><p><code>Metadata</code> - a map of atom keys with any term as value.  This can be\nused to add annotations like the \"authors\" of a module, \"deprecated\",\nor anything else a language or documentation tool may find relevant</p></li>\n<li><p><code>Docs</code> - a list of documentation for other entities (such as\nfunctions and types) in the module</p></li>\n</ul>\n\n<p>For each entry in <code>Docs</code>, we have:</p>\n\n<ul>\n<li><p><code>{Kind, Name, Arity}</code> - the kind, name and arity identifying the\nfunction, callback, type, etc.  The official entities are: <code>function</code>,\n<code>type</code> and <code>callback</code>.  Other languages will add their own. For\ninstance, Elixir and LFE may add <code>macro</code></p></li>\n<li><p><code>Anno</code> - annotation (line, column, file) of the module documentation\nor of the definition itself (see erl_anno)</p></li>\n<li><p><code>Signature</code> - the signature of the entity.  It is is a list of\nbinaries. Each entry represents a binary in the signature that can\nbe joined with a whitespace or a newline.  For example,\n<code>[\"binary_to_atom(Binary, Encoding)\", \"when is_binary(Binary)\"]</code>\nmay be rendered as as a single line or two lines. It exists\nexclusively for exhibition purposes</p></li>\n<li><p><code>Doc</code> - a map with the documentation language as key, such as\n<code>&lt;&lt;\"en\"&gt;&gt;</code> or <code>&lt;&lt;\"pt_BR\"&gt;&gt;</code>, and the documentation as a value.\nThe documentation may either be a binary or any Erlang term,\nboth described by <code>Format</code>. If it is an Erlang term, then the\n<code>Format</code> must be \"application/erlang+SUFFIX\", such as\n\"application/erlang+html\" when the documentation is an Erlang\nrepresentation of an HTML document. The <code>Doc</code> may also be the\natom <code>none</code> in case there is no documentation or the atom <code>hidden</code>\nif documentation has been explicitly disabled for this entry</p></li>\n<li><p><code>Metadata</code> - a map of atom keys with any term as value</p></li>\n</ul>\n\n<blockquote>\n  <p>Note: the documentation map can be empty. In this case, a reference\nto said function was added to the documentation index, making it\neffectively public, but no documentation was written.</p>\n</blockquote>\n\n<p>This shared format is the heart of the EEP as it is what effectively\nallows cross-language collaboration.</p>\n\n<p>The <code>Metadata</code> field exists to allow languages, tools and libraries to\nadd custom information to each entry.  This EEP documents the\nfollowing metadata keys:</p>\n\n<ul>\n<li><p><code>authors := [binary()]</code> - a list of authors as binaries</p></li>\n<li><p><code>cross_references := [module() | {module(), {Kind, Name, Arity}}]</code> -\na list of modules or module entries that can be used as cross\nreferences when generating documentation</p></li>\n<li><p><code>deprecated := binary()</code> - when present, it means the current entry\nis deprecated with a binary that represents the reason for\ndeprecation and a recommendation to replace the deprecated code</p></li>\n<li><p><code>since := binary()</code> - a binary representing the version such entry\nwas added, such as <code>&lt;&lt;\"1.3.0\"&gt;&gt;</code> or <code>&lt;&lt;\"20.0\"&gt;&gt;</code></p></li>\n<li><p><code>edit_url := binary()</code> - a binary representing a URL to change to\nchange the documentation itself</p></li>\n</ul>\n\n<p>Any key may be added to Metadata at any time.  Keys that are frequently\nused by the community can be standardized in future versions. </p>\n\n<h2>Part 3: Integration with OTP</h2>\n\n<p>The last part focuses on integrating the previous parts with OTP docs,\ntools and workflows.  The items below are suggestions and are not\nnecessary for the adoption of this EEP, neither by OTP nor by any other\nlanguage or library.</p>\n\n<p>At this point we should consider changes to OTP such as:</p>\n\n<ul>\n<li><p>Distributing the <code>doc/chunks/*.chunk</code> files as part of OTP and\nchanging the tools that ship with OTP to rely on them. For example,\n<code>erl -man lists</code> could be changed to locate the <code>lists.chunk</code> file,\nparsing the documentation out and then converting it to a man page\non the fly.  This task may require multiple changes, as OTP stores\ndocumentation on XML files as well as directly in the source code.\n<code>edoc</code> itself should likely be augmented with functions that spit\nout <code>.chunk</code> files from the source code</p></li>\n<li><p>Adding <code>h(Module)</code>, <code>h(Module, Function, Arity)</code>, and similar to\nErlang's shell to print the documentation of a module or of a\ngiven function and arity. This should be able to print docs any\nother library or language that implements this proposal</p></li>\n</ul>\n\n<h1>FAQ</h1>\n\n<p><em>Q: Why do we have a Format entry in the documentation?</em></p>\n\n<p>The main trade-off in the proposal is the documentation format.  We have\ntwo options:</p>\n\n<ul>\n<li>Allow each language/library/tool to choose their own documentation\nformat</li>\n<li>Impose a unified documentation format on all languages</li>\n</ul>\n\n<p>A unified format for documentation gives no flexibility to languages and\nlibraries in choosing how documentation is written.  As the ecosystem\ngets more diverse, it will be unlikely to find a format that suits all.\nFor this reason we introduced a Format field that allows each language\nand library to pick their documentation format.  The downside is that,\nif the Elixir docs are written in Markdown and a language does not know\nhow to format Markdown, then the language will have to choose to either\nnot show the Elixir docs or show them raw (i.e. in Markdown).</p>\n\n<p>Erlang is in a privileged position.  All languages will be able to\nsupport whatever format is chosen for Erlang since all languages run on\nErlang and will have direct access to Erlang's tooling.</p>\n\n<p><em>Q: If I have an Erlang/Elixir/LFE/Alpaca library that uses a custom\ndocumentation toolkit, will I also be able to leverage this?</em></p>\n\n<p>As long as the documentation ends up up in the <code>Docs</code> chunk or inside\nthe <code>doc/chunks</code> directory, we absolutely do not care how the\ndocumentation was originally written.  If you use a custom format,\nyou may need to teach your language of choice how to render it though.\nSee the previous question.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}