{"pageProps":{"item":{"id":"My-OTP-21-Highlights","title":"My OTP 21 Highlights","author":"Lukas Larsson","excerpt":"\nOTP-21 Release Candidate 1 has just been released. I thought that I would go\nthrough the changes that I am the most excited about. Most likely this will\nmostly mean features in erts and the core libraries as those are the\nchanges that I am the most familiar with.","article_date":1525219200000,"tags":["otp","21","release"],"frontmatter":{"layout":"post","title":"My OTP 21 Highlights","tags":"otp 21 release","author":"Lukas Larsson"},"content":"\nOTP-21 Release Candidate 1 has just been released. I thought that I would go\nthrough the changes that I am the most excited about. Most likely this will\nmostly mean features in erts and the core libraries as those are the\nchanges that I am the most familiar with.\n\nYou can download the readme describing the changes here: [OTP 21-RC1 Readme](http://erlang.org/download/otp_src_21.0-rc1.readme).\nOr, as always, look at the release notes of the application you are interested in.\nFor instance here: [OTP 21-RC1 Erts Release Notes](http://erlang.org/doc/apps/erts/notes.html).\n\n# Compiler / Interpreter #\n\nBjörn Gustavsson has been doing a lot of work with the compiler and interpreter\nthe last year while I have been sitting next to him cheering. The largest changes\nis part of the OTP-14626 ticket. While working on the\n[BEAMJIT](https://www.youtube.com/watch?v=PtgD5WRzcy4) development\nI've been looking a lot at the [luajit](http://luajit.org/) project and what\nMike Pall has done both in the JIT but also in the interpreter. Inspired by\nthis and some other ideas that we got from the BEAMJIT project we decided it was time\nto do a major overhaul of the way that the BEAM interpreter is created. Most of the\nchanges done boil down to decreasing the size of beam code in memory, thus making more\ncode fit in the L1/L3 caches and in extension making code run faster. We've\ndecreased the loaded code size by about 20% using our optimizations. This has\ntranslated to about a 5% performance increase for most Erlang code\nwhich is quite amazing. Me or Björn will most likely write more about exactly\nwhat this has entailed in a future blogpost.\n\nAnother compiler change that has had quite a large impact (at least in our benchmarks)\nis OTP-14505 contributed by José Valim in [PR 1080](http://github.com/erlang/otp/pull/1080).\nThe change makes the compiler re-write:\n\n    example({ok, Val}) -> {ok, Val}.\n\nto\n\n    example({ok, Val} = Tuple) -> Tuple.\n\neliminating the extra creation of the tuple. As it turns out this is a quite\ncommon pattern in Erlang code so this will be good for all programs.\n\nAn example of this performance gain can be seen in the estone benchmarks SUITE\nbelow. OTP-14626 together with some other compiler and erts improvements have\nincreased the number of stones from 370000 in OTP-20.3 (the green line), to\n400000 in OTP-21 (the blue line). So about 7.5%.\n\n![Estone OTP-21 benchmark](../images/estone_otp21_benchmark.png)\n\n# Erlang run-time system #\n\nThere are many changes in the run-time system.\n\n## File handling ##\n\nAll file IO has traditionally been handled through a port. In OTP-21 all of the\nfile IO has been rewritten to use nifs instead, OTP-14256. This was mainly done\nin order to run file operation in the dirty IO schedulers. It also had the nice\nside-effect of significantly increasing throughput of certain operations.\n\n![File tiny reads OTP-21 benchmark](../images/file_tiny_reads_otp21_benchmark.png)\n\nFor instance in the tiny reads benchmark OTP-21 (the blue line) is about 2.8 times\nfaster than OTP-20.3 (the green line).\n\nAlso it is now possible to open device files using file:open, see OTP-11462.\n\n## I/O Polling ##\n\nThe entire underlying mechanism for checking for I/O on sockets has been rewritten\nand optimized for modern OS kernel polling features. See OTP-14346 and\n[I/O polling options in OTP 21]({{ site.baseurl }}/IO-Polling) for more details.\n\n## Distribution ##\n\nIt has always been possible to write your own distribution carrier if you want\nto if, for instance, you wanted to use [RFC-2549](https://tools.ietf.org/html/rfc2549)\nto send your distributed Erlang messages. However you have had to implement it as\na linked-in driver. With the introduction of OTP-14459 you can now use a process\nor port as the distribution carrier. So now you can use gen_pigeon instead of having\nto call the boost equivalent.\n\nThe ability to use processes as distribution carriers is now used by the TLS\ndistribution. This allows us to not have to jump through several hoops as was done\nbefore increasing the throughput of TLS distribution significantly.\n\n## Process signals ##\n\nWhen running benchmarks using cowboy and hammering it with connections that\ndo not use keep-alive, one of the SMP scalability bottlenecks that pop up\nis the link lock of the supervisor that supervises all the connections.\nThe reason why this lock pops up is because when you have a lot of linked\nprocesses, the rb-tree in which the links are stored becomes very large so\nthe insertion and deletion time increases. In OTP-14589 this has been\nchanged so that all link and monitor requests now are sent as messages\nfor the receiving process to take care of. This means that the lock has been\ncompletely removed. Now all signals (be they messages, links, monitors,\nprocess\\_info, group\\_leader etc) are handled through the same queue.\n\nIn addition, OTP-14901 now makes it so that monitor + send signals\nare merged into one signal. So the contention is reduced even further\nfor gen_server:call like functions.\n\n![GenStress OTP-21 benchmark](../images/genstress_otp21_benchmark.png)\n\nThe performance difference is quite significant. The genstress benchmark\nseen above OTP-21 (the blue line) has almost doubled in throughput\ncompared to OTP-20.3 (the green line).\n\n# Logger\n\nOTP-13295 adds a completely new logging framework for Erlang/OTP. It is\ninspired by the way that [lager](https://github.com/erlang-lager/lager),\nthe [Elixir Logger](https://hexdocs.pm/logger/Logger.html) and the [Python\nlogger](https://docs.python.org/3/howto/logging.html) works.\nWith logger the logging handlers can intercept the logging\ncall in the process that does the actual call instead of having to\nwait for a message. This opens up all sorts of possibilities of early\nrejection of log messages in case of an overload, see [Logger User's Guide](http://erlang.org/documentation/doc-10.0-rc1/lib/kernel-6.0/doc/html/logger_chapter.html#protecting-the-handler-from-overload)\nfor more details. The user can also add special purpose filters that are run\nbefore the handler is invoked in order to silence or amend log messages in the system.\n\n# Misc\n\nHiPE has finally been fixed by Magnus Lång to use the receive reference optimization\nthat beam has had for a long time, OTP-14785.\n\nThe ftp and tfpt parts of inets have been separated into their own applications\ninstead of being bundled, OTP-14113.\n\nThe rand module has seen a lot of work, adding new features. I'm not sure when or\nhow the difference is useful, but the theory around this is fascinating, OTP-13764.\n\nThe maps module now has an maps:iterator/0 and maps:next/1, OTP-14012.\n\nio_lib:format/3 has been added to limit the output of the functions. This is especially\nuseful when building logging frameworks as you may get arbitrarily large terms to\nformat and may want to cut them in order to not overwhelm the system, OTP-14983.\n\nAs a final note, I'm not sure if anyone noticed, but as of OTP-20.3, processes that\nare in the state GARBING when your system crashes now have stack traces in the\ncrash dump!!!\n"}},"__N_SSG":true}