<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/ssa-history/">SSA History</a></h3><p><em>Friday, 28 September 2018<!-- --> - <!-- -->Bj√∂rn Gustavsson</em></p><p>This blog post looks back on the development of
the <a href="https://github.com/erlang/otp/pull/1935">SSA-based intermediate representation</a>
from the beginning of this year to the end
of August when the branch was merged.</p><h2>January 2018</h2><p>In January this year we realized that we have reached
the limit of the optimizations that we could do working
on BEAM code.</p><p><a href="https://github.com/jhogberg">John</a> had finished the work on extending <a href="https://github.com/erlang/otp/blob/2e40d8d1c51ad1c3d3750490ecac6b290233f085/lib/compiler/src/beam_bsm.erl"><code>beam_bsm</code></a>
(a pass that attempts to <a href="http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries">delay creation of sub
binaries</a>). The extended <code>beam_bsm</code> pass could apply the
optimization in a few more cases than it could before, but the amount
of code in <code>beam_bsm</code> to achieve that modest improvement of the
optimization was insane.</p><p>John, <a href="https://github.com/garazdawi">Lukas</a>, and I discussed what we should do about
it. Clearly, we needed a better intermediate format. But what should
it be? Could we use the existing BEAM code but with variables instead of
BEAM registers and do register allocation later? That would solve
some of the problems but not all of them. The irregular nature of
BEAM instructions makes it cumbersome to traverse and analyze
BEAM code.</p><p>So we decided to do like most modern compilers and use an <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a>-based
intermediate format.</p><h3>Rewrites are scary!</h3><p>Introducing a new intermediate format would require rewriting at
least some parts of the compiler. The problem with rewrites is
that they always take longer time than expected and that they often
get abandoned before they are finished.</p><p>To increase the odds that this rewrite would be successful, we come
up with this plan to do the minimum amount of work to get something working
as soon as possible:</p><ol><li><p>Write a new pass that translates from <a href="http://blog.erlang.org/beam-compiler-history#r6b-enter-kernel-erlang">Kernel Erlang</a> to SSA code.</p></li><li><p>Write a new pass that translates from SSA code to BEAM code.</p></li><li><p>Keep all existing optimization passes.</p></li><li><p>Rewrite the optimization passes one at a time.</p></li></ol><p>It didn&#x27;t quite work out according to the plan, as will soon be evident.</p><h2>February 2018</h2><p>I made the first the commit February 1 this year.</p><h3>beam_kernel_to_ssa</h3><p>The first pass I wrote was the translator from Kernel Erlang to SSA code.
We named it <code>beam_kernel_to_ssa</code>.</p><p>My first thought was to write the pass from scratch, as opposed to
base it on <code>v3_codegen</code>. After all, there are fundamental differences
between BEAM code and SSA code. BEAM code is a flat list of instructions.
SSA code consists of blocks of numbered blocks stored in a map, and there
are also the phi nodes.</p><p>On the other hand, the input for both <code>v3_codegen</code> and
<code>beam_kernel_to_ssa</code> was Kernel Erlang. There was nothing wrong with
the code that handled the Kernel Erlang records and I didn&#x27;t want to
rewrite that code from scratch.  Instead, I rewrote the part of the
code that produced a list of BEAM instructions to produce a list of
SSA instructions.  I then wrote a simple pass (about 100 lines of
code) that <a href="https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/src/beam_kernel_to_ssa.erl#L1231">packaged the SSA instructions into blocks and added the
phi nodes</a>.</p><h3>Testing beam_kernel_to_ssa</h3><p>I prefer to test the code I write a soon as possible after writing it.
It is much easier to find and fix bugs in code that has been recently
written.</p><p>How can one test <code>beam_kernel_to_ssa</code> before the code generator for
BEAM code has been written?</p><p>One cannot, not completely, but there are ways to find major problems.</p><p>One such way is <a href="https://en.wikipedia.org/wiki/Smoke_testing_(software)">smoke testing</a>. I modified
the compiler so that it would first run <code>beam_kernel_to_ssa</code> but
discard its output, then run <code>v3_codegen</code> and the rest of the compiler
passes. That allowed me to run the entire compiler test suite, and
if the <code>beam_kernel_to_ssa</code> pass crashed, I&#x27;ve had found a bug.</p><p>Another way was to write a validator or linter of the SSA code.
<a href="https://github.com/jhogberg">John</a> wrote the <code>beam_ssa_lint</code> pass (actually called
<code>beam_ssa_validator</code> at that time and later renamed), which would
verify that a variable was only defined once, that variables were
defined before they were used, that labels in terminators and phi
nodes referred to defined blocks, and so on. It helped me find a
few bugs.</p><p><a href="http://erlang.org/doc/apps/dialyzer/index.html">Dialyzer</a> also helped me find some bugs. I made sure
that I added types for all fields in all new records and
specifications for all exported functions. Dialyzer pointed out
some bugs when I ran it and thinking about the types when writing
the <code>-type</code> declarations was also useful.</p><h3>Finishing beam_kernel_to_ssa</h3><p>I am not sure exactly how long time I spent on the initial
implementation of <code>beam_kernel_to_ssa</code>, but it was probably less
than two weeks. There were a few snags along the way, most of
them bugs in <code>v3_kernel</code> that did not cause any problems
with the old <code>v3_codegen</code>.</p><p>Here is an example. I chose to fix it in OTP 21 even though it was
harmless in that release:</p><p><a href="https://github.com/erlang/otp/commit/c896f08f5c028b1e31290e6a5502597401acd39f">v3_kernel: Stop ensuring one return value in #k_try{}</a></p><h3>beam_ssa_pre_codegen</h3><p>Next up was the translation from SSA code to BEAM code.</p><p>I have already decided that the translation was sufficiently complicated
that to better be split into two major passes.</p><p>The first pass of those passes,
<a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl"><code>beam_ssa_pre_codegen</code></a>, would work on the SSA
code, rewriting it, and adding annotations for another pass that would
generate the BEAM code, but the output would still be valid SSA code
so that <code>ssa_lint</code> could be used to validate the output. The pretty-printed
SSA code also includes the annotations to facilitate debugging.</p><p>The <code>dprecg</code> option can be used to produce a pretty-printed listing of
the SSA code. The following command will create the file <code>blog.precodegen</code>:</p><pre><code>erlc +dprecg blog.erl</code></pre><p>The next section will dig deeper into the workings of <code>beam_ssa_pre_codegen</code>.
On a first reading, you might want to skip that section and jump ahead to
the section about <a href="#beam_ssa_codegen">beam_ssa_codegen</a>.</p><h3>Digging deeper in beam_ssa_pre_codegen</h3><p>To provide some context for the description of <code>beam_ssa_pre_codegen</code>,
we will first look at some BEAM code and talk about stack frames and
Y registers.</p><p>Here is the example in Erlang:</p><pre><code class="language-erlang">foo(C, L) -&gt;
    Sum = lists:sum(L),
    C + Sum.</code></pre><p>The BEAM code looks like this:</p><pre><code>{allocate,1,2}.
{move,{x,0},{y,0}}.
{move,{x,1},{x,0}}.
{line,[{location,&quot;blog.erl&quot;,5}]}.
{call_ext,1,{extfunc,lists,sum,1}}.
{line,[{location,&quot;blog.erl&quot;,6}]}.
{gc_bif,&#x27;+&#x27;,{f,0},1,[{y,0},{x,0}],{x,0}}.
{deallocate,1}.
return.</code></pre><p>As usual, we will walk through the code one or a few lines at a time.</p><pre><code>{allocate,1,2}.</code></pre><p>The <code>allocate</code> instruction allocates a stack frame. The <code>1</code> operand
means that there should be room for one slot in the stack frame for
storing one value.  The slots in the stack frame are called <em>Y
registers</em>.</p><p>The <code>2</code> operand means that two X registers (<code>{x,0}</code> and <code>{x,1}</code>) are
live and must be preserved if <code>allocate</code> needs to do a garbage
collection in order to allocate space for the stack frame.</p><pre><code>{move,{x,0},{y,0}}.</code></pre><p>The <code>C</code> argument for <code>foo/2</code> is in <code>{x,0}</code>. The <code>move</code> instruction
copies the value of <code>{x,0}</code> to <code>{y,0}</code>, which is the zeroth slot
in the stack frame. The reason for doing this copy will soon become
clear.</p><pre><code>{move,{x,1},{x,0}}.</code></pre><p>Preparing for the call of <code>lists:sum/1</code>, the value of <code>L</code> in <code>{x,1}</code>
is copied to <code>{x,0}</code>.</p><pre><code>{line,[{location,&quot;blog.erl&quot;,5}]}.
{call_ext,1,{extfunc,lists,sum,1}}.</code></pre><p>Here <code>lists:sum/1</code> is called. The argument is in <code>{x,0}</code>. The result
(the sum of all numbers in the list) is returned in <code>{x,0}</code>. Also,
the contents of all other X registers are destroyed. That means that
any value that is to be used after a function call must be saved to
a Y register.</p><pre><code>{gc_bif,&#x27;+&#x27;,{f,0},1,[{y,0},{x,0}],{x,0}}.</code></pre><p>This instruction calculates the sum of <code>C</code> (in <code>{y,0}</code>) and <code>Sum</code> (in <code>{x,0}</code>),
storing the result in <code>{x,0}</code>.</p><pre><code>{deallocate,1}.</code></pre><p>Preparing to return from the function, the <code>deallocate</code> instruction
removes the stack frame that <code>allocate</code> created.</p><pre><code>return.</code></pre><p><code>return</code> returns from the function. The return value is in <code>{x,0}</code>.</p><p>Here is the SSA code for the function:</p><pre><code>function blog:foo(_0, _1) {
0:
  %% blog.erl:5
  _2 = call remote (literal lists):(literal sum)/1, _1

  %% blog.erl:5
  _3 = bif:&#x27;+&#x27; _0, _2
  @ssa_bool = succeeded _3
  br @ssa_bool, label 3, label 1

3:
  ret _3

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}</code></pre><p>After running <code>beam_ssa_pre_codegen</code>, the SSA code looks like this:</p><pre><code>function blog:foo(x0/_0, x1/_1) {
  %% _0: 0..1
  %% _1: 0..1 0..3
%% #{frame_size =&gt; 1,yregs =&gt; [0]}
0:
  %% _0:4: 1..5
  [1] y0/_0:4 = copy x0/_0

  %% blog.erl:5
  %% _2: 3..5
  [3] x0/_2 = call remote (literal lists):(literal sum)/1, x1/_1

  %% blog.erl:5
  %% _3: 5..11
  [5] x0/_3 = bif:&#x27;+&#x27; y0/_0:4, x0/_2

  %% @ssa_bool: 7..9
  [7] z0/@ssa_bool = succeeded x0/_3
  [9] br z0/@ssa_bool, label 3, label 1

3:
  [11] ret x0/_3

1:
  %% @ssa_ret: 13..15
  [13] x0/@ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  [15] ret x0/@ssa_ret
}</code></pre><p>We will describe what the important (for this example) sub passes of
<code>beam_ssa_pre_codegen</code> do, and point to the relevant part of code while
doing so.</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L715">place_frames</a> determines where stack frames should be allocated.
In the example, block 0 needs a stack frame.</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1114">find_yregs</a> determines which variables that are to be
placed in Y registers. The result will be a <code>yregs</code> annotation added
to each block that allocates a stack frame. For this example, the
annotation will look like:</p>&lt;pre class=&quot;highlight&quot;&gt;
    %% #{frame_size =&gt; 1,&lt;b&gt;yregs =&gt; [0]&lt;/b&gt;}
&lt;/pre&gt;<p>Variable <code>_0</code> is <code>C</code> from the Erlang code. It needs to be saved across the
call to <code>lists:sum/1</code>.</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1645">reserve_yregs</a> uses the <code>yregs</code> annotations and inserts <code>copy</code> instructions
to copy each variable that needs saving to a new variable. For the example,
the following instruction will be added</p><pre><code>  [1] y0/_0:4 = copy x0/_0</code></pre><p>It copies the value of <code>_0</code> to <code>_0:4</code>.</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1487">number_instructions</a> numbers all instructions as a preparation for register
allocation. In the listing, those numbers are in brackets before each instruction:
<code>[1]</code>, <code>[3]</code>, <code>[5]</code>, and so on.</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1515">live_intervals</a> calculates the intervals in which each variable is live.
In the listing, the live intervals are shown as comments before the definition
of the variable:</p><pre><code>  %% _0:4: 1..5
  [1] y0/_0:4 = copy x0/_0</code></pre><p>The variable <code>_0:4</code> is live from instruction <code>[1]</code> (its definition) to
<code>[5]</code> (its last use).</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118">linear_scan</a> uses the <a href="http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf">linear scan</a> algorithm
to allocate registers for each variable. The result is saved as annotation
for the function. In the listing of the SSA code, the register will be added
to the definition and each use of a variable. For example:</p><pre><code>  [1] y0/_0:4 = copy x0/_0</code></pre><p>Variable <code>_0</code> (the argument <code>L</code>) is in <code>{x,0}</code>. Its copy in <code>_0:4</code> is in
<code>{y,0}</code>.</p><p>But what is <code>z0</code>?</p>&lt;pre class=&quot;highlight&quot;&gt;
      [7] &lt;b&gt;z0&lt;/b&gt;/@ssa_bool = succeeded x0/_3
      [9] br &lt;b&gt;z0&lt;/b&gt;/@ssa_bool, label 3, label 1
&lt;/pre&gt;<p><code>succeeded</code> is not a BEAM instruction. It will be combined with the previous
instruction (<code>bif:+</code> in this example) and the <code>br</code> instruction that follows it
to the following BEAM instruction:</p><pre><code>{gc_bif,&#x27;+&#x27;,{f,0},1,[{y,0},{x,0}],{x,0}}.</code></pre><p>Thus, the value <code>@ssa_bool</code> is never explicitly stored in a BEAM
register.  Before I invented Z registers, <code>@ssa_bool</code> would have been
assigned to an X register.  That worked most of the time, but sometimes
an X register would seem to be occupied when it was not, and prevent
another instruction from using that register.</p><p>Here are the <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L52">references that I used when implementing linear scan</a>.</p><p>The sub pass <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1741">frame_size</a> uses the information from the linear scan pass to calculate the size
of each stack frame. The result is stored as an annotation:</p>&lt;pre class=&quot;highlight&quot;&gt;
    %% #{&lt;b&gt;frame_size =&gt; 1&lt;/b&gt;,yregs =&gt; [0]}
&lt;/pre&gt;<h3>beam_ssa_codegen</h3><p>The <a href="https://github.com/erlang/otp/blob/ec1f35c9f52be894ba295b9a48237020855e3c46/lib/compiler/src/beam_ssa_codegen.erl"><code>beam_ssa_codegen</code></a> pass generates BEAM code
from the annotated SSA code. Testing of this pass was easier, because
I could compile some sample code and try to run it.</p><p>Often I did not even have to run the code to know that it was wrong.
The compiler would tell me, loudly:</p><p>{% raw %}</p><pre><code>blog: function bar/2+4:
  Internal consistency check failed - please report this bug.
  Instruction: {test_heap,2,3}
  Error:       {{x,2},not_live}:</code></pre><p>{% endraw %}</p><p>It&#x27;s time to introduce the <code>beam_validator</code> pass.</p><h4>beam_validator</h4><p>The <a href="https://github.com/erlang/otp/blob/e2a939dc4d23d75a0588722d0a08aef129b4c0be/lib/compiler/src/beam_validator.erl"><code>beam_validator</code></a> pass was introduced in one of
the R10B releases (probably in 2006). It is run directly before the
BEAM code is packaged into a binary and written to a BEAM file. The
purpose of <code>beam_validator</code> is to find unsafe instructions that
could crash the runtime system or cause it to misbehave in other
ways.</p><p>Let&#x27;s look at a simple example:</p><pre><code class="language-erlang">bar(H, T) -&gt;
    [H|T].</code></pre><p>Here is the BEAM code, but edited by me to contain an unsafe instruction:</p>&lt;pre class=&quot;highlight&quot;&gt;
      {label,4}.
        {test_heap,2,&lt;b&gt;3&lt;/b&gt;}.
        {put_list,{x,0},{x,1},{x,0}}.
        return.
&lt;/pre&gt;<p>The number of live registers is here given as <code>3</code> instead of <code>2</code>.
That means that <code>{x,0}</code>, <code>{x,1}</code>, and <code>{x,2}</code> are supposed to contain
valid Erlang terms. Because <code>bar/2</code> is only called with two arguments,
<code>{x,2}</code> can contain any old garbage.</p><p>When running this code, it could crash the runtime system, or it could
be completely harmless. It depends on whether there will be a garbage
collection during execution of the <code>test_heap</code> instruction, and on the
exact nature of the garbage in <code>{x,2}</code>. For example, if the garbage
happens to be an atom nothing bad will happen. That means that this
type of compiler bug is difficult to reliably catch in a test case.</p><p><code>beam_validator</code> will find this bug immediately. It keeps track of
which registers are initialized at any point in the function. If it
finds a reference to a register that is not initialized it will
complain:</p><p>{% raw %}</p><pre><code>blog: function bar/2+4:
  Internal consistency check failed - please report this bug.
  Instruction: {test_heap,2,3}
  Error:       {{x,2},not_live}:</code></pre><p>{% endraw %}</p><h4>Friend and foe</h4><p>During the implementation of <code>beam_ssa_codegen</code>, the <code>beam_validator</code>
pass pointed out many bugs for me. It was my friend.</p><p>It was also my foe, sort of. It would complain that some perfectly safe
code was unsafe. When that happened, I had to thoroughly investigate the
code to make doubly sure it was safe, and then extend <code>beam_validator</code>
to make it smarter so that it would understand that the code was safe.</p><p>Here is one example where I had to make <code>beam_validator</code> smarter.
Consider this code:</p><pre><code>{move,{x,0},{y,0}}.
{test,is_map,{f,777},[{x,0}]}.
{put_map_assoc,{f,0},{y,0},...}.</code></pre><p>The <code>move</code> instruction stores a copy of <code>{x,0}</code> in <code>{y,0}</code> (a location
on the stack). The following <code>test</code> instruction tests whether <code>{x,0}</code>
is a map and branches to label 777 if not. The <code>put_map_assoc</code> instruction
updates the map in <code>{y,0}</code>.</p><p>The <code>put_map_assoc</code> instruction will crash if its source argument is
not a map.  Therefore, <code>beam_validator</code> complains if <code>put_map_assoc</code> is
used with a source argument that is not a map. In this example,
<code>beam_validator</code> had not seen a <code>test</code> instruction that ensured that
<code>{y,0}</code> was a map, so it complained. It is obvious (for a human) that
<code>{y,0}</code> is a map because it is a copy of <code>{x,0}</code>, which is a map.</p><p><code>v3_codegen</code> never generated such code; in fact, it explicitly
<a href="https://github.com/erlang/otp/blob/64422fcac9c602641dcf24ef2d35e3491376304d/lib/compiler/src/v3_codegen.erl#L1600">avoided generating such code</a>.
I did not want to add similar kludges to the new code generator, so
<a href="https://github.com/erlang/otp/commit/1f221b27f1336e747f7409692f260055dd3ddf79"><code>beam_validator</code> had to become smarter</a>.</p><h4>Unsafe optimization passes</h4><p>Some of the unsafe code that <code>beam_validator</code> found was really unsafe,
but it was not the fault of my new compiler passes, but of the
optimization passes that optimized the generated BEAM code.</p><p>The problem was that some of the optimization passes had implicit
assumptions of the kind of code that <code>v3_codegen</code> would generate
(or, rather, would <strong>not</strong> generate). The new code generator broke
those assumptions.</p><p>At first, when I saw those bugs, I removed the broken part of the
optimization pass. Making the optimizations safe would be non-trivial
and ultimately wasted work because we intended to rewrite all those
optimization passes to work on SSA code.</p><p>When I have seen a few too many of those unsafe optimizations, <a href="https://github.com/erlang/otp/commit/3fc40fd57fa01b097b4c363860c4d4762e13db8b">I ripped
out all of the unsafe optimization passes</a>.</p><p>That meant that we would have to re-implement all of the optimizations
before the generated code would be as good as the code from the old
compiler. I had also noticed that the new BEAM code generator in a
few ways generated better code than the old one, but in other ways the
code was worse. For example, the generated code used more stack space and
did a lot of register shuffling. Eventually, that had to be addressed in
some way.</p><p>Meanwhile, I had worse problems to worry about.</p><h2>March 2018</h2><p>On March 14 I presented my progress on the new compiler passes for
the OTP team. One of my slides had the following text:</p><blockquote><ul><li>Can compile all modules in OTP (and run many of them correctly)</li></ul></blockquote><p>Yes, I had finished the initial implementation of <code>beam_ssa_codegen</code>
so that I could compile all code in OTP.</p><p>The problem that I only at hinted in the slide was that Erlang could
crash and dump core when running test suites. Not every time, and
never in the same test case twice. It only happened when I have
compiled OTP with the new compiler.</p><p>The crash didn&#x27;t seem related to the test cases themselves, but to the
writing of log files. I soon narrowed it down to that the crash could
happen if <a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/kernel/src/file_io_server.erl"><code>file_io_server</code></a> had been compiled with
the new compiler passes. However, that was not much help. The module
contains complicated code that uses the binary syntax, <code>try</code>/<code>catch</code>,
and <code>receive</code>, all of which are complicated instructions that might
not be correctly translated by the new compiler passes.</p><p><code>beam_validator</code> was supposed to catch those kinds of bugs before
they can cause a crash. Either there was some kind of bug that
<code>beam_validator</code> didn&#x27;t look for, or there was a bug in the
implementation of some of the instructions in the BEAM interpreter.</p><p>I ended up spending the rest of March trying to hunt down that bug.</p><h2>April 2018</h2><p>At the beginning of April, the bug still eluded me. I had narrowed
it down somewhat. I was pretty sure it had something to do with
<code>receive</code>.</p><p>Then <a href="https://github.com/rickard-green">Rickard</a> gave me some information that I could connect to another
piece of information that I had absorbed during my hunt for the bug.</p><h3>The bug</h3><p>This section is somewhat advanced, and if you wish you can
skip to <a href="#the-fix">the fix</a>.</p><p>Reading about the <a href="https://github.com/erlang/otp/blob/OTP-21.0.9/erts/emulator/internal_doc/GarbageCollection.md">Erlang Garbage Collector</a> can give some
background to better understand this section.</p><p>Rickard reminded me about the <code>message_queue_data</code> option that
had been added to <a href="http://erlang.org/doc/man/erlang.html#process_flag-2"><code>process_flag/2</code></a> in OTP 19. After
calling <code>process_flag(message_queue_data, off_heap)</code> all messages
that have not yet been received would be stored outside the process
heap. Storing the messages outside the heap means that the garbage
collector doesn&#x27;t have to spend time copying the unreceived messages
during garbage collection, which can be a huge win for processes that
have many messages in its message queue.</p><p>The implementations details of messages outside the heap are
crucial. Consider this selective <code>receive</code>:</p><pre><code class="language-erlang">receive
    {tagged_message,Message} -&gt; Message
end.</code></pre><p>When the BEAM interpreter executes this code, it will retrieve a
reference message from the external message queue and match it against
the tuple pattern. If the message does not match, the next message
will be processed in the same way, and so on.</p><p>If a message does not match, there <strong>must not</strong> be any remaining
references to it stored on the stack. The reason is that if there is a
garbage collection, the garbage collector will copy the message (or
part of the message) to the heap, and, even worse, it will destroy the
original message during the copy operation. The message is still in
the external message queue, but it has now been corrupted by the
garbage collector. If the message is later matched out in a <code>receive</code>,
it will likely cause a crash.</p><p>When Rickard first implemented off-heap messages, he asked me whether
the compiler could ever store references to unreceived messages
on the stack. I assured him that it could not happen.</p><p>Yes, that was true, it could not happen because of the way
<code>v3_codegen</code> generated the code for <code>receive</code>.</p><p>With the new compiler passes, <a href="https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/test/beam_validator_SUITE_data/receive_stacked.S#L22">it <strong>could</strong> happen</a>. When
I first discussed the bug with Richard in March, he did mention that
it is forbidden to store references to off-heap messages on the
stack. At that time, I was not aware that the compiler could store
references to off-heap messages on the stack.</p><p>When Rickard reminded me about that for the second time in April, I remember
seeing during my bug hunt generated code that stored off-heap message
references on the stack.</p><h3>The fix</h3><p>After finding the reason for the bug, I first taught <code>beam_validator</code>
to <a href="https://github.com/erlang/otp/commit/90853d8e7b50be13a3b71f4a1ed6b0407e1f7c2f">complain about &quot;fragile references&quot; on the stack</a>.
I included that commit in OTP 21.</p><p>I then added a sub pass to <code>beam_ssa_pre_codegen</code> to <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L919">rewrite <code>receive</code></a>.
It introduces new variables and <code>copy</code> instructions to ensure that
any references to the message being matched are kept in X registers.</p><p>With no known bugs in the code generator, I could start rewriting the optimization
passes I had removed.</p><h3>More optimizations</h3><h4>beam_ssa_recv</h4><p><a href="https://github.com/erlang/otp/blob/367f4a3fabb12cda3f2547e9908acbf28cb34e3a/lib/compiler/src/beam_ssa_recv.erl"><code>beam_ssa_recv</code></a> is a replacement for the unsafe
<a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_receive.erl"><code>beam_receive</code></a> pass.  The purpose is to optimize a
<code>receive</code> that can only match a newly created reference.  The
optimization avoids scanning the messages that were placed in the
message queue before the reference was created.</p><p>I actually wrote <code>beam_ssa_recv</code> at the beginning of March as an
experiment to see how easy it would be to write optimizations of SSA code.
It turned out to be pretty easy. <code>beam_ssa_recv</code> can apply the optimization
in more places than <code>beam_receive</code> could, using slightly less code.</p><p>In the old <code>beam_receive</code> pass, a lot of code is needed to handle
the many variants of BEAM instructions. For example, in
<a href="https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/src/beam_receive.erl#L185"><code>opt_update_regs/3</code></a> there are three
clauses just to handle three variants of a <code>call</code> instruction (calling
a local function, calling an external function, and calling a fun).</p><p>Here is an example of a function that <code>beam_receive</code> did not optimize, but
<a href="https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/test/receive_SUITE_data/ref_opt/yes_14.erl"><code>beam_ssa_recv</code> can optimize</a>.</p><h4>beam_ssa_opt</h4><p>The <a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl"><code>beam_ssa_opt</code></a> pass runs a <a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl#L49">number of
optimizations</a>. Many of the optimizations are replacements
for the optimizations I removed earlier.</p><h4>beam_ssa_type</h4><p><a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl"><code>beam_ssa_type</code></a> replaces the unsafe <a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl"><code>beam_type</code></a> pass.</p><p>The <code>beam_type</code> pass did a local type analysis (basically for extended basic blocks),
and tried to simplify the code, for example by removing unnecessary type tests.</p><p>The <code>beam_ssa_type</code> pass analyzes the types in an entire function and
simplifies the code, for example by removing unnecessary type
tests. It finds many more opportunities for optimizations than
<code>beam_type</code> did.</p><h2>May 2018</h2><p>At the beginning of May, <a href="https://github.com/jhogberg">John</a> started working on what was to become
this pull request:</p><p><a href="https://github.com/erlang/otp/pull/1958">#1958: Rewrite BSM optimizations in the new SSA-based intermediate format</a></p><p>I continued to write optimizations and fix bugs that John found while
developing his optimizations.</p><h3>Rethinking the binary matching instructions</h3><p>While working on his binary optimizations, John realized that the SSA
instructions for binary matching were difficult to optimize. The
binary match instructions I had designed were close to the semantics
of the BEAM instructions. John suggested that the <code>bs_get</code> instruction
should be broken up into a <code>bs_match</code> instruction and a <code>bs_extract</code>
instruction to simplify optimizations.</p><p>The breaking up of the instructions meant that <a href="https://github.com/erlang/otp/blob/master/lib/compiler/src/beam_ssa_pre_codegen.erl#L209"><code>beam_ssa_pre_codegen</code>
would have to work harder to combine
them</a>, but it vastly simplified John&#x27;s
optimizations. It turned out that it also enabled other optimizations:
the <a href="https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L777">liveness optimizations</a> could remove unused
instructions more aggressively.</p><p>On the first day of <a href="https://codesync.global/conferences/code-beam-sto-2018/">Code BEAM STO 2018</a> May 31, I didn&#x27;t
know of any bugs in the new compiler passes and my list of optimizations to
re-implement was shrinking steadily. I met <a href="https://github.com/michalmuskala">Micha≈Ç Muska≈Ça</a>
(a frequent contributor to Erlang/OTP and a member of the
<a href="https://elixirforum.com/groups/Elixir-Core-Team">Elixir Core Team</a>) there and told him about my work
on the compiler and that it was stable enough be tested outside OTP,
for example to compile Elixir code...</p><h2>June 2018</h2><h3>Micha≈Ç&#x27;s feedback</h3><p>I received an email from Micha≈Ç in the middle of June. He had tried out
my compiler branch. He wrote:</p><blockquote><p>First impression is that it took a loooong time to compile Elixir&#x27;s unicode module,
so long that I had to shut it down after about 10 minutes.</p></blockquote><p>He sent me an Erlangified version of <a href="https://github.com/elixir-lang/elixir/blob/54cb02c2407856f4063c75a440507dacb6a31dbc/lib/elixir/unicode/unicode.ex">Elixir&#x27;s unicode module</a>.
The size of the Erlang source for the module was almost 82,000 lines or
about 3,700,000 bytes. Based on the size, compilation could be expected to be
a little bit slow, but not that slow. On his computer, OTP 21.0-RC2 finished
the compilation in 16 seconds.</p><p>I compiled the module using the <code>time</code> option. The slowest pass was <code>beam_ssa_type</code>.
After some further profiling, I found the bottleneck in the joining of two maps.
Here is the <a href="https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl#L944">corrected code</a>. The original code didn&#x27;t compare
the size of maps and swap them as needed. I might have done some other improvements,
too. Anyway, that took care of that bottleneck. Now <code>beam_ssa_pre_codegen</code> was the
slowest pass.</p><p>I fixed several bottlenecks in the <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118">linear scan sub pass</a>, and after
that some other bottleneck in <code>beam_ssa_pre_codegen</code>. I think that reduced the
compilation time to well under one minute.</p><h3>Optimizing code generation</h3><p>After having finished the re-implementation of the last optimization
pass (I think it was the <a href="https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L517">optimization of floating point
operations</a>, as previously done by the unsafe
<a href="https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl"><code>beam_type</code></a> pass), I started to compare the code
generated by OTP 21 with code from the new compiler passes.</p><p>I used <a href="https://github.com/erlang/otp/blob/master/scripts/diffable">scripts/diffable</a>, which compiles about 1000
modules from OTP to BEAM code and massages the BEAM code to make it more friendly
for diffing. I then ran <code>diff -u old new</code> to compare the new code to
the old code.</p><p>In the last part of June and the first week of July, I then improved
<code>beam_ssa_pre_codegen</code> and <code>beam_ssa_codegen</code> to address the issues that I
noticed when reading the diff.</p><h4><code>beam_ssa_pre_codegen</code> improvements</h4><p>I did not change the <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118">linear scan</a> sub pass of <code>beam_ssa_pre_codegen</code>
itself. Instead I added transformations of the SSA code that would help
linear scan do a better job of allocating registers.</p><p>The most obvious issue I noticed was unnecessary <code>move</code> instructions.
Here are two of the sub passes I added to address that issue:</p><ul><li><p><a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1916">reserve_xregs</a> gives hints to the linear scan sub pass that a
certain X register should be used for a certain variable, if possible.</p></li><li><p><a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1422">opt_get_list</a> tries to eliminate the extra <code>move</code> instruction that
is frequently added when matching out elements from a list.  See the
comments in the code for an example and an explanation.</p></li></ul><p>Another frequent issue was that the code generated from the new code
generator used more stack space because two variables that were not
strictly live at the same time were allocated different Y registers
(slots on the stack) instead of re-using the same Y register. I addressed
that issue in <a href="https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1222">copy_retval</a>. See the comments in the code for an example.</p><h4><code>beam_ssa_codegen</code> improvements</h4><p>Micha≈Ç noticed that when a value was stored in both an X register and
a Y register (on the stack), instructions using the value would
always use the Y register. The old code generator would use the X
register.  The new code could be slower because the BEAM interpreter
is generally optimized for operands being in X registers.</p><p>I added <a href="https://github.com/erlang/otp/blob/7fbb86c77fa99caddabedfb992f47ddeece80652/lib/compiler/src/beam_ssa_codegen.erl#L359">prefer_xregs</a> to address that issue. See the comments in the code
for examples.</p><h2>July 2018</h2><p>Vacation.</p><h2>August 2018</h2><p>Before I left for vacation, it seemed that the new compiler passes generally
generated code at least as good as the old compiler passes. In some cases,
the code would be much better.</p><p>Back after my vacation, I did some final polishing.</p><p>On Aug 17 I created a <a href="https://github.com/erlang/otp/pull/1935">pull request</a>.</p><p>Before merging the pull request, I sneaked in a few final optimizations.</p><p>On Aug 24 I <a href="https://github.com/erlang/otp/commit/9facb02b91979ef90b47ac0a54d1eb71fdaa1ee1">merged</a> the pull request.</p><h2>The Future</h2><p>The SSA-based intermediate representation provides a solid framework for
future improvements of the compiler. After the merging of the pull request in
August, several pull requests have already added further improvements:</p><ul><li><p><a href="https://github.com/erlang/otp/pull/1947">Introduce a put_tuple2 instruction</a></p></li><li><p><a href="https://github.com/erlang/otp/pull/1955">Replace beam_dead with beam_ssa_dead</a></p></li><li><p><a href="https://github.com/erlang/otp/pull/1958">Rewrite BSM optimizations in the new SSA-based intermediate format</a></p></li><li><p><a href="https://github.com/erlang/otp/pull/1959">Clean up variable-related cruft in new SSA passes</a></p></li><li><p><a href="https://github.com/erlang/otp/pull/1960">beam_validator: Use set_aliased_type in more operations</a></p></li><li><p><a href="https://github.com/erlang/otp/pull/1965">Minor cleanups and bug fixes of the compiler</a></p></li></ul><p>Here is a list of possible further improvements that could be implemented either
by OTP members or external contributors before OTP 22 is released:</p><ul><li><p>Rewrite <code>sys_core_dsetel</code> to be SSA-based.</p></li><li><p>Rewrite the guard optimizing sub pass <code>guard_opt/2</code> in <code>v3_kernel</code>
to an SSA-based optimization pass.</p></li><li><p>Rewrite <code>beam_trim</code>. It would probably have to be a part of <code>beam_ssa_codegen</code>.</p></li><li><p>Optimize <code>switch</code> branches. If two branches jump to blocks
that do the same thing, let both branches jump to the same
block. <code>beam_jump</code> does this kind of optimization, but doing it
earlier in the SSA representation could speed up compilation of functions
with many clauses.</p></li><li><p>Get rid of the <code>beam_utils</code> module, especially the <code>is_killed()</code> and
<code>is_not_used()</code> family of functions. The functions in <code>beam_utils</code>
used by <code>beam_jump</code> could be moved into <code>beam_jump</code>.</p></li><li><p>Rewrite <code>beam_bs</code> to be SSA-based. This rewrite might not improve
the generated code, but it might speed up compilation of modules
with heavy use of the binary syntax.</p></li></ul></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"ssa-history","title":"SSA History","author":"Bj√∂rn Gustavsson","excerpt":"\nThis blog post looks back on the development of\nthe [SSA-based intermediate representation][pr1935]\nfrom the beginning of this year to the end\nof August when the branch was merged.\n\n[place_frames]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L715,\n[find_yregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1114,\n[reserve_yregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1645,\n[number_instructions]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1487,\n[live_intervals]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1515,\n[linear_scan]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118,\n[frame_size]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1741,\n[v3_codegen_kludge]: https://github.com/erlang/otp/blob/64422fcac9c602641dcf24ef2d35e3491376304d/lib/compiler/src/v3_codegen.erl#L1600,\n[file_io_server]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/kernel/src/file_io_server.erl,\n[rickard]: https://github.com/rickard-green,\n[process_flag]: http://erlang.org/doc/man/erlang.html#process_flag-2,\n[lukas_gc]: https://github.com/erlang/otp/blob/OTP-21.0.9/erts/emulator/internal_doc/GarbageCollection.md,\n[bad_receive]: https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/test/beam_validator_SUITE_data/receive_stacked.S#L22,\n[receive_fix]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L919,\n[beam_receive]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_receive.erl,\n[beam_ssa_recv]: https://github.com/erlang/otp/blob/367f4a3fabb12cda3f2547e9908acbf28cb34e3a/lib/compiler/src/beam_ssa_recv.erl,\n[beam_ssa_recv_opt_update_regs]: https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/src/beam_receive.erl#L185,\n[yes_14]: https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/test/receive_SUITE_data/ref_opt/yes_14.erl,\n[beam_ssa_opt]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl,\n[beam_ssa_opt_passes]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl#L49,\n[beam_ssa_type]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl,\n[beam_ssa_pre_codegen_fix_bs]: https://github.com/erlang/otp/blob/master/lib/compiler/src/beam_ssa_pre_codegen.erl#L209,\n[beam_ssa_opt_live]: https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L777,\n[pr1958]: https://github.com/erlang/otp/pull/1958,\n[code_beam_2018]: https://codesync.global/conferences/code-beam-sto-2018/,\n[elixir_core_team]: https://elixirforum.com/groups/Elixir-Core-Team,\n[beam_ssa_type_bottleneck]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl#L944,\n[reserve_xregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1916,\n[copy_retval]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1222,\n[opt_get_list]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1422,\n[prefer_xregs]: https://github.com/erlang/otp/blob/7fbb86c77fa99caddabedfb992f47ddeece80652/lib/compiler/src/beam_ssa_codegen.erl#L359,\n[beam_type]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl,\n[beam_ssa_opt_float]: https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L517,\n[merged_ssa]: https://github.com/erlang/otp/commit/9facb02b91979ef90b47ac0a54d1eb71fdaa1ee1,\n[beam_ssa_pre_codegen]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl,\n[beam_ssa_codegen]: https://github.com/erlang/otp/blob/ec1f35c9f52be894ba295b9a48237020855e3c46/lib/compiler/src/beam_ssa_codegen.erl,\n[beam_validator]: https://github.com/erlang/otp/blob/e2a939dc4d23d75a0588722d0a08aef129b4c0be/lib/compiler/src/beam_validator.erl,\n[v3_kernel_bug]: https://github.com/erlang/otp/commit/c896f08f5c028b1e31290e6a5502597401acd39f,\n[beam_validator_fragile]: https://github.com/erlang/otp/commit/90853d8e7b50be13a3b71f4a1ed6b0407e1f7c2f,\n[unsafe_passes]: https://github.com/erlang/otp/commit/3fc40fd57fa01b097b4c363860c4d4762e13db8b,\n[beam_validator_maps]: https://github.com/erlang/otp/commit/1f221b27f1336e747f7409692f260055dd3ddf79,\n[john]: https://github.com/jhogberg,\n[lukas]: https://github.com/garazdawi,\n[michal]: https://github.com/michalmuskala,\n[elixir_unicode]: https://github.com/elixir-lang/elixir/blob/54cb02c2407856f4063c75a440507dacb6a31dbc/lib/elixir/unicode/unicode.ex,\n[diffable]: https://github.com/erlang/otp/blob/master/scripts/diffable,\n[pr1935]: https://github.com/erlang/otp/pull/1935,\n[bin_matching]: http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries,\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form,\n[kernel]: http://blog.erlang.org/beam-compiler-history#r6b-enter-kernel-erlang,\n[beam_bsm]: https://github.com/erlang/otp/blob/2e40d8d1c51ad1c3d3750490ecac6b290233f085/lib/compiler/src/beam_bsm.erl,\n[software_smoke_testing]: https://en.wikipedia.org/wiki/Smoke_testing_(software),\n[beam_kernel_to_ssa_finalize]: https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/src/beam_kernel_to_ssa.erl#L1231,\n[dialyzer]: http://erlang.org/doc/apps/dialyzer/index.html,\n[linear_scan_polleto]: http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf,\n[linear_scan_references]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L52,\n[pr1947]: https://github.com/erlang/otp/pull/1947,\n[pr1955]: https://github.com/erlang/otp/pull/1955,\n[pr1959]: https://github.com/erlang/otp/pull/1959,\n[pr1960]: https://github.com/erlang/otp/pull/1960,\n[pr1965]: https://github.com/erlang/otp/pull/1965","article_date":1538092800000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"SSA History","tags":"compiler BEAM","author":"Bj√∂rn Gustavsson"},"content":"\nThis blog post looks back on the development of\nthe [SSA-based intermediate representation][pr1935]\nfrom the beginning of this year to the end\nof August when the branch was merged.\n\n## January 2018\n\nIn January this year we realized that we have reached\nthe limit of the optimizations that we could do working\non BEAM code.\n\n[John][john] had finished the work on extending [`beam_bsm`][beam_bsm]\n(a pass that attempts to [delay creation of sub\nbinaries][bin_matching]). The extended `beam_bsm` pass could apply the\noptimization in a few more cases than it could before, but the amount\nof code in `beam_bsm` to achieve that modest improvement of the\noptimization was insane.\n\nJohn, [Lukas][lukas], and I discussed what we should do about\nit. Clearly, we needed a better intermediate format. But what should\nit be? Could we use the existing BEAM code but with variables instead of\nBEAM registers and do register allocation later? That would solve\nsome of the problems but not all of them. The irregular nature of\nBEAM instructions makes it cumbersome to traverse and analyze\nBEAM code.\n\nSo we decided to do like most modern compilers and use an [SSA][ssa]-based\nintermediate format.\n\n### Rewrites are scary!\n\nIntroducing a new intermediate format would require rewriting at\nleast some parts of the compiler. The problem with rewrites is\nthat they always take longer time than expected and that they often\nget abandoned before they are finished.\n\nTo increase the odds that this rewrite would be successful, we come\nup with this plan to do the minimum amount of work to get something working\nas soon as possible:\n\n1. Write a new pass that translates from [Kernel Erlang][kernel] to SSA code.\n\n2. Write a new pass that translates from SSA code to BEAM code.\n\n3. Keep all existing optimization passes.\n\n4. Rewrite the optimization passes one at a time.\n\nIt didn't quite work out according to the plan, as will soon be evident.\n\n## February 2018\n\nI made the first the commit February 1 this year.\n\n### beam_kernel_to_ssa\n\nThe first pass I wrote was the translator from Kernel Erlang to SSA code.\nWe named it `beam_kernel_to_ssa`.\n\nMy first thought was to write the pass from scratch, as opposed to\nbase it on `v3_codegen`. After all, there are fundamental differences\nbetween BEAM code and SSA code. BEAM code is a flat list of instructions.\nSSA code consists of blocks of numbered blocks stored in a map, and there\nare also the phi nodes.\n\nOn the other hand, the input for both `v3_codegen` and\n`beam_kernel_to_ssa` was Kernel Erlang. There was nothing wrong with\nthe code that handled the Kernel Erlang records and I didn't want to\nrewrite that code from scratch.  Instead, I rewrote the part of the\ncode that produced a list of BEAM instructions to produce a list of\nSSA instructions.  I then wrote a simple pass (about 100 lines of\ncode) that [packaged the SSA instructions into blocks and added the\nphi nodes][beam_kernel_to_ssa_finalize].\n\n### Testing beam_kernel_to_ssa\n\nI prefer to test the code I write a soon as possible after writing it.\nIt is much easier to find and fix bugs in code that has been recently\nwritten.\n\nHow can one test `beam_kernel_to_ssa` before the code generator for\nBEAM code has been written?\n\nOne cannot, not completely, but there are ways to find major problems.\n\nOne such way is [smoke testing][software_smoke_testing]. I modified\nthe compiler so that it would first run `beam_kernel_to_ssa` but\ndiscard its output, then run `v3_codegen` and the rest of the compiler\npasses. That allowed me to run the entire compiler test suite, and\nif the `beam_kernel_to_ssa` pass crashed, I've had found a bug.\n\nAnother way was to write a validator or linter of the SSA code.\n[John][john] wrote the `beam_ssa_lint` pass (actually called\n`beam_ssa_validator` at that time and later renamed), which would\nverify that a variable was only defined once, that variables were\ndefined before they were used, that labels in terminators and phi\nnodes referred to defined blocks, and so on. It helped me find a\nfew bugs.\n\n[Dialyzer][dialyzer] also helped me find some bugs. I made sure\nthat I added types for all fields in all new records and\nspecifications for all exported functions. Dialyzer pointed out\nsome bugs when I ran it and thinking about the types when writing\nthe `-type` declarations was also useful.\n\n### Finishing beam_kernel_to_ssa\n\nI am not sure exactly how long time I spent on the initial\nimplementation of `beam_kernel_to_ssa`, but it was probably less\nthan two weeks. There were a few snags along the way, most of\nthem bugs in `v3_kernel` that did not cause any problems\nwith the old `v3_codegen`.\n\nHere is an example. I chose to fix it in OTP 21 even though it was\nharmless in that release:\n\n[v3_kernel: Stop ensuring one return value in #k_try{}][v3_kernel_bug]\n\n### beam_ssa_pre_codegen\n\nNext up was the translation from SSA code to BEAM code.\n\nI have already decided that the translation was sufficiently complicated\nthat to better be split into two major passes.\n\nThe first pass of those passes,\n[`beam_ssa_pre_codegen`][beam_ssa_pre_codegen], would work on the SSA\ncode, rewriting it, and adding annotations for another pass that would\ngenerate the BEAM code, but the output would still be valid SSA code\nso that `ssa_lint` could be used to validate the output. The pretty-printed\nSSA code also includes the annotations to facilitate debugging.\n\nThe `dprecg` option can be used to produce a pretty-printed listing of\nthe SSA code. The following command will create the file `blog.precodegen`:\n\n```\nerlc +dprecg blog.erl\n```\n\nThe next section will dig deeper into the workings of `beam_ssa_pre_codegen`.\nOn a first reading, you might want to skip that section and jump ahead to\nthe section about [beam_ssa_codegen](#beam_ssa_codegen).\n\n### Digging deeper in beam_ssa_pre_codegen\n\nTo provide some context for the description of `beam_ssa_pre_codegen`,\nwe will first look at some BEAM code and talk about stack frames and\nY registers.\n\nHere is the example in Erlang:\n\n```erlang\nfoo(C, L) -\u003e\n    Sum = lists:sum(L),\n    C + Sum.\n```\n\nThe BEAM code looks like this:\n\n    {allocate,1,2}.\n    {move,{x,0},{y,0}}.\n    {move,{x,1},{x,0}}.\n    {line,[{location,\"blog.erl\",5}]}.\n    {call_ext,1,{extfunc,lists,sum,1}}.\n    {line,[{location,\"blog.erl\",6}]}.\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n    {deallocate,1}.\n    return.\n\nAs usual, we will walk through the code one or a few lines at a time.\n\n    {allocate,1,2}.\n\nThe `allocate` instruction allocates a stack frame. The `1` operand\nmeans that there should be room for one slot in the stack frame for\nstoring one value.  The slots in the stack frame are called *Y\nregisters*.\n\nThe `2` operand means that two X registers (`{x,0}` and `{x,1}`) are\nlive and must be preserved if `allocate` needs to do a garbage\ncollection in order to allocate space for the stack frame.\n\n    {move,{x,0},{y,0}}.\n\nThe `C` argument for `foo/2` is in `{x,0}`. The `move` instruction\ncopies the value of `{x,0}` to `{y,0}`, which is the zeroth slot\nin the stack frame. The reason for doing this copy will soon become\nclear.\n\n    {move,{x,1},{x,0}}.\n\nPreparing for the call of `lists:sum/1`, the value of `L` in `{x,1}`\nis copied to `{x,0}`.\n\n    {line,[{location,\"blog.erl\",5}]}.\n    {call_ext,1,{extfunc,lists,sum,1}}.\n\nHere `lists:sum/1` is called. The argument is in `{x,0}`. The result\n(the sum of all numbers in the list) is returned in `{x,0}`. Also,\nthe contents of all other X registers are destroyed. That means that\nany value that is to be used after a function call must be saved to\na Y register.\n\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\nThis instruction calculates the sum of `C` (in `{y,0}`) and `Sum` (in `{x,0}`),\nstoring the result in `{x,0}`.\n\n    {deallocate,1}.\n\nPreparing to return from the function, the `deallocate` instruction\nremoves the stack frame that `allocate` created.\n\n    return.\n\n`return` returns from the function. The return value is in `{x,0}`.\n\nHere is the SSA code for the function:\n\n```\nfunction blog:foo(_0, _1) {\n0:\n  %% blog.erl:5\n  _2 = call remote (literal lists):(literal sum)/1, _1\n\n  %% blog.erl:5\n  _3 = bif:'+' _0, _2\n  @ssa_bool = succeeded _3\n  br @ssa_bool, label 3, label 1\n\n3:\n  ret _3\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\nAfter running `beam_ssa_pre_codegen`, the SSA code looks like this:\n\n```\nfunction blog:foo(x0/_0, x1/_1) {\n  %% _0: 0..1\n  %% _1: 0..1 0..3\n%% #{frame_size =\u003e 1,yregs =\u003e [0]}\n0:\n  %% _0:4: 1..5\n  [1] y0/_0:4 = copy x0/_0\n\n  %% blog.erl:5\n  %% _2: 3..5\n  [3] x0/_2 = call remote (literal lists):(literal sum)/1, x1/_1\n\n  %% blog.erl:5\n  %% _3: 5..11\n  [5] x0/_3 = bif:'+' y0/_0:4, x0/_2\n\n  %% @ssa_bool: 7..9\n  [7] z0/@ssa_bool = succeeded x0/_3\n  [9] br z0/@ssa_bool, label 3, label 1\n\n3:\n  [11] ret x0/_3\n\n1:\n  %% @ssa_ret: 13..15\n  [13] x0/@ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  [15] ret x0/@ssa_ret\n}\n```\n\nWe will describe what the important (for this example) sub passes of\n`beam_ssa_pre_codegen` do, and point to the relevant part of code while\ndoing so.\n\nThe sub pass [place_frames] determines where stack frames should be allocated.\nIn the example, block 0 needs a stack frame.\n\nThe sub pass [find_yregs] determines which variables that are to be\nplaced in Y registers. The result will be a `yregs` annotation added\nto each block that allocates a stack frame. For this example, the\nannotation will look like:\n\n\u003cpre class=\"highlight\"\u003e\n    %% #{frame_size =\u003e 1,\u003cb\u003eyregs =\u003e [0]\u003c/b\u003e}\n\u003c/pre\u003e\n\nVariable `_0` is `C` from the Erlang code. It needs to be saved across the\ncall to `lists:sum/1`.\n\nThe sub pass [reserve_yregs] uses the `yregs` annotations and inserts `copy` instructions\nto copy each variable that needs saving to a new variable. For the example,\nthe following instruction will be added\n\n```\n  [1] y0/_0:4 = copy x0/_0\n```\nIt copies the value of `_0` to `_0:4`.\n\nThe sub pass [number_instructions] numbers all instructions as a preparation for register\nallocation. In the listing, those numbers are in brackets before each instruction:\n`[1]`, `[3]`, `[5]`, and so on.\n\nThe sub pass [live_intervals] calculates the intervals in which each variable is live.\nIn the listing, the live intervals are shown as comments before the definition\nof the variable:\n\n```\n  %% _0:4: 1..5\n  [1] y0/_0:4 = copy x0/_0\n```\n\nThe variable `_0:4` is live from instruction `[1]` (its definition) to\n`[5]` (its last use).\n\nThe sub pass [linear_scan] uses the [linear scan][linear_scan_polleto] algorithm\nto allocate registers for each variable. The result is saved as annotation\nfor the function. In the listing of the SSA code, the register will be added\nto the definition and each use of a variable. For example:\n\n```\n  [1] y0/_0:4 = copy x0/_0\n```\n\nVariable `_0` (the argument `L`) is in `{x,0}`. Its copy in `_0:4` is in\n`{y,0}`.\n\nBut what is `z0`?\n\n\u003cpre class=\"highlight\"\u003e\n      [7] \u003cb\u003ez0\u003c/b\u003e/@ssa_bool = succeeded x0/_3\n      [9] br \u003cb\u003ez0\u003c/b\u003e/@ssa_bool, label 3, label 1\n\u003c/pre\u003e\n\n`succeeded` is not a BEAM instruction. It will be combined with the previous\ninstruction (`bif:+` in this example) and the `br` instruction that follows it\nto the following BEAM instruction:\n\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\nThus, the value `@ssa_bool` is never explicitly stored in a BEAM\nregister.  Before I invented Z registers, `@ssa_bool` would have been\nassigned to an X register.  That worked most of the time, but sometimes\nan X register would seem to be occupied when it was not, and prevent\nanother instruction from using that register.\n\nHere are the [references that I used when implementing linear scan][linear_scan_references].\n\nThe sub pass [frame_size] uses the information from the linear scan pass to calculate the size\nof each stack frame. The result is stored as an annotation:\n\n\u003cpre class=\"highlight\"\u003e\n    %% #{\u003cb\u003eframe_size =\u003e 1\u003c/b\u003e,yregs =\u003e [0]}\n\u003c/pre\u003e\n\n[place_frames]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L715\n\n[find_yregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1114\n\n[reserve_yregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1645\n\n[number_instructions]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1487\n\n[live_intervals]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1515\n\n[linear_scan]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118\n\n[frame_size]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1741\n\n### beam_ssa_codegen\n\nThe [`beam_ssa_codegen`][beam_ssa_codegen] pass generates BEAM code\nfrom the annotated SSA code. Testing of this pass was easier, because\nI could compile some sample code and try to run it.\n\nOften I did not even have to run the code to know that it was wrong.\nThe compiler would tell me, loudly:\n\n{% raw %}\n```\nblog: function bar/2+4:\n  Internal consistency check failed - please report this bug.\n  Instruction: {test_heap,2,3}\n  Error:       {{x,2},not_live}:\n```\n{% endraw %}\n\nIt's time to introduce the `beam_validator` pass.\n\n#### beam_validator\n\nThe [`beam_validator`][beam_validator] pass was introduced in one of\nthe R10B releases (probably in 2006). It is run directly before the\nBEAM code is packaged into a binary and written to a BEAM file. The\npurpose of `beam_validator` is to find unsafe instructions that\ncould crash the runtime system or cause it to misbehave in other\nways.\n\nLet's look at a simple example:\n\n```erlang\nbar(H, T) -\u003e\n    [H|T].\n```\n\nHere is the BEAM code, but edited by me to contain an unsafe instruction:\n\n\u003cpre class=\"highlight\"\u003e\n      {label,4}.\n        {test_heap,2,\u003cb\u003e3\u003c/b\u003e}.\n        {put_list,{x,0},{x,1},{x,0}}.\n        return.\n\u003c/pre\u003e\n\nThe number of live registers is here given as `3` instead of `2`.\nThat means that `{x,0}`, `{x,1}`, and `{x,2}` are supposed to contain\nvalid Erlang terms. Because `bar/2` is only called with two arguments,\n`{x,2}` can contain any old garbage.\n\nWhen running this code, it could crash the runtime system, or it could\nbe completely harmless. It depends on whether there will be a garbage\ncollection during execution of the `test_heap` instruction, and on the\nexact nature of the garbage in `{x,2}`. For example, if the garbage\nhappens to be an atom nothing bad will happen. That means that this\ntype of compiler bug is difficult to reliably catch in a test case.\n\n`beam_validator` will find this bug immediately. It keeps track of\nwhich registers are initialized at any point in the function. If it\nfinds a reference to a register that is not initialized it will\ncomplain:\n\n{% raw %}\n```\nblog: function bar/2+4:\n  Internal consistency check failed - please report this bug.\n  Instruction: {test_heap,2,3}\n  Error:       {{x,2},not_live}:\n```\n{% endraw %}\n\n#### Friend and foe\n\nDuring the implementation of `beam_ssa_codegen`, the `beam_validator`\npass pointed out many bugs for me. It was my friend.\n\nIt was also my foe, sort of. It would complain that some perfectly safe\ncode was unsafe. When that happened, I had to thoroughly investigate the\ncode to make doubly sure it was safe, and then extend `beam_validator`\nto make it smarter so that it would understand that the code was safe.\n\nHere is one example where I had to make `beam_validator` smarter.\nConsider this code:\n\n    {move,{x,0},{y,0}}.\n    {test,is_map,{f,777},[{x,0}]}.\n    {put_map_assoc,{f,0},{y,0},...}.\n\nThe `move` instruction stores a copy of `{x,0}` in `{y,0}` (a location\non the stack). The following `test` instruction tests whether `{x,0}`\nis a map and branches to label 777 if not. The `put_map_assoc` instruction\nupdates the map in `{y,0}`.\n\nThe `put_map_assoc` instruction will crash if its source argument is\nnot a map.  Therefore, `beam_validator` complains if `put_map_assoc` is\nused with a source argument that is not a map. In this example,\n`beam_validator` had not seen a `test` instruction that ensured that\n`{y,0}` was a map, so it complained. It is obvious (for a human) that\n`{y,0}` is a map because it is a copy of `{x,0}`, which is a map.\n\n`v3_codegen` never generated such code; in fact, it explicitly\n[avoided generating such code][v3_codegen_kludge].\nI did not want to add similar kludges to the new code generator, so\n[`beam_validator` had to become smarter][beam_validator_maps].\n\n[v3_codegen_kludge]: https://github.com/erlang/otp/blob/64422fcac9c602641dcf24ef2d35e3491376304d/lib/compiler/src/v3_codegen.erl#L1600\n\n#### Unsafe optimization passes\n\nSome of the unsafe code that `beam_validator` found was really unsafe,\nbut it was not the fault of my new compiler passes, but of the\noptimization passes that optimized the generated BEAM code.\n\nThe problem was that some of the optimization passes had implicit\nassumptions of the kind of code that `v3_codegen` would generate\n(or, rather, would **not** generate). The new code generator broke\nthose assumptions.\n\nAt first, when I saw those bugs, I removed the broken part of the\noptimization pass. Making the optimizations safe would be non-trivial\nand ultimately wasted work because we intended to rewrite all those\noptimization passes to work on SSA code.\n\nWhen I have seen a few too many of those unsafe optimizations, [I ripped\nout all of the unsafe optimization passes][unsafe_passes].\n\nThat meant that we would have to re-implement all of the optimizations\nbefore the generated code would be as good as the code from the old\ncompiler. I had also noticed that the new BEAM code generator in a\nfew ways generated better code than the old one, but in other ways the\ncode was worse. For example, the generated code used more stack space and\ndid a lot of register shuffling. Eventually, that had to be addressed in\nsome way.\n\nMeanwhile, I had worse problems to worry about.\n\n## March 2018\n\nOn March 14 I presented my progress on the new compiler passes for\nthe OTP team. One of my slides had the following text:\n\n\u003e * Can compile all modules in OTP (and run many of them correctly)\n\nYes, I had finished the initial implementation of `beam_ssa_codegen`\nso that I could compile all code in OTP.\n\nThe problem that I only at hinted in the slide was that Erlang could\ncrash and dump core when running test suites. Not every time, and\nnever in the same test case twice. It only happened when I have\ncompiled OTP with the new compiler.\n\nThe crash didn't seem related to the test cases themselves, but to the\nwriting of log files. I soon narrowed it down to that the crash could\nhappen if [`file_io_server`][file_io_server] had been compiled with\nthe new compiler passes. However, that was not much help. The module\ncontains complicated code that uses the binary syntax, `try`/`catch`,\nand `receive`, all of which are complicated instructions that might\nnot be correctly translated by the new compiler passes.\n\n`beam_validator` was supposed to catch those kinds of bugs before\nthey can cause a crash. Either there was some kind of bug that\n`beam_validator` didn't look for, or there was a bug in the\nimplementation of some of the instructions in the BEAM interpreter.\n\nI ended up spending the rest of March trying to hunt down that bug.\n\n[file_io_server]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/kernel/src/file_io_server.erl\n\n## April 2018\n\nAt the beginning of April, the bug still eluded me. I had narrowed\nit down somewhat. I was pretty sure it had something to do with\n`receive`.\n\nThen [Rickard] gave me some information that I could connect to another\npiece of information that I had absorbed during my hunt for the bug.\n\n### The bug\n\nThis section is somewhat advanced, and if you wish you can\nskip to [the fix](#the-fix).\n\nReading about the [Erlang Garbage Collector][lukas_gc] can give some\nbackground to better understand this section.\n\nRickard reminded me about the `message_queue_data` option that\nhad been added to [`process_flag/2`][process_flag] in OTP 19. After\ncalling `process_flag(message_queue_data, off_heap)` all messages\nthat have not yet been received would be stored outside the process\nheap. Storing the messages outside the heap means that the garbage\ncollector doesn't have to spend time copying the unreceived messages\nduring garbage collection, which can be a huge win for processes that\nhave many messages in its message queue.\n\nThe implementations details of messages outside the heap are\ncrucial. Consider this selective `receive`:\n\n```erlang\nreceive\n    {tagged_message,Message} -\u003e Message\nend.\n```\n\nWhen the BEAM interpreter executes this code, it will retrieve a\nreference message from the external message queue and match it against\nthe tuple pattern. If the message does not match, the next message\nwill be processed in the same way, and so on.\n\nIf a message does not match, there **must not** be any remaining\nreferences to it stored on the stack. The reason is that if there is a\ngarbage collection, the garbage collector will copy the message (or\npart of the message) to the heap, and, even worse, it will destroy the\noriginal message during the copy operation. The message is still in\nthe external message queue, but it has now been corrupted by the\ngarbage collector. If the message is later matched out in a `receive`,\nit will likely cause a crash.\n\nWhen Rickard first implemented off-heap messages, he asked me whether\nthe compiler could ever store references to unreceived messages\non the stack. I assured him that it could not happen.\n\nYes, that was true, it could not happen because of the way\n`v3_codegen` generated the code for `receive`.\n\nWith the new compiler passes, [it **could** happen][bad_receive]. When\nI first discussed the bug with Richard in March, he did mention that\nit is forbidden to store references to off-heap messages on the\nstack. At that time, I was not aware that the compiler could store\nreferences to off-heap messages on the stack.\n\nWhen Rickard reminded me about that for the second time in April, I remember\nseeing during my bug hunt generated code that stored off-heap message\nreferences on the stack.\n\n[rickard]: https://github.com/rickard-green\n[process_flag]: http://erlang.org/doc/man/erlang.html#process_flag-2\n[lukas_gc]: https://github.com/erlang/otp/blob/OTP-21.0.9/erts/emulator/internal_doc/GarbageCollection.md\n[bad_receive]: https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/test/beam_validator_SUITE_data/receive_stacked.S#L22\n\n### The fix\n\nAfter finding the reason for the bug, I first taught `beam_validator`\nto [complain about \"fragile references\" on the stack][beam_validator_fragile].\nI included that commit in OTP 21.\n\nI then added a sub pass to `beam_ssa_pre_codegen` to [rewrite `receive`][receive_fix].\nIt introduces new variables and `copy` instructions to ensure that\nany references to the message being matched are kept in X registers.\n\nWith no known bugs in the code generator, I could start rewriting the optimization\npasses I had removed.\n\n[receive_fix]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L919\n\n### More optimizations\n\n#### beam_ssa_recv\n\n[`beam_ssa_recv`][beam_ssa_recv] is a replacement for the unsafe\n[`beam_receive`][beam_receive] pass.  The purpose is to optimize a\n`receive` that can only match a newly created reference.  The\noptimization avoids scanning the messages that were placed in the\nmessage queue before the reference was created.\n\nI actually wrote `beam_ssa_recv` at the beginning of March as an\nexperiment to see how easy it would be to write optimizations of SSA code.\nIt turned out to be pretty easy. `beam_ssa_recv` can apply the optimization\nin more places than `beam_receive` could, using slightly less code.\n\nIn the old `beam_receive` pass, a lot of code is needed to handle\nthe many variants of BEAM instructions. For example, in\n[`opt_update_regs/3`][beam_ssa_recv_opt_update_regs] there are three\nclauses just to handle three variants of a `call` instruction (calling\na local function, calling an external function, and calling a fun).\n\nHere is an example of a function that `beam_receive` did not optimize, but\n[`beam_ssa_recv` can optimize][yes_14].\n\n[beam_receive]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_receive.erl\n[beam_ssa_recv]: https://github.com/erlang/otp/blob/367f4a3fabb12cda3f2547e9908acbf28cb34e3a/lib/compiler/src/beam_ssa_recv.erl\n[beam_ssa_recv_opt_update_regs]: https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/src/beam_receive.erl#L185\n[yes_14]: https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/test/receive_SUITE_data/ref_opt/yes_14.erl\n\n#### beam_ssa_opt\n\nThe [`beam_ssa_opt`][beam_ssa_opt] pass runs a [number of\noptimizations][beam_ssa_opt_passes]. Many of the optimizations are replacements\nfor the optimizations I removed earlier.\n\n[beam_ssa_opt]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl\n\n[beam_ssa_opt_passes]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl#L49\n\n#### beam_ssa_type\n\n[`beam_ssa_type`][beam_ssa_type] replaces the unsafe [`beam_type`][beam_type] pass.\n\nThe `beam_type` pass did a local type analysis (basically for extended basic blocks),\nand tried to simplify the code, for example by removing unnecessary type tests.\n\nThe `beam_ssa_type` pass analyzes the types in an entire function and\nsimplifies the code, for example by removing unnecessary type\ntests. It finds many more opportunities for optimizations than\n`beam_type` did.\n\n[beam_ssa_type]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl\n\n## May 2018\n\nAt the beginning of May, [John][john] started working on what was to become\nthis pull request:\n\n[#1958: Rewrite BSM optimizations in the new SSA-based intermediate format][pr1958]\n\nI continued to write optimizations and fix bugs that John found while\ndeveloping his optimizations.\n\n### Rethinking the binary matching instructions\n\nWhile working on his binary optimizations, John realized that the SSA\ninstructions for binary matching were difficult to optimize. The\nbinary match instructions I had designed were close to the semantics\nof the BEAM instructions. John suggested that the `bs_get` instruction\nshould be broken up into a `bs_match` instruction and a `bs_extract`\ninstruction to simplify optimizations.\n\nThe breaking up of the instructions meant that [`beam_ssa_pre_codegen`\nwould have to work harder to combine\nthem][beam_ssa_pre_codegen_fix_bs], but it vastly simplified John's\noptimizations. It turned out that it also enabled other optimizations:\nthe [liveness optimizations][beam_ssa_opt_live] could remove unused\ninstructions more aggressively.\n\n[beam_ssa_pre_codegen_fix_bs]: https://github.com/erlang/otp/blob/master/lib/compiler/src/beam_ssa_pre_codegen.erl#L209\n[beam_ssa_opt_live]: https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L777\n\nOn the first day of [Code BEAM STO 2018][code_beam_2018] May 31, I didn't\nknow of any bugs in the new compiler passes and my list of optimizations to\nre-implement was shrinking steadily. I met [Micha≈Ç Muska≈Ça][michal]\n(a frequent contributor to Erlang/OTP and a member of the\n[Elixir Core Team][elixir_core_team]) there and told him about my work\non the compiler and that it was stable enough be tested outside OTP,\nfor example to compile Elixir code...\n\n[pr1958]: https://github.com/erlang/otp/pull/1958\n[code_beam_2018]: https://codesync.global/conferences/code-beam-sto-2018/\n[elixir_core_team]: https://elixirforum.com/groups/Elixir-Core-Team\n\n## June 2018\n\n### Micha≈Ç's feedback\n\nI received an email from Micha≈Ç in the middle of June. He had tried out\nmy compiler branch. He wrote:\n\n\u003e First impression is that it took a loooong time to compile Elixir's unicode module,\nso long that I had to shut it down after about 10 minutes.\n\nHe sent me an Erlangified version of [Elixir's unicode module][elixir_unicode].\nThe size of the Erlang source for the module was almost 82,000 lines or\nabout 3,700,000 bytes. Based on the size, compilation could be expected to be\na little bit slow, but not that slow. On his computer, OTP 21.0-RC2 finished\nthe compilation in 16 seconds.\n\nI compiled the module using the `time` option. The slowest pass was `beam_ssa_type`.\nAfter some further profiling, I found the bottleneck in the joining of two maps.\nHere is the [corrected code][beam_ssa_type_bottleneck]. The original code didn't compare\nthe size of maps and swap them as needed. I might have done some other improvements,\ntoo. Anyway, that took care of that bottleneck. Now `beam_ssa_pre_codegen` was the\nslowest pass.\n\nI fixed several bottlenecks in the [linear scan sub pass][linear_scan], and after\nthat some other bottleneck in `beam_ssa_pre_codegen`. I think that reduced the\ncompilation time to well under one minute.\n\n[beam_ssa_type_bottleneck]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl#L944\n\n### Optimizing code generation\n\nAfter having finished the re-implementation of the last optimization\npass (I think it was the [optimization of floating point\noperations][beam_ssa_opt_float], as previously done by the unsafe\n[`beam_type`][beam_type] pass), I started to compare the code\ngenerated by OTP 21 with code from the new compiler passes.\n\nI used [scripts/diffable][diffable], which compiles about 1000\nmodules from OTP to BEAM code and massages the BEAM code to make it more friendly\nfor diffing. I then ran `diff -u old new` to compare the new code to\nthe old code.\n\nIn the last part of June and the first week of July, I then improved\n`beam_ssa_pre_codegen` and `beam_ssa_codegen` to address the issues that I\nnoticed when reading the diff.\n\n#### `beam_ssa_pre_codegen` improvements\n\nI did not change the [linear scan][linear_scan] sub pass of `beam_ssa_pre_codegen`\nitself. Instead I added transformations of the SSA code that would help\nlinear scan do a better job of allocating registers.\n\nThe most obvious issue I noticed was unnecessary `move` instructions.\nHere are two of the sub passes I added to address that issue:\n\n* [reserve_xregs] gives hints to the linear scan sub pass that a\ncertain X register should be used for a certain variable, if possible.\n\n* [opt_get_list] tries to eliminate the extra `move` instruction that\nis frequently added when matching out elements from a list.  See the\ncomments in the code for an example and an explanation.\n\nAnother frequent issue was that the code generated from the new code\ngenerator used more stack space because two variables that were not\nstrictly live at the same time were allocated different Y registers\n(slots on the stack) instead of re-using the same Y register. I addressed\nthat issue in [copy_retval]. See the comments in the code for an example.\n\n#### `beam_ssa_codegen` improvements\n\nMicha≈Ç noticed that when a value was stored in both an X register and\na Y register (on the stack), instructions using the value would\nalways use the Y register. The old code generator would use the X\nregister.  The new code could be slower because the BEAM interpreter\nis generally optimized for operands being in X registers.\n\nI added [prefer_xregs] to address that issue. See the comments in the code\nfor examples.\n\n[reserve_xregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1916\n[copy_retval]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1222\n[opt_get_list]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1422\n\n[prefer_xregs]: https://github.com/erlang/otp/blob/7fbb86c77fa99caddabedfb992f47ddeece80652/lib/compiler/src/beam_ssa_codegen.erl#L359\n\n[beam_type]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl\n\n[beam_ssa_opt_float]: https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L517\n\n## July 2018\n\nVacation.\n\n## August 2018\n\nBefore I left for vacation, it seemed that the new compiler passes generally\ngenerated code at least as good as the old compiler passes. In some cases,\nthe code would be much better.\n\nBack after my vacation, I did some final polishing.\n\nOn Aug 17 I created a [pull request][pr1935].\n\nBefore merging the pull request, I sneaked in a few final optimizations.\n\nOn Aug 24 I [merged][merged_ssa] the pull request.\n\n[merged_ssa]: https://github.com/erlang/otp/commit/9facb02b91979ef90b47ac0a54d1eb71fdaa1ee1\n\n[beam_ssa_pre_codegen]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl\n[beam_ssa_codegen]: https://github.com/erlang/otp/blob/ec1f35c9f52be894ba295b9a48237020855e3c46/lib/compiler/src/beam_ssa_codegen.erl\n[beam_validator]: https://github.com/erlang/otp/blob/e2a939dc4d23d75a0588722d0a08aef129b4c0be/lib/compiler/src/beam_validator.erl\n\n[v3_kernel_bug]: https://github.com/erlang/otp/commit/c896f08f5c028b1e31290e6a5502597401acd39f\n[beam_validator_fragile]: https://github.com/erlang/otp/commit/90853d8e7b50be13a3b71f4a1ed6b0407e1f7c2f\n[unsafe_passes]: https://github.com/erlang/otp/commit/3fc40fd57fa01b097b4c363860c4d4762e13db8b\n[beam_validator_maps]: https://github.com/erlang/otp/commit/1f221b27f1336e747f7409692f260055dd3ddf79\n\n[john]: https://github.com/jhogberg\n[lukas]: https://github.com/garazdawi\n[michal]: https://github.com/michalmuskala\n\n[elixir_unicode]: https://github.com/elixir-lang/elixir/blob/54cb02c2407856f4063c75a440507dacb6a31dbc/lib/elixir/unicode/unicode.ex\n[diffable]: https://github.com/erlang/otp/blob/master/scripts/diffable\n\n[pr1935]: https://github.com/erlang/otp/pull/1935\n\n[bin_matching]: http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries\n\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form\n\n[kernel]: http://blog.erlang.org/beam-compiler-history#r6b-enter-kernel-erlang\n\n[beam_bsm]: https://github.com/erlang/otp/blob/2e40d8d1c51ad1c3d3750490ecac6b290233f085/lib/compiler/src/beam_bsm.erl\n\n[software_smoke_testing]: https://en.wikipedia.org/wiki/Smoke_testing_(software)\n\n[beam_kernel_to_ssa_finalize]: https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/src/beam_kernel_to_ssa.erl#L1231\n\n[dialyzer]: http://erlang.org/doc/apps/dialyzer/index.html\n\n[linear_scan_polleto]: http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf\n[linear_scan_references]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L52\n\n## The Future\n\nThe SSA-based intermediate representation provides a solid framework for\nfuture improvements of the compiler. After the merging of the pull request in\nAugust, several pull requests have already added further improvements:\n\n* [Introduce a put_tuple2 instruction][pr1947]\n\n* [Replace beam_dead with beam_ssa_dead][pr1955]\n\n* [Rewrite BSM optimizations in the new SSA-based intermediate format][pr1958]\n\n* [Clean up variable-related cruft in new SSA passes][pr1959]\n\n* [beam_validator: Use set_aliased_type in more operations][pr1960]\n\n* [Minor cleanups and bug fixes of the compiler][pr1965]\n\nHere is a list of possible further improvements that could be implemented either\nby OTP members or external contributors before OTP 22 is released:\n\n* Rewrite `sys_core_dsetel` to be SSA-based.\n\n* Rewrite the guard optimizing sub pass `guard_opt/2` in `v3_kernel`\n  to an SSA-based optimization pass.\n\n* Rewrite `beam_trim`. It would probably have to be a part of `beam_ssa_codegen`.\n\n* Optimize `switch` branches. If two branches jump to blocks\n  that do the same thing, let both branches jump to the same\n  block. `beam_jump` does this kind of optimization, but doing it\n  earlier in the SSA representation could speed up compilation of functions\n  with many clauses.\n\n* Get rid of the `beam_utils` module, especially the `is_killed()` and\n  `is_not_used()` family of functions. The functions in `beam_utils`\n  used by `beam_jump` could be moved into `beam_jump`.\n\n* Rewrite `beam_bs` to be SSA-based. This rewrite might not improve\n  the generated code, but it might speed up compilation of modules\n  with heavy use of the binary syntax.\n\n[pr1947]: https://github.com/erlang/otp/pull/1947\n[pr1955]: https://github.com/erlang/otp/pull/1955\n[pr1959]: https://github.com/erlang/otp/pull/1959\n[pr1960]: https://github.com/erlang/otp/pull/1960\n[pr1965]: https://github.com/erlang/otp/pull/1965\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"ssa-history"},"buildId":"92Ploa_JRk4A9mAiRpquq","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_buildManifest.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_ssgManifest.js" async=""></script></body></html>