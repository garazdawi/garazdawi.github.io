{"pageProps":{"index":{"id":"0011","content":"<pre><code>Author: Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;\nStatus: Accepted/R12B-3u Proposal is implemented in OTP release R12B-3,\n except for Unicode support according to EEP 10\nType: Standards Track\nCreated: 04-Jun-2008\nErlang-Version: R12B-5\nPost-History: 01-Jan-1970\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 11: <a href=\"eep-0011.md\" title=\"EEP Source\"> Built in regular expressions in Erlang</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP suggests how to integrate an external regular expression\nlibrary into the Erlang virtual machine.</p>\n\n<h1>Motivation</h1>\n\n<p>Regular expressions are widely used. Regardless of how other features\nof a language can be used to match or pick out parts of a string, many\nprogrammers prefer the regular expression syntax and expect\nregular expressions to be available in a modern language.</p>\n\n<p>The Perl programming language has integrated regular expressions\ndirectly into the syntax and Perl programmers are often highly skilled\nat writing complicated regular expressions that parse e.g. text files,\nHTTP requests or simple user input. The Perl extensions to the common\nregular expressions are widely known and many modern programming\nlanguages support something similar.</p>\n\n<p>Erlang currently has a minimalistic regular expression module (regexp\nmodule in STDLIB), which lacks features commonly available in other\nimplementations. The current library is also painfully slow compared\nto the native C libraries utilized in other languages.</p>\n\n<p>Erlang needs to interface with a modern regular expression library in\na way that does not break the properties of the virtual machine.</p>\n\n<h1>Rationale</h1>\n\n<h2>Preconditions</h2>\n\n<p>Writing a more efficient regular expression library purely in Erlang\nhas been attempted, but so far no really efficient implementation has\nbeen proposed, and the work involved in creating one is deemed\nextensive.</p>\n\n<p>On the other hand, several more or less successful attempts to\nintegrate an external regular expressions library into the virtual\nmachine have been presented. None of them, however, have addressed the\nissue of long running regular expressions stalling the schedulers.</p>\n\n<p>A built in function in the Erlang VM needs to stop execution when it\nhas run a certain amount of iterations, to avoid stalling a scheduler\nand thereby starving other processes in the system. When the Erlang\nprocess get's scheduled again, the built in function restarts and has\nprovided some way of storing it's current state so that execution of\nthe function can continue where it was once left. </p>\n\n<p>The execution of a regular expression match is in many ways similar to the\nvirtual machine's execution of ordinary beam code, but the available\nlibraries are (for obvious reasons) not prepared to give up the\nexecution temporarily to allow other processes to execute. A\ncomplicated regular expression on large amounts of subject data can\ntake seconds or even minutes to execute. Stalling one of the\nschedulers in the VM for that amount of time is not an option in a\nreal parallel system. As suggested interfaces to external libraries\nhave never addressed this problem, none have been accepted and/or\nintegrated in the main Erlang distribution.</p>\n\n<p>Stack usage is another issue seldom addressed. The Erlang virtual\nmachine may run a lot of scheduler threads, especially on processors\nwith large amounts of cores. Multithreading applications need to be\ncareful about stack usage, why recursive C routines are best\navoided. The Erlang virtual machine avoids recursion in C code, why a\nlinked in library should do the same. When it comes to realtime\noperating systems, the need to avoid recursion in the C code is even\nmore obvious. The library used for Erlang regular expressions simply\ncannot be recursive on the C stack, at least not in a way where stack\nusage cannot be determined at compile time.</p>\n\n<h3>Multithreading versus interruptable execution</h3>\n\n<p>The problem of interrupting the execution of a regular expression (or\nother lengthy operations) when another Erlang process should be\nscheduled, has two obvious solutions:</p>\n\n<ol>\n<li><p>Count the number of iterations in a regular expression match, store\nthe state after a certain amount of iterations (or a certain amount\nof time) and return control to the scheduler when execution time\nslot is exceeded.  </p></li>\n<li><p>Let the operating system take care of the problem by executing the\nregular expression matches in separate kernel threads.</p></li>\n</ol>\n\n<p>In the virtual machine's file driver, the second approach is used,\nintroducing the concept of the asynchronous thread pool. The file I/O\ncase is however special as the I/O operation in itself usually\nconsumes far more time than the running time for the inter-thread\ncommunication and task switching involved when using asynchronous\nthreads. Besides, there simply is no other solution at hand for I/O,\nso OS threads is the <em>only</em> solution at hand in that case.</p>\n\n<p>If regular expressions were to be executed in separate threads, even\nvery small and simple expressions would have to carry the extra burden\nof OS level task switching and communication.</p>\n\n<p>Other lengthy operations in the virtual machine use the first\napproach of voluntary interruption and rescheduling. In the cases\nwhere external libraries are involved, like IP communication, the\nemulator provides ways to passively wait for events by supplying\ninterfaces to I/O multiplexing (select/poll). This is the way to avoid\nblocking the schedulers in most drivers. Asynchronous threads are only\nutilized where there simply are no other options, like in file I/O\n(which cannot utilize I/O multiplexing).</p>\n\n<p>Using the first solution when interfacing an external library in a\ndriver or BIF, involves either finding a library where interruption and\nrestart of execution is possible, or modifying an existing library to\nsupport this.</p>\n\n<p>Even though modifying a library will make upgrading and patching of\nthe library much harder, the benefits are significant. When executing e.g.\nregular expressions, the same thread that actually is executing the\nbeam code will be utilized, why setup time and overhead in general is\nkept at a minimum. Of course execution time of the regexp itself will\nbe slightly longer, as the implementation needs to keep track of the\nnumber of executed iterations and needs to be prepared to store the\ncurrent state for later execution wakeup. The much smaller setup time\nis however expected to be dominating when it comes to smaller regular\nexpressions (or rather expressions that involve a small number of\nloops). One also has to bear in mind that this solution imposes much\nless load on the operating system scheduler, which is a good thing for\nlarge and/or embedded systems.</p>\n\n<p>For operating systems where no kernel threads are available, the first\nsolution is the only acceptable. Separate threads for pure user space\ncode execution will do more harm than good to the realtime properties\nof the Erlang system.</p>\n\n<h3>Selecting a suitable library to integrate</h3>\n\n<p>The library to integrate into the virtual machine should in an ideal\nsituation fulfill the following wishes:</p>\n\n<ul>\n<li>Interruptable, the execution of the regular expression match should\nstop after a certain amount of iterations and should then be\nrestartable at a later time.</li>\n<li>The library should be implemented in plain C, not any other language\nor extension.</li>\n<li>The C implementation should be non-recursive.</li>\n<li>The library should implement modern (Perl like) regular expression \nsyntax.</li>\n<li>The library should be efficient.</li>\n<li>The library should provide Unicode support.</li>\n</ul>\n\n<p>No available regular expression library currently provides a perfect\nmatch. The best available is the <a href=\"http://www.pcre.org/\" title=\"The PCRE homepage\">PCRE</a> library, which has compile time\noptions for not using the C stack, Perl (and Python) compatible\nregular expressions and also is written in a well structured way,\nmaking it suitable for integration, porting and implementing\nextensions needed in the Erlang case.</p>\n\n<p>Other alternatives include rxlib (no longer maintained), the Tcl/Tk\nregular expression implementation, GNU regex, Jakarta and Onigurama,\namong others. Of those the Tcl/Tk implementation seems the most\npromising, especially as it for many situations is much faster than\nother implementations. The algorithms and code are however quite\nincomprehensible and the regular expression flavor not the most\nwidespread.</p>\n\n<p>After having had a good look at the alternatives, I came to the\nconclusion that PCRE was the best choice for the following reasons:</p>\n\n<ul>\n<li>The code is maintained, very readable and easy to work with.</li>\n<li>The library is fast, although not the fastest.</li>\n<li>Extensive test suites.</li>\n<li>Perl compatible syntax.</li>\n<li>Widely spread: Used in Apache, PHP, Apple Safari etc.</li>\n<li>The regexp engine is pure C.</li>\n<li>Unicode support (UTF-8) which fits nicely into the suggested\nUnicode representation in Erlang (<a href=\"/eeps/eep-0010\" title=\"EEP 10\">EEP 10</a>).</li>\n<li>Recursion on the C stack can be avoided.</li>\n<li>The library has most of the infrastructure for an interruptable\nexecution of the expressions present, although restarting of\ninterrupted matches is not (yet) implemented.</li>\n</ul>\n\n<p>Although the subjective reasoning about code readability might seem\nsomewhat out of place, the PCRE code base makes updates to the library\neasier to integrate, as relatively few and comprehensible alterations\nneed to be done to the library to make it fit into the virtual\nmachine. To be able to maintain the library is important and being\nable to understand the code is crucial.</p>\n\n<p>The most appealing feature of the library is however the extensive\nsupport for Perl compatible regular expressions. PCRE is certainly one\nof the most powerful libraries around and Erlang programmers used to\nPerl's regular expressions will feel at home.</p>\n\n<h2>Programmers interface</h2>\n\n<p>In Perl, the regular expressions are integrated into the language\nitself. This could of course be done in Erlang too. However, Erlang\nalready has syntax for matching structured data as well as binary\nditto. Introducing new primitives for string matching with regular\nexpressions seems out of place. Erlang is also not a language designed\nfor processing textual data in the way Perl is, but a language that\ncan handle complicated structured data. The bit-syntax however might\none day benefit from regular expression extensions, but that is beyond\nthe scope of this EEP.</p>\n\n<p>A regular expression module interfacing with the library through built\nin functions is the usual way to do it in Erlang, and that's the way\nthis EEP suggests. As the module name regexp is already taken, the\nabbreviation \"re\" for module name seems to be a good choice.</p>\n\n<p>As a base implementation, I suggest a module with two basic functions:\none for precompiling a regular expression into \"bytecode\" for the\nregular expression matching execution; and one for actually running\nthe regexp matching. The function that runs the matching should take\neither a compiled regular expression, or the source of a regular\nexpression as input (together with the subject string and the options\nfor execution). </p>\n\n<p>Around these two suggested functions one can implement functionality\nin Erlang to mimic the existing regular expression library or\nimplement new functionality. </p>\n\n<p>The current regexp module can, apart from matching, split a string\naccording to a regular expression (functionality similar to the Perl\nbuilt in function split) and do substitution of sub-strings based on\nregular expression matching (like the s/<RE>/<String>/ expression in\nPerl or awk). With corresponding functions in the \"re\" module, the new\nmodule would provide all functionality of the old one.</p>\n\n<p>The names of the functions should, as much as possible, be chosen so\nthat mix up with the current regexp library functions is avoided, why I\nsuggest \"compile\" and \"run\" and \"replace\" as names for regexp\ncompilation, execution and substitution respectively. As no good\nsynonym for the name \"split\" has emerged, that name is retained in the\nnew module.</p>\n\n<p>Here follows part of the suggested manual page:</p>\n\n<h3>Excerpt from a suggested manual page</h3>\n\n<h4>DATA TYPES</h4>\n\n<pre><code>iodata() = iolist() | binary()\niolist() = [char() | binary() | iolist()]\n           % a binary is allowed as the tail of the list\n\nmp() = Opaque datatype containing a compiled regular expression.\n</code></pre>\n\n<h4>EXPORTS</h4>\n\n<h5>compile(Regexp) -> {ok, MP} | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Regexp = iodata()\n</code></pre>\n\n<p>The same as compile(Regexp,[])</p>\n\n<h5>compile(Regexp,Options) -> {ok, MP} | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Regexp = iodata()\nOptions = [ Option ]\nOption = anchored | caseless | dollar_endonly | dotall | extended |\n         firstline | multiline | no_auto_capture | dupnames |\n         ungreedy | {newline, NLSpec}\nNLSpec = cr | crlf | lf | anycrlf\nMP = mp()\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>This function compiles a regular expression with the syntax described below\ninto an internal format to be used later as a parameter to the run/2,3 functions.</p>\n\n<p>Compiling the regular expression before matching is useful if the same\nexpression is to be used in matching against multiple subjects during the\nprogram's lifetime. Compiling once and executing many times is far more\nefficient than compiling each time one wants to match.</p>\n\n<p>The options have the following meanings:</p>\n\n<ul>\n<li><p><code>anchored</code> <br />\nThe pattern is forced to be \"anchored\", that is, it is constrained to match\nonly at the first matching point in the string that is being searched\n(the \"subject string\"). This effect can also be achieved by appropriate\nconstructs in the pattern itself.</p></li>\n<li><p><code>caseless</code> <br />\nLetters in the pattern match both upper and lower case letters.\nIt is equivalent to Perl's <code>/i</code> option, and it can be changed within\na pattern by a <code>(?i)</code> option setting. Uppercase and lowercase letters\nare defined as in the ISO-8859-1 character set.</p></li>\n<li><p><code>dollar_endonly</code> <br />\nA dollar metacharacter in the pattern matches only at the end of the subject\nstring. Without this option, a dollar also matches immediately before a newline\nat the end of the string (but not before any other newlines). The dollar_endonly\noption is ignored if multiline is given. There is no equivalent option in Perl,\nand no way to set it within a pattern.</p></li>\n<li><p><code>dotall</code> <br />\nA dot maturate in the pattern matches all characters, including those that\nindicate newline. Without it, a dot does not match when the current position\nis at a newline. This option is equivalent to Perl's <code>/s</code> option, and it\ncan be changed within a pattern by a <code>(?s)</code> option setting. A negative class\nsuch as <code>[^a]</code> always matches newline characters,\nindependent of the setting of this option.</p></li>\n<li><p><code>extended</code> <br />\nWhitespace data characters in the pattern are ignored except when escaped or\ninside a character class. Whitespace does not include the VT character\n(ASCII 11). In addition, characters between an unescaped <code>#</code> outside a\ncharacter class and the next newline, inclusive, are also ignored. This is\nequivalent to Perl's <code>/x</code> option, and it can be changed within a pattern by\na <code>(?x)</code> option setting. This option makes it possible to include comments\ninside complicated patterns. Note, however, that this applies only to data\ncharacters. Whitespace characters may never appear within special character\nsequences in a pattern, for example within the sequence <code>(?(</code> which introduces\na conditional subpattern.</p></li>\n<li><p><code>firstline</code> <br />\nAn unanchored pattern is required to match before or at the first newline\nin the subject string, though the matched text may continue over the newline.</p></li>\n<li><p><code>multiline</code> <br />\nBy default, PCRE treats the subject string as consisting of a single line of\ncharacters (even if it actually contains newlines). The \"start of line\"\nmetacharacter (<code>^</code>) matches only at the start of the string, while the\n\"end of line\" metacharacter (<code>$</code>) matches only at the end of the string,\nor before a terminating newline (unless dollar_endonly is given). This is\nthe same as Perl.</p>\n\n<p>When multiline it is given, the \"start of line\" and \"end of line\" constructs\nmatch immediately following or immediately before internal newlines in the\nsubject string, respectively, as well as at the very start and end. This is\nequivalent to Perl's <code>/m</code> option, and it can be changed within a pattern by\na <code>(?m)</code> option setting. If there are no newlines in a subject string,\nor no occurrences of <code>^</code> or <code>$</code> in a pattern, setting multiline has no effect.</p></li>\n<li><p><code>no_auto_capture</code> <br />\nDisables the use of numbered capturing parentheses in the pattern.\nAny opening parenthesis that is not followed by <code>?</code> behaves as if it were\nfollowed by <code>?:</code> but named parentheses can still be used for capturing\n(and they acquire numbers in the usual way). There is no equivalent\nof this option in Perl.</p></li>\n<li><p><code>dupnames</code> <br />\nNames used to identify capturing subpatterns need not be unique.\nThis can be helpful for certain types of pattern when it is known\nthat only one instance of the named subpattern can ever be matched.\nThere are more details of named subpatterns below.</p></li>\n<li><p><code>ungreedy</code> <br />\nThis option inverts the \"greediness\" of the quantifiers so that they\nare not greedy by default, but become greedy if followed by <code>?</code>.\nIt is not compatible with Perl. It can also be set by a <code>(?U)</code> option\nsetting within the pattern.</p></li>\n<li><p><code>{newline, NLSpec}</code> <br />\nOverride the default definition of a newline in the subject string, which is LF (ASCII 10) in Erlang.</p>\n\n<ul>\n<li><code>cr</code> <br />\nNewline is indicated by a single character CR (ASCII 13) </li>\n<li><code>lf</code> <br />\nNewline is indicated by a single character LF (ASCII 10), the default </li>\n<li><code>crlf</code> <br />\nNewline is indicated by the two-character CRLF (ASCII 13 followed by ASCII 10) sequence. </li>\n<li><code>anycrlf</code> <br />\nAny of the three preceding sequences should be recognized. </li>\n</ul></li>\n</ul>\n\n<h5>run(Subject,RE) -> {match, Captured} | nomatch | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Subject = iodata()\nRE = mp() | iodata()\nCaptured = [ CaptureData ]\nCaptureData = {int(),int()} | string() | binary()\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>The same as run(Subject,RE,[]).</p>\n\n<h5>run(Subject,RE) -> {match, Captured} | match | nomatch | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Subject = iodata()\nRE = mp() | iodata()\nOptions = [ Option ]\nOption = anchored | global | notbol | noteol | notempty | {offset, int()} |\n         {newline, NLSpec} | {capture, ValueSpec} |\n         {capture, ValueSpec, Type} | CompileOpt\nType = index | list | binary\nValueSpec = all | all_but_first | first | ValueList\nValueList = [ ValueID ]\nValueID = int() | string() | atom()\nCompileOpt = see compile/2 above\nNLSpec = cr | crlf | lf | anycrlf\nCaptured = [ CaptureData ] | [ [ CaptureData ] ... ]\nCaptureData = {int(),int()} | string() | binary()\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>Executes a regexp matching, returning <code>match</code> / <code>{match, Captured}</code> or\n<code>nomatch</code>. The regular expression can be given either as iodata()\nin which case it is automatically compiled (as by re:compile/2)\nand executed, or as a pre compiled mp() in which case it is executed\nagainst the subject directly.</p>\n\n<p>When compilation is involved, the function may return compilation errors\nas when compiling separately (<code>{error, {string(),int()}}</code>); when\nonly matching, no errors are returned.</p>\n\n<p>If the regular expression is previously compiled, the option list can\nonly contain the options <code>anchored</code>, <code>global</code>, <code>notbol</code>, <code>noteol</code>, <code>notempty</code>,\n<code>{offset, int()}</code>, <code>{newline, NLSpec}</code> and <code>{capture, ValueSpec}</code> /\n<code>{capture, ValueSpec, Type}</code>. Otherwise all options valid for the\n<code>re:compile/2</code> function are allowed as well. Options allowed both\nfor compilation and execution of a match, namely <code>anchored</code> and\n<code>{newline, NLSpec}</code>, will affect both the compilation and execution\nif present together with a non pre-compiled regular expression.</p>\n\n<p>The <code>{capture, ValueSpec}</code> / <code>{capture, ValueSpec, Type}</code> defines\nwhat to return from the function upon successful matching. The capture\ntuple may contain both a value specification telling which of the captured\nsubstrings are to be returned, and a type specification, telling how\ncaptured substrings are to be returned (as index tuples, lists or binaries).\nThe capture option makes the function quite flexible and powerful.\nThe different options are described in detail below</p>\n\n<p>If the capture options describe that no substring capturing at all is to be\ndone (<code>{capture, none}</code>), the function will return the single atom match\nupon successful matching, otherwise the tuple <code>{match, ValueList}</code>\nis returned. Disabling capturing can be done either by specifying\nnone or an empty list as ValueSpec.</p>\n\n<p>A description of all the options relevant for execution follows:</p>\n\n<ul>\n<li><p><code>anchored</code> <br />\nLimits <code>re:run/3</code> to matching at the first matching position. If a pattern\nwas compiled with anchored, or turned out to be anchored by virtue of its\ncontents, it cannot be made unachored at matching time, hence there is no\nunanchored option.</p></li>\n<li><p><code>global</code> <br />\nImplements global (repetitive) search as the <code>/g</code> flag in i.e. Perl.\nEach match found is returned as a separate list() containing\nthe specific match as well as any matching subexpressions (or as\nspecified by the capture option). The Captured part of the return\nvalue will hence be a list() of list()'s when this option is given.</p>\n\n<p>When the regular expression matches an empty string, the behaviour\nmight seem non-intuitive, why the behaviour requites some clarifying.\nWith the global option, <code>re:run/3</code> handles empty matches in the same way\nas Perl, meaning that a match at any point giving an empty string\n(with length 0) will be retried with the options <code>[anchored, notempty]</code>\nas well. If that search gives a result of length > 0, the result\nis included. An example:</p>\n\n<pre><code>re:run(\"cat\",\"(|at)\",[global]).\n</code></pre>\n\n<p>The matching will be performed as following:</p>\n\n<ul>\n<li><p><strong>At offset 0</strong> <br />\nThe regexp <code>(|at)</code> will first match at the initial position of\nthe string cat, giving the result set <code>[{0,0},{0,0}]</code> (the\nsecond <code>{0,0}</code> is due to the subexpression marked by the\nparentheses). As the length of the match is 0, we don't\nadvance to the next position yet.</p></li>\n<li><p><strong>At offset 0 with <code>[anchored, notempty]</code></strong> <br />\nThe search is retried with the options [anchored, notempty] at\nthe same position, which does not give any interesting result of\nlonger length, why the search position is now advanced to the next\ncharacter (<code>a</code>).</p></li>\n<li><p><strong>At offset 1</strong> <br />\nNow the search results in <code>[{1,0}, {1,0}]</code> meaning this search\nwill also be repeated with the extra options.</p></li>\n<li><strong>At offset 1 with <code>[anchored, notempty]</code></strong> <br />\nNow the ab alternative is found and the result will be\n<code>[{1,2}, {1,2}]</code>. The result is added to the list of results\nand the position in the search string is advanced two steps.</li>\n<li><strong>At offset 3</strong> \nThe search now once again matches the empty string,\ngiving <code>[{3,0}, {3,0}]</code>.</li>\n<li><strong>At offset 1 with `[anchored, notempty]</strong> <br />\nThis will give no result of length > 0 and we are at the last\nposition, so the global search is complete. </li>\n</ul>\n\n<p>The result of the call is:</p>\n\n<pre><code>{match,[[{0,0},{0,0}],[{1,0},{1,0}],[{1,2},{1,2}],[{3,0},{3,0}]]}\n</code></pre></li>\n<li><p><code>notempty</code> <br />\nAn empty string is not considered to be a valid match if this option\nis given. If there are alternatives in the pattern, they are tried.\nIf all the alternatives match the empty string, the entire match fails.\nFor example, if the pattern:</p>\n\n<pre><code>a?b?\n</code></pre>\n\n<p>is applied to a string not beginning with \"a\" or \"b\", it matches the\nempty string at the start of the subject. With notempty given,\nthis match is not valid, so <code>re:run/3</code> searches further into the string\nfor occurrences of \"a\" or \"b\".</p>\n\n<p>Perl has no direct equivalent of notempty, but it does make a special\ncase of a pattern match of the empty string within its <code>split()</code> function,\nand when using the <code>/g</code> modifier. It is possible to emulate Perl's\nbehavior after matching a null string by first trying the match\nagain at the same offset with notempty and anchored, and then\nif that fails by advancing the starting offset (see below)\nand trying an ordinary match again.</p></li>\n<li><p><code>notbol</code> <br />\nThis option specifies that the first character of the subject string\nis not the beginning of a line, so the circumflex metacharacter should\nnot match before it. Setting this without multiline (at compile time)\ncauses circumflex never to match. This option affects only the behavior\nof the circumflex metacharacter. It does not affect <code>\\A</code>.</p></li>\n<li><p><code>noteol</code> <br />\nThis option specifies that the end of the subject string is not the end\nof a line, so the dollar metacharacter should not match it nor\n(except in multiline mode) a newline immediately before it.\nSetting this without multiline (at compile time) causes dollar\nnever to match. This option affects only the behavior of the dollar\nmetacharacter. It does not affect <code>\\Z</code> or <code>\\z</code>.</p></li>\n<li><p><code>{offset`` , int()}</code> <br />\nStart matching at the offset (position) given in the subject string.\nThe offset is zero-based, so that the default is <code>{offset,0}</code>\n(all of the subject string). </p></li>\n<li><p><code>{newline, NLSpec}</code>\nOverride the default definition of a newline in the subject string,\nwhich is LF (ASCII 10) in Erlang.</p>\n\n<ul>\n<li><code>cr</code> <br />\nNewline is indicated by a single character CR (ASCII 13).</li>\n<li><code>lf</code> <br />\nNewline is indicated by a single character LF (ASCII 10),\nthe default.</li>\n<li><code>crlf</code> <br />\nNewline is indicated by the two-character CRLF\n(ASCII 13 followed by ASCII 10) sequence. </li>\n<li><code>anycrlf</code> <br />\nAny of the three preceding sequences should be recognized</li>\n</ul></li>\n<li><p><code>{capture, ValueSpec}</code> / <code>{capture, ValueSpec, Type}</code> <br />\nSpecifies which captured substrings are returned and in what format.\nBy default, <code>re:run/3</code> captures all of the matching part of the substring\nas well as all capturing subpatterns (all of the pattern is\nautomatically captured). The default return type is (zero-based)\nindexes of the captured parts of the string, given as <code>{Offset,Length}</code>\npairs (the index Type of capturing).</p>\n\n<p>As an example of the default behavior, the following call:</p>\n\n<pre><code>re:run(\"ABCabcdABC\",\"abcd\",[]).\n</code></pre>\n\n<p>returns, as first and only captured string the matching part of\nthe subject (\"abcd\" in the middle) as a index pair <code>{3,4}</code>, where\ncharacter positions are zero based, just as in offsets. The return\nvalue of the call above would then be:</p>\n\n<pre><code>{match,[{3,4}]}\n</code></pre>\n\n<p>Another (and quite common) case is where the regular expression\nmatches all of the subject, as in:</p>\n\n<pre><code>re:run(\"ABCabcdABC\",\".*abcd.*\",[]).\n</code></pre>\n\n<p>where the return value correspondingly will point out all of the string,\nbeginning at index 0 and being 10 characters long:</p>\n\n<pre><code>{match,[{0,10}]}\n</code></pre>\n\n<p>If the regular expression contains capturing subpatterns,\nlike in the following case:</p>\n\n<pre><code>re:run(\"ABCabcdABC\",\".*(abcd).*\",[]).\n</code></pre>\n\n<p>all of the matched subject is captured, as well as\nthe captured substrings:</p>\n\n<pre><code>{match,[{0,10},{3,4}]}\n</code></pre>\n\n<p>the complete matching pattern always giving the first return value in\nthe list and the rest of the subpatterns being added in the order they\noccurred in the regular expression.</p>\n\n<p>The capture tuple is built up as follows:</p>\n\n<ul>\n<li><p><code>ValueSpec</code> <br />\nSpecifies which captured (sub)patterns are to be returned.\nThe <code>ValueSpec</code> can either be an atom describing a predefined set\nof return values, or a list containing either the indexes or the\nnames of specific subpatterns to return.</p>\n\n<p>The predefined sets of subpatterns are:</p>\n\n<ul>\n<li><p><code>all</code>\nAll captured subpatterns including the complete matching string.\nThis is the default.</p></li>\n<li><p><code>first</code> <br />\nOnly the first captured subpattern, which is always the complete\nmatching part of the subject. All explicitly captured subpatterns\nare discarded.</p></li>\n<li><p><code>all_but_first</code> <br />\nAll but the first matching subpattern, i.e. all explicitly\ncaptured subpatterns, but not the complete matching part of the\nsubject string. This is useful if the regular expression as\na whole matches a large part of the subject, but the part you're\ninterested in is in an explicitly captured subpattern.\nIf the return type is list or binary, not returning subpatterns\nyou're not interested in is a good way to optimize.</p></li>\n<li><p><code>none</code>\nDo not return matching subpatterns at all, yielding the single\natom match as the return value of the function when matching\nsuccessfully instead of the {match, list()} return. Specifying\nan empty list gives the same behavior. </p></li>\n</ul>\n\n<p>The value list is a list of indexes for the subpatterns to return,\nwhere index 0 is for all of the pattern, and 1 is for the first\nexplicit capturing subpattern in the regular expression,\nand so forth. When using named captured subpatterns (see below)\nin the regular expression, one can use <code>atom()</code>'s or <code>string()</code>'s\nto specify the subpatterns to be returned. This deserves an example,\nconsider the following regular expression::</p>\n\n<pre><code>\".*(abcd).*\"\n</code></pre>\n\n<p>matched against the string <code>\"ABCabcdABC\"</code>, capturing only the\n<code>\"abcd\"</code> part (the first explicit subpattern):</p>\n\n<pre><code>re:run(\"ABCabcdABC\",\".*(abcd).*\",[{capture,[1]}]).\n</code></pre>\n\n<p>The call will yield the following result:</p>\n\n<pre><code>{match,[{3,4}]}\n</code></pre>\n\n<p>as the first explicitly captured subpattern is <code>\"(abcd)\"</code>,\nmatching <code>\"abcd\"</code> in the subject, at (zero-based) position 3,\nof length 4.</p>\n\n<p>Now consider the same regular expression, but with the subpattern\nexplicitly named <code>'FOO'</code>:</p>\n\n<pre><code>\".*(?&lt;FOO&gt;abcd).*\"\n</code></pre>\n\n<p>With this expression, we could still give the index of the subpattern\nwith the following call::</p>\n\n<pre><code>re:run(\"ABCabcdABC\",\".*(?&lt;FOO&gt;abcd).*\",[{capture,[1]}]).\n</code></pre>\n\n<p>giving the same result as before. But as the subpattern is named,\nwe can also give its name in the value list::</p>\n\n<pre><code>re:run(\"ABCabcdABC\",\".*(?&lt;FOO&gt;abcd).*\",[{capture,['FOO']}]).\n</code></pre>\n\n<p>which would yield the same result as the earlier examples, namely:</p>\n\n<pre><code>{match,[{3,4}]}\n</code></pre>\n\n<p>The values list might specify indexes or names not present in the\nregular expression, in which case the return values vary depending\non the type. If the type is <code>index</code>, the tuple <code>{-1,0}</code> is returned\nfor values having no corresponding subpattern in the regexp, but for\nthe other types (binary and list), the values are the empty binary\nor list respectively.</p></li>\n<li><p><code>Type</code> <br />\nOptionally specifies how captured substrings are to be returned.\nIf omitted, the default of index is used. The Type can be one of\nthe following:</p>\n\n<ul>\n<li><p><code>index</code> <br />\nReturn captured substrings as pairs of byte indexes into\nthe subject string and length of the matching string in\nthe subject (as if the subject string was flattened with\niolist<em>to</em>binary prior to matching). This is the default.</p></li>\n<li><p><code>list</code> <br />\nReturn matching substrings as lists of characters\n(Erlang <code>string()</code>'s).</p></li>\n<li><p><code>binary</code> <br />\nReturn matching substrings as binaries.</p></li>\n</ul></li>\n</ul>\n\n<p>In general, subpatterns that got assigned no value in the match\nare returned as the tuple <code>{-1,0}</code> when type is <code>index</code>.\nUnasigned subpatterns are returned as the empty binary or list\nrespectively for other return types. Consider the regular expression:</p>\n\n<pre><code>\".*((?&lt;FOO&gt;abdd)|a(..d)).*\"\n</code></pre>\n\n<p>There are three explicitly capturing subpatterns, where the opening\nparenthesis position determines the order in the result,\nhence <code>\"((?&lt;FOO&gt;abdd)|a(..d))\"</code> is subpattern index 1,\n<code>\"(?&lt;FOO&gt;abdd)\"</code> is subpattern index 2 and <code>\"(..d)\"</code>\nis subpattern index 3. When matched against the following string:</p>\n\n<pre><code>\"ABCabcdABC\"\n</code></pre>\n\n<p>the subpattern at index 2 won't match, as <code>\"abdd\"</code> is not present\nin the string, but the complete pattern matches (due to the alternative\n<code>\"a(..d)\"</code>. The subpattern at index 2 is therefore unassigned and\nthe default return value will be:</p>\n\n<pre><code>{match,[{0,10},{3,4},{-1,0},{4,3}]}\n</code></pre>\n\n<p>Setting the capture Type to binary would give the following:</p>\n\n<pre><code>{match,[&lt;&lt;\"ABCabcdABC\"&gt;&gt;,&lt;&lt;\"abcd\"&gt;&gt;,&lt;&lt;&gt;&gt;,&lt;&lt;\"bcd\"&gt;&gt;]}\n</code></pre>\n\n<p>where the empty binary (<code>&lt;&lt;&gt;&gt;</code>) represents the unassigned subpattern.\nIn the binary case, some information about the matching is therefore lost,\nthe <code>&lt;&lt;&gt;&gt;</code> might just as well be an empty string captured.</p>\n\n<p>If differentiation between empty matches and non existing subpatterns\nis necessary, use the type index and do the conversion to\nthe final type in Erlang code.</p>\n\n<p>When the option global is given, the capture specification affects each\nmatch separately, so that:</p>\n\n<pre><code>re:run(\"cacb\",\"c(a|b)\",[global,{capture,[1],list}]).\n</code></pre>\n\n<p>gives the result:</p>\n\n<p><p><code>{match,[[\"a\"],[\"b\"]]}</code></p></li>\n</ul>\nThe options solely affecting the compilation step are described in\nthe <code>re:compile/2</code> function.</p>\n\n<h5>replace(Subject, RE, Replacement) -> iodata() | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Subject = iodata()\nRE = mp() | iodata()\nReplacement = iodata()\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>The same as replace(Subject, RE, Replacement,[]).</p>\n\n<h5>replace(Subject, RE, Replacement, Options) -> iodata() | binary() | list() | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Subject = iodata()\nRE = mp() | iodata()\nReplacement = iodata()\nOptions = [ Option ]\nOption = anchored | global | notbol | noteol | notempty |\n         {offset, int()} | {newline, NLSpec} |\n         {return, ReturnType} | CompileOpt\nReturnType = iodata | list | binary\nCompileOpt = see compile/2 above\nNLSpec = cr | crlf | lf | anycrlf\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>Replaces the matched part of the Subject string with\nthe content of Replacement.</p>\n\n<p>Options are given as to the re:run/3 function except that the <code>capture</code>\noption of re:run/3 is not allowed. Instead a <code>{return, ReturnType}</code>\nis present. The default return type is <code>iodata</code> , constructed in a way\nto minimize copying. The iodata result can be used directly in many\nI/O-operations. If a flat list() is desired, specify <code>{return, list}</code>\nand if a binary is preferred, specify <code>{return, binary}</code>.</p>\n\n<p>The replacement string can contain the special character <code>&amp;</code>,\nwhich inserts the whole matching expression in the result,\nand the special sequence <code>\\N</code> (where N is an integer > 0),\nresulting in the subexpression number N will be inserted in the result.\nIf no subexpression with that number is generated by the regular expression,\nnothing is inserted.</p>\n\n<p>To insert an <code>&amp;</code> or <code>\\</code> in the result, precede it with a <code>\\</code>.\nNote that Erlang already gives a special meaning to <code>\\</code> in literal strings,\nwhy a single <code>\\</code> has to be written as <code>\"\\\\\"</code> and therefore\na double <code>\\</code> as <code>\"\\\\\\\\\"</code>. Example:</p>\n\n<pre><code>re:replace(\"abcd\",\"c\",\"[&amp;]\",[{return,list}]).\n</code></pre>\n\n<p>gives:</p>\n\n<pre><code>\"ab[c]d\"\n</code></pre>\n\n<p>while:</p>\n\n<pre><code>re:replace(\"abcd\",\"c\",\"[\\\\&amp;]\",[{return,list}]).\n</code></pre>\n\n<p>gives:</p>\n\n<pre><code>\"ab[&amp;]d\"\n</code></pre>\n\n<p>The <code>{error, ErrSpec}</code> return value can only arise from compilation,\ni.e. when a non precompiled malformed RE is given.</p>\n\n<h5>split(Subject,RE) -> SplitList | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Subject = iodata()\nRE = mp() | iodata()\nSplitList = [ iodata() ]\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>The same as <code>split(Subject, RE, [])</code>.</p>\n\n<h5>split(Subject,RE,Options) -> SplitList | {error, ErrSpec}</h5>\n\n<p>Types:</p>\n\n<pre><code>Subject = iodata()\nRE = mp() | iodata()\nOptions = [ Option ]\nOption = anchored | global | notbol | noteol | notempty |\n         {offset, int()} | {newline, NLSpec} | {return, ReturnType} |\n         {parts, NumParts} | group | CompileOpt\nNumParts = int() | infinity\nReturnType = iodata | list | binary\nCompileOpt = see compile/2 above\nNLSpec = cr | crlf | lf | anycrlf\nSplitList = [ RetData ] | [ GroupedRetData ]\nGroupedRetData = [ RetData ]\nRetData = iodata() | binary() | list()\nErrSpec = {ErrString, Position}\nErrString = string()\nPosition = int()\n</code></pre>\n\n<p>This function splits the input into parts by finding tokens according to\nthe regular expression supplied.</p>\n\n<p>The splitting is done basically by running a global regexp match and dividing\nthe initial string wherever a match occurs. The matching part of the string\nis removed from the output.</p>\n\n<p>The result is given as a list of \"strings\", the preferred datatype given in\nthe return option (default <code>iodata</code>).</p>\n\n<p>If subexpressions are given in the regular expression, the matching\nsubexpressions are returned in the resulting list as well. An example:</p>\n\n<pre><code>re:split(\"Erlang\",\"[ln]\",[{return,list}]).\n</code></pre>\n\n<p>will yield the result:</p>\n\n<pre><code>[\"Er\",\"a\",\"g\"]\n</code></pre>\n\n<p>while:</p>\n\n<pre><code>re:split(\"Erlang\",\"([ln])\",[{return,list}]).\n</code></pre>\n\n<p>will yield:</p>\n\n<pre><code>[\"Er\",\"l\",\"a\",\"n\",\"g\"]\n</code></pre>\n\n<p>The text matching the subexpression (marked by the parantheses in the regexp)\nis inserted in the result list where it was found. In effect this means that\nconcatenating the result of a split where the whole regexp is\na single subexpression (as in the example above) will always\nresult in the original string.</p>\n\n<p>As there is no matching subexpression for the last part in the example\n(the <code>\"g\"</code>), there is nothing inserted after that. To make the group of\nstrings and the parts matching the subexpressions more obvious, one might use\nthe group option, which groups together the part of the subject string with\nthe parts matching the subexpressions when the string was split:</p>\n\n<pre><code>re:split(\"Erlang\",\"([ln])\",[{return,list},group]).\n</code></pre>\n\n<p>gives:</p>\n\n<pre><code>[[\"Er\",\"l\"],[\"a\",\"n\"],[\"g\"]]\n</code></pre>\n\n<p>Here the regular expression matched first the <code>\"l\"</code>, causing <code>\"Er\"</code> to be\nthe first part in the result. When the regular expression matched,\nthe (only) subexpression was bound to the <code>\"l\"</code>, why the <code>\"l\"</code> is inserted in\nthe group together with <code>\"Er\"</code>. The next match is of the <code>\"n\"</code>, making <code>\"a\"</code>\nthe next part to be returned. As the subexpression is bound to\nthe substring <code>\"n\"</code> in this case, the <code>\"n\"</code> is inserted into this group.\nThe last group consists of the rest of the string, as no more matches are found.</p>\n\n<p>All empty strings are per default removed from the end of the result list,\nthe semantics beeing that we split the string in as many parts as possible\nuntil we reach the end of the string. In effect this means that all empty\nstrings are stripped from the result list (or all empty groups if the group\noption is given). The <code>parts</code> option can be used to change this behaviour.\nLet's look at an example:</p>\n\n<pre><code>re:split(\"Erlang\",\"[lg]\",[{return,list}]).\n</code></pre>\n\n<p>The result will be::</p>\n\n<pre><code>[\"Er\",\"an\"]\n</code></pre>\n\n<p>as the matching of the \"g\" in the end effectively makes the matching reach\nthe end of the string. If we however say we want more parts:</p>\n\n<pre><code>re:split(\"Erlang\",\"[lg]\",[{return,list},{parts,3}]).\n</code></pre>\n\n<p>We will get the last part as well, even though there is only an empty string\nafter the last match (matching the <code>\"g\"</code>):</p>\n\n<pre><code>[\"Er\",\"an\",[]]\n</code></pre>\n\n<p>More than three parts are not possible with this indata, why:</p>\n\n<pre><code>re:split(\"Erlang\",\"[lg]\",[{return,list},{parts,4}]).\n</code></pre>\n\n<p>will give the same result. To specify that as many results as possible\nare to be returned, including any empty results at end, you can specify\ninfinity as the number of parts to return. Specifying 0 as the number of\nparts gives the default behaviour of returning all parts except empty\nparts at the end.</p>\n\n<p>If subexpressions are captured, empty subexpression matches at the end\nare also stripped from the result if <code>{parts, N}</code> is not specified.\nIf you are familiar with Perl, the default behaviour corresponds exactly\nto the Perl default, the <code>{parts, N}</code> where <code>N</code> is a positive integer\ncorresponds exactly to the Perl behaviour with a positive numerical\nthird parameter and the {parts, infinity} behaviour corresponds to that\nwhen the Perl routine is given a negative integer as the third parameter.</p>\n\n<p>Summary of options not previously described for the <code>re:run/3</code> function:</p>\n\n<ul>\n<li><p><code>{return, ReturnType}</code> <br />\nSpecifies how the parts of the original string are presented in\nthe result list. The possible types are:</p>\n\n<ul>\n<li><p><code>iodata</code> <br />\nThe variant of iodata() that gives the least copying of data with\nthe current implementation (often a binary, but don't depend on it).</p></li>\n<li><p><code>binary</code> <br />\nAll parts returned as binaries. </p></li>\n<li><p><code>list</code> <br />\nAll parts returned as lists of characters (\"strings\").</p></li>\n</ul></li>\n<li><p><code>group</code> <br />\nGroups together the part of the string with the parts of the string\nmatching the subexpressions of the regexp.</p>\n\n<p>The return value from the function will in this case be a <code>list()</code>\nof <code>list()</code>'s. Each sublist begins with the string picked out of\nthe subject string, followed by the parts matching each of\nthe subexpressions in order of occurence in the regular expression.</p></li>\n<li><p><code>{parts, N}</code> <br />\nSpecifies the number of parts the subject string is to be split into.</p>\n\n<p>The number of parts should be 0 for the default behaviour\n\"as many as there are, skipping empty parts at the end\", a positive\ninteger for a specific maximum on the number of parts and infinity for\nthe maximum number of parts possible, regardless of if the parts are\nempty strings at the end.</p></li>\n</ul>\n\n<h3>Supported string representations</h3>\n\n<p>As can be viewed in the manual excerpt, I suggest allowing both the\nregular expressions and the subject strings to be provided as\n<code>iodata()</code>, which means either binaries, lists or a mix of binaries\nand deep lists. When Unicode is not involved, this basically means a\nimplicit <code>iolist_to_binary()</code> when supplying data to the re module.</p>\n\n<h3>Further extensions</h3>\n\n<p>The following extensions are not yet implemented in the prototype, but\nshould be included in a final release:</p>\n\n<ul>\n<li><p>Unicode support. Unicode strings should be represented as suggested\nin <a href=\"/eeps/eep-0010\" title=\"EEP 10\">EEP 10</a>, which means either UTF-8 in binaries, lists of Unicode\ncharacters as integers, or a mix thereof. If the regular expression\nwas compiled for Unicode or a <code>unicode</code> option is supplied when\ncompiling and running in one go, the data is expected to be in one\nof the supported Unicode formats, otherwise a <code>badarg</code> exception\nwill be thrown.</p></li>\n<li><p>Match predicates to make it easy to use regular expressions in\nlogical Erlang expressions.</p></li>\n</ul>\n\n<p>Of these, Unicode support is the far most important, and also the one\nthat can not be implemented efficiently purely in Erlang code.</p>\n\n<h2>Prototype implementation</h2>\n\n<p>A prototype implementation using the PCRE library is present along\nwith a reference manual page in the R12B-4 distribution. This\nimplementation does not yet fully support Unicode, as <a href=\"/eeps/eep-0010\" title=\"EEP 10\">EEP 10</a> is not\naccepted at the time of writing. The prototype implementation also \nlacks the \"split\" function, which was implemented after the R12B-4 release. </p>\n\n<p>In terms of performance, fairly simple regular expressions matches are\nwith this prototype up to 75 times faster than with the current regexp\nmodule. The bookkeeping to allow for interruptions of the regular\nexpression execution costs between 1 and 2% of the performance when no\nout scheduling is needed. In worst cases a 5% performance loss can be\nnoted compared to an untouched library, but then actual restarting is\ninvolved, so the numbers are not fully comparable.</p>\n\n<p>Compiling PCRE to use the C stack for recursive calls and avoid\nrestarting is expected to give the best results in terms of execution\nspeed. The difference in benchmarks to the fully interruptable version\nis however only in the range of 1 to 3% when no restarting occurs and\nstill no more than 6% when restarting actually occurs.</p>\n\n<p>The conclusion is that the extra cost imposed on the PCRE library to\nallow an integration into the Erlang emulator without using\nasynchronous threads is in an absolute worst scenario no more than 6%\ncompared to a theoretical maximum.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}