<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
Status: Final/R15B Proposal is implemented in OTP release R15B
Type: Standards Track
Created: 01-Mar-2011
Erlang-Version: R15A
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 36: <a href="eep-0036.md" title="EEP Source"> Line numbers in exceptions</a></h2>

<h1>Abstract</h1>

<p>Extend each entry in the call stack backtrace (hereafter called
<strong>stacktrace</strong>) returned from the <code>erlang:get_stacktrace/0</code> BIF and from the
<code>catch</code> operator with filenames and line number information.</p>

<h1>Specification</h1>

<p>Currently a stack trace returned from <code>erlang:get_stacktrace/0</code>
(and the <code>catch</code> operator) is a list of three-tuples, where
each tuple looks like:</p>

<pre><code>{Module,Function,Arity}
</code></pre>

<p>(In some cases, the third element may be a list of arguments instead
of the function arity.)</p>

<p>We propose to change each tuple to:</p>

<pre><code>{Module,Function,Arity,LocationInfo}
</code></pre>

<p><code>LocationInfo</code> is a property list (a list of two-tuples) that
contains filename and line number information. If there is
line number information available, the list will look like:</p>

<pre><code>[{file,FilenameString},{line,LineNumber}]
</code></pre>

<p>The list should be accessed using <code>proplists:get_value/3</code> or
<code>lists:keyfind/3</code>, not by direct matching, since a future release
may add more items to the list or change the order.</p>

<p>The filename is usually the same as the module with the extension
".erl" added, but if function definitions have been placed in a header
file, the filename will be the name of the header file.  The filename
will also be different if the Erlang source file has been generated by
a code generator such as yecc.</p>

<p>The line number will never be zero; instead <code>LocationInfo</code> will be
set to an empty list.</p>

<p>The list will be empty if there is no location information available.
Here are some reasons that location information may be missing:</p>

<ul>
<li><p>The module has been compiled with an older BEAM compiler that does
not support generation of line number information.</p></li>
<li><p>The module was created by calling <code>compile:forms/1,2</code> with forms
that did not contain non-zero line numbers and/or filenames.</p></li>
<li><p>A parse transform created abstract forms having the line number zero.</p></li>
<li><p>The module was created using an alternate compiler that did not
provide filenames and/or (non-zero) line numbers.</p></li>
<li><p>The line number information may have been stripped from
the BEAM file.</p></li>
<li><p>The exception occurs in a BIF (implemented in C in the run-time
system).</p></li>
</ul>

<h2>Implementation requirements</h2>

<p>This EEP does not specify exactly how line number information should
be implemented, but it does impose some requirements on the
implementation:</p>

<ul>
<li><p>The presence of line number information should have (virtually) no
impact on the execution time for a program if no exceptions occur.  In
practice, that means that an implementation is <em>not</em> allowed to add
extra instructions or BIF calls that will be executed when no
exception occurs.</p></li>
<li><p>Line number information should not be dependent on debug information
being present in the BEAM file.</p></li>
<li><p>Line number information should be included by default in BEAM files.
(There could be options to turn off the inclusion of line number
information.)</p></li>
<li><p>Loading line number information should be the default. There may be
an option to turn off loading of line number information in order to
save memory.</p></li>
</ul>

<h2>Example</h2>

<p>In the examples, we will use the following module:</p>

<pre><code>-module(example).
-export([m/1]).
-include("header.hrl").

m(L) -&gt;
    {ok,lists:map(fun f/1, L)}.  %Line 6
</code></pre>

<p>and the header file header.hrl:</p>

<pre><code>f(X) -&gt;
    abs(X) + 1.        %Line 2
</code></pre>

<p>Using R14B01 to call our example module, we get the following
result:</p>

<pre><code>1&gt; example:m([-1,0,1,2]).
{ok,[2,1,2,3]}
2&gt; example:m([-1,0,1,2,not_a_number]).
** exception error: bad argument
     in function  abs/1
        called as abs(not_a_number)
     in call from example:f/1
     in call from lists:map/2
     in call from lists:map/2
     in call from example:m/1
3&gt; catch example:m([-1,0,1,2,not_a_number]).
{'EXIT',{badarg,[{erlang,abs,[not_a_number]},
                 {example,f,1},
                 {lists,map,2},
                 {lists,map,2},
                 {example,m,1},
                 {erl_eval,do_apply,5},
                 {erl_eval,expr,5},
                 {shell,exprs,7}]}}
</code></pre>

<p>In a system with line number information enabled, we get:</p>

<pre><code>1&gt; example:m([-1,0,1,2]).             
{ok,[2,1,2,3]}
2&gt; example:m([-1,0,1,2,not_a_number]).
** exception error: bad argument
     in function  abs/1
        called as abs(not_a_number)
     in call from example:f/1 (header.hrl, line 2)
     in call from lists:map/2 (lists.erl, line 948)
     in call from lists:map/2 (lists.erl, line 948)
     in call from example:m/1 (example.erl, line 6)
3&gt; catch example:m([-1,0,1,2,not_a_number]).
{'EXIT',{badarg,[{erlang,abs,[not_a_number],[]},
                 {example,f,1,[{file,"header.hrl"},{line,2}]},
                 {lists,map,2,[{file,"lists.erl"},{line,948}]},
                 {lists,map,2,[{file,"lists.erl"},{line,948}]},
                 {example,m,1,[{file,"example.erl"},{line,6}]},
                 {erl_eval,do_apply,5,[{file,"erl_eval.erl"},{line,482}]},
                 {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,276}]},
                 {shell,exprs,7,[{file,"shell.erl"},{line,666}]}]}}
</code></pre>

<p>If we compile the <code>example</code> module using the BEAM compiler in R14B01,
there will not be any line number information for that module:</p>

<pre><code>1&gt; example:m([-1,0,1,2,not_a_number]).
** exception error: bad argument
     in function  abs/1
        called as abs(not_a_number)
     in call from example:f/1 
     in call from lists:map/2 (lists.erl, line 948)
     in call from lists:map/2 (lists.erl, line 948)
     in call from example:m/1 
2&gt; catch example:m([-1,0,1,2,not_a_number]).
{'EXIT',{badarg,[{erlang,abs,[not_a_number],[]},
                 {example,f,1,[]},
                 {lists,map,2,[{file,"lists.erl"},{line,948}]},
                 {lists,map,2,[{file,"lists.erl"},{line,948}]},
                 {example,m,1,[]},
                 {erl_eval,do_apply,5,[{file,"erl_eval.erl"},{line,482}]},
                 {erl_eval,expr,5,[{file,"erl_eval.erl"},{line,276}]},
                 {shell,exprs,7,[{file,"shell.erl"},{line,666}]}]}}
</code></pre>

<h1>Motivation</h1>

<p>The lack of line number information in exceptions is a major stumbling
block for many beginners, and is a time waster for experienced Erlang
programmers.</p>

<p>An often repeated piece of advice to mitigate the lack of line number
information is to write smaller functions.  To some extent, that is
good advice, but some functions are most naturally written as a single
function with many clauses.  One example is the <code>handle_call/3</code>
callback for a <code>gen_server</code> process.  Another example is test suites.
In a typical test suite, every line tests a condition and can
potentially fail.  It is not practical to put every line that may fail
in a separate function.</p>

<p>Test suites based on <code>common_test</code> are automatically run through a
parse transform that provides line number information when an
exception occurs.  The parse transform inserts before every line code
that saves the current function name and line number in the process
dictionary.  When an exception occurs, the line number can be
retrieved and presented.</p>

<p>One problem with this approach is that the test suite will run slower,
which can cause test cases to fail if timeouts expire in the system
being tested.  Another problem is that by default the parse transform
is only run on the test modules themselves, and therefore exceptions
that occur in other parts of the code (support libraries for testing
or the product itself) does not have any line information.</p>

<h1>Rationale</h1>

<p>We have chosen to let <code>erlang:get_stacktrace/0</code> and the <code>catch</code>
operator return stacktraces with filename and line number information
(instead of introducing a new function called, for example,
<code>erlang:get_full_stacktrace/3</code>).  That means that code that simply
passes on the stacktrace (to <code>erlang:raise/3</code>) does not need to be
updated.  For example, the following code that catches an exception,
logs it, and pass it on does not need to be updated:</p>

<pre><code>try
    some_call_that_may_fail()
catch
    Class:Reason -&gt;
        Stk = erlang:get_stacktrace(),
        log(Class, Reason, Stk),
        erlang:raise(Class, Reason, Stk)
end
</code></pre>

<p>One the other hand, that means that code that assumes that the
stacktrace only may contain three-tuples will no longer work and needs
to be updated.</p>

<p>There are several reasons for the requirement that the line number
information should be loaded by default (rather than ordered by
giving an option).</p>

<ul>
<li><p>In real systems, code size is usually not an issue since it is
overshadowed by the memory used for process heaps, off-heap binaries,
and ETS table.  Therefore, the 10 percent increase of the code size
(as measured in the reference implementation) is not an issue for
most users, but the benefit of having line number information is
potentially huge.</p></li>
<li><p>Newcomers to Erlang have the most need for line number information
and they should get it without giving any special option. If an option
is needed, questions to the mailing lists about how to find from which
source line an exception was caused will continue to waste time.</p></li>
<li><p>If an option must be given, even developers that know about it may
forget to give it and might therefore end up having to investigate an
exception without line number information. (Which may waste a lot of
time if the problem is not easily reproduce-able.)</p></li>
</ul>

<p>Therefore it is better that the developers that cannot afford any
increase in the size of the loaded code are the ones that must give an
option to turn off loading of line number information.</p>

<h1>Backwards Compatibility</h1>

<p>Applications that examine the stacktrace and assume that it contains
three-tuples must be updated. The <code>erlang:raise/3</code> BIF still accepts
three-tuples (it will translate those to four tuples with an empty
list in the fourth element); thus it is not mandatory to update calls
to <code>erlang:raise/3</code>.</p>

<h1>Implementation</h1>

<p>The reference implementation can be fetched from Github like this:</p>

<pre><code>git fetch git://github.com/bjorng/otp.git bjorn/line-numbers-in-exceptions
</code></pre>

<p>Here is an overview of the implementation:</p>

<p>The BEAM compiler inserts a <code>line</code> instruction before every construct
that may generate an exception and before every call that will be
included in the stacktrace. (Local tail-recursive calls need no <code>line</code>
instruction, but external tail-recursive calls need a <code>line</code>
instruction because they may be calls to BIFs.)</p>

<p>The <code>line</code> instruction has a single operand, an index into a line
number table.  The line number table is stored in the "Line" chunk in
the BEAM file.  The "Line" chunk and line instructions increase the
file size of BEAM files by about five percent.</p>

<p>The loader will remove the <code>line</code> instructions from the code that will
be executed, but will remember their location and create a table
sorted in address order mapping from program counter to line number
information.  When a stacktrace needs to be built, the run-time system
will do a binary search for the program counter of exception-causing
instruction and each continuation pointer.</p>

<p>For the benefit of embedded system that run in a very constrained
memory space, the run-time system can be started with the '+L' option
to disable loading of the line number information.  The code will
still be about one percent larger than code compiled without line
number information, because the compiler was unable to do code sharing
optimizations on instructions that cause exceptions (such as the
<code>badmatch</code> instruction).</p>

<p>In the current implementation, the line number information increases
the size of the loaded code by roughly ten percent.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0036","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Bj√∂rn Gustavsson \u0026lt;bjorn(at)erlang(dot)org\u0026gt;\nStatus: Final/R15B Proposal is implemented in OTP release R15B\nType: Standards Track\nCreated: 01-Mar-2011\nErlang-Version: R15A\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 36: \u003ca href=\"eep-0036.md\" title=\"EEP Source\"\u003e Line numbers in exceptions\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eExtend each entry in the call stack backtrace (hereafter called\n\u003cstrong\u003estacktrace\u003c/strong\u003e) returned from the \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e BIF and from the\n\u003ccode\u003ecatch\u003c/code\u003e operator with filenames and line number information.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eCurrently a stack trace returned from \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e\n(and the \u003ccode\u003ecatch\u003c/code\u003e operator) is a list of three-tuples, where\neach tuple looks like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{Module,Function,Arity}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e(In some cases, the third element may be a list of arguments instead\nof the function arity.)\u003c/p\u003e\n\n\u003cp\u003eWe propose to change each tuple to:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{Module,Function,Arity,LocationInfo}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eLocationInfo\u003c/code\u003e is a property list (a list of two-tuples) that\ncontains filename and line number information. If there is\nline number information available, the list will look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[{file,FilenameString},{line,LineNumber}]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe list should be accessed using \u003ccode\u003eproplists:get_value/3\u003c/code\u003e or\n\u003ccode\u003elists:keyfind/3\u003c/code\u003e, not by direct matching, since a future release\nmay add more items to the list or change the order.\u003c/p\u003e\n\n\u003cp\u003eThe filename is usually the same as the module with the extension\n\".erl\" added, but if function definitions have been placed in a header\nfile, the filename will be the name of the header file.  The filename\nwill also be different if the Erlang source file has been generated by\na code generator such as yecc.\u003c/p\u003e\n\n\u003cp\u003eThe line number will never be zero; instead \u003ccode\u003eLocationInfo\u003c/code\u003e will be\nset to an empty list.\u003c/p\u003e\n\n\u003cp\u003eThe list will be empty if there is no location information available.\nHere are some reasons that location information may be missing:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eThe module has been compiled with an older BEAM compiler that does\nnot support generation of line number information.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe module was created by calling \u003ccode\u003ecompile:forms/1,2\u003c/code\u003e with forms\nthat did not contain non-zero line numbers and/or filenames.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eA parse transform created abstract forms having the line number zero.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe module was created using an alternate compiler that did not\nprovide filenames and/or (non-zero) line numbers.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe line number information may have been stripped from\nthe BEAM file.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe exception occurs in a BIF (implemented in C in the run-time\nsystem).\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eImplementation requirements\u003c/h2\u003e\n\n\u003cp\u003eThis EEP does not specify exactly how line number information should\nbe implemented, but it does impose some requirements on the\nimplementation:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eThe presence of line number information should have (virtually) no\nimpact on the execution time for a program if no exceptions occur.  In\npractice, that means that an implementation is \u003cem\u003enot\u003c/em\u003e allowed to add\nextra instructions or BIF calls that will be executed when no\nexception occurs.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eLine number information should not be dependent on debug information\nbeing present in the BEAM file.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eLine number information should be included by default in BEAM files.\n(There could be options to turn off the inclusion of line number\ninformation.)\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eLoading line number information should be the default. There may be\nan option to turn off loading of line number information in order to\nsave memory.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eExample\u003c/h2\u003e\n\n\u003cp\u003eIn the examples, we will use the following module:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-module(example).\n-export([m/1]).\n-include(\"header.hrl\").\n\nm(L) -\u0026gt;\n    {ok,lists:map(fun f/1, L)}.  %Line 6\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand the header file header.hrl:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(X) -\u0026gt;\n    abs(X) + 1.        %Line 2\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUsing R14B01 to call our example module, we get the following\nresult:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; example:m([-1,0,1,2]).\n{ok,[2,1,2,3]}\n2\u0026gt; example:m([-1,0,1,2,not_a_number]).\n** exception error: bad argument\n     in function  abs/1\n        called as abs(not_a_number)\n     in call from example:f/1\n     in call from lists:map/2\n     in call from lists:map/2\n     in call from example:m/1\n3\u0026gt; catch example:m([-1,0,1,2,not_a_number]).\n{'EXIT',{badarg,[{erlang,abs,[not_a_number]},\n                 {example,f,1},\n                 {lists,map,2},\n                 {lists,map,2},\n                 {example,m,1},\n                 {erl_eval,do_apply,5},\n                 {erl_eval,expr,5},\n                 {shell,exprs,7}]}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn a system with line number information enabled, we get:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; example:m([-1,0,1,2]).             \n{ok,[2,1,2,3]}\n2\u0026gt; example:m([-1,0,1,2,not_a_number]).\n** exception error: bad argument\n     in function  abs/1\n        called as abs(not_a_number)\n     in call from example:f/1 (header.hrl, line 2)\n     in call from lists:map/2 (lists.erl, line 948)\n     in call from lists:map/2 (lists.erl, line 948)\n     in call from example:m/1 (example.erl, line 6)\n3\u0026gt; catch example:m([-1,0,1,2,not_a_number]).\n{'EXIT',{badarg,[{erlang,abs,[not_a_number],[]},\n                 {example,f,1,[{file,\"header.hrl\"},{line,2}]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {example,m,1,[{file,\"example.erl\"},{line,6}]},\n                 {erl_eval,do_apply,5,[{file,\"erl_eval.erl\"},{line,482}]},\n                 {erl_eval,expr,5,[{file,\"erl_eval.erl\"},{line,276}]},\n                 {shell,exprs,7,[{file,\"shell.erl\"},{line,666}]}]}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf we compile the \u003ccode\u003eexample\u003c/code\u003e module using the BEAM compiler in R14B01,\nthere will not be any line number information for that module:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; example:m([-1,0,1,2,not_a_number]).\n** exception error: bad argument\n     in function  abs/1\n        called as abs(not_a_number)\n     in call from example:f/1 \n     in call from lists:map/2 (lists.erl, line 948)\n     in call from lists:map/2 (lists.erl, line 948)\n     in call from example:m/1 \n2\u0026gt; catch example:m([-1,0,1,2,not_a_number]).\n{'EXIT',{badarg,[{erlang,abs,[not_a_number],[]},\n                 {example,f,1,[]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {example,m,1,[]},\n                 {erl_eval,do_apply,5,[{file,\"erl_eval.erl\"},{line,482}]},\n                 {erl_eval,expr,5,[{file,\"erl_eval.erl\"},{line,276}]},\n                 {shell,exprs,7,[{file,\"shell.erl\"},{line,666}]}]}}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThe lack of line number information in exceptions is a major stumbling\nblock for many beginners, and is a time waster for experienced Erlang\nprogrammers.\u003c/p\u003e\n\n\u003cp\u003eAn often repeated piece of advice to mitigate the lack of line number\ninformation is to write smaller functions.  To some extent, that is\ngood advice, but some functions are most naturally written as a single\nfunction with many clauses.  One example is the \u003ccode\u003ehandle_call/3\u003c/code\u003e\ncallback for a \u003ccode\u003egen_server\u003c/code\u003e process.  Another example is test suites.\nIn a typical test suite, every line tests a condition and can\npotentially fail.  It is not practical to put every line that may fail\nin a separate function.\u003c/p\u003e\n\n\u003cp\u003eTest suites based on \u003ccode\u003ecommon_test\u003c/code\u003e are automatically run through a\nparse transform that provides line number information when an\nexception occurs.  The parse transform inserts before every line code\nthat saves the current function name and line number in the process\ndictionary.  When an exception occurs, the line number can be\nretrieved and presented.\u003c/p\u003e\n\n\u003cp\u003eOne problem with this approach is that the test suite will run slower,\nwhich can cause test cases to fail if timeouts expire in the system\nbeing tested.  Another problem is that by default the parse transform\nis only run on the test modules themselves, and therefore exceptions\nthat occur in other parts of the code (support libraries for testing\nor the product itself) does not have any line information.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eWe have chosen to let \u003ccode\u003eerlang:get_stacktrace/0\u003c/code\u003e and the \u003ccode\u003ecatch\u003c/code\u003e\noperator return stacktraces with filename and line number information\n(instead of introducing a new function called, for example,\n\u003ccode\u003eerlang:get_full_stacktrace/3\u003c/code\u003e).  That means that code that simply\npasses on the stacktrace (to \u003ccode\u003eerlang:raise/3\u003c/code\u003e) does not need to be\nupdated.  For example, the following code that catches an exception,\nlogs it, and pass it on does not need to be updated:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etry\n    some_call_that_may_fail()\ncatch\n    Class:Reason -\u0026gt;\n        Stk = erlang:get_stacktrace(),\n        log(Class, Reason, Stk),\n        erlang:raise(Class, Reason, Stk)\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOne the other hand, that means that code that assumes that the\nstacktrace only may contain three-tuples will no longer work and needs\nto be updated.\u003c/p\u003e\n\n\u003cp\u003eThere are several reasons for the requirement that the line number\ninformation should be loaded by default (rather than ordered by\ngiving an option).\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIn real systems, code size is usually not an issue since it is\novershadowed by the memory used for process heaps, off-heap binaries,\nand ETS table.  Therefore, the 10 percent increase of the code size\n(as measured in the reference implementation) is not an issue for\nmost users, but the benefit of having line number information is\npotentially huge.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eNewcomers to Erlang have the most need for line number information\nand they should get it without giving any special option. If an option\nis needed, questions to the mailing lists about how to find from which\nsource line an exception was caused will continue to waste time.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf an option must be given, even developers that know about it may\nforget to give it and might therefore end up having to investigate an\nexception without line number information. (Which may waste a lot of\ntime if the problem is not easily reproduce-able.)\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTherefore it is better that the developers that cannot afford any\nincrease in the size of the loaded code are the ones that must give an\noption to turn off loading of line number information.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eApplications that examine the stacktrace and assume that it contains\nthree-tuples must be updated. The \u003ccode\u003eerlang:raise/3\u003c/code\u003e BIF still accepts\nthree-tuples (it will translate those to four tuples with an empty\nlist in the fourth element); thus it is not mandatory to update calls\nto \u003ccode\u003eerlang:raise/3\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eImplementation\u003c/h1\u003e\n\n\u003cp\u003eThe reference implementation can be fetched from Github like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003egit fetch git://github.com/bjorng/otp.git bjorn/line-numbers-in-exceptions\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHere is an overview of the implementation:\u003c/p\u003e\n\n\u003cp\u003eThe BEAM compiler inserts a \u003ccode\u003eline\u003c/code\u003e instruction before every construct\nthat may generate an exception and before every call that will be\nincluded in the stacktrace. (Local tail-recursive calls need no \u003ccode\u003eline\u003c/code\u003e\ninstruction, but external tail-recursive calls need a \u003ccode\u003eline\u003c/code\u003e\ninstruction because they may be calls to BIFs.)\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eline\u003c/code\u003e instruction has a single operand, an index into a line\nnumber table.  The line number table is stored in the \"Line\" chunk in\nthe BEAM file.  The \"Line\" chunk and line instructions increase the\nfile size of BEAM files by about five percent.\u003c/p\u003e\n\n\u003cp\u003eThe loader will remove the \u003ccode\u003eline\u003c/code\u003e instructions from the code that will\nbe executed, but will remember their location and create a table\nsorted in address order mapping from program counter to line number\ninformation.  When a stacktrace needs to be built, the run-time system\nwill do a binary search for the program counter of exception-causing\ninstruction and each continuation pointer.\u003c/p\u003e\n\n\u003cp\u003eFor the benefit of embedded system that run in a very constrained\nmemory space, the run-time system can be started with the '+L' option\nto disable loading of the line number information.  The code will\nstill be about one percent larger than code compiled without line\nnumber information, because the compiler was unable to do code sharing\noptimizations on instructions that cause exceptions (such as the\n\u003ccode\u003ebadmatch\u003c/code\u003e instruction).\u003c/p\u003e\n\n\u003cp\u003eIn the current implementation, the line number information increases\nthe size of the loaded code by roughly ten percent.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0036"},"buildId":"NPm6cMGILpqRmaNHZXj9d","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/NPm6cMGILpqRmaNHZXj9d/_buildManifest.js" async=""></script><script src="/_next/static/NPm6cMGILpqRmaNHZXj9d/_ssgManifest.js" async=""></script></body></html>