<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Per Gustafsson &lt;pergu(at)it(dot)uu(dot)se&gt;
Status: Final/R12B-0 Proposal is implemented in OTP release R12B-0
Type: Standards Track
Created: 10-Aug-2007
Erlang-Version: R12B-0
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 4: <a href="eep-0004.md" title="EEP Source"> New BIFs for bit-level binaries (bit strings)</a></h2>

<h1>Abstract</h1>

<p>This EEP describes the introduction of bit level binaries to the
Erlang programming language. They can be constructed and manipulated
using the bit syntax and  a new set of BIFs which operate on bit-level
binaries. These new BIFs are introduced in order to not alter the semantics of
existing BIFs which operate on binaries, but instead implement similar
operations for bit level binaries using new BIFs.</p>

<h1>Definitions</h1>

<p>A bit-level binary in this document called a <em>bit string</em> is a sequence of
bits of any length. A <em>binary</em> on the other hand is a sequence of bits
where the number of bits is evenly divisible by eight. These
definitions implies that any binary is also a bit string.</p>

<h1>Manipulating bit strings using the bit syntax</h1>

<p>A bit syntax expression: </p>

<p><code>&lt;&lt;Seg1,...,SegN&gt;&gt;</code> </p>

<p>Evaluates to a bit string, if the sum of the sizes of all segments in the
expression is divisible by eight the result is also a
binary. Previously such expression could only evaluate to binaries and
a runtime error was raised if this was not the case.</p>

<p>With this extension the expression <code>Bin = &lt;&lt;1:9&gt;&gt;</code> which previously caused a
runtime error now creates a 9-bit binary. To be able to use this
bit string to build a new bigger bit string we can write: </p>

<p><code>&lt;&lt;Bin/bitstring, 0:1&gt;&gt;</code></p>

<p>Note the use of bitstring as the type. This expands to binary-unit:1 where as
the binary type would have expanded to binary-unit:8. Since bitstring is a long
word to write in a binary pattern there is an alias <em>bits</em> which is used in the
rest of this proposal, similarily for binary there is a shorthand <em>bytes</em>.</p>

<p>To match out a bit-level binary we also use the bit string type as in ::</p>

<pre><code>case Bin of
  &lt;&lt;1:1,Rest/bits&gt;&gt; -&gt; Rest;
  &lt;&lt;0:1,_/bits&gt;&gt; -&gt; 0
end
</code></pre>

<p>This allows us to avoid situations were we would have to calculate
padding.        </p>

<h1>Specifications</h1>

<p><code>bitsize/1::bitstring() -&gt; integer()</code></p>

<p>Returns the size of a bit string in bits. This BIF is allowed in guards.</p>

<p><code>list_to_bitstring/1::bitstring_list() -&gt; bitstr()</code></p>

<p><code>bitstring_list = cons(char() | bitstring()| bitstring_list(), bitstring() | bitstring_list) | nil()</code></p>

<p>Concatenates the bit strings and chars in the bitstring_list to create a bit
string, each char becomes an 8-bit bit string.</p>

<p><code>is_bitstring/1::any() -&gt; bool()</code></p>

<p>Returns true if the argument is a bit string, otherwise it returns
false. This BIF is allowed in guards.</p>

<p><code>bitstring_to_list/1::bitstring() -&gt; [char()|bitstring()]</code></p>

<p>Turns a bit string into a list of characters and if the number of bits
in the bit string is not evenly divisible by eight the last element in
the list is a bit string consisting of the last 1-7 bits of the original
bit string.</p>

<h1>Rationale</h1>

<p>The current definition of binaries makes it complicated to use the bit
syntax for decoding when the format is not byte oriented, because the
programmer is always forced to pad the binaries that he is using to
become a sequence of bytes. Allowing bit-level binaries alleviates
this problem.</p>

<p>The new BIFs proposed here are intended to give programmers the same
tools to manipulate bit-level binaries as they are used to when
manipulating binaries without changing the semantics of already
existing BIFs and maintain properties such as if this statement:</p>

<p><code>is_binary(X) andalso size(X) =:= 0</code></p>

<p>evaluates to true then that implies that <code>X = &lt;&lt;&gt;&gt;</code>.</p>

<h1>Implementation</h1>

<p>The extensions described in this document are either already
implemented in R11B-4, but protected by a compiler switched or can be
easily implemented.</p>

<h1>Backwards Compatibility</h1>

<p>This change will not be entirely backward compatible for example:
<code>N=9, &lt;&lt;1:N&gt;&gt;</code> would cause an error in the old system and now it would
evaluate to a bit string. </p>

<p>The new BIFs are intended to give the same expressiveness for handling
bit-level binaries as we have for ordinary binaries without changing
the semantics of the BIFs for binaries such as size/1,
binary<em>to</em>list/1, list<em>to</em>binary/1 etc.. This means that all such BIFs
will throw an exception if their arguments contains bit strings.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0004","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Per Gustafsson \u0026lt;pergu(at)it(dot)uu(dot)se\u0026gt;\nStatus: Final/R12B-0 Proposal is implemented in OTP release R12B-0\nType: Standards Track\nCreated: 10-Aug-2007\nErlang-Version: R12B-0\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 4: \u003ca href=\"eep-0004.md\" title=\"EEP Source\"\u003e New BIFs for bit-level binaries (bit strings)\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP describes the introduction of bit level binaries to the\nErlang programming language. They can be constructed and manipulated\nusing the bit syntax and  a new set of BIFs which operate on bit-level\nbinaries. These new BIFs are introduced in order to not alter the semantics of\nexisting BIFs which operate on binaries, but instead implement similar\noperations for bit level binaries using new BIFs.\u003c/p\u003e\n\n\u003ch1\u003eDefinitions\u003c/h1\u003e\n\n\u003cp\u003eA bit-level binary in this document called a \u003cem\u003ebit string\u003c/em\u003e is a sequence of\nbits of any length. A \u003cem\u003ebinary\u003c/em\u003e on the other hand is a sequence of bits\nwhere the number of bits is evenly divisible by eight. These\ndefinitions implies that any binary is also a bit string.\u003c/p\u003e\n\n\u003ch1\u003eManipulating bit strings using the bit syntax\u003c/h1\u003e\n\n\u003cp\u003eA bit syntax expression: \u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026lt;\u0026lt;Seg1,...,SegN\u0026gt;\u0026gt;\u003c/code\u003e \u003c/p\u003e\n\n\u003cp\u003eEvaluates to a bit string, if the sum of the sizes of all segments in the\nexpression is divisible by eight the result is also a\nbinary. Previously such expression could only evaluate to binaries and\na runtime error was raised if this was not the case.\u003c/p\u003e\n\n\u003cp\u003eWith this extension the expression \u003ccode\u003eBin = \u0026lt;\u0026lt;1:9\u0026gt;\u0026gt;\u003c/code\u003e which previously caused a\nruntime error now creates a 9-bit binary. To be able to use this\nbit string to build a new bigger bit string we can write: \u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026lt;\u0026lt;Bin/bitstring, 0:1\u0026gt;\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eNote the use of bitstring as the type. This expands to binary-unit:1 where as\nthe binary type would have expanded to binary-unit:8. Since bitstring is a long\nword to write in a binary pattern there is an alias \u003cem\u003ebits\u003c/em\u003e which is used in the\nrest of this proposal, similarily for binary there is a shorthand \u003cem\u003ebytes\u003c/em\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo match out a bit-level binary we also use the bit string type as in ::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase Bin of\n  \u0026lt;\u0026lt;1:1,Rest/bits\u0026gt;\u0026gt; -\u0026gt; Rest;\n  \u0026lt;\u0026lt;0:1,_/bits\u0026gt;\u0026gt; -\u0026gt; 0\nend\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis allows us to avoid situations were we would have to calculate\npadding.        \u003c/p\u003e\n\n\u003ch1\u003eSpecifications\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode\u003ebitsize/1::bitstring() -\u0026gt; integer()\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eReturns the size of a bit string in bits. This BIF is allowed in guards.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003elist_to_bitstring/1::bitstring_list() -\u0026gt; bitstr()\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebitstring_list = cons(char() | bitstring()| bitstring_list(), bitstring() | bitstring_list) | nil()\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eConcatenates the bit strings and chars in the bitstring_list to create a bit\nstring, each char becomes an 8-bit bit string.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eis_bitstring/1::any() -\u0026gt; bool()\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eReturns true if the argument is a bit string, otherwise it returns\nfalse. This BIF is allowed in guards.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebitstring_to_list/1::bitstring() -\u0026gt; [char()|bitstring()]\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eTurns a bit string into a list of characters and if the number of bits\nin the bit string is not evenly divisible by eight the last element in\nthe list is a bit string consisting of the last 1-7 bits of the original\nbit string.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe current definition of binaries makes it complicated to use the bit\nsyntax for decoding when the format is not byte oriented, because the\nprogrammer is always forced to pad the binaries that he is using to\nbecome a sequence of bytes. Allowing bit-level binaries alleviates\nthis problem.\u003c/p\u003e\n\n\u003cp\u003eThe new BIFs proposed here are intended to give programmers the same\ntools to manipulate bit-level binaries as they are used to when\nmanipulating binaries without changing the semantics of already\nexisting BIFs and maintain properties such as if this statement:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eis_binary(X) andalso size(X) =:= 0\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eevaluates to true then that implies that \u003ccode\u003eX = \u0026lt;\u0026lt;\u0026gt;\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eImplementation\u003c/h1\u003e\n\n\u003cp\u003eThe extensions described in this document are either already\nimplemented in R11B-4, but protected by a compiler switched or can be\neasily implemented.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eThis change will not be entirely backward compatible for example:\n\u003ccode\u003eN=9, \u0026lt;\u0026lt;1:N\u0026gt;\u0026gt;\u003c/code\u003e would cause an error in the old system and now it would\nevaluate to a bit string. \u003c/p\u003e\n\n\u003cp\u003eThe new BIFs are intended to give the same expressiveness for handling\nbit-level binaries as we have for ordinary binaries without changing\nthe semantics of the BIFs for binaries such as size/1,\nbinary\u003cem\u003eto\u003c/em\u003elist/1, list\u003cem\u003eto\u003c/em\u003ebinary/1 etc.. This means that all such BIFs\nwill throw an exception if their arguments contains bit strings.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0004"},"buildId":"Ouo7gQeKiYSKAal9g8wsl","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/Ouo7gQeKiYSKAal9g8wsl/_buildManifest.js" async=""></script><script src="/_next/static/Ouo7gQeKiYSKAal9g8wsl/_ssgManifest.js" async=""></script></body></html>