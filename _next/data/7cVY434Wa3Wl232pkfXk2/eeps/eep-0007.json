{"pageProps":{"index":{"id":"0007","content":"<pre><code>Author: Alceste Scalas &lt;alceste(at)crs4(dot)it&gt;\nStatus: Draft\nType: Standards Track\nCreated: 3-Sep-2007\nErlang-Version: R12B\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 7: <a href=\"eep-0007.md\" title=\"EEP Source\"> Foreign Function Interface (FFI)</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP describes a Foreign Function Interface (FFI) for Erlang/OTP,\nthat allows to easily perform direct calls of external C functions.\nIt introduces three new BIFs (<code>ffi:raw_call/3</code>,\n<code>erl_ddll:load_library/3</code> and <code>ffi:raw_call/2</code>) that accomplish the main\nFFI tasks: loading generic C libraries, making external function calls\nand performing automatic Erlang-to-C and C-to-Erlang type conversions.</p>\n\n<p>It also introduces two auxiliary BIFs for converting C buffers/strings\ninto binaries (<code>ffi:raw_buffer_to_binary/2</code> and\n<code>ffi:raw_cstring_to_binary/1</code>), a new <code>ffi</code> Erlang module that\nprovides a higher-level API with stricter type checking, and some\nutility macros.  Finally, it extends <code>erl_ddll:info/2</code> with FFI\ninformation.</p>\n\n<h1>Motivation</h1>\n\n<p>The current Erlang extension mechanisms can be divided in two main\ncategories:</p>\n\n<ol>\n<li><p>absolute stability at the price of speed (C nodes, pipe drivers);</p></li>\n<li><p>more speed at the (potential) price of stability (linked-in\ndrivers).</p></li>\n</ol>\n\n<p>Linked-in drivers have thus become the standard way for creating\nlibrary bindings when efficiency is an issue.  In both cases, however,\nthe Erlang driver interface implies the development of relevant\namounts of glue code, mostly because the communication between Erlang\nand C always requires data parsing and (de)serialization.  Several\ntools have been created in order to autogenerate (at least part of)\nthat glue: from the (now unmaintained) <a href=\"http://www1.erlang.org/documentation/doc-4.8.2/lib/ig-1.8/doc/index.html\" title=\"IG: the Erlang Interface Generator, TÃ¶rnquist and Lundell\">IG driver generation tool</a>\nto the newer <a href=\"http://www.erlang.se/workshop/2002/Fritchie.pdf\" title=\"The Evolution of Erlang Drivers and the Erlang Driver Toolkit, Fritchie\">Erlang Driver Toolkit (EDTK)</a> and <a href=\"http://dryverl.objectweb.org/\" title=\"The Dryverl Erlang/C binding compiler\">Dryverl</a>.</p>\n\n<p>But, even with the help of these tools, developing an Erlang driver is\na difficult and time-consuming task (especially when interfacing\nexternal libraries with tens or hundreds of functions), and the glue\ncode itself increases the possibility to introduce bugs --- that, in\nthe case of linked-in drivers, usually mean VM crashes.  For all these\nreasons, the lack of libraries and the difficulty of interfacing them\nfrom other languages is one of the negative aspects that are usually\nassociated with Erlang.</p>\n\n<p>The same problems also arise when a developer needs to replace\nperformance-critical portions of his/her Erlang code with optimized C\nfunctions.  In this case, also the data serialization/deserialization\noverhead may be a significant issue.</p>\n\n<p>An easier method for interfacing Erlang and C code could drastically\nextend the Erlang capabilities and open new usage scenarios.</p>\n\n<h1>Rationale</h1>\n\n<p>This EEP proposes a Foreign Function Interface (FFI) extension that\nwould allow to easily perform direct C function calls.  This concept\nis implemented in almost every language, with two main (non-exclusive)\napproaches:</p>\n\n<ol>\n<li><p>automatic type conversions between the host and the foreign\nlanguage (examples: <a href=\"http://python.net/crew/theller/ctypes/\" title=\"The CPython package\">Python</a>, <a href=\"http://www.cse.unsw.edu.au/~chak/haskell/ffi/\" title=\"The Haskell 98 Foreign Function Interface\">Haskell</a>);</p></li>\n<li><p>documented C interface for handling host language types from the\nforeign language (examples: <a href=\"http://java.sun.com/j2se/1.5.0/docs/guide/jni/\" title=\"The Java Native Interface\">Java</a>, <a href=\"http://docs.python.org/ext/ext.html\" title=\"Extending and Embedding the Python Interpreter\">Python</a> <a href=\"http://docs.python.org/api/api.html\" title=\"Python/C API Reference Manual\">(API)</a>).</p></li>\n</ol>\n\n<p>This EEP follows the first approach, but (when possible) also reuses\npart of the existing C Driver API (and, thus, allows to manage\n<code>ErlDrvBinary</code> and <code>ErlIOVec</code> pointers in the external C\nfunctions).</p>\n\n<p>The FFI has been designed <em>not</em> to require language changes or\nintroduce incompatibilities.</p>\n\n<p>The BIFs and functions proposed in this EEP don't give any access to\nthe Erlang VM internals --- but the called C functions could leak\nmemory and/or cause the Erlang VM to crash.  The FFI is, thus, not\nintended for \"casual\" Erlang developers: this is a tool designed for\nlibrary bindings developers (that should take care of hiding FFI calls\nfrom final users), and advanced programmers looking for an easy (and\nefficient) way to call C code from Erlang.</p>\n\n<h1>Overview</h1>\n\n<p>In order to call a C function, the FFI needs a port opened towards the\nrequired C code.  Thus, with the current driver loading mechanism, a\ndeveloper would be required to:</p>\n\n<ol>\n<li><p>create a C file with a void <code>ErlDrvEntry</code> structure and driver\ninit function;</p></li>\n<li><p>compile it and possibly link it against the required C libraries,\nthus obtaining a void Erlang driver;</p></li>\n<li><p>load the driver in the Erlang VM, by using <code>erl_ddll:load/2</code>.</p></li>\n</ol>\n\n<p>In order to simplify this procedure, this EEP proposes the\n<code>erl_ddll:load_library/3</code> function, that allows to load a generic\nlibrary in the Erlang VM --- even if it lacks the structure of an\nErlang linked-in driver.</p>\n\n<p><code>erl_ddll:load_library/3</code> also offers an option to preload a list of C\nfunction symbols and signatures, thus precompiling the internal\nstructures needed for performing dynamic function calls.  Information\nabout preloaded data can be retrieved with <code>erl_ddll:info/2</code>.</p>\n\n<p>Once a library or driver has been loaded, <code>erlang:open_port/2</code> or\n<code>erlang:open_port/1</code> could be used to get a port for the FFI\nfunctions, and perform calls either through the low-level or the\nhigh-level APIs.</p>\n\n<h2>Low-level API</h2>\n\n<p>The low-level FFI methods are denoted by the <code>raw_</code> prefix.  The\nmain function is the <code>ffi:raw_call/3</code> BIF, that performs a direct C\nfunction call through an open port.  It converts C types to/from\nErlang types.</p>\n\n<p>When taken alone, <code>ffi:raw_call/3</code> has got a major drawback: it introduces\ngreat call overhead, due to the C symbol lookup and the dynamic\nconstruction of the function call.</p>\n\n<p>In order to exploit preloading option of <code>erl_ddll:load_library/3</code>, the\n<code>ffi:raw_call/2</code> BIF is introduced: it avoids symbol lookup and call\nstructure compilation, thus guaranteeing a lower call overhead than\n<code>ffi:raw_call/3</code>.</p>\n\n<p>Furthermore, the low-level interface provides two BIFs for creating an\nErlang binary from a C pointer (possibly returned by a FFI call).\nThese BIFs are <code>ffi:raw_buffer_to_binary/2</code> and\n<code>ffi:raw_cstring_to_binary/1</code>.</p>\n\n<h2>High-level API</h2>\n\n<p>The high-level interface is built upon the low-level one.  It\nintroduces the concept of type-tagged values: any value passed to or\nreturned from FFI calls has the form of a <code>{Type, Value}</code> tuple.  This\nallows to:</p>\n\n<ol>\n<li><p>increase the readability of FFI calls;</p></li>\n<li><p>make the C calls safer: the consistency of tagged values is checked\nbefore the values themselves are passed to the low-level API.\nFurthermore, the preload information given to\n<code>erl_ddll:load_library/3</code> is used (when available) to ensure that the\ntagged values actually match the function signature;</p></li>\n<li><p>simulate the static typing of C code, thus requiring proper and\nexplicit \"casts\" when a tagged value needs to be converted to\nanother type.</p></li>\n</ol>\n\n<p>These checks are performed by <code>ffi:call/3</code>, <code>ffi:buffer_to_binary/2</code>\nand <code>ffi:cstring_to_binary/1</code> (the type-tagged equivalents of the\nlow-level BIFs).  Type-tagged values can also be checked with\n<code>ffi:check/1</code>.  Furthermore, the allowed minimum and maximum value of\neach FFI type can be examined with <code>ffi:min/1</code> and <code>ffi:max/1</code>.</p>\n\n<h2>Utility macros</h2>\n\n<p>The FFI defines a series of utility macros in the <code>ffi_hardcodes.hrl</code>\nheader file, that could be used for binary matching of C buffers and\nstructures.</p>\n\n<h1>Specifications</h1>\n\n<h2>Types</h2>\n\n<h3><code>c_func_name()</code></h3>\n\n<pre><code>c_func_name() = atom() | string()\n</code></pre>\n\n<p>Name of a C function.</p>\n\n<h3><code>type_tag()</code></h3>\n\n<pre><code>type_tag() = atom()\n</code></pre>\n\n<p>Valid FFI type atom.  For the list of allowed values, see the\nAppendix.</p>\n\n<h3><code>tagged_value()</code></h3>\n\n<pre><code>tagged_value() = tuple(type_tag(), term())\n</code></pre>\n\n<p>Type-tagged value used for FFI calls.</p>\n\n<h3><code>tagged_func_name()</code></h3>\n\n<pre><code>tagged_func_name() = tuple(type_tag(), c_func_name())\n</code></pre>\n\n<p>C function name with return type.</p>\n\n<h3><code>func_index()</code></h3>\n\n<pre><code>func_index() = integer()\n</code></pre>\n\n<p>Function position on the list of preloads given to\n<code>erl_ddll:load_library/3</code>.</p>\n\n<h3><code>tagged_func_index()</code></h3>\n\n<pre><code>tagged_func_index() = tuple(type_tag(), func_index())\n</code></pre>\n\n<p>C function index with return type.</p>\n\n<h3><code>signature()</code></h3>\n\n<pre><code>signature() = tuple(type_tag(), ...)\n</code></pre>\n\n<p>Signature of a C function: return type followed by arguments types (if\nany).</p>\n\n<h2><code>erl_ddll:load_library/3</code></h2>\n\n<pre><code>erl_ddll:load_library(Path, Name,\n                      OptionsList) -&gt; ok | {error, ErrorDesc}\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><p><code>Path = Name = string() | atom()</code></p></li>\n<li><p><code>OptionList = [Option]</code></p></li>\n<li><p><code>Option = tuple(preload, [Preload])</code></p></li>\n<li><p><code>Preload = tuple(c_func_name(), signature())</code></p></li>\n</ul>\n\n<p>Load a generic shared library.</p>\n\n<p>If an <code>ErlDrvEntry</code> structure and a driver init function are found when\nloading the library, this BIF will behave like <code>erl_ddll:load/2</code>.  The\nfunction parameters are also the same of <code>erl_ddll:load/2</code>, with the\nfollowing addition:</p>\n\n<p><strong>OptionList</strong> is a list of options for library/driver loading.\nThe supported options are:</p>\n\n<ul>\n<li><p><strong><code>{preload, PreloadList}</code></strong>\nPreload the given list of functions, and prepare their\ncall structures.  Each PreloadList element is a tuple\nin the form:</p>\n\n<pre><code>tuple(c_func_name(), `signature())\n</code></pre>\n\n<p>i.e. the function name followed by its return and\narguments types.</p></li>\n</ul>\n\n<p>The function return values are the same of <code>erl_ddll:load/2</code>.</p>\n\n<p>Once a library has been loaded, it is possible to use\n<code>erlang:open_port/2</code> to get a port.  That port could <em>always</em> be used\nwith <code>ffi:call/3</code>, <code>ffi:raw_call/3</code> or <code>ffi:raw_call/2</code>.  However,\nif the loaded library does <em>not</em> contain a proper <code>ErlDrvEntry</code>\nstructure and a driver init function, the port will <strong>not</strong> be usable\nwith <code>erlang:port_command/2</code>, <code>erlang:port_control/3</code> etc.</p>\n\n<p>The following example loads the C standard library and preloads some\nfunctions: ::</p>\n\n<pre><code>ok = erl_ddll:load_library(\"/lib\", libc,\n                           [{preload,\n                             [{puts, {sint, nonnull}},\n                              {putchar, {sint, sint}},\n                              {malloc, {nonnull, size_t}},\n                              {free, {void, nonnull}}]}]).\n</code></pre>\n\n<h2><code>erl_ddll:load_library/2</code></h2>\n\n<pre><code>erl_ddll:load_library(Path, Name)\n</code></pre>\n\n<p>Utility function that calls <code>erl_ddll:load_library/3</code> with an empty\nOptionsList.</p>\n\n<h2><code>erlang:open_port/1</code></h2>\n\n<pre><code>erlang:open_port(Library)\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>Library = string() | atom()</code></li>\n</ul>\n\n<p>Open a port towards the specified shared library, possibly loaded with\n<code>erl_ddll:load_library/3</code>.  Calling this function is equivalent to:</p>\n\n<pre><code>erlang:open_port({spawn, Library}, [binary])\n</code></pre>\n\n<h2><code>erl_ddll:info/2</code></h2>\n\n<p>This EEP proposes a new parameter for the <code>erl_ddll:info/2</code> BIF: the\n'preloads' atom.  It allows to retrieve information about FFI preloads\nfor the given library.</p>\n\n<p>The preload information is a list of proplists, one for each preloaded\nfunction.  Each proplist, in turn, has the following format: </p>\n\n<pre><code>[ { index,     integer()   },     % Position in the preload list\n  { name,      string()    },     % Function name\n  { address,   integer()   },     % Function address\n  { signature, signature() } ]    % Function signature\n</code></pre>\n\n<p>This information would be made available also through <code>erl_ddll:info/0</code>\nand <code>erl_ddll:info/1</code>.</p>\n\n<h2><code>ffi:raw_call/3</code></h2>\n\n<pre><code>ffi:raw_call(Port, CallArgs, Signature) -&gt; term()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><p><code>Port = port()</code></p></li>\n<li><p><code>CallArgs = tuple(</code>c<em>func</em>name()<code>, Arg1, ...)</code></p></li>\n<li><p><code>Arg1, ... = term()</code></p></li>\n<li><p><code>Signature = signature()</code></p></li>\n</ul>\n\n<p>Call the specified C function.</p>\n\n<p>This BIF accepts the following parameters:</p>\n\n<ul>\n<li><p><strong>Port</strong></p>\n\n<p>A port opened towards the required driver/library.</p></li>\n<li><p><strong>CallArgs</strong></p>\n\n<p>A tuple with the function name (atom or string) followed by\nits arguments (if any).</p></li>\n<li><p><strong>Signature</strong></p>\n\n<p>Function signature.</p></li>\n</ul>\n\n<p>This BIF returns the return value of the C function being called (or\n'void' if the return type is void).  It automatically converts Erlang\nterms to/from C values.  The supported C types and conversions are\nreported in the Appendix.</p>\n\n<p>The following example calls the <code>malloc()</code> and <code>free()</code> functions from the\nstandard C library (it should work with any Erlang linked-in driver): ::</p>\n\n<pre><code>Pointer = ffi:raw_call(Port, {malloc, 1024}, {pointer, size_t}),\nok = ffi:raw_call(Port, {free, Pointer}, {void, pointer}).\n</code></pre>\n\n<p><strong>WARNING:</strong> bugs and/or misuses of the external C functions can\naffect the Erlang VM, possibly making it crash.  Use this BIF with\nextreme care.</p>\n\n<h2><code>ffi:raw_call/2</code></h2>\n\n<pre><code>ffi:raw_call(Port, OptimizedCall) -&gt; term()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><p><code>Port = port()</code></p></li>\n<li><p><code>OptimizedCall = {FuncIndex, Arg1, ...}</code></p></li>\n<li><p><code>FuncIndex = func_index()</code></p></li>\n<li><p><code>Arg1, ... = term()</code></p></li>\n</ul>\n\n<p>Call a function preloaded with the 'preload' option of\n<code>erl_ddll:load_library/3</code>.</p>\n\n<p>This BIF accepts the following parameters:</p>\n\n<ul>\n<li><p><strong>Port</strong></p>\n\n<p>A port opened towards the required driver/library (that\n<strong>must</strong> have been loaded with <code>erl_ddll:load_library/3</code>).</p></li>\n<li><p><strong>OptimizedCall</strong>\nA tuple with the function index (i.e. its position in\nthe preload list) followed by its arguments (if any).</p></li>\n</ul>\n\n<p>This BIF returns the return value of the C function being called (or\n'void' if the return type is void).  It automatically converts Erlang\nterms to/from C values.  The supported C types and conversions are\nreported in the Appendix.</p>\n\n<p>The following example calls <code>malloc()</code> and <code>free()</code>, after they have been\npreloaded with the code sample shown in <code>erl_ddll:load_library/3</code>:</p>\n\n<pre><code>Port = open_port({spawn, \"libc\"}, [binary]),\nPointer = ffi:raw_call(Port, {3, 1024}),\nffi:raw_call(Port, {4, Pointer})\n</code></pre>\n\n<p><strong>WARNING:</strong> bugs and/or misuses of the external C functions can\naffect the Erlang VM, possibly making it crash.  Use this BIF with\nextreme care.</p>\n\n<h2><code>ffi:raw_buffer_to_binary/2</code></h2>\n\n<pre><code>ffi:raw_buffer_to_binary(Pointer, Size) -&gt; binary()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><p><code>Pointer = integer()</code></p></li>\n<li><p><code>Size = integer()</code></p></li>\n</ul>\n\n<p>Return a binary with a copy of Size bytes read from the given C\npointer (represented by an integer, possibly returned by a FFI call).</p>\n\n<p><strong>WARNING:</strong> passing the wrong pointer to this BIF may cause the\nErlang VM to crash.  Use with extreme care.</p>\n\n<h2><code>ffi:raw_cstring_to_binary/1</code></h2>\n\n<pre><code>ffi:raw_cstring_to_binary(CString) -&gt; binary()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>CString = integer()</code></li>\n</ul>\n\n<p>Return a binary with a copy of the given NULL-terminated C string (an\ninteger representing a pointer, possibly returned by a FFI call).  The\nbinary will include the trailing 0.</p>\n\n<p><strong>WARNING:</strong> passing a wrong pointer to this BIF may cause the Erlang\nVM to crash.  Use with extreme care.</p>\n\n<h2><code>ffi:call/3</code></h2>\n\n<pre><code>call(Port, CFunc, Args) -&gt; RetVal\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><p><code>Port = port()</code></p></li>\n<li><p><code>CFunc = c_func_name() | func_index()\n| tagged_func_name()_ |</code>tagged<em>func</em>index()`</p></li>\n<li><p>`Args = [tagged_value()]</p></li>\n<li><p><code>RetVal = tagged_value()</code></p></li>\n</ul>\n\n<p>Call the C function <code>CFunc</code> with the given list of arguments, using\nthe port <code>Port</code>.  If the function was preloaded with\n<code>ffi:load_library/3</code>, all the type tags will be matched against the\npreloaded signature before performing the call.</p>\n\n<p>Return the return value of the C function, with the proper type tag.</p>\n\n<p><strong>Note:</strong> if <code>CFunc</code> is not of type <code>tagged_func_name()</code>, the C\nfunction will be called if and only if it was preloaded with\n<code>erl_ddll:load_library/3</code> (it is required in order to determine its\nreturn type).</p>\n\n<p>As an example, the following <code>malloc()</code> calls are all valid and\nequivalent when executed after the code sample shown in\n<code>erl_ddll:load_library/3</code>:</p>\n\n<pre><code>%% Use function name, but require preloads for return type\n{nonnull, Ptr1} = ffi:call(Port, \"malloc\", [{size_t, 1024}]),\n{nonnull, Ptr2} = ffi:call(Port, malloc, [{size_t, 1024}]),\n\n%% Use function index from preloads list\n{nonnull, Ptr3} = ffi:call(Port, 3, [{size_t, 1024}]),\n{nonnull, Ptr4} = ffi:call(Port, {nonnull, 3}, [{size_t, 1024}]),\n\n%% These calls do not require any preload information\n{nonnull, Ptr5} = ffi:call(Port, {nonnull, \"malloc\"}, [{size_t, 1024}]),\n{nonnull, Ptr6} = ffi:call(Port, {nonnull, malloc}, [{size_t, 1024}]),\n</code></pre>\n\n<p><strong>WARNING:</strong> bugs and/or misuses of the external C functions can\naffect the Erlang VM, possibly making it crash.  Use this BIF with\nextreme care.</p>\n\n<h2><code>ffi:buffer_to_binary/2</code></h2>\n\n<pre><code>ffi:buffer_to_binary(TaggedNonNull, Size) -&gt; binary()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><p><code>TaggedNonNull = tuple(nonnull, integer())</code></p></li>\n<li><p><code>Size: integer()</code></p></li>\n</ul>\n\n<p>Return a binary with a copy of <code>Size</code> bytes read from the given C\npointer.</p>\n\n<p><strong>WARNING:</strong> passing a wrong pointer to this function may cause the\nErlang VM to crash.  Use with extreme care.</p>\n\n<h2><code>ffi:cstring_to_binary/1</code></h2>\n\n<pre><code>ffi:cstring_to_binary(TaggedCString) -&gt; binary()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>TaggedCString = tuple(cstring, integer())</code></li>\n</ul>\n\n<p>Return a binary with a copy of the given NULL-terminated C string.</p>\n\n<p><strong>WARNING:</strong> passing a wrong pointer to this function may cause the\nErlang VM to crash.  Use with extreme care.</p>\n\n<h2><code>ffi:sizeof/1</code></h2>\n\n<pre><code>ffi:sizeof(TypeTag) -&gt; integer()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>TypeTag: type_tag()</code></li>\n</ul>\n\n<p>Return the size (in bytes) of the given FFI type, on the current\nplatform.</p>\n\n<h2><code>ffi:check/1</code></h2>\n\n<pre><code>ffi:check(TaggedValue) -&gt; true | false\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>TaggedValue = tagged_value()</code></li>\n</ul>\n\n<p>Returns 'true' if the given type-tagged value is well-formed and\nconsistent (i.e. it falls in the allowed range for its type, on the\ncurrent platform).  Otherwise, returns 'false'.</p>\n\n<h2><code>ffi:min/1</code></h2>\n\n<pre><code>ffi:min(TypeTag) -&gt; integer()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>TypeTag = type_tag()</code></li>\n</ul>\n\n<p>Return the minimum value allowed for the given FFI type, on the\ncurrent platform.</p>\n\n<h2><code>ffi:max/1</code></h2>\n\n<pre><code>ffi:max(TypeTag) -&gt; integer()\n</code></pre>\n\n<p>Types:</p>\n\n<ul>\n<li><code>TypeTag = type_tag()</code></li>\n</ul>\n\n<p>Return the maximum value allowed for the given FFI type, on the\ncurrent platform.</p>\n\n<h2><code>ffi_hardcodes.hrl</code></h2>\n\n<p>The <code>ffi_hardcodes.hrl</code> file is part of the Erlang ffi library.  It\ndefines a set of macros for handling FFI types sizes, and for easy\nbinary matching on C buffers and structures:</p>\n\n<ul>\n<li><p><strong><code>FFI_HARDCODED_&lt;TYPE&gt;</code></strong></p>\n\n<p>An Erlang bit-syntax snippet (Size/TypeSpecifier) that could\nbe used to match the given FFI type inside a binary (possibly\nobtained from a C buffer).  For example, the following binary\nmatching:</p>\n\n<pre><code>&lt;&lt;ULong:?FFI_HARDCODED_ULONG, _Rest/binary&gt;&gt; = Binary\n</code></pre>\n\n<p>on x86-64 will expand to:</p>\n\n<pre><code>&lt;&lt;ULong:64/native-unsigned-integer, _Rest/binary&gt;&gt; = Binary\n</code></pre></li>\n<li><p><strong><code>FFI_HARDCODED_SIZEOF_&lt;TYPE&gt;</code></strong></p>\n\n<p>The type size in <em>bytes</em></p></li>\n<li><p><strong><code>FFI_HARDCODED_&lt;TYPE&gt;_BITS</code></strong></p>\n\n<p>The type size in <em>bits</em></p></li>\n</ul>\n\n<p>As implied by their name, the <code>ffi_hardcodes.hrl</code> contents are\n<em>specific to the build platform</em>, and when they are used, they will be\nhard-coded in the resulting <code>.beam</code> files.  Thus, these macros\nshould be avoided if a developer expects his/her FFI-based code to be\n<em>portable without recompilation</em>.  The recommended method for getting\nFFI type sizes in a portable way is the <code>ffi:sizeof/1</code> function.</p>\n\n<h1>Further notes</h1>\n\n<h2>Notes on FFI preloading</h2>\n\n<p>When a library is loaded with <code>erl_ddll:load_library/3</code>, it may be\nreloaded or unloaded just like any Erlang linked-in driver.  If the\n'preload' option is used, then two additional behaviors arise:</p>\n\n<ul>\n<li><p>if <code>erl_ddll:load_library/3</code> is called two or more times with the\nsame library, then the associated preload list must be rebuilt\naccording to the last call.  If no 'preload' option is used, then\nthe last preloads (if any) must be kept intact;</p></li>\n<li><p>if an <code>erl_ddll:reload/2</code> is issued, then the last preloads must be\nrefreshed by performing a new symbol lookup in the loaded library.\nIf one or more symbols could not be found anymore, then they must be\ndisabled (and an error must raised when trying to use them with\n<code>ffi:raw_call/2</code>).</p></li>\n</ul>\n\n<h2>Notes on vararg functions</h2>\n\n<p><code>ffi:call/3</code> and <code>ffi:raw_call/3</code> may be used to call vararg C\nfunctions, simply by providing the desired number of arguments.</p>\n\n<p>In order to exploit the preloading optimizations, however, it is\nnecessary to use a different preload for each different function call\nsignature.  For example, if a developer is going to call <code>printf()</code>\nwith different arguments, he/she will need to use a preloading list\nlike the following one:</p>\n\n<pre><code>ok = erl_ddll:load_library(\"/lib\", libc,\n                           [{preload,\n                             [{printf, {sint, cstring}},\n                              {printf, {sint, cstring, double}},\n                              {printf, {sint, cstring, uint, sint}},\n                              {printf, {sint, cstring, cstring}}]}]).\n</code></pre>\n\n<h2>Notes on C pointers and Erlang binaries</h2>\n\n<p>As reported in the Appendix, an Erlang binary can be passed to a C\nfunction as a 'pointer' value.  In this case, the C function will\nreceive a pointer to the first byte of binary data.</p>\n\n<p>That pointer will be valid <em>only</em> until the C function returns.  If\nthe C side needs to access the pointer data later, then it should use\nthe 'binary' FFI type (see next paragraph) or copy the data itself in\na safe place.</p>\n\n<h2>Notes on Erlang binaries and reference counting</h2>\n\n<p>As reported in the Appendix, when the 'binary' FFI type is used as\nargument, the C function will also receive a binary (in the form of an\n<code>ErlDrvBinary</code> pointer).  Correspondingly, a C function with 'binary'\nFFI return type must return an <code>ErlDrvBinary</code> pointer.  Furthermore,\nan 'erliovec' argument type will cause the conversion of an Erlang\n<code>iolist()</code> into an <code>ErlIOVec</code> (and its pointer will be passed to\nthe C function).</p>\n\n<p>There are three rules for properly handling the refcount of binaries\npassed to, or returned from, the C side through a FFI call.</p>\n\n<ol>\n<li><p>when a binary is received as argument (either directly, or inside\nan <code>ErlIOVec</code>), and the C side needs to keep a reference, then\nthe refcount must be increased;</p></li>\n<li><p>when a binary is created with <code>driver_alloc_binary()</code>, it will\nhave the refcount value of 1.  It is considered to be <em>still</em>\nreferenced by the C side;</p></li>\n<li><p>as a consequence of the previous point, if the C side wants to\nreturn a newly-crated binary <em>without</em> keeping references, it must\ncall <code>driver_binary_dec_refc()</code> before returning.</p></li>\n</ol>\n\n<h2>Notes on type-tagged values</h2>\n\n<p>As reported above, the high-level FFI API is based on type-tagged\nvalues.  Type tags, however, may introduce yet another way to\nannotate/represent the types of Erlang function parameters --- and it\nmay become an annoying redundancy, expecially now that type <a href=\"http://user.it.uu.se/~kostis/Papers/contracts.pdf\" title=\"A Language for Specifying Type Contracts in Erlang and its Interaction with Success Typings, JimÃ©nez Lindahl and Sagonas (Presented at the 2007 SIGPLAN Erlang Workshop).\">contracts</a>\nare (probably) going to be introduced in Erlang.</p>\n\n<p>Thus, the high-level FFI API should be considered highly experimental\nand subject to change, depending on how type contracts will allow to\nachieve the same tasks (see [High-level API][]).  This issue will need\nto be explored if/when contracts will be available in the standard\nErlang/OTP distribution.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>This EEP, and the proposed FFI patches (see below), do not introduce\nincompatibilities with the standard OTP release.  However, three\n(possibly) relevant internal changes are required:</p>\n\n<ol>\n<li><p>the <code>driver_binary_dec_refc()</code> function must be allowed to\nreach the refcount of 0 without errors or warnings (even when\ndebugging).  This is necessary in order to allow a C function to\ncreate a binary, drop its references and return it to the Erlang VM\n(see 'Notes on Erlang binaries and reference counting');</p></li>\n<li><p>as a consequence of the previous point,\n<code>driver_binary_inc_refc()</code> must be allowed to reach a minimum\nrefcount of 1 without errors or warnings (the current minimum value\nis 2);</p></li>\n<li><p>the <code>iolist()</code> -> <code>ErlIOVec</code> conversion code in <code>io.c</code> needs\nto be exposed as a stand-alone function, to be used by the FFI.</p></li>\n</ol>\n\n<h1>Reference implementation</h1>\n\n<p>An implementation of this EEP is available on <a href=\"http://muvara.org/crs4/erlang/ffi\" title=\"Foreign Function Interface (FFI) for Erlang/OTP\">muvara.org</a>\nas a set of patches against OTP R11B-5.</p>\n\n<p>The code is based on the GCC FFI library <a href=\"http://gcc.gnu.org/viewcvs/trunk/libffi/\" title=\"libffi: the GCC Foreign Function Interface Library\">(libffi)</a>.  libffi is\nmulti-platform, can be packaged and used separately from the GCC\nsource code, and is released under a very permissive <a href=\"http://gcc.gnu.org/viewcvs/checkout/trunk/libffi/LICENSE\" title=\"The libffi license\">license</a>\n(compatible with the Erlang Public License).  It has been used to\nimplement the FFI interface of several applications and languages,\nincluding <a href=\"http://python.net/crew/theller/ctypes/\" title=\"The CPython package\">Python</a>.</p>\n\n<p>The current EEP implementation looks for libffi on the build system,\nand links the Erlang emulator against it (preferring the libffi shared\nlibrary, when available).  It may be a \"good enough\" approach, since\nlibffi is usually pre-packaged and easily available on GNU/Linux, BSD\nand Solaris distributions.  However, this approach may create troubles\nfor developers that compile everything from scratch, could not install\na precompiled libffi package, or just want to force static linking\nbetween the Erlang emulator and libffi.  In order to address these\nissues, it is customary that a copy of libffi is distributed together\nwith the host language, and possibly kept in sync with the upstream\nversion.  This is what Python actually does, and Erlang/OTP could\npossibly adopt the same approach depending on the developers'\nfeedback.</p>\n\n<h1>Appendix</h1>\n\n<h2>Erlang-to-C automatic type conversions</h2>\n\n<p>The following table reports the Erlang-to-C conversions, used for\npassing Erlang terms as C function call arguments.</p>\n\n<pre><code>====================== ===============================\n C argument type        Supported Erlang types\n====================== ===============================\nuchar                  integer()\nschar                  integer()\nushort                 integer()\nsshort                 integer()\nuint                   integer()\nsint                   integer()\nulong                  integer()\nslong                  integer()\nuint8                  integer()\nsint8                  integer()\nuint16                 integer()\nsint16                 integer()\nuint32                 integer()\nsint32                 integer()\nuint64                 integer()\nsint64                 integer()\nfloat                  float()\ndouble                 float()\nlongdouble             float()\npointer                binary() | integer()\ncstring                binary() | integer()\nnonnull                binary() | integer()\nsize_t                 integer()\nssize_t                integer()\npid_t                  integer()\noff_t                  integer()\nbinary                 binary()\nerliovec               iolist()\n====================== ===============================\n</code></pre>\n\n<h2>C-to-Erlang automatic type conversions</h2>\n\n<p>The following table reports the C-to-Erlang conversions, used for\nconverting C function return values into Erlang terms.</p>\n\n<pre><code>====================== ===============================\n C return type          Resulting Erlang type\n====================== ===============================\nuchar                  integer()\nschar                  integer()\nushort                 integer()\nsshort                 integer()\nuint                   integer()\nsint                   integer()\nulong                  integer()\nslong                  integer()\nuint8                  integer()\nsint8                  integer()\nuint16                 integer()\nsint16                 integer()\nuint32                 integer()\nsint32                 integer()\nuint64                 integer()\nsint64                 integer()\nfloat                  float()\ndouble                 float()\nlongdouble             float()\npointer                integer()\ncstring                integer()\nnonnull                integer()\nsize_t                 integer()\nssize_t                integer()\noff_t                  integer()\npid_t                  integer()\nbinary                 binary()\n====================== ===============================\n</code></pre>\n\n<h1>Copyright</h1>\n\n<p>Copyright (C) 2007 by CRS4 (Center for Advanced Studies, Research and\nDevelopment in Sardinia) - <a href=\"http://www.crs4.it/\">http://www.crs4.it/</a></p>\n\n<p>Author: Alceste Scalas <alceste (at) crs4 (dot) it></p>\n\n<p>This EEP is released under the terms of the Creative Commons\nAttribution 3.0 License. See <a href=\"http://creativecommons.org/licenses/by/3.0/\">http://creativecommons.org/licenses/by/3.0/</a></p>\n"}},"__N_SSG":true}