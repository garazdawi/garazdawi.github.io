<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/introducing-ssa/">Introduction to SSA</a></h3><p><em>Wednesday, 5 September 2018<!-- --> - <!-- -->Björn Gustavsson</em></p><p>This blog post is an introduction to the <a href="https://github.com/erlang/otp/pull/1935">new SSA-based intermediate
representation</a> that has recently been merged to the <code>master</code>
branch in the <a href="https://github.com/erlang/otp">Erlang/OTP repository</a>. It uses the same
example as in the <a href="http://blog.erlang.org/opt-traps-and-pitfalls/">previous blog post</a>, first looking at the
generated SSA code, and then at some optimizations.</p><p>Here again is the example function that does the kind of tuple matching
typically done when matching records:</p><pre><code class="language-erlang">foo({tag,A,_,_}) -&gt;
    {ok,A}.</code></pre><p>At the end of this blog post there will be section on <a href="#generating_listings">how to generate
listing files</a> to inspect the code from the
compiler passes.</p><h2>A brief introduction to the SSA intermediate format</h2><p>SSA stands for <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">Static Single Assignment</a>. Strictly speaking, SSA
is the property of an <a href="https://en.wikipedia.org/wiki/Intermediate_representation">intermediate representation</a> where
each variable is assigned exactly once, and where every variable is
defined before it is used. In this blog post, we will use the term
<em>SSA code</em> to refer to the new intermediate representation in the
Erlang compiler.</p><p>Here is the SSA code for the <code>foo/1</code> function:</p><pre><code>function blog:foo(_0) {
0:
  @ssa_bool:6 = bif:is_tuple _0
  br @ssa_bool:6, label 7, label 3

7:
  @ssa_arity = bif:tuple_size _0
  @ssa_bool:8 = bif:&#x27;=:=&#x27; @ssa_arity, literal 4
  br @ssa_bool:8, label 5, label 3

5:
  _8 = get_tuple_element _0, literal 0
  _7 = get_tuple_element _0, literal 1
  @ssa_bool = bif:&#x27;=:=&#x27; _8, literal tag
  br @ssa_bool, label 4, label 3

4:
  _9 = put_tuple literal ok, _7
  ret _9

3:
  _4 = put_list _0, literal []

  %% blog.erl:4
  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
  ret @ssa_ret:9

%% Unreachable blocks

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret
}</code></pre><h3>A deeper look at the example</h3><p>We will go through the code a few lines at the time.</p><pre><code>function blog:foo(_0) {</code></pre><p>This is the head of the function. It gives the module name (<code>blog</code>),
function name (<code>foo</code>), and the arguments (the single variable _0).</p><p>Variables named as <code>_</code> followed by an integer are inherited from
<a href="http://blog.erlang.org/core-erlang-by-example/">Core Erlang</a>. In OTP 22, variable names in Core Erlang
are integers (to avoid filling the atom table when compiling huge
functions).</p><pre><code>0:</code></pre><p>Following the function head is one or more <em>blocks</em> (sometimes called
<em>nodes</em>).  A integer followed by a colon gives the number of the block
that follows.</p><p>The block number <code>0</code> is special.  It is the first block that will be
executed in this function.</p><pre><code>  @ssa_bool:6 = bif:is_tuple _0</code></pre><p>Here is the first real instruction! All instructions have this
basic format. First there is a variable, followed by <code>=</code>, followed
by the name of the instruction, followed by its operands.</p><p>The variable to the left, <code>@ssa_bool:6</code> in this example, will be
assigned the value of the expression to right of the <code>=</code>.</p><p>Each variable can only be assigned once, just as in Erlang. The name
of this variable consists of two parts, the base part <code>@ssa_bool</code> and
the numeric suffix <code>6</code>. Whenever the base name itself is not unique,
the numeric suffix is added to make the name unique.</p><p>The instruction name is <code>bif:is_tuple</code>. This is one of the
instructions that use a two-part name.  The <code>bif</code> prefix means that
the second part must be the name of an Erlang guard BIF, in this case
<code>is_tuple/1</code>.</p><p>Following the name of the instruction is the operand <code>_0</code>, which is
the name of the function argument for the <code>foo/1</code> function.</p><p>Thus, this instruction will call <code>is_tuple/1</code> and assign the result
(either <code>true</code> or <code>false</code>) to <code>ssa_bool:6</code>.</p><pre><code>  br @ssa_bool:6, label 7, label 3</code></pre><p>This is the last instruction of block 0. Instructions at the end
of a block are called <em>terminators</em> and they have a different format
compared to instructions in the interior of a block. Terminators
either transfer control to another block or returns from the
function.</p><p><code>br</code> transfers control to another block. The first operand is a
variable, whose value must be <code>true</code> or <code>false</code>. If the value of
<code>ssa_bool:6</code> is <code>true</code>, the second operand (<code>label 7</code>) is used as the
block number for the block where execution will continue. In this
example: block 7. Similarly, if the value of <code>ssa_bool:6</code> is <code>false</code>,
the third operand (<code>label 3</code>) will be used to transfer control to
block 3.</p><pre><code>7:
  @ssa_arity = bif:tuple_size _0</code></pre><p>This is the beginning of block 7. This block will be executed
if <code>_0</code> was found to be a tuple. <code>@ssa_arity</code> will be assigned
the value of the call <code>tuple_size(_0)</code>.</p><p>Note that <code>@ssa_arity</code> does not have a numeric suffix, since there
is no other variable in this function having the same base name.</p><pre><code>  @ssa_bool:8 = bif:&#x27;=:=&#x27; @ssa_arity, literal 4</code></pre><p>Here <code>bif:=:=</code> compares <code>@ssa_arity</code> and <code>4</code> and assigns the
result to <code>@ssa_bool:8</code>. (Note that <code>=:=</code> is a guard BIF
in Erlang; it is allowed but unusual to write
<code>erlang:&#x27;=:=&#x27;(Arity, 4)</code> instead of <code>Arity =:= 4</code>.)</p><pre><code>  br @ssa_bool:8, label 5, label 3</code></pre><p>Here is another <code>br</code> instruction. It will transfer control to
block 5 if <code>@ssa_bool:8</code> is <code>true</code> (that is, if <code>@ssa_arity</code>
is equal to 4), and to block 3 otherwise.</p><pre><code>5:
  _8 = get_tuple_element _0, literal 0
  _7 = get_tuple_element _0, literal 1</code></pre><p>Block 5 is executed if <code>_0</code> has been found to be a tuple of
size 4. The <code>get_tuple_element</code> instruction extracts an element
from a tuple at the given position. The position is zero-based.</p><p>The <code>get_tuple_element</code> instruction in SSA in named after the
BEAM instruction with the same name:</p><pre><code>{get_tuple_element,{x,0},0,{x,1}}.</code></pre><p>Notice the similarity between the SSA instruction and the BEAM
instruction. The SSA form uses variables instead of registers,
and the destination variable is to the left of the <code>=</code> as in
all SSA instructions.</p><pre><code>  @ssa_bool = bif:&#x27;=:=&#x27; _8, literal tag
  br @ssa_bool, label 4, label 3</code></pre><p>Here comes the test that the first element of the tuple
is equal to the atom <code>tag</code>. If the first element is <code>tag</code>,
execution continues at block 4, otherwise at block 3.</p><pre><code>4:
  _9 = put_tuple literal ok, _7</code></pre><p>This instruction constructs the <code>{ok,A}</code> tuple. The variable <code>_7</code>
contains the second element of the tuple.</p><p>The <code>put_tuple</code> instruction takes any number of operands and
constructs a tuple from them. The result is assigned to the
variable <code>_9</code>.</p><p>In this case, the <code>put_tuple</code> instruction in SSA does more than the
corresponding BEAM instruction. To construct the same tuple, three
BEAM instructions are needed:</p><pre><code>{put_tuple,2,{x,0}}.
{put,{atom,ok}}.
{put,{x,2}}.</code></pre><p>Having a single instruction to construct a tuple instead of
the multiple BEAM instructions simplifies optimizations
immensely. Also note that SSA has no equivalent of the <code>test_heap</code>
instruction that caused so much trouble in the <a href="http://blog.erlang.org/opt-traps-and-pitfalls/">previous blog post</a>.</p><pre><code>  ret _9</code></pre><p><code>ret</code> is another terminator instruction. <code>ret</code> returns from the function
with the value of variable <code>_9</code> as the return value.</p><p>That concludes the successful path through the function.</p><pre><code>3:
  _4 = put_list _0, literal []

  %% blog.erl:4
  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
  ret @ssa_ret:9</code></pre><p>This block is executed if any of <code>br</code> instructions in the previous blocks
were given the value <code>false</code>, that is if the function argument was not a tuple or
had the wrong size or wrong first element.</p><p>The comment line (starting with <code>%%</code>) has been added by the pretty printer based on
annotation in the <code>call</code> instruction.</p><p>It is left as an exercise to the reader to figure out exactly what the
instructions in the block do.  As a hint, here is the code for the
block translated back to Erlang code:</p><pre><code class="language-erlang">erlang:error(function_clause, [_0]).</code></pre><p>Moving on to the part of the function that is not executed at all:</p><pre><code>%% Unreachable blocks

1:
  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg
  ret @ssa_ret</code></pre><p>The comment (<code>Unreachable blocks</code>) was added by the pretty printer to
indicate that the blocks that follow can never be executed, because no
block will ever branch to them.</p><p>Why is there an unreachable block?</p><p>Block 1 is a special block. It generates a <code>badarg</code> exeception, just
as a call to <code>error:error(badarg)</code>. The SSA code generator always
includes block 1 with the exact same instructions in every function,
even if it never actually used.</p><p>We will not go into details about the purpose of this block in this
blog post (but we will see how it is used in the next blog post).</p><h2>Optimizing the code</h2><p>Now it&#x27;s time to see how the SSA code can be optimized. The SSA
optimizations follow the same idea as the <a href="http://blog.erlang.org/core-erlang-optimizations/">Core Erlang
optimizations</a> of using many simple optimizations
working together rather than a few complicated optimizations.</p><p>Here is the code for the function again as it looks after running a few preliminary
optimization passes:</p><pre><code>function blog:foo(_0) {
0:
  @ssa_bool:6 = bif:is_tuple _0
  br @ssa_bool:6, label 7, label 3

7:
  @ssa_arity = bif:tuple_size _0
  @ssa_bool:8 = bif:&#x27;=:=&#x27; @ssa_arity, literal 4
  br @ssa_bool:8, label 5, label 3

5:
  _8 = get_tuple_element _0, literal 0
  _7 = get_tuple_element _0, literal 1
  @ssa_bool = bif:&#x27;=:=&#x27; _8, literal tag
  br @ssa_bool, label 4, label 3

4:
  _9 = put_tuple literal ok, _7
  ret _9

3:
  _4 = put_list _0, literal []
  br label 10

10:
  %% blog.erl:4
  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
  ret @ssa_ret:9
}</code></pre><p>The unreachable block 1 has been deleted.</p><p>A pass that <a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L100">splits blocks</a> before certain
instructions has also been run (in order to make the passes for
<a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L1025">sinking <code>get_tuple_element</code> instructions</a> and <a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L119">swapping
<code>element/2</code> calls</a> more effective). This pass has
split block 3 into two blocks. At the end of block 3 there is a
variant of the <code>br</code> terminator that we have not seen before.  <code>br label
10</code> unconditionally continues the execution at block 10.</p><p>The first interesting optimization for our example is the
<a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L194">ssa_opt_record</a> optimizations, which attempts to translate tuple
matching instructions with an <code>is_tagged_tuple</code> instruction.
Here is the part of the code that will be optimized:</p>&lt;pre class=&quot;highlight&quot;&gt;
    0:
      @ssa_bool:6 = bif:is_tuple _0
      br @ssa_bool:6, label 7, &lt;b&gt;label 3&lt;/b&gt;

    7:
      @ssa_arity = bif:tuple_size _0
      @ssa_bool:8 = bif:&#x27;=:=&#x27; @ssa_arity, &lt;b&gt;literal 4&lt;/b&gt;
      br @ssa_bool:8, label 5, &lt;b&gt;label 3&lt;/b&gt;

    5:
      _8 = get_tuple_element _0, literal 0
      @ssa_bool = bif:&#x27;=:=&#x27; _8, &lt;b&gt;literal tag&lt;/b&gt;
      br @ssa_bool, label 4, &lt;b&gt;label 3&lt;/b&gt;
&lt;/pre&gt;<p>The optimization is done in two stages. First the code is analyzed to find out
whether the optimization is applicable. There must be a test for a tuple of
a certain size (4 in this example) and with a certain first element
(<code>tag</code> in this example). Furthermore all failure labels must be the same.</p><p>If all conditions are fulfilled, the optimization is done in the second stage.
Here is the code again, with the optimized part of the code highlighted:</p>&lt;pre class=&quot;highlight&quot;&gt;
    function blog:foo(_0) {
    0:
      @ssa_bool:6 = &lt;b&gt;is_tagged_tuple _0, literal 4, literal tag&lt;/b&gt;
      br @ssa_bool:6, label 7, label 3

    7:
      @ssa_arity = bif:tuple_size _0
      @ssa_bool:8 = bif:&#x27;=:=&#x27; @ssa_arity, literal 4
      br @ssa_bool:8, label 5, label 3

    5:
      _8 = get_tuple_element _0, literal 0
      @ssa_bool = bif:&#x27;=:=&#x27; _8, literal tag
      br @ssa_bool, label 4, label 3

    4:
      _7 = get_tuple_element _0, literal 1
      _9 = put_tuple literal ok, _7
      ret _9

    3:
      _4 = put_list _0, literal []
      br label 10

    10:
      %% blog.erl:4
      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
      ret @ssa_ret:9
    }
&lt;/pre&gt;<p>Yes, it really is this simple, but so far it is more of a
<a href="https://stackoverflow.com/questions/32618848/what-is-pessimization">pessimization</a> than an optimization, because the <code>bif:is_tuple</code>
instruction has been replaced with the more expensive
<code>is_tagged_tuple</code> instruction.</p><p>The next optimization is a type analysis pass, which is implemented in
the module <a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_type.erl">beam_ssa_type</a>. Here is the code after running <code>beam_ssa_type</code>:</p>&lt;pre class=&quot;highlight&quot;&gt;
    function blog:foo(_0) {
    0:
      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag
      br @ssa_bool:6, label 7, label 3

    7:
      @ssa_arity = bif:tuple_size _0
      @ssa_bool:8 = bif:&#x27;=:=&#x27; &lt;b&gt;literal 4, literal 4&lt;/b&gt;
      &lt;b&gt;br label 5&lt;/b&gt;

    5:
      _8 = get_tuple_element _0, literal 0
      @ssa_bool = bif:&#x27;=:=&#x27; &lt;b&gt;literal tag, literal tag&lt;/b&gt;
      &lt;b&gt;br label 4&lt;/b&gt;

    4:
      _7 = get_tuple_element _0, literal 1
      _9 = put_tuple literal ok, _7
      ret _9

    3:
      _4 = put_list _0, literal []
      br label 10

    10:
      %% blog.erl:4
      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
      ret @ssa_ret:9
    }
&lt;/pre&gt;<p><code>beam_ssa_type</code> analyzes the code in execution order, remembering the
type of each variable seen. Based on the types, <code>beam_ssa_type</code> replaces
variables with known values with the values themselves.</p><p>Two of the conditional branchs have been converted to unconditional
branches.</p><p>The next optimization is <a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L683">liveness analysis</a>. The code
is scanned in reverse execution order, and if an expression is never
used, and has no observable side effect, it can be deleted. The
highlighted instructions in the code that follows was identified by
the liveness analysis pass as unused:</p>&lt;pre class=&quot;highlight&quot;&gt;
    function blog:foo(_0) {
    0:
      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag
      br @ssa_bool:6, label 7, label 3

    7:
      &lt;b&gt;@ssa_arity = bif:tuple_size _0&lt;/b&gt;
      &lt;b&gt;@ssa_bool:8 = bif:&#x27;=:=&#x27; literal 4, literal 4&lt;/b&gt;
      br label 5

    5:
      &lt;b&gt;_8 = get_tuple_element _0, literal 0&lt;/b&gt;
      &lt;b&gt;@ssa_bool = bif:&#x27;=:=&#x27; literal tag, literal tag&lt;/b&gt;
      br label 4

    4:
      _7 = get_tuple_element _0, literal 1
      _9 = put_tuple literal ok, _7
      ret _9

    3:
      _4 = put_list _0, literal []
      br label 10

    10:
      %% blog.erl:4
      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
      ret @ssa_ret:9
    }
&lt;/pre&gt;<p>Because those expressions don&#x27;t have any side effects, they can be deleted:</p>&lt;pre class=&quot;highlight&quot;&gt;
    function blog:foo(_0) {
    0:
      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag
      br @ssa_bool:6, label 7, label 3

    7:
      br label 5

    5:
      br label 4

    4:
      _7 = get_tuple_element _0, literal 1
      _9 = put_tuple literal ok, _7
      ret _9

    3:
      _4 = put_list _0, literal []
      br label 10

    10:
      %% blog.erl:4
      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
      ret @ssa_ret:9
    }
&lt;/pre&gt;<p>After running a pass that <a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L976">merges blocks</a>, the final code
looks like this:</p><pre><code>function blog:foo(_0) {
0:
  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag
  br @ssa_bool:6, label 5, label 3

5:
  _7 = get_tuple_element _0, literal 1
  _9 = put_tuple literal ok, _7
  ret _9

3:
  _4 = put_list _0, literal []

  %% blog.erl:4
  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4
  ret @ssa_ret:9
}</code></pre><p>Now it&#x27;s time to look at the resulting BEAM code. Here is the successful part of the
function:</p><pre><code>%% Block 0.
{test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.

%% Block 5.
{test_heap,3,1}.
{get_tuple_element,{x,0},1,{x,0}}.
{put_tuple,2,{x,1}}.
{put,{atom,ok}}.
{put,{x,0}}.
{move,{x,1},{x,0}}.
return.</code></pre><p>Since register allocation was done after the <code>is_tagged_tuple</code>
optimization, the <code>get_tuple_instruction</code> will extract the second
element of the tuple to the first available register, namely
<code>{x,0}</code>. That avoids any potential problem of registers being
undefined at a <code>test_heap</code> instruction. The <code>put_tuple</code> instruction
will put the built tuple into <code>{x,1}</code> since the following
<code>{put,{x,0}}</code> instruction still needs the contents of <code>{x,0}</code>. To
return the built tuple, the <code>{move,{x,1},{x,0}}</code> instruction just
before the <code>return</code> instruction copies the contents of <code>{x,1}</code>
to <code>{x,0}</code>.</p><p>It happens that for this particular example, the OTP 21 compiler will produce
slightly better code:</p>&lt;pre class=&quot;highlight&quot;&gt;
    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.
    {test_heap,3,1}.
    {get_tuple_element,{x,0},1,&lt;b&gt;{x,2}&lt;/b&gt;}.
    {put_tuple,2,&lt;b&gt;{x,0}&lt;/b&gt;}.
    {put,{atom,ok}}.
    {put,&lt;b&gt;{x,2}&lt;/b&gt;}.
    return.
&lt;/pre&gt;<p>(The tuple can be built to <code>{x,0}</code> directly, avoiding the <code>move</code>
instruction before the <code>return</code>.)</p><h2>Getting rid of the <code>move</code> instruction</h2><p>Perhaps I should have chosen another example to avoid revealing that
the SSA-based compiler sometimes produces worse code than the old
compiler.</p><p>Anyway, now that the secret is out, let&#x27;s see what can been done
about that extra <code>move</code> instruction.</p><p>Let&#x27;s look at another example:</p><pre><code class="language-erlang">make_tuple(A) -&gt;
    {ok,A}.</code></pre><p>The BEAM code produced by either the compiler in OTP 21
or the new SSA-based compiler looks like this:</p><pre><code>{test_heap,3,1}.
{put_tuple,2,{x,1}}.
{put,{atom,ok}}.
{put,{x,0}}.
{move,{x,1},{x,0}}.
return.</code></pre><p>Clearly, the way the tuple building instructions work, it would be
impossible to avoid the <code>move</code> instruction. When building a tuple, the
destination register for the built tuple must not be the same
as one of the source registers. It seems that we will need
better instructions for constructing tuples if we are to avoid
the <code>move</code> instruction.</p><p>The problem doesn&#x27;t exist when building a list:</p><pre><code>%% build_list(A) -&gt; [A].
{test_heap,2,1}.
{put_list,{x,0},nil,{x,0}}.
return.</code></pre><p>The <code>put_list</code> instruction can safely place the built list into the
same register as either of the source registers.</p><p>Introducing a new <code>put_tuple2</code> instruction that builds a tuple in a
single instruction, the <code>move</code> instruction can be eliminated:</p><pre><code>{test_heap,3,1}.
{put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.
return.</code></pre><p>At the time of writing, the implementation of <code>put_tuple2</code> has not yet
been merged to the <code>master</code> branch, but can be found in <a href="https://github.com/erlang/otp/pull/1947">#1947:
Introduce a put_tuple2 instruction</a>.</p><h2>Next time</h2><p>As we have seen, a variable in the SSA code can only be assigned
once (just as in Erlang). So how can the following code be
translated to SSA code?</p><pre><code>bar(X) -&gt;
    case X of
        none -&gt;
            Y = 0;
        _ -&gt;
            Y = X
    end,
    Y + 1.</code></pre><h2>&lt;a name=&quot;generating_listings&quot;&gt;<!-- -->&lt;/a&gt;<!-- -->How to generate listing files</h2><p>To generate the unoptimized SSA code for a module, use the <code>dssa</code> option:</p><pre><code>erlc +dssa blog.erl</code></pre><p>The SSA code will be pretty printed into the file <code>blog.ssa</code>.</p><p>Use the <code>dssaopt</code> option to generate the optimized SSA code, printing
it to the file <code>blog.ssaopt</code>.</p><pre><code>erlc +dssaopt blog.erl</code></pre><p>To see how the SSA code looked when not all optimization passes had been
run, I used variations of the following command line</p><pre><code>erlc +dssaopt +no_ssa_opt_type +no_ssa_opt_live +no_ssa_opt_merge_blocks blog.erl</code></pre><p>Those options are intentionally not documented. Skipping optimization
is only intended for debugging or exploring how the optimization
passes work. Skipping some optimizations passes that are actually
mandatory will crash the compiler.</p><p>To find the names of the options for skipping passes, see the <a href="https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L49">list of
sub passes of <code>beam_ssa_opt</code></a> and add <code>no_</code> to the name of the
pass.</p><p>To generate <code>blog.S</code> with the BEAM code, use the <code>-S</code> option:</p><pre><code>erlc -S blog.erl</code></pre><p>To skip all SSA optimizations, use the <code>no_ssa_opt</code> option:</p><pre><code>erlc +no_ssa_opt -S blog.erl</code></pre></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"introducing-ssa","title":"Introduction to SSA","author":"Björn Gustavsson","excerpt":"\nThis blog post is an introduction to the [new SSA-based intermediate\nrepresentation][pr1935] that has recently been merged to the `master`\nbranch in the [Erlang/OTP repository][otp]. It uses the same\nexample as in the [previous blog post][prev], first looking at the\ngenerated SSA code, and then at some optimizations.\n\n[pr1935]: https://github.com/erlang/otp/pull/1935,\n[pr1947]: https://github.com/erlang/otp/pull/1947,\n[otp]: https://github.com/erlang/otp,\n[intermediate]: https://en.wikipedia.org/wiki/Intermediate_representation,\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form,\n[prev]: http://blog.erlang.org/opt-traps-and-pitfalls/,\n[sys_core_fold]: http://blog.erlang.org/core-erlang-optimizations/,\n[pessimization]: https://stackoverflow.com/questions/32618848/what-is-pessimization,\n[core_erlang]: http://blog.erlang.org/core-erlang-by-example/,\n[passes]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L49,\n[ssa_opt_split_blocks]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L100,\n[ssa_opt_element]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L119,\n[ssa_opt_record]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L194,\n[ssa_opt_live]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L683,\n[ssa_opt_merge_blocks]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L976,\n[ssa_opt_sink]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L1025,\n[beam_ssa_type]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_type.erl","article_date":1536105600000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Introduction to SSA","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post is an introduction to the [new SSA-based intermediate\nrepresentation][pr1935] that has recently been merged to the `master`\nbranch in the [Erlang/OTP repository][otp]. It uses the same\nexample as in the [previous blog post][prev], first looking at the\ngenerated SSA code, and then at some optimizations.\n\nHere again is the example function that does the kind of tuple matching\ntypically done when matching records:\n\n```erlang\nfoo({tag,A,_,_}) -\u003e\n    {ok,A}.\n```\n\nAt the end of this blog post there will be section on [how to generate\nlisting files](#generating_listings) to inspect the code from the\ncompiler passes.\n\n## A brief introduction to the SSA intermediate format\n\nSSA stands for [Static Single Assignment][ssa]. Strictly speaking, SSA\nis the property of an [intermediate representation][intermediate] where\neach variable is assigned exactly once, and where every variable is\ndefined before it is used. In this blog post, we will use the term\n*SSA code* to refer to the new intermediate representation in the\nErlang compiler.\n\nHere is the SSA code for the `foo/1` function:\n\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = bif:is_tuple _0\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n\n%% Unreachable blocks\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\n### A deeper look at the example\n\nWe will go through the code a few lines at the time.\n\n```\nfunction blog:foo(_0) {\n```\n\nThis is the head of the function. It gives the module name (`blog`),\nfunction name (`foo`), and the arguments (the single variable _0).\n\nVariables named as `_` followed by an integer are inherited from\n[Core Erlang][core_erlang]. In OTP 22, variable names in Core Erlang\nare integers (to avoid filling the atom table when compiling huge\nfunctions).\n\n```\n0:\n```\n\nFollowing the function head is one or more *blocks* (sometimes called\n*nodes*).  A integer followed by a colon gives the number of the block\nthat follows.\n\nThe block number `0` is special.  It is the first block that will be\nexecuted in this function.\n\n```\n  @ssa_bool:6 = bif:is_tuple _0\n```\n\nHere is the first real instruction! All instructions have this\nbasic format. First there is a variable, followed by `=`, followed\nby the name of the instruction, followed by its operands.\n\nThe variable to the left, `@ssa_bool:6` in this example, will be\nassigned the value of the expression to right of the `=`.\n\nEach variable can only be assigned once, just as in Erlang. The name\nof this variable consists of two parts, the base part `@ssa_bool` and\nthe numeric suffix `6`. Whenever the base name itself is not unique,\nthe numeric suffix is added to make the name unique.\n\nThe instruction name is `bif:is_tuple`. This is one of the\ninstructions that use a two-part name.  The `bif` prefix means that\nthe second part must be the name of an Erlang guard BIF, in this case\n`is_tuple/1`.\n\nFollowing the name of the instruction is the operand `_0`, which is\nthe name of the function argument for the `foo/1` function.\n\nThus, this instruction will call `is_tuple/1` and assign the result\n(either `true` or `false`) to `ssa_bool:6`.\n\n```\n  br @ssa_bool:6, label 7, label 3\n```\n\nThis is the last instruction of block 0. Instructions at the end\nof a block are called *terminators* and they have a different format\ncompared to instructions in the interior of a block. Terminators\neither transfer control to another block or returns from the\nfunction.\n\n`br` transfers control to another block. The first operand is a\nvariable, whose value must be `true` or `false`. If the value of\n`ssa_bool:6` is `true`, the second operand (`label 7`) is used as the\nblock number for the block where execution will continue. In this\nexample: block 7. Similarly, if the value of `ssa_bool:6` is `false`,\nthe third operand (`label 3`) will be used to transfer control to\nblock 3.\n\n\n```\n7:\n  @ssa_arity = bif:tuple_size _0\n```\n\nThis is the beginning of block 7. This block will be executed\nif `_0` was found to be a tuple. `@ssa_arity` will be assigned\nthe value of the call `tuple_size(_0)`.\n\nNote that `@ssa_arity` does not have a numeric suffix, since there\nis no other variable in this function having the same base name.\n\n```\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n```\n\nHere `bif:=:=` compares `@ssa_arity` and `4` and assigns the\nresult to `@ssa_bool:8`. (Note that `=:=` is a guard BIF\nin Erlang; it is allowed but unusual to write\n`erlang:'=:='(Arity, 4)` instead of `Arity =:= 4`.)\n\n```\n  br @ssa_bool:8, label 5, label 3\n```\n\nHere is another `br` instruction. It will transfer control to\nblock 5 if `@ssa_bool:8` is `true` (that is, if `@ssa_arity`\nis equal to 4), and to block 3 otherwise.\n\n```\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n```\n\nBlock 5 is executed if `_0` has been found to be a tuple of\nsize 4. The `get_tuple_element` instruction extracts an element\nfrom a tuple at the given position. The position is zero-based.\n\nThe `get_tuple_element` instruction in SSA in named after the\nBEAM instruction with the same name:\n\n    {get_tuple_element,{x,0},0,{x,1}}.\n\nNotice the similarity between the SSA instruction and the BEAM\ninstruction. The SSA form uses variables instead of registers,\nand the destination variable is to the left of the `=` as in\nall SSA instructions.\n\n```\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n```\n\nHere comes the test that the first element of the tuple\nis equal to the atom `tag`. If the first element is `tag`,\nexecution continues at block 4, otherwise at block 3.\n\n```\n4:\n  _9 = put_tuple literal ok, _7\n```\n\nThis instruction constructs the `{ok,A}` tuple. The variable `_7`\ncontains the second element of the tuple.\n\nThe `put_tuple` instruction takes any number of operands and\nconstructs a tuple from them. The result is assigned to the \nvariable `_9`.\n\nIn this case, the `put_tuple` instruction in SSA does more than the\ncorresponding BEAM instruction. To construct the same tuple, three\nBEAM instructions are needed:\n\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n\nHaving a single instruction to construct a tuple instead of\nthe multiple BEAM instructions simplifies optimizations\nimmensely. Also note that SSA has no equivalent of the `test_heap`\ninstruction that caused so much trouble in the [previous blog post][prev].\n\n```\n  ret _9\n```\n\n`ret` is another terminator instruction. `ret` returns from the function\nwith the value of variable `_9` as the return value.\n\nThat concludes the successful path through the function.\n\n```\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n```\n\nThis block is executed if any of `br` instructions in the previous blocks\nwere given the value `false`, that is if the function argument was not a tuple or\nhad the wrong size or wrong first element.\n\nThe comment line (starting with `%%`) has been added by the pretty printer based on\nannotation in the `call` instruction.\n\nIt is left as an exercise to the reader to figure out exactly what the\ninstructions in the block do.  As a hint, here is the code for the\nblock translated back to Erlang code:\n\n```erlang\nerlang:error(function_clause, [_0]).\n```\n\nMoving on to the part of the function that is not executed at all:\n\n```\n%% Unreachable blocks\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n```\n\nThe comment (`Unreachable blocks`) was added by the pretty printer to\nindicate that the blocks that follow can never be executed, because no\nblock will ever branch to them.\n\nWhy is there an unreachable block?\n\nBlock 1 is a special block. It generates a `badarg` exeception, just\nas a call to `error:error(badarg)`. The SSA code generator always\nincludes block 1 with the exact same instructions in every function,\neven if it never actually used.\n\nWe will not go into details about the purpose of this block in this\nblog post (but we will see how it is used in the next blog post).\n\n## Optimizing the code\n\nNow it's time to see how the SSA code can be optimized. The SSA\noptimizations follow the same idea as the [Core Erlang\noptimizations][sys_core_fold] of using many simple optimizations\nworking together rather than a few complicated optimizations.\n\nHere is the code for the function again as it looks after running a few preliminary\noptimization passes:\n\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = bif:is_tuple _0\n  br @ssa_bool:6, label 7, label 3\n\n7:\n  @ssa_arity = bif:tuple_size _0\n  @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n  br @ssa_bool:8, label 5, label 3\n\n5:\n  _8 = get_tuple_element _0, literal 0\n  _7 = get_tuple_element _0, literal 1\n  @ssa_bool = bif:'=:=' _8, literal tag\n  br @ssa_bool, label 4, label 3\n\n4:\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n  br label 10\n\n10:\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\nThe unreachable block 1 has been deleted.\n\nA pass that [splits blocks][ssa_opt_split_blocks] before certain\ninstructions has also been run (in order to make the passes for\n[sinking `get_tuple_element` instructions][ssa_opt_sink] and [swapping\n`element/2` calls][ssa_opt_element] more effective). This pass has\nsplit block 3 into two blocks. At the end of block 3 there is a\nvariant of the `br` terminator that we have not seen before.  `br label\n10` unconditionally continues the execution at block 10.\n\nThe first interesting optimization for our example is the\n[ssa_opt_record] optimizations, which attempts to translate tuple\nmatching instructions with an `is_tagged_tuple` instruction.\nHere is the part of the code that will be optimized:\n\n\u003cpre class=\"highlight\"\u003e\n    0:\n      @ssa_bool:6 = bif:is_tuple _0\n      br @ssa_bool:6, label 7, \u003cb\u003elabel 3\u003c/b\u003e\n\n    7:\n      @ssa_arity = bif:tuple_size _0\n      @ssa_bool:8 = bif:'=:=' @ssa_arity, \u003cb\u003eliteral 4\u003c/b\u003e\n      br @ssa_bool:8, label 5, \u003cb\u003elabel 3\u003c/b\u003e\n\n    5:\n      _8 = get_tuple_element _0, literal 0\n      @ssa_bool = bif:'=:=' _8, \u003cb\u003eliteral tag\u003c/b\u003e\n      br @ssa_bool, label 4, \u003cb\u003elabel 3\u003c/b\u003e\n\u003c/pre\u003e\n\nThe optimization is done in two stages. First the code is analyzed to find out\nwhether the optimization is applicable. There must be a test for a tuple of\na certain size (4 in this example) and with a certain first element\n(`tag` in this example). Furthermore all failure labels must be the same.\n\nIf all conditions are fulfilled, the optimization is done in the second stage.\nHere is the code again, with the optimized part of the code highlighted:\n\n\u003cpre class=\"highlight\"\u003e\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = \u003cb\u003eis_tagged_tuple _0, literal 4, literal tag\u003c/b\u003e\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      @ssa_arity = bif:tuple_size _0\n      @ssa_bool:8 = bif:'=:=' @ssa_arity, literal 4\n      br @ssa_bool:8, label 5, label 3\n\n    5:\n      _8 = get_tuple_element _0, literal 0\n      @ssa_bool = bif:'=:=' _8, literal tag\n      br @ssa_bool, label 4, label 3\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n\u003c/pre\u003e\n\nYes, it really is this simple, but so far it is more of a\n[pessimization] than an optimization, because the `bif:is_tuple`\ninstruction has been replaced with the more expensive\n`is_tagged_tuple` instruction.\n\nThe next optimization is a type analysis pass, which is implemented in\nthe module [beam_ssa_type]. Here is the code after running `beam_ssa_type`:\n\n\u003cpre class=\"highlight\"\u003e\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      @ssa_arity = bif:tuple_size _0\n      @ssa_bool:8 = bif:'=:=' \u003cb\u003eliteral 4, literal 4\u003c/b\u003e\n      \u003cb\u003ebr label 5\u003c/b\u003e\n\n    5:\n      _8 = get_tuple_element _0, literal 0\n      @ssa_bool = bif:'=:=' \u003cb\u003eliteral tag, literal tag\u003c/b\u003e\n      \u003cb\u003ebr label 4\u003c/b\u003e\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n\u003c/pre\u003e\n\n`beam_ssa_type` analyzes the code in execution order, remembering the\ntype of each variable seen. Based on the types, `beam_ssa_type` replaces\nvariables with known values with the values themselves.\n\nTwo of the conditional branchs have been converted to unconditional\nbranches.\n\nThe next optimization is [liveness analysis][ssa_opt_live]. The code\nis scanned in reverse execution order, and if an expression is never\nused, and has no observable side effect, it can be deleted. The\nhighlighted instructions in the code that follows was identified by\nthe liveness analysis pass as unused:\n\n\u003cpre class=\"highlight\"\u003e\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      \u003cb\u003e@ssa_arity = bif:tuple_size _0\u003c/b\u003e\n      \u003cb\u003e@ssa_bool:8 = bif:'=:=' literal 4, literal 4\u003c/b\u003e\n      br label 5\n\n    5:\n      \u003cb\u003e_8 = get_tuple_element _0, literal 0\u003c/b\u003e\n      \u003cb\u003e@ssa_bool = bif:'=:=' literal tag, literal tag\u003c/b\u003e\n      br label 4\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n\u003c/pre\u003e\n\nBecause those expressions don't have any side effects, they can be deleted:\n\n\u003cpre class=\"highlight\"\u003e\n    function blog:foo(_0) {\n    0:\n      @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n      br @ssa_bool:6, label 7, label 3\n\n    7:\n      br label 5\n\n    5:\n      br label 4\n\n    4:\n      _7 = get_tuple_element _0, literal 1\n      _9 = put_tuple literal ok, _7\n      ret _9\n\n    3:\n      _4 = put_list _0, literal []\n      br label 10\n\n    10:\n      %% blog.erl:4\n      @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n      ret @ssa_ret:9\n    }\n\u003c/pre\u003e\n\nAfter running a pass that [merges blocks][ssa_opt_merge_blocks], the final code\nlooks like this:\n\n```\nfunction blog:foo(_0) {\n0:\n  @ssa_bool:6 = is_tagged_tuple _0, literal 4, literal tag\n  br @ssa_bool:6, label 5, label 3\n\n5:\n  _7 = get_tuple_element _0, literal 1\n  _9 = put_tuple literal ok, _7\n  ret _9\n\n3:\n  _4 = put_list _0, literal []\n\n  %% blog.erl:4\n  @ssa_ret:9 = call remote (literal erlang):(literal error)/2, literal function_clause, _4\n  ret @ssa_ret:9\n}\n```\n\nNow it's time to look at the resulting BEAM code. Here is the successful part of the\nfunction:\n\n    %% Block 0.\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n\n    %% Block 5.\n    {test_heap,3,1}.\n    {get_tuple_element,{x,0},1,{x,0}}.\n    {put_tuple,2,{x,1}}.\n    {put,{atom,ok}}.\n    {put,{x,0}}.\n    {move,{x,1},{x,0}}.\n    return.\n\nSince register allocation was done after the `is_tagged_tuple`\noptimization, the `get_tuple_instruction` will extract the second\nelement of the tuple to the first available register, namely\n`{x,0}`. That avoids any potential problem of registers being\nundefined at a `test_heap` instruction. The `put_tuple` instruction\nwill put the built tuple into `{x,1}` since the following\n`{put,{x,0}}` instruction still needs the contents of `{x,0}`. To\nreturn the built tuple, the `{move,{x,1},{x,0}}` instruction just\nbefore the `return` instruction copies the contents of `{x,1}`\nto `{x,0}`.\n\nIt happens that for this particular example, the OTP 21 compiler will produce\nslightly better code:\n\n\u003cpre class=\"highlight\"\u003e\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    {test_heap,3,1}.\n    {get_tuple_element,{x,0},1,\u003cb\u003e{x,2}\u003c/b\u003e}.\n    {put_tuple,2,\u003cb\u003e{x,0}\u003c/b\u003e}.\n    {put,{atom,ok}}.\n    {put,\u003cb\u003e{x,2}\u003c/b\u003e}.\n    return.\n\u003c/pre\u003e\n\n(The tuple can be built to `{x,0}` directly, avoiding the `move`\ninstruction before the `return`.)\n\n## Getting rid of the `move` instruction\n\nPerhaps I should have chosen another example to avoid revealing that\nthe SSA-based compiler sometimes produces worse code than the old\ncompiler.\n\nAnyway, now that the secret is out, let's see what can been done\nabout that extra `move` instruction.\n\nLet's look at another example:\n\n```erlang\nmake_tuple(A) -\u003e\n    {ok,A}.\n```\n\nThe BEAM code produced by either the compiler in OTP 21\nor the new SSA-based compiler looks like this:\n\n    {test_heap,3,1}.\n    {put_tuple,2,{x,1}}.\n    {put,{atom,ok}}.\n    {put,{x,0}}.\n    {move,{x,1},{x,0}}.\n    return.\n\nClearly, the way the tuple building instructions work, it would be\nimpossible to avoid the `move` instruction. When building a tuple, the\ndestination register for the built tuple must not be the same\nas one of the source registers. It seems that we will need\nbetter instructions for constructing tuples if we are to avoid\nthe `move` instruction.\n\nThe problem doesn't exist when building a list:\n\n    %% build_list(A) -\u003e [A].\n    {test_heap,2,1}.\n    {put_list,{x,0},nil,{x,0}}.\n    return.\n\nThe `put_list` instruction can safely place the built list into the\nsame register as either of the source registers.\n\nIntroducing a new `put_tuple2` instruction that builds a tuple in a\nsingle instruction, the `move` instruction can be eliminated:\n\n    {test_heap,3,1}.\n    {put_tuple2,{x,0},{list,[{atom,ok},{x,0}]}}.\n    return.\n\nAt the time of writing, the implementation of `put_tuple2` has not yet\nbeen merged to the `master` branch, but can be found in [#1947:\nIntroduce a put_tuple2 instruction][pr1947].\n\n## Next time\n\nAs we have seen, a variable in the SSA code can only be assigned\nonce (just as in Erlang). So how can the following code be\ntranslated to SSA code?\n\n```\nbar(X) -\u003e\n    case X of\n        none -\u003e\n            Y = 0;\n        _ -\u003e\n            Y = X\n    end,\n    Y + 1.\n```\n\n## \u003ca name=\"generating_listings\"\u003e\u003c/a\u003eHow to generate listing files\n\nTo generate the unoptimized SSA code for a module, use the `dssa` option:\n\n```\nerlc +dssa blog.erl\n```\n\nThe SSA code will be pretty printed into the file `blog.ssa`.\n\nUse the `dssaopt` option to generate the optimized SSA code, printing\nit to the file `blog.ssaopt`.\n\n```\nerlc +dssaopt blog.erl\n```\n\nTo see how the SSA code looked when not all optimization passes had been\nrun, I used variations of the following command line\n\n```\nerlc +dssaopt +no_ssa_opt_type +no_ssa_opt_live +no_ssa_opt_merge_blocks blog.erl\n```\n\nThose options are intentionally not documented. Skipping optimization\nis only intended for debugging or exploring how the optimization\npasses work. Skipping some optimizations passes that are actually\nmandatory will crash the compiler.\n\nTo find the names of the options for skipping passes, see the [list of\nsub passes of `beam_ssa_opt`][passes] and add `no_` to the name of the\npass.\n\nTo generate `blog.S` with the BEAM code, use the `-S` option:\n\n```\nerlc -S blog.erl\n```\n\nTo skip all SSA optimizations, use the `no_ssa_opt` option:\n\n```\nerlc +no_ssa_opt -S blog.erl\n```\n\n[pr1935]: https://github.com/erlang/otp/pull/1935\n[pr1947]: https://github.com/erlang/otp/pull/1947\n[otp]: https://github.com/erlang/otp\n[intermediate]: https://en.wikipedia.org/wiki/Intermediate_representation\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form\n[prev]: http://blog.erlang.org/opt-traps-and-pitfalls/\n[sys_core_fold]: http://blog.erlang.org/core-erlang-optimizations/\n[pessimization]: https://stackoverflow.com/questions/32618848/what-is-pessimization\n[core_erlang]: http://blog.erlang.org/core-erlang-by-example/\n\n[passes]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L49\n[ssa_opt_split_blocks]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L100\n[ssa_opt_element]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L119\n[ssa_opt_record]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L194\n[ssa_opt_live]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L683\n[ssa_opt_merge_blocks]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L976\n[ssa_opt_sink]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_opt.erl#L1025\n\n[beam_ssa_type]: https://github.com/erlang/otp/blob/869537a9bf799c8d12fc46c2b413e532d6e3b10c/lib/compiler/src/beam_ssa_type.erl\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"introducing-ssa"},"buildId":"gLD8MrZYLxdGHP5ltLIGn","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/gLD8MrZYLxdGHP5ltLIGn/_buildManifest.js" async=""></script><script src="/_next/static/gLD8MrZYLxdGHP5ltLIGn/_ssgManifest.js" async=""></script></body></html>