<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/core-erlang-by-example/">Core Erlang by Example</a></h3><p><em>Monday, 7 May 2018<!-- --> - <!-- -->Björn Gustavsson</em></p><p>This blog post is the first about the Core Erlang format. In this
blog post, we introduce the Core Erlang format through examples
that compare Erlang code to the corresponding Core Erlang
code.</p><p>I used the following command to translate my example module to
Core Erlang code:</p><pre><code>$ erlc +time +to_core core_example.erl
Compiling &quot;core_example&quot;
 parse_module                  :      0.000 s      10.8 kB
 transform_module              :      0.000 s      10.8 kB
 lint_module                   :      0.003 s      10.8 kB
 expand_records                :      0.000 s      10.8 kB
 core                          :      0.000 s      89.9 kB
 sys_core_fold                 :      0.000 s      58.6 kB
 core_transforms               :      0.000 s      58.6 kB
 listing                       :      0.002 s      58.6 kB</code></pre><p>The <a href="http://blog.erlang.org/compiler-lost-in-translation/">previous blog post</a>
explored the passes from <code>parse_module</code> to <code>expand_records</code>. The
<code>core</code> passes translates from the abstract code to Core Erlang. We
will talk more about the Core Erlang passes in future blog posts.</p><p>I have slightly edited the examples to make them somewhat easier to
read. There will be an unedited example at the very end of this blog post.</p><p>There&#x27;s a lot to cover, so let&#x27;s get started!</p><h2>The simplest function</h2><p>Let start with the simplest possible function, a function with no
arguments returning an atom:</p><pre><code class="language-erlang">simplest() -&gt; &#x27;ok&#x27;.</code></pre><p>In Core Erlang, that will be:</p><pre><code>&#x27;simplest&#x27;/0 =
    fun () -&gt;
	&#x27;ok&#x27;</code></pre><p>From that example, we can work out the following principles:</p><ul><li><p>Atoms are always quoted.</p></li><li><p>Naming of the function has been separated from implementation
of the function.</p></li><li><p>The body of a <code>fun</code> is not followed by an <code>end</code> as in Erlang.</p></li></ul><h2>Slightly less simple</h2><p>Here is as slightly more complicated function:</p><pre><code class="language-erlang">id(I) -&gt; I.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;id&#x27;/1 =
    fun (_@c0) -&gt;
	_@c0</code></pre><p><strong>Note</strong>: All examples were compiled with OTP 20. The name of the
generated variables will be different in the upcoming OTP 21.</p><p>Essentially, variables are named as in Erlang. In the translation
to Core Erlang, the compiler generates new variable names for the
arguments in a function head. The following code is also valid
Core Erlang:</p><pre><code>&#x27;id&#x27;/1 =
    fun (I) -&gt;
	I</code></pre><h2>More than one clause</h2><p>Here is a function with more than one clause:</p><pre><code class="language-erlang">a(42) -&gt; ok;
a(_) -&gt; error.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;a&#x27;/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;42&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  &lt;_@c2&gt; when &#x27;true&#x27; -&gt;
	      &#x27;error&#x27;
	end</code></pre><ul><li><p>A <code>fun</code> can only have a single clause.</p></li><li><p>Pattern matching must be done in a <code>case</code>, not in the <code>fun</code> head.</p></li><li><p>Guards are mandatory for each clause in a <code>case</code>.</p></li><li><p><code>_</code> is <strong>not</strong> a valid variable name in Core Erlang. Uninteresting
values must be bound to a new variable.</p></li><li><p>The <code>&lt;</code> and <code>&gt;</code> around the patterns will be explained soon.</p></li></ul><p>In Erlang, multiple function clauses can also be written with a
<code>case</code> like this:</p><pre><code class="language-erlang">b(N) -&gt;
    case N of
        42 -&gt; ok;
        _ -&gt; error
    end.</code></pre><p>The Core Erlang code will be essentially the same as the Core Erlang
code for <code>a/1</code>:</p><pre><code>&#x27;b&#x27;/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;42&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  &lt;_@c3&gt; when &#x27;true&#x27; -&gt;
	      &#x27;error&#x27;
	end</code></pre><h2>Two clauses, three arguments</h2><p>Let&#x27;s try multiple arguments:</p><pre><code class="language-erlang">c(inc, Base, N) -&gt;
    Base+N;
c(_, Base, _) -&gt;
    Base.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;c&#x27;/3 =
    fun (_@c2,_@c1,_@c0) -&gt;
	case &lt;_@c2,_@c1,_@c0&gt; of
	  &lt;&#x27;inc&#x27;,Base,N&gt; when &#x27;true&#x27; -&gt;
	      call &#x27;erlang&#x27;:&#x27;+&#x27;(Base, N)
	  &lt;_@c6,Base,_@c7&gt; when &#x27;true&#x27; -&gt;
	      Base
	end</code></pre><ul><li><p><code>&lt;</code> and <code>&gt;</code> denote a <strong>value list</strong>. The patterns in each clause in
the <code>case</code> are always part of a value list. The <code>case</code> expression is
a value list unless there is only one expression.</p></li><li><p>Operators such as <code>+</code> are not part of the Core Erlang language,
so the compiler has translated the use of <code>+</code> to a call to the
BIF <code>erlang:&#x27;+&#x27;/2</code>.</p></li></ul><h2>If</h2><p>Let&#x27;s see how <code>if</code> is implemented:</p><pre><code class="language-erlang">d(A, B) -&gt;
    if
        A &gt; B -&gt;
            greater;
        true -&gt;
            not_greater
    end.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;d&#x27;/2 =
    fun (_@c1,_@c0) -&gt;
	case &lt;&gt; of
	  &lt;&gt; when call &#x27;erlang&#x27;:&#x27;&gt;&#x27;(_@c1, _@c0) -&gt;
	      &#x27;greater&#x27;
	  &lt;&gt; when &#x27;true&#x27; -&gt;
	      &#x27;not_greater&#x27;
	end</code></pre><ul><li>The <code>case</code> expression and the patterns are each value lists with
zero elements. All the action is in the guards.</li></ul><h2>Repeated variables</h2><p>In Erlang, a variable can be repeated in a clause or within a
pattern to indicate that the values must be the same:</p><pre><code class="language-erlang">cmp(Same, Same) -&gt; same;
cmp(_, _) -&gt; different.</code></pre><p>Core Erlang does not allow repeating a variable:</p><pre><code>&#x27;cmp&#x27;/2 =
    fun (_@c1,_@c0) -&gt;
	case &lt;_@c1,_@c0&gt; of
	  &lt;Same,_@c4&gt; when call &#x27;erlang&#x27;:&#x27;=:=&#x27;(_@c4, Same) -&gt;
	      &#x27;same&#x27;
	  &lt;_@c5,_@c6&gt; when &#x27;true&#x27; -&gt;
	      &#x27;different&#x27;
	end</code></pre><ul><li>Here the second occurence of the variable <code>Same</code> has been renamed to
a new variable named <code>_@c4</code>, and a guard has been added to compare
<code>Same</code> and <code>_@c4</code>.</li></ul><h2>Exceptions</h2><p>This function will fail with a <code>function_clause</code> exception if it is called
with any other value than <code>42</code>:</p><pre><code class="language-erlang">e(42) -&gt; ok.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;e&#x27;/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;42&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  &lt;_@c1&gt; when &#x27;true&#x27; -&gt;
	      primop &#x27;match_fail&#x27;({&#x27;function_clause&#x27;,_@c1})
	end</code></pre><ul><li><p>A <code>case</code> in Core Erlang must not fall off at the end, that is,
there must always be a clause that will match.</p></li><li><p>In this example, the last clause with a variable pattern and
a <code>true</code> guard is guaranteed to match.</p></li><li><p>The body for the last clause calls a <strong>primop</strong> to generate
a function clause exception. Primops are primitive operations
provided by the Erlang implementation, but not specified in the
Core Erlang language specification.</p></li></ul><p>Here is a similar function excepts that is uses <code>case</code> and therefore
will generate a <code>case_clause</code> exception if called with any other
argument than <code>42</code>:</p><pre><code class="language-erlang">f(N) -&gt;
    case N of
        42 -&gt; ok
    end.</code></pre><p>The Core Erlang code is similar to the code for <code>e/1</code>:</p><pre><code>&#x27;f&#x27;/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;42&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  &lt;_@c1&gt; when &#x27;true&#x27; -&gt;
	      primop &#x27;match_fail&#x27;({&#x27;case_clause&#x27;,_@c1})
	end</code></pre><ul><li>The only difference is the argument for the <code>match_fail</code> primop.</li></ul><p>Let&#x27;s rewrite this function one more time:</p><pre><code class="language-erlang">g(N) -&gt;
    42 = N,
    ok.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;g&#x27;/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;42&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  &lt;_@c1&gt; when &#x27;true&#x27; -&gt;
	      primop &#x27;match_fail&#x27;({&#x27;badmatch&#x27;,_@c1})
	end</code></pre><ul><li>Again, the only difference is the argument for the <code>match_fail</code> primop.</li></ul><h2>Binding variables using &#x27;let&#x27;</h2><p>Here is a function that binds the variable <code>I</code>:</p><pre><code class="language-erlang">h(A) -&gt;
    I = id(A),
    I + A.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;h&#x27;/1 =
    fun (_@c0) -&gt;
	let &lt;I&gt; =
              apply &#x27;id&#x27;/1(_@c0)
	in
              call &#x27;erlang&#x27;:&#x27;+&#x27;(I, _@c0)</code></pre><ul><li><p><code>apply</code> calls a fun or local function.</p></li><li><p>The return value of the <code>apply</code> is bound to the variable <code>I</code>.</p></li><li><p>The variable <code>I</code> can only be used in the code that follows the
<code>in</code> keyword.</p></li><li><p>The variable name is in a value list. That is because <code>let</code>
can bind several variables at once.</p></li></ul><h2>Binding more than one variable in a &#x27;let&#x27;</h2><p>Erlang has essentially no scoping. When a variable has been bound,
it remains bound to the end of the function. For example, variables bound
in a <code>case</code> can be used after the <code>case</code>:</p><pre><code class="language-erlang">i(E) -&gt;
    case E of
        a -&gt;
            X = 1,
            Y = 10;
        b -&gt;
            X = 23,
            Y = 17
    end,
    {X,Y}.</code></pre><p>In Core Erlang:</p><pre><code>&#x27;i&#x27;/1 =
    fun (_@c0) -&gt;
	let &lt;_@c7,X,Y&gt; =
	    case _@c0 of
	      &lt;&#x27;a&#x27;&gt; when &#x27;true&#x27; -&gt;
		  &lt;10,1,10&gt;
	      &lt;&#x27;b&#x27;&gt; when &#x27;true&#x27; -&gt;
		  &lt;17,23,17&gt;
	      &lt;_@c5&gt; when &#x27;true&#x27; -&gt;
		  primop &#x27;match_fail&#x27;({&#x27;case_clause&#x27;,_@c5})
	    end
	in
	    {X,Y}</code></pre><ul><li><p>A <code>case</code> in Core Erlang does not export any variables. All variables
that are to be used after the <code>case</code> must be explicitly returned.</p></li><li><p>In this example, the first two clauses of the <code>case</code> return a
value list with <strong>three</strong> values. The first value is the return value
of the case, which in this case is ignored. The other two values are
the values assigned to the <code>X</code> and <code>Y</code> variables, respectively.</p></li><li><p>The values returned from the <code>case</code> is bound in the <code>let</code>. The ignored
return value is bound to a new variable (<code>_@c7</code>), which is never used.
The exported values are bound to the <code>X</code> and <code>Y</code> variables.</p></li></ul><h2>The unedited Core Erlang code</h2><p>So far all Core Erlang examples have been edited to make the points
I am trying to make stand out clearer. Let&#x27;s have a look at the unedited
version of a previous example:</p><pre><code>&#x27;e&#x27;/1 =
    %% Line 33
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;42&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  ( &lt;_@c1&gt; when &#x27;true&#x27; -&gt;
		( primop &#x27;match_fail&#x27;
		      ({&#x27;function_clause&#x27;,_@c1})
		  -| [{&#x27;function_name&#x27;,{&#x27;e&#x27;,1}}] )
	    -| [&#x27;compiler_generated&#x27;] )
	end</code></pre><ul><li><p>The <code>-|</code> associates an annotation with a Core Erlang construct.
The meaning of an annotation is not specified in the Core Erlang
language specification.</p></li><li><p>The <code>compiler_generated</code> annotation associated with the last clause
is a hint added by the compiler that subsequent optimization passes should
not generate a warning if the clause was found to never match and dropped.</p></li><li><p>The comment &quot;Line 33&quot; at the beginning is actually an annotation that
the pretty printer has turned into a comment to avoid rendering the
pretty-printed code unreadable.</p></li></ul><h2>Conclusion</h2><p>Core Erlang is less complicated than Erlang, and is therefore more
suited than the abstract format for code analyzing tools (such as
<a href="http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html">Dialyzer</a>) and optimizers.</p><h2>To learn more about Core Erlang</h2><p>All details can be found in <a href="https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf">Core Erlang 1.0.3 language specification</a>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"core-erlang-by-example","title":"Core Erlang by Example","author":"Björn Gustavsson","excerpt":"\nThis blog post is the first about the Core Erlang format. In this\nblog post, we introduce the Core Erlang format through examples\nthat compare Erlang code to the corresponding Core Erlang\ncode.\n\n[dialyzer]: http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html,\n[core]: https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf","article_date":1525651200000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Core Erlang by Example","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post is the first about the Core Erlang format. In this\nblog post, we introduce the Core Erlang format through examples\nthat compare Erlang code to the corresponding Core Erlang\ncode.\n\nI used the following command to translate my example module to\nCore Erlang code:\n\n```\n$ erlc +time +to_core core_example.erl\nCompiling \"core_example\"\n parse_module                  :      0.000 s      10.8 kB\n transform_module              :      0.000 s      10.8 kB\n lint_module                   :      0.003 s      10.8 kB\n expand_records                :      0.000 s      10.8 kB\n core                          :      0.000 s      89.9 kB\n sys_core_fold                 :      0.000 s      58.6 kB\n core_transforms               :      0.000 s      58.6 kB\n listing                       :      0.002 s      58.6 kB\n```\n\nThe [previous blog post](http://blog.erlang.org/compiler-lost-in-translation/)\nexplored the passes from `parse_module` to `expand_records`. The\n`core` passes translates from the abstract code to Core Erlang. We\nwill talk more about the Core Erlang passes in future blog posts.\n\nI have slightly edited the examples to make them somewhat easier to\nread. There will be an unedited example at the very end of this blog post.\n\nThere's a lot to cover, so let's get started!\n\n## The simplest function\n\nLet start with the simplest possible function, a function with no\narguments returning an atom:\n\n```erlang\nsimplest() -\u003e 'ok'.\n```\n\nIn Core Erlang, that will be:\n\n```\n'simplest'/0 =\n    fun () -\u003e\n\t'ok'\n```\n\nFrom that example, we can work out the following principles:\n\n* Atoms are always quoted.\n\n* Naming of the function has been separated from implementation\nof the function.\n\n* The body of a `fun` is not followed by an `end` as in Erlang.\n\n\n## Slightly less simple\n\nHere is as slightly more complicated function:\n\n```erlang\nid(I) -\u003e I.\n```\n\nIn Core Erlang:\n\n```\n'id'/1 =\n    fun (_@c0) -\u003e\n\t_@c0\n```\n\n**Note**: All examples were compiled with OTP 20. The name of the\ngenerated variables will be different in the upcoming OTP 21.\n\nEssentially, variables are named as in Erlang. In the translation\nto Core Erlang, the compiler generates new variable names for the\narguments in a function head. The following code is also valid\nCore Erlang:\n\n\n```\n'id'/1 =\n    fun (I) -\u003e\n\tI\n```\n\n## More than one clause\n\nHere is a function with more than one clause:\n\n```erlang\na(42) -\u003e ok;\na(_) -\u003e error.\n```\n\nIn Core Erlang:\n\n```\n'a'/1 =\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003c42\u003e when 'true' -\u003e\n\t      'ok'\n\t  \u003c_@c2\u003e when 'true' -\u003e\n\t      'error'\n\tend\n```\n\n* A `fun` can only have a single clause.\n\n* Pattern matching must be done in a `case`, not in the `fun` head.\n\n* Guards are mandatory for each clause in a `case`.\n\n* `_` is **not** a valid variable name in Core Erlang. Uninteresting\nvalues must be bound to a new variable.\n\n* The `\u003c` and `\u003e` around the patterns will be explained soon.\n\nIn Erlang, multiple function clauses can also be written with a\n`case` like this:\n\n```erlang\nb(N) -\u003e\n    case N of\n        42 -\u003e ok;\n        _ -\u003e error\n    end.\n```\n\nThe Core Erlang code will be essentially the same as the Core Erlang\ncode for `a/1`:\n\n```\n'b'/1 =\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003c42\u003e when 'true' -\u003e\n\t      'ok'\n\t  \u003c_@c3\u003e when 'true' -\u003e\n\t      'error'\n\tend\n```\n\n## Two clauses, three arguments\n\nLet's try multiple arguments:\n\n```erlang\nc(inc, Base, N) -\u003e\n    Base+N;\nc(_, Base, _) -\u003e\n    Base.\n```\n\nIn Core Erlang:\n\n```\n'c'/3 =\n    fun (_@c2,_@c1,_@c0) -\u003e\n\tcase \u003c_@c2,_@c1,_@c0\u003e of\n\t  \u003c'inc',Base,N\u003e when 'true' -\u003e\n\t      call 'erlang':'+'(Base, N)\n\t  \u003c_@c6,Base,_@c7\u003e when 'true' -\u003e\n\t      Base\n\tend\n```\n\n* `\u003c` and `\u003e` denote a **value list**. The patterns in each clause in\nthe `case` are always part of a value list. The `case` expression is\na value list unless there is only one expression.\n\n* Operators such as `+` are not part of the Core Erlang language,\nso the compiler has translated the use of `+` to a call to the\nBIF `erlang:'+'/2`.\n\n## If\n\nLet's see how `if` is implemented:\n\n```erlang\nd(A, B) -\u003e\n    if\n        A \u003e B -\u003e\n            greater;\n        true -\u003e\n            not_greater\n    end.\n```\n\nIn Core Erlang:\n\n```\n'd'/2 =\n    fun (_@c1,_@c0) -\u003e\n\tcase \u003c\u003e of\n\t  \u003c\u003e when call 'erlang':'\u003e'(_@c1, _@c0) -\u003e\n\t      'greater'\n\t  \u003c\u003e when 'true' -\u003e\n\t      'not_greater'\n\tend\n```\n\n* The `case` expression and the patterns are each value lists with\nzero elements. All the action is in the guards.\n\n## Repeated variables\n\nIn Erlang, a variable can be repeated in a clause or within a\npattern to indicate that the values must be the same:\n\n```erlang\ncmp(Same, Same) -\u003e same;\ncmp(_, _) -\u003e different.\n```\n\nCore Erlang does not allow repeating a variable:\n\n```\n'cmp'/2 =\n    fun (_@c1,_@c0) -\u003e\n\tcase \u003c_@c1,_@c0\u003e of\n\t  \u003cSame,_@c4\u003e when call 'erlang':'=:='(_@c4, Same) -\u003e\n\t      'same'\n\t  \u003c_@c5,_@c6\u003e when 'true' -\u003e\n\t      'different'\n\tend\n```\n\n* Here the second occurence of the variable `Same` has been renamed to\na new variable named `_@c4`, and a guard has been added to compare\n`Same` and `_@c4`.\n\n## Exceptions\n\nThis function will fail with a `function_clause` exception if it is called\nwith any other value than `42`:\n\n```erlang\ne(42) -\u003e ok.\n```\n\nIn Core Erlang:\n\n```\n'e'/1 =\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003c42\u003e when 'true' -\u003e\n\t      'ok'\n\t  \u003c_@c1\u003e when 'true' -\u003e\n\t      primop 'match_fail'({'function_clause',_@c1})\n\tend\n```\n\n* A `case` in Core Erlang must not fall off at the end, that is,\nthere must always be a clause that will match.\n\n* In this example, the last clause with a variable pattern and\na `true` guard is guaranteed to match.\n\n* The body for the last clause calls a **primop** to generate\na function clause exception. Primops are primitive operations\nprovided by the Erlang implementation, but not specified in the\nCore Erlang language specification.\n\nHere is a similar function excepts that is uses `case` and therefore\nwill generate a `case_clause` exception if called with any other\nargument than `42`:\n\n```erlang\nf(N) -\u003e\n    case N of\n        42 -\u003e ok\n    end.\n```\n\nThe Core Erlang code is similar to the code for `e/1`:\n\n\n```\n'f'/1 =\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003c42\u003e when 'true' -\u003e\n\t      'ok'\n\t  \u003c_@c1\u003e when 'true' -\u003e\n\t      primop 'match_fail'({'case_clause',_@c1})\n\tend\n```\n\n* The only difference is the argument for the `match_fail` primop.\n\nLet's rewrite this function one more time:\n\n```erlang\ng(N) -\u003e\n    42 = N,\n    ok.\n```\n\nIn Core Erlang:\n\n```\n'g'/1 =\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003c42\u003e when 'true' -\u003e\n\t      'ok'\n\t  \u003c_@c1\u003e when 'true' -\u003e\n\t      primop 'match_fail'({'badmatch',_@c1})\n\tend\n```\n\n* Again, the only difference is the argument for the `match_fail` primop.\n\n## Binding variables using 'let'\n\nHere is a function that binds the variable `I`:\n\n```erlang\nh(A) -\u003e\n    I = id(A),\n    I + A.\n```\n\nIn Core Erlang:\n\n```\n'h'/1 =\n    fun (_@c0) -\u003e\n\tlet \u003cI\u003e =\n              apply 'id'/1(_@c0)\n\tin\n              call 'erlang':'+'(I, _@c0)\n```\n\n\n* `apply` calls a fun or local function.\n\n* The return value of the `apply` is bound to the variable `I`.\n\n* The variable `I` can only be used in the code that follows the\n`in` keyword.\n\n* The variable name is in a value list. That is because `let`\ncan bind several variables at once.\n\n## Binding more than one variable in a 'let'\n\nErlang has essentially no scoping. When a variable has been bound,\nit remains bound to the end of the function. For example, variables bound\nin a `case` can be used after the `case`:\n\n```erlang\ni(E) -\u003e\n    case E of\n        a -\u003e\n            X = 1,\n            Y = 10;\n        b -\u003e\n            X = 23,\n            Y = 17\n    end,\n    {X,Y}.\n```\n\nIn Core Erlang:\n\n```\n'i'/1 =\n    fun (_@c0) -\u003e\n\tlet \u003c_@c7,X,Y\u003e =\n\t    case _@c0 of\n\t      \u003c'a'\u003e when 'true' -\u003e\n\t\t  \u003c10,1,10\u003e\n\t      \u003c'b'\u003e when 'true' -\u003e\n\t\t  \u003c17,23,17\u003e\n\t      \u003c_@c5\u003e when 'true' -\u003e\n\t\t  primop 'match_fail'({'case_clause',_@c5})\n\t    end\n\tin\n\t    {X,Y}\n```\n\n* A `case` in Core Erlang does not export any variables. All variables\nthat are to be used after the `case` must be explicitly returned.\n\n* In this example, the first two clauses of the `case` return a\nvalue list with **three** values. The first value is the return value\nof the case, which in this case is ignored. The other two values are\nthe values assigned to the `X` and `Y` variables, respectively.\n\n* The values returned from the `case` is bound in the `let`. The ignored\nreturn value is bound to a new variable (`_@c7`), which is never used.\nThe exported values are bound to the `X` and `Y` variables.\n\n## The unedited Core Erlang code\n\nSo far all Core Erlang examples have been edited to make the points\nI am trying to make stand out clearer. Let's have a look at the unedited\nversion of a previous example:\n\n```\n'e'/1 =\n    %% Line 33\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003c42\u003e when 'true' -\u003e\n\t      'ok'\n\t  ( \u003c_@c1\u003e when 'true' -\u003e\n\t\t( primop 'match_fail'\n\t\t      ({'function_clause',_@c1})\n\t\t  -| [{'function_name',{'e',1}}] )\n\t    -| ['compiler_generated'] )\n\tend\n```\n\n* The `-|` associates an annotation with a Core Erlang construct.\nThe meaning of an annotation is not specified in the Core Erlang\nlanguage specification.\n\n* The `compiler_generated` annotation associated with the last clause\nis a hint added by the compiler that subsequent optimization passes should\nnot generate a warning if the clause was found to never match and dropped.\n\n* The comment \"Line 33\" at the beginning is actually an annotation that\nthe pretty printer has turned into a comment to avoid rendering the\npretty-printed code unreadable.\n\n## Conclusion\n\nCore Erlang is less complicated than Erlang, and is therefore more\nsuited than the abstract format for code analyzing tools (such as\n[Dialyzer][dialyzer]) and optimizers.\n\n[dialyzer]: http://erlang.org/doc/apps/dialyzer/dialyzer_chapter.html\n\n## To learn more about Core Erlang\n\nAll details can be found in [Core Erlang 1.0.3 language specification][core].\n\n[core]: https://www.it.uu.se/research/group/hipe/cerl/doc/core_erlang-1.0.3.pdf\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"core-erlang-by-example"},"buildId":"ob9V3f7Iet6syJeg0QYgd","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_buildManifest.js" async=""></script><script src="/_next/static/ob9V3f7Iet6syJeg0QYgd/_ssgManifest.js" async=""></script></body></html>