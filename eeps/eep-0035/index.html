<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;,
        Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;
Status: Draft
Type: Standards Track
Created: 29-Sep-2010
Erlang-Version: R14B
Post-History:
Replaces: 9
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 35: <a href="eep-0035.md" title="EEP Source"> Binary string module(s)</a></h2>

<h1>Abstract</h1>

<p>This EEP contains developed suggestions regarding the module <code>binary_string</code>
first suggested in <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>. The module name is now however changed to <code>bstring</code>.</p>

<p><a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> suggests several modules and is partially superseded by later
EEP's (i.e. <a href="/eeps/eep-0011" title="EEP 11, intresting extensions to EEP 9">EEP 11</a> and <a href="/eeps/eep-0031" title="EEP 31, rewrite of EEP 9, module binary">EEP 31</a>), while still containing valuable suggestions not
yet implemented. This last remaining module suggested in <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> will therefore
appear in this separate EEP. This is made in agreement with
the original author of <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>.</p>

<p>The module <code>bstring</code> is suggested to contain functions for
convenient manipulation of textual data stored in binaries,
i.e. binary strings. It somewhat resembles the <code>string</code> module
(which is list oriented), but is not to be viewed simply as a
<code>string</code> module for binaries.</p>

<p>The module suggested handles binary character encoding in both the
standard character encodings of Erlang, namely ISO-Latin-1 and UTF-8.</p>

<h1>Motivation</h1>

<p>Text strings are traditionally represented as lists of integers in
Erlang. While this is convenient and more or less built into the
syntax of the language (i.e. "ABC" is syntactic sugar for [$A,$B,$C]),
a more compact representation is often desired. Also, in some
circumstances binaries can be more efficient to manipulate in terms of
algorithm complexity than lists are (especially in the fixed character
width case of ISO-Latin-1).</p>

<p>More modules have been added to the standard libraries lately to aid
the usage of binaries for text strings, both as representing
ISO-Latin-1 characters and Unicode strings encoded in UTF-8. Most
notably the <code>re</code> library, but also the <code>unicode</code> module are fairly
new additions to <code>stdlib</code> which will make life easier for the
programmer when it comes to manipulating binary encoded strings. Also
a module for fast searching and replacing in byte oriented binaries is
present (the module <code>binary</code>), but no traditional string manipulation module is
yet in the libraries. To ease use of binary encoded strings, such a module is
needed.</p>

<h1>Rationale</h1>

<p>The module <code>string</code> for text oriented operations on lists has been
present in the standard libraries for so long that most programmers
don't remember a time when it wasn't there. It is said to originally
be a merge of two different string modules, written and designed by
two different programmers with possibly slightly different goals and
definitely slightly different views on function naming. While
sometimes criticized for duplicated functionality and inconsistent
function naming, among other things, the module has remained useful
throughout the entire lifespan of Erlang/OTP. The string
representation used has also withstood the evolution of Unicode.</p>

<p>It is worth to note that the only functions in the <code>string</code> module
that actually are language or region dependent are later additions to
the module. Those functions (like <code>to_upper</code>, <code>to_lower</code>, <code>to_integer</code> and
<code>to_float</code>), or their binary equivalence, are not part of the module
interface I suggest for <code>bstring</code> for the simple reason that they
need language support not yet present in Erlang. A future EEP might
suggest such language support (i.e. some kind of "locale" support), but
that is future work not covered by this EEP.</p>

<p>So, however criticized, the string module is very useful for
manipulating lists, and the same functionality for binary strings is
desirable. While a lot of the functionality will be similar, there are
some major issues to consider when implementing a module for
manipulating strings encoded in binaries:</p>

<ul>
<li><p>Unicode - Binaries can have different encodings. A Character encoded
as UTF-8 might take more than one (up to four) byte positions, and
even the same character can have different encodings in ISO-Latin-1
and UTF-8 (all codepoints from 128 to 255). The functions need to be
informed of the character encoding explicitly, The encoding
information is not present in the binaries.</p></li>
<li><p>Mixed character encodings - As characters can be encoded in
different ways, two strings in the same program could have different
encodings. Supplying the functions with non-homogeneous string
encoding data should be consistently solved throughout the module,
as should the selection of returned encoding where applicable.</p></li>
<li><p>Default character encoding - As functions will take extra arguments
to specify encoding, a consistent default might be useful. Choosing
the default is not entirely simple, as the tradition states
ISO-Latin-1, while the future suggests UTF-8.</p></li>
<li><p>Languages - Erlang has no notion of "Locale" or preferred number
format. A general string module can not assume neither a specific
notion of uppercase or lowercase letters, nor a specific number
encoding format (especially true for floating point numbers).</p></li>
<li><p>Word separators - The space character is certainly not the only word
separator for textual data (in any language). The notion of words
separated by spaces imposes a restriction of the relevant languages.</p></li>
<li><p>Left to right or right to left - Notions like left or right to
denote the beginning or end of a string are certainly not language
independent. While strings in a language have a beginning and an end,
that beginning and end may be placed both to the left, the right or
even at the top, bottom or center of the graphical representation. A
string manipulation module should not use naming implying a
left-to-right script, or any other type of script.</p></li>
<li><p>Naming and duplicated functionality - The original <code>string</code> module
has been accused of having somewhat inconsistent naming and
functionality duplicated. In fact the only duplicated functions are
<code>substr</code> and <code>sub_string</code>. Some cleanup of the interface might
be needed.</p></li>
<li><p>Byte oriented versus character oriented return values - When dealing
with Unicode data, a character may take more than one byte, why
i.e. counting the number of characters in a string tells you very
little about the actual size of the string in bytes. Furthermore,
later processing of a binary might require byte-oriented
manipulation of a string rather than character oriented (i.e. you
want to manipulate the string using the <code>binary</code> module or with
bit-syntax), while characters are actually what constitutes a
string, not bytes. You would want both.</p></li>
<li><p>New or replaced functionality - New functionality have been suggested from several sources,
most notably <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>. For example the function <code>split</code> suggested in <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> is very similar to 
<c>string:tokens/2</c>. Should we keep <code>tokens</code> anyway, for example?</p></li>
</ul>

<p>I'll address the different issues below.</p>

<h2>Unicode</h2>

<p>The interface has to support both ISO-Latin-1 and UTF-8. The <code>unicode</code> module supports even more encodings, but Erlang/OTP uses UTF-8 for all "internal" interfaces and UTF-8 is the expected encoding of a binary Unicode string. Even though UTF-8 is compatible with ISO-Latin-1 in the 7bit ASCII range, characters with codepoints between 128 and 255 are encoded differently in the "plain" ISO-Latin-1 encoding and in UTF-8. This means that all functions in the <code>bstring</code> module need to have the actual encoding as one or more extra parameters.</p>

<p>One could invent a more abstract binary string format where the data is for example represented as a tuple with the string and the encoding packed together. However no other module supports such a string construct and I don't think that would really add something, neither functionality nor readability. Consider code like:</p>

<pre><code>bstring:tokens(Bin,latin1,[$ ,$\n])
</code></pre>

<p>compared to:</p>

<pre><code>bstring:tokens({Bin,latin1}, [$ ,$\n]).
</code></pre>

<p>or even:</p>

<pre><code>bstring:tokens(#bstring{data = Bin, encoding = latin1}, [$ ,$\n]).
</code></pre>

<p>In many cases the extra information needs to be added in connection to the call, making the code no more readable or simple to write than with the separate extra argument. Consider if we had a default value for encoding. The code:</p>

<pre><code>f(Data) -&gt;
       bstring:tokens(Data,[$ ,$\n]).
</code></pre>

<p>would not in any way indicate if <code>Data</code> was supposed to be a binary with the default encoding or some kind of complex data structure indicating both the actual string and it's encoding. </p>

<p>I think the extra argument for the encoding is straight forward and simple, and it makes programming easier when using the binary string in other modules as well (i.e. <code>re</code>, <code>binary</code>, <code>file</code> etc). I think we should simply not have a special string datatype for this module, character encoding should be supplied as a separate argument.</p>

<h2>Mixed character encodings</h2>

<p>To ease transition between character encodings, I think the interface should accept different encodings for both different parameters and the return value. This makes it possible to convert on the fly and for the functions to decide on the most efficient character conversion path for the supplied arguments and the return value. </p>

<p>The downside of this approach is that some functions will take a lot of parameters telling different character encodings, for example a string concatenation routine could look like:</p>

<pre><code>  concat(BString1, Encoding1, BString2, Encoding2, Encoding3) -&gt; BString3
</code></pre>

<p>being called like:</p>

<pre><code>  US = bstring:concat(SA,latin1, SB, latin1, unicode),
</code></pre>

<p>which might look a little awkward to write. On the other hand, conversion is made on the fly and you will not need to explicitly call the <code>unicode</code> module to convert the result. </p>

<p>I think implicit conversion is so useful that it is worth the extra arguments. For example a <code>concat</code> function would be more or less useless without it, the bit syntax would be much easier to use if no conversion should be allowed.</p>

<h2>Default character encoding</h2>

<p>Choosing a default character encoding is not obvious. While ISO-Latin-1 is the default in Erlang (i.e. &lt;&lt;"korvsmörgås">> gives a ISO-Latin-1 encoded binary string), UTF-8 usage is expected to grow in the future. </p>

<p>Although its tempting to select UTF-8 as the default encoding, I think we should stick to ISO-Latin-1 as the default even for this module. There are several reasons:</p>

<ul>
<li><p>We need not, as a rule, impose new standards in every module we add
to the standard library. Consistence certainly adds value, and both
the bit-syntax, the source code encoding and things like the
io:format routine has ISO-Latin-1 as default. Lets not make this
module inconsistent with the others.</p></li>
<li><p>The <code>string</code> module is often used to manipulate arbitrary lists
of integers, not always actually representing textual data. In the
same way can <code>bstring</code> probably be used to manipulate arbitrary
blobs of bytes if ISO-latin-1 versions are used. ISO-Latin-1 is
actually the raw bytes uninterpreted, why any binary data can be
worked on in a ISO-Latin-1 oriented routine. Using UTF-8 encoding as
default would narrow the use for the default functions to only work
on real text data.</p></li>
<li><p>The pure ISO-Latin-1 implementations of the functions will be the
most efficient ones as no data checking at all is needed. Any byte
value is acceptable in any version. Some functions are usable on
UTF-8 strings even though they expect ISO-Latin-1 data. The
difference between the ISO-Latin-1 version and the UTF-8 version
being only indata control. If the data given to, for example
<code>bstring:concat</code> is already checked for correct UTF-8, the simpler
ISO-Latin-1 version of the function is both more efficient and
guaranteed to give as correct output as the input:</p>

<pre><code>    CorrectUtf8_1 = give_me_good_string(),
    CorrectUtf8_2 = give_me_another_good_string(),
    CorrectUtf8_3 = bstring:concat(CorrectUtf8_1, latin1, CorrectUtf8_2, latin1, latin1),
    ...
</code></pre>

<p>Simply put, ISO-Latin-1 versions of the functions are more generally
useful than pure UTF-8 versions and are also more efficient.</p></li>
<li><p>A wrapper module providing pure UTF-8 interfaces can easily be
written. The overhead of going via a wrapper would be relatively
lower for an UTF-8 wrapper than for an ISO-Latin-1 ditto, as the
overhead of character decoding/encoding of UTF-8 strings in the
module would be quite high. Simply put, a wrapper would cost very
little compared to the cost of checking the data for UTF-8
correctness.</p>

<p>I actually suggest a module <code>ubstring</code> that has the part of the
<code>bstring</code> interface where a default encoding is implied, but with
the difference that UTF-8 is expected. For example, a function
<code>ubstring:tokens/2</code> would look like this:</p>

<pre><code>tokens(S,L) -&gt; bstring:tokens(S,unicode,L).
</code></pre>

<p>Quite simple.</p></li>
</ul>

<p>To conclude, I think all functions should exist in a version where no
encoding is supplied and ISO-Latin-1 encoded data is expected.</p>

<h2>Languages</h2>

<p>Even though Unicode characters can be used to express text in most
known, living and dead scripts, language and region knowledge is a
completely different thing. String interfaces often impose language
specific properties of the string, like left-to-right writing
direction, the notion of words built up by space separated groups of
characters, ways of representing numbers and decimal points etc. As
Erlang does not (yet) have a way of specifying such language-, or
region-specific properties of a string, the interface should not
contain language-dependent functionality. The <code>string</code> module did not
originally contain such functions (except that character alignment
functions were named <code>left</code> and <code>right</code>), but unfortunately
functions like <code>to_float</code> and <code>to_upper</code> have been added.</p>

<p>I think that having language-dependent functions in the <code>string</code>
module was a mistake and I do not want to make that mistake
again. Hence I have not included such functions or names in
<code>bstring</code>.</p>

<p>I rather suggest "Locale" functionality as a subject of a future
EEP. For those who consider that simple, try to write a correct
<code>to_upper</code> function for just all European languages, make sure it
works on all platforms that can run Erlang... Maybe not rocket science, but a
<em>lot</em> of metadata is required. Data that is not always available in
the underlying OS, but probably needs to be distributed with Erlang/OTP for
consistent functionality. Definitely worth it's own EEP.</p>

<h2>Word separators</h2>

<p>In connection with language independence, I think we should drop the
notion of <em>words</em> as a group of characters separated by space. The word
"token" is more general and does not in the same way indicate language
constructs. The <code>string</code> module has the ASCII space character as a
default for word separation, which I think should be dropped in
<code>bstring</code>. Whatever should separate tokens should be supplied,
possibly as alternatives. I therefore suggest the functions
<code>bstring:num_tokens</code> and <code>bstring:nth_token</code> to fulfill the
functionality of <code>string:words</code> and <code>string:sub_word</code>.</p>

<p>As in <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>, I suggest a new function <code>split</code> to handle the case
of multi-character separators for tokens. A compilation of <code>split</code>
and <code>join</code> makes a convenient <code>replace</code> function too.</p>

<h2>Left-to-right or Right-to-left</h2>

<p>As mentioned earlier, I don't think direction of the graphical
representation should be implied in the interface, why I suggest using
notions like leading and trailing (meaning leading and trailing
characters in the binary) rather than any directional notions. I also
think aligning strings (like in <code>strings:right</code> etc.) could be solved
in one function <code>align</code>, taking one of the atoms <code>leading</code>,
<code>trailing</code> or <code>center</code> as a parameter, if it should at all be
implemented.</p>

<h2>Naming and duplicated functionality</h2>

<p>I definitely do not think we should have all interfaces from
<code>string</code> duplicated to <code>bstring</code>. Especially interfaces that are
aliases should not be carried along to the <code>bstring</code> module. Most
functions in the <code>string</code> module however have short and fairly
describing names, often similar to names found in other languages. I
think using a <code>r</code> prefix for functionality working from the end of
the string towards the beginning is a good choice, as is <code>c</code> for
complement.</p>

<h2>Byte oriented versus character oriented return values</h2>

<p>Some functions in <code>string</code>, that are certainly useful, return numbers
denoting character positions. The same functions should definitely be
present in the <code>bstring</code> module and the return values should
definitely be character oriented. However byte offsets are definitely
useful, for example if we use a function like <code>span</code> to find the
first character not in a set of characters, we might want the byte
offset of that first character too.</p>

<p>I suggest adding some interfaces returning byte offsets, or <em>part()'s</em>
like the ones used in the <code>binary</code> module and by <code>re</code>, to cope
with the need for byte offsets and lengths in some circumstances. A
<code>b</code> suffix to the function name could denote such functionality, so
that <code>bstring:span</code> returns a character position while
<code>bstring:spanb</code> returns a byte position and <code>btring:str</code> returns a
character position and <code>bstring:strb</code> returns a <em>part()</em>. Although
this will in the end give rise to more functions in the interface,
having return-type-changing options in an option list is not the way
to go (I know, I have them in <code>re</code>, but it's still not generally a
good idea...).</p>

<h2>New or replaced functionality</h2>

<p>When writing a general string module, there is no end to the new, more
or less esoteric, functionality one could add. I think we, at least
in an initial implementation, should stick to the functionality
outlined in <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>, namely extending <code>str</code> and friends to
optionally take a list of alternative strings to search for, add a
function <code>split</code> to take care of multi-character separators (as
opposed to single character separators in the function <code>tokens</code>) and
a substitution function, which I think should be named <code>replace</code> as
in other modules.</p>

<p>The use of pre-compiled matches from the <code>binary</code> module is however
not a good idea, as the <code>binary</code> module has no notion of character
encoding. Search strings need to be given in defined character
encodings and both the "haystacks" and the "needles" encoding need to
be known when doing an efficient search. So - no pre-compiled search
expressions.</p>

<h2>Excerpt of a suggested manual page</h2>

<p>As made obvious above, I prefer the name <code>bstring</code> for a binary
string module in favor of the more verbose name <code>binary_string</code>
originally suggested. In that module <code>bstring</code>, I suggest the
following interfaces, expressed as in a manual page of OTP.</p>

<h2>DATA TYPES</h2>

<pre><code>    encoding() = latin1 | unicode | utf8
      - The encoding of characters in the binary data, both input and output
    bstring() 
      - Binary with characters encoded either in ISO-Latin-1 or UTF-8
    unicode_char() = non_negative_integer() 
      - An integer representing a valid unicode codepoint
    non_negative_integer()
      - An integer &gt;= 0
</code></pre>

<h2>EXPORTS</h2>

<h3><code>align(BString, Alignment, Number, Char) -&gt; Result</code></h3>

<h3><code>align(BString, Encoding, Alignment, Number, Char) -&gt; Result</code></h3>

<p>Types:</p>

<pre><code>BString = Result = bstring()
Encoding = encoding()
Alignment = leading | trailing | center
Number = non_negative_integer()
Char = unicode_char()
</code></pre>

<p>Aligns the characters in <code>BString</code> in a <code>Result</code> of <code>Number</code> characters according to the <code>Alignment</code> parameter. Alignment is done by inserting the character <code>Char</code> in the beginning or end (or both) of the binary string. </p>

<p>The resulting binary string will contain exactly <code>Number</code> characters, the string is truncated if it contains more characters than <code>Number</code> - either at the end if <code>Alignment</code> is <code>leading</code>, or at the beginning if <code>Alignment</code> is <code>trailing</code>, or at both ends if <code>Alignment</code> is <code>center</code> . If <code>Encoding</code> is <code>unicode</code>, the <code>Result</code> may well contain more bytes than <code>Number</code>, as one character may require several bytes. </p>

<p>Example: </p>

<pre><code>&gt; bstring:align(&lt;&lt;"Hello"&gt;&gt;, latin1, center, 10, $.).
&lt;&lt;"..Hello..."&gt;&gt;
</code></pre>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, <code>Encoding</code> or <code>Alignment</code> has an invalid value, the character <code>Char</code> cannot be encoded in the character encoding given as <code>Encoding</code> or any of the parameters are of the wrong type. </p>

<h3><code>chr(BString, Character) -&gt; Position</code></h3>

<h3><code>chr(BString, Encoding, Character) -&gt; Position</code></h3>

<h3><code>rchr(BString, Character) -&gt; Position</code></h3>

<h3><code>rchr(BString, Encoding, Character) -&gt; Position</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = encoding()
Character = unicode_char()
Position = integer()
</code></pre>

<p>Returns the (zero-based) character position of the first/last occurrence of <code>Character</code> in <code>BString</code> . <code>-1</code> is returned if <code>Character</code> does not occur. </p>

<p>Note that the character position is not the same as the byte position. Use the <code>chrb</code> and <code>rchrb</code> functions to get the byte positions. </p>

<p>If <code>Character</code> cannot be represented in the encoding, it is not an error, you are just certain to get <code>-1</code> as a return value. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>chrb(BString, Character) -&gt; {BytePosition, ByteLength}</code></h3>

<h3><code>chrb(BString, Encoding, Character) -&gt; {BytePosition, ByteLength}</code></h3>

<h3><code>rchrb(BString, Character) -&gt; {BytePosition, ByteLength}</code></h3>

<h3><code>rchrb(BString, Encoding, Character) -&gt; {BytePosition, ByteLength}</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = encoding()
Character = unicode_char()
BytePosition = integer()
ByteLength = non_negative_integer()
</code></pre>

<p>Works as <code>chr</code> and <code>rchr</code> respectively, but returns the byte position and byte length of the character. </p>

<p>If the character is not found, <code>{-1,0}</code> is returned. </p>

<h3><code>concat(BString1, BString2) -&gt; BString3</code></h3>

<h3><code>concat(BString1, Encoding1, BString2, Encoding2, Encoding3) -&gt; BString3</code></h3>

<p>Types:</p>

<pre><code>BString1 = BString2 = BString3 = bstring()
Encoding1 = Encoding2 = Encoding3 = encoding()
</code></pre>

<p>Concatenates two binary strings to form a new string. Returns the new binary string in the encoding given by Encoding3. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if <code>BString1</code> or <code>Bstring2</code> does not contain characters encoded according to the <code>Encoding1</code> and <code>Encoding2</code> parameters, the encoding parameters has an invalid value, the codepoints in the in-parameters cannot be represented in the output encoding or any of the parameters are of the wrong type. </p>

<h3><code>equal(BString1, BString2) -&gt; bool()</code></h3>

<h3><code>equal(BString1, Encoding1, BString2, Encoding2) -&gt; bool()</code></h3>

<p>Types:</p>

<pre><code>BString1 = BString2 = bstring()
Encoding1 = Encoding2 = encoding()
</code></pre>

<p>Tests whether two binary strings are equal. Returns <code>true</code> if they are, otherwise <code>false</code> . </p>

<p><code>Encoding1</code> is the encoding of <code>BString1</code> and <code>Encoding2</code> is the encoding of <code>BString2</code> . </p>

<p>Note that the strings can have different encoding and that it is the character values encoded in the strings that are compared. The binary strings are scanned as long as they are equal, meaning that if the function returns <code>true</code>, both strings are correctly encoded, while a return value of <code>false</code> does not guarantee correct encoding in both binary strings. An exception is raised if faulty encoding is determined while comparing the strings, not if parts of the string not inspected contain encoding errors. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if wrongly encoded characters, according to the encoding parameters, are encountered during comparison, the encoding parameters has an invalid value or any of the parameters are of the wrong type. </p>

<h3><code>join(BStringList, Separator) -&gt; Result</code></h3>

<h3><code>join(BStringList, BStringListEncoding, Separator, SeparatorEncoding, ResultEncoding) -&gt; Result</code></h3>

<p>Types:</p>

<pre><code>BStringList = [bstring()]
BStringListEncoding = SeparatorEncoding = ResultEncoding = encoding()
Separator = bstring()
Result = bstring()
</code></pre>

<p>Returns a binary string with the elements of <code>BStringList</code> separated by the binary string in <code>Seperator</code> . </p>

<p>All the binary strings in <code>BStringList</code> should have the same encoding (given as <code>BStringListEncoding</code> . The <code>Separator</code> can however have a different encoding (given as <code>SeparatorEncoding</code> ), as can the <code>Result</code> (given as <code>ResultEncoding</code> ). </p>

<p>Example: </p>

<pre><code>&gt; bstring:join([&lt;&lt;"one"&gt;&gt;, &lt;&lt;"two"&gt;&gt;, &lt;&lt;"three"&gt;&gt;], latin1, &lt;&lt;", "&gt;&gt;, latin1, latin1).
&lt;&lt;"one, two, three"&gt;&gt;
</code></pre>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if binary strings in <code>BStringList</code> or the <code>Separator</code> do not contain characters encoded according to the <code>BStringListEncoding</code> and <code>SeparatorEncoding</code> parameters respectively, the encoding parameters has an invalid value, the codepoints in the in-parameters cannot be represented in the output encoding <code>ResultEncoding</code> or any of the parameters are of the wrong type. </p>

<h3><code>len(BString) -&gt; Length</code></h3>

<h3><code>len(BString, Encoding) -&gt; Length</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = encoding()
Length = non_negative_integer()
</code></pre>

<p>Returns the number of characters in the binary string. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value or any of the parameters are of the wrong type. </p>

<h3><code>nth_token(BString, N, CharList) -&gt; Result</code></h3>

<h3><code>nth_token(BString, Encoding, N, CharList) -&gt; Result</code></h3>

<p>Types:</p>

<pre><code>BString = Result = bstring()
Encoding = encoding()
CharList = [ unicode_char() ]
N = non_negative_integer()
</code></pre>

<p>Returns the token number <code>N</code> of <code>BString</code> (zero-based). Tokens are separated by the characters in <code>CharList</code> . </p>

<p>The returned token will have the same encoding as <code>BString</code> . </p>

<p>For example: </p>

<pre><code>&gt; bstring:nth_token(&lt;&lt;" Hello old boy !"&gt;&gt;,latin1,3,[$o, $ ]).
&lt;&lt;"ld b"&gt;&gt;
</code></pre>

<p><code>CharList</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>CharList</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>

<p>Values of <code>N</code> >= number of tokens in <code>BString</code> will result in the empty binary string <code>&lt;&lt;&gt;&gt;</code> being returned. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>num_tokens(BString, CharList) -&gt; Count</code></h3>

<h3><code>num_tokens(BString, Encoding, CharList) -&gt; Count</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = encoding()
CharList = [ unicode_char() ]
Count = non_negative_integer()
</code></pre>

<p>Returns the number of tokens in <code>String</code>, separated by the characters in <code>CharList</code> . </p>

<p>The result is the same as for length(bstring:tokens(BString,Encoding,CharList)), but avoids building the result. </p>

<p>For example: </p>

<pre><code>&gt; num_tokens(&lt;&lt;" Hello old boy!"&gt;&gt;, latin1, [$o, $ ]).
4
</code></pre>

<p><code>CharList</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>CharList</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>span(BString, Chars) -&gt; Length</code></h3>

<h3><code>span(BString, Encoding, Chars) -&gt; Length</code></h3>

<h3><code>rspan(BString, Chars) -&gt; Length</code></h3>

<h3><code>rspan(BString, Encoding, Chars) -&gt; Length</code></h3>

<h3><code>cspan(BString, Chars) -&gt; Length</code></h3>

<h3><code>cspan(BString, Encoding, Chars) -&gt; Length</code></h3>

<h3><code>rcspan(BString, Chars) -&gt; Length</code></h3>

<h3><code>rcspan(BString, Encoding, Chars) -&gt; Length</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = encoding()
Chars = [ integer() ]
Length = non_negative_integer()
</code></pre>

<p>Returns the length (in characters) of the maximum initial (span and cspan) or trailing (rspan and rcspan) segment of BString, which consists entirely of characters from (span and rspan), or not from (cspan and rcspan) Chars. </p>

<p><code>Chars</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>Char</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>

<p>For example: </p>

<pre><code>&gt; bstring:span(&lt;&lt;"\t    abcdef"&gt;&gt;,latin1," \t").
5
&gt; bstring:cspan((&lt;&lt;"\t    abcdef"&gt;&gt;,latin1, " \t").
0
</code></pre>

<p>Codepoints in <code>Chars</code> that can not be represented by <code>Encoding</code> is not considered an error. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>spanb(BString, Chars) -&gt; ByteLength</code></h3>

<h3><code>spanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>

<h3><code>rspanb(BString, Chars) -&gt; ByteLength</code></h3>

<h3><code>rspanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>

<h3><code>cspanb(BString, Chars) -&gt; ByteLength</code></h3>

<h3><code>cspanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>

<h3><code>rcspanb(BString, Chars) -&gt; ByteLength</code></h3>

<h3><code>rcspanb(BString, Encoding, Chars) -&gt; ByteLength</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = encoding()
Chars = [ integer() ]
ByteLength = non_negative_integer()
</code></pre>

<p>Work exactly as the functions <code>span</code>, <code>rspan</code>, <code>cspan</code> and <code>rcspan</code> respectively, but returns the number of bytes rather than the number of characters. </p>

<h3><code>split(BString, Separators, Where) -&gt; Tokens</code></h3>

<h3><code>split(BString, Encoding, Separators, SepEncoding, Where, ReturnEncoding) -&gt; Tokens</code></h3>

<p>Types:</p>

<pre><code>String = bstring()
Encoding = SepEncoding = ReturnEncoding = encoding()
Separators = [ bstring() ]
Where = first | last | all
Tokens = [bstring()]
</code></pre>

<p>Returns a list of tokens in <code>BString</code>, separated by the binary strings in <code>Separators</code> . </p>

<p>The <code>Tokens</code> returned are encoded according to <code>ReturnEncoding</code> . </p>

<p>Example: </p>

<pre><code>&gt; bstring:split(&lt;&lt;"abc defxxghix jkl"&gt;&gt;, latin1, [&lt;&lt;"x"&gt;&gt;,&lt;&lt;" "&gt;&gt;],all,latin1).
[&lt;&lt;"abc"&gt;&gt;, &lt;&lt;"def"&gt;&gt;, &lt;&lt;"ghi"&gt;&gt;, &lt;&lt;"jkl"&gt;&gt;]
</code></pre>

<p><code>Separators</code> is to be viewed as a <em>set</em> of binary strings, order is not significant. Codepoints given in <code>Separators</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>

<p>The <code>Where</code> parameter specifies at which occurrence of any of the <code>Separators</code> the binary string is to be split, either at the <code>first</code> occurrence, the <code>last</code> occurrence or at <code>all</code> occurrences, in which case the <code>Tokens</code> may be an arbitrary long list. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if <code>BString</code> or <code>Separators</code> does not contain characters encoded according to the <code>Encoding</code> and <code>SepEncoding</code> parameters respectively, the resulting tokens cannot be encoded in the <code>ReturnEncoding</code>, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>str(BString, SubBStrings) -&gt; Position</code></h3>

<h3><code>str(BString, Encoding, SubBStrings, SubEnc) -&gt; Position</code></h3>

<h3><code>rstr(BString, SubBStrings) -&gt; Position</code></h3>

<h3><code>rstr(BString, Encoding, SubBStrings, SubEnc) -&gt; Position</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
SubBString = bstring() | [ bstring() ]
Encoding = SubEnc = encoding()
Position = integer()
</code></pre>

<p>Returns the (zero-based) character position where the first/last occurrence of any of the <code>SubBStrings</code> begins in <code>BString</code> . <code>-1</code> is returned if <code>SubBString</code> does not exist in <code>BString</code> . </p>

<p>Note that the <code>Character</code> position is not the same as the byte position. Use the <code>strb</code> and <code>rstrb</code> functions to get the byte positions. </p>

<p>The encoding need not be the same for <code>BString</code> and <code>SubBStrings</code>, however all strings in SubBStrings need to have the same encoding. </p>

<p>If the codepoints in SubBString can not be represented in the encoding of BString, that is not an error, but will always result in the return value -1. </p>

<p>Example: </p>

<pre><code>&gt; bstring:str(&lt;&lt;" Hello Hello World World "&gt;&gt;,latin1,&lt;&lt;"Hello World"&gt;&gt;,latin1).
7
</code></pre>

<p>Note that if both encodings are the same and repeated searches with the same <code>SubBStrings</code> are to be performed, it is more efficient to use the <code>binary:match/{2,3}</code> functions with a precompiled pattern on the raw binary data. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> or <code>SubBString</code> does not contain characters encoded according to the <code>Encoding</code> and <code>SubEnc</code> parameters, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>strb(BString, SubBStrings) -&gt; {BytePosition, ByteLength}</code></h3>

<h3><code>strb(BString, Encoding, SubBStrings, SubEnc) -&gt; {BytePosition, ByteLength}</code></h3>

<h3><code>rstrb(BString, SubBStrings) -&gt; {BytePosition, ByteLength}</code></h3>

<h3><code>rstrb(BString, Encoding, SubBStrings, SubEnc) -&gt; {BytePosition, ByteLength}</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
SubBString = bstring() | [ bstring() ]
Encoding = SubEnc = encoding()
BytePosition = integer()
ByteLength = non_negative_integer()
</code></pre>

<p>Works as <code>str</code> and <code>rstr</code> respectively, but returns the byte position and byte length of the found substring. </p>

<p>Note that <code>ByteLength</code> is the length the found substring has in <code>BString</code>, regardless of the encoding in <code>SubBStrings</code>, so that <code>ByteLength</code> may be both larger and smaller than <code>byte_size(SubBString)</code> depending on the binary string's encoding. </p>

<p>If the substring is not found, <code>{-1,0}</code> is returned. </p>

<h3><code>strip(BString, Which, CharList) -&gt; Result</code></h3>

<h3><code>strip(BString, Encoding, Which, CharList) -&gt; Result</code></h3>

<p>Types:</p>

<pre><code>BString = Result = bstring()
Encoding = encoding()
Which = leading | trailing | both
CharList = [ unicode_char() ]
</code></pre>

<p>Removes leading (<code>Which</code> = <code>leading</code>), trailing (<code>Which</code> = <code>trailing</code>) or both leading and trailing (<code>Which</code> = <code>both</code>) characters belonging to the set indicated by <code>CharList</code> from the binary string <code>BString</code> . </p>

<p>This is essentially the same as using <code>spanb</code> and/or <code>rspanb</code> in combination with bit syntax to remove the characters. </p>

<p>Example: </p>

<pre><code>&gt; bstring:strip(&lt;&lt;"...He.llo....."&gt;&gt;, latin1, both, [$.]).
&lt;&lt;"He.llo"&gt;&gt;
</code></pre>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if scanned part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, <code>Encoding</code> or <code>Which</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>replace(BString, Separators, Replacement, Where) -&gt; Result</code></h3>

<h3><code>replace(BString, Encoding, Separators, SeparatorsEncoding, Replacement, ReplacementEncoding, Where, ResultEncoding) -&gt; Result</code></h3>

<p>Types:</p>

<pre><code>BString = bstring()
Encoding = SeparatorsEncoding = ReplacementEncoding, ResultEncoding = encoding()
Separators = [ bstring() ]
Replacement = bstring()
Where = first | last | all
Result = bstring()
</code></pre>

<p>Produces the same result as </p>

<pre><code>bstring:join(bstring:split(BString,Encoding,Separators,SeparatorsEncoding,Where,
                           unicode),
             unicode,Replacement,ReplacementEncoding,ResultEncoding)
</code></pre>

<p>but with less overhead. </p>

<h3><code>substr(BString, Start, Length) -&gt; SubBString</code></h3>

<h3><code>substr(BString, Encoding, Start, Length) -&gt; SubBString</code></h3>

<p>Types:</p>

<pre><code>BString = SubBString = bstring()
Encoding = bstring()
Start = integer()
Length = non_negative_integer() | infinity
</code></pre>

<p>Returns a substring of <code>String</code>, starting at the zero-based character position <code>Start</code>, and ending at the end of the binary string (if <code>Length</code> is <code>infinity</code> or up to, but not including, the character position <code>Start+Length</code> (if <code>Length</code> is a non negative integer). </p>

<p>The returned <code>SubBString</code> will have the same encoding as <code>BString</code> . </p>

<p>Example: </p>

<pre><code>&gt; bstring:substr(&lt;&lt;"Hello World"&gt;&gt;, latin1, 3, 5).
&lt;&lt;"lo Wo"&gt;&gt;
</code></pre>

<p>A negative value of <code>Start</code> denotes <code>abs(Start)</code> characters from the <em>end</em> of <code>BString</code>, so that <code>-1</code> is the last character position in the binary string. </p>

<p>Example: </p>

<pre><code>&gt; bstring:substr(&lt;&lt;"Hello World"&gt;&gt;, latin1, -1, 3).
&lt;&lt;"rld"&gt;&gt;
</code></pre>

<p>As the true length of an UTF-8 encoded binary string is quite costly to determine ( <code>O(N)</code>, where <code>N</code> is the number of bytes in the binary), the function is very forgiving about positions given outside of the string, both <code>Start</code> s and <code>Length</code> s. Character positions outside of the string in either direction are collapsed to the empty binary string. </p>

<p>Examples: </p>

<pre><code>&gt; bstring:substr(&lt;&lt;"01234"&gt;&gt;, latin1, 5, 5).
&lt;&lt;&gt;&gt;
&gt; bstring:substr(&lt;&lt;"01234"&gt;&gt;, latin1, 4, 5).
&lt;&lt;"4"&gt;&gt;
&gt; bstring:substr(&lt;&lt;"01234"&gt;&gt;, latin1, -5, 100).
&lt;&lt;"01234"&gt;&gt;
&gt; bstring:substr(&lt;&lt;"01234"&gt;&gt;, latin1, -6, 1).
&lt;&lt;&gt;&gt;    
&gt; bstring:substr(&lt;&lt;"01234"&gt;&gt;, latin1, -6, 2).
&lt;&lt;"0"&gt;&gt;
</code></pre>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h3><code>tokens(BString, SeparatorList) -&gt; Tokens</code></h3>

<h3><code>tokens(BString, Encoding, SeparatorList) -&gt; Tokens</code></h3>

<p>Types:</p>

<pre><code>String = bstring()
Encoding = encoding
SeparatorList = [ non_negative_integer() ]
Tokens = [bstring()]
</code></pre>

<p>Returns a list of tokens in <code>BString</code>, separated by the characters in <code>SeparatorList</code> . </p>

<p>The <code>Tokens</code> returned are encoded in the same character encoding as the <code>BString</code> . </p>

<p>Example: </p>

<pre><code>&gt; bstring:tokens(&lt;&lt;"abc defxxghix jkl"&gt;&gt;, latin1, [$x,$ ]).
[&lt;&lt;"abc"&gt;&gt;, &lt;&lt;"def"&gt;&gt;, &lt;&lt;"ghi"&gt;&gt;, &lt;&lt;"jkl"&gt;&gt;]
</code></pre>

<p><code>SeparatorList</code> is to be viewed as a <em>set</em> of characters, order is not significant. Codepoints given in <code>SeparatorList</code> that cannot be represented by the <code>Encoding</code>, is not an error. </p>

<p>If the encoding is not given, it is assumed to be <code>latin1</code>, implying that no interpretation is given to the bytes in the binary string. </p>

<p>Raises a <code>badarg</code> exception if the searched part of <code>BString</code> does not contain characters encoded according to the <code>Encoding</code> parameter, the <code>Encoding</code> has an invalid value, or any of the parameters are of the wrong type. </p>

<h1>Performance</h1>

<p>This module can, and probably should, be implemented entirely in
Erlang, no BIF's or NIF's are needed.  Both the <code>binary</code> and
<code>unicode</code> modules can be utilized to speed up conversion and indata
checking. The Unicode versions will definitely be slower than the
ISO-Latin-1 versions, as character encoding, decoding and checking is
bound to produce overhead.</p>

<p>The suggested wrapper <code>ubstring</code> should not impose any significant
cost compared to calling <code>bstring</code> with all encoding arguments set
to <code>unicode</code>.</p>

<p>The idea is to make string manipulation using binaries convenient as
it has a great positive impact on systems memory-wise. Increased speed
compared to list-oriented strings is not the goal, although it may
well be a side-effect.</p>

<h1>Reference implementation</h1>

<p>No specific reference implementation is made, the code will however be made available 
on GitHub during any development. </p>

<h1>Copyright</h1>

<p>This document is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons Attribution 3.0 License">Creative Commons license</a>.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0035","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Patrik Nyblom \u0026lt;pan(at)erlang(dot)org\u0026gt;,\n        Fredrik Svahn \u0026lt;Fredrik(dot)Svahn(at)gmail\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 29-Sep-2010\nErlang-Version: R14B\nPost-History:\nReplaces: 9\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 35: \u003ca href=\"eep-0035.md\" title=\"EEP Source\"\u003e Binary string module(s)\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP contains developed suggestions regarding the module \u003ccode\u003ebinary_string\u003c/code\u003e\nfirst suggested in \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e. The module name is now however changed to \u003ccode\u003ebstring\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e suggests several modules and is partially superseded by later\nEEP's (i.e. \u003ca href=\"/eeps/eep-0011\" title=\"EEP 11, intresting extensions to EEP 9\"\u003eEEP 11\u003c/a\u003e and \u003ca href=\"/eeps/eep-0031\" title=\"EEP 31, rewrite of EEP 9, module binary\"\u003eEEP 31\u003c/a\u003e), while still containing valuable suggestions not\nyet implemented. This last remaining module suggested in \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e will therefore\nappear in this separate EEP. This is made in agreement with\nthe original author of \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe module \u003ccode\u003ebstring\u003c/code\u003e is suggested to contain functions for\nconvenient manipulation of textual data stored in binaries,\ni.e. binary strings. It somewhat resembles the \u003ccode\u003estring\u003c/code\u003e module\n(which is list oriented), but is not to be viewed simply as a\n\u003ccode\u003estring\u003c/code\u003e module for binaries.\u003c/p\u003e\n\n\u003cp\u003eThe module suggested handles binary character encoding in both the\nstandard character encodings of Erlang, namely ISO-Latin-1 and UTF-8.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eText strings are traditionally represented as lists of integers in\nErlang. While this is convenient and more or less built into the\nsyntax of the language (i.e. \"ABC\" is syntactic sugar for [$A,$B,$C]),\na more compact representation is often desired. Also, in some\ncircumstances binaries can be more efficient to manipulate in terms of\nalgorithm complexity than lists are (especially in the fixed character\nwidth case of ISO-Latin-1).\u003c/p\u003e\n\n\u003cp\u003eMore modules have been added to the standard libraries lately to aid\nthe usage of binaries for text strings, both as representing\nISO-Latin-1 characters and Unicode strings encoded in UTF-8. Most\nnotably the \u003ccode\u003ere\u003c/code\u003e library, but also the \u003ccode\u003eunicode\u003c/code\u003e module are fairly\nnew additions to \u003ccode\u003estdlib\u003c/code\u003e which will make life easier for the\nprogrammer when it comes to manipulating binary encoded strings. Also\na module for fast searching and replacing in byte oriented binaries is\npresent (the module \u003ccode\u003ebinary\u003c/code\u003e), but no traditional string manipulation module is\nyet in the libraries. To ease use of binary encoded strings, such a module is\nneeded.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe module \u003ccode\u003estring\u003c/code\u003e for text oriented operations on lists has been\npresent in the standard libraries for so long that most programmers\ndon't remember a time when it wasn't there. It is said to originally\nbe a merge of two different string modules, written and designed by\ntwo different programmers with possibly slightly different goals and\ndefinitely slightly different views on function naming. While\nsometimes criticized for duplicated functionality and inconsistent\nfunction naming, among other things, the module has remained useful\nthroughout the entire lifespan of Erlang/OTP. The string\nrepresentation used has also withstood the evolution of Unicode.\u003c/p\u003e\n\n\u003cp\u003eIt is worth to note that the only functions in the \u003ccode\u003estring\u003c/code\u003e module\nthat actually are language or region dependent are later additions to\nthe module. Those functions (like \u003ccode\u003eto_upper\u003c/code\u003e, \u003ccode\u003eto_lower\u003c/code\u003e, \u003ccode\u003eto_integer\u003c/code\u003e and\n\u003ccode\u003eto_float\u003c/code\u003e), or their binary equivalence, are not part of the module\ninterface I suggest for \u003ccode\u003ebstring\u003c/code\u003e for the simple reason that they\nneed language support not yet present in Erlang. A future EEP might\nsuggest such language support (i.e. some kind of \"locale\" support), but\nthat is future work not covered by this EEP.\u003c/p\u003e\n\n\u003cp\u003eSo, however criticized, the string module is very useful for\nmanipulating lists, and the same functionality for binary strings is\ndesirable. While a lot of the functionality will be similar, there are\nsome major issues to consider when implementing a module for\nmanipulating strings encoded in binaries:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eUnicode - Binaries can have different encodings. A Character encoded\nas UTF-8 might take more than one (up to four) byte positions, and\neven the same character can have different encodings in ISO-Latin-1\nand UTF-8 (all codepoints from 128 to 255). The functions need to be\ninformed of the character encoding explicitly, The encoding\ninformation is not present in the binaries.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eMixed character encodings - As characters can be encoded in\ndifferent ways, two strings in the same program could have different\nencodings. Supplying the functions with non-homogeneous string\nencoding data should be consistently solved throughout the module,\nas should the selection of returned encoding where applicable.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eDefault character encoding - As functions will take extra arguments\nto specify encoding, a consistent default might be useful. Choosing\nthe default is not entirely simple, as the tradition states\nISO-Latin-1, while the future suggests UTF-8.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eLanguages - Erlang has no notion of \"Locale\" or preferred number\nformat. A general string module can not assume neither a specific\nnotion of uppercase or lowercase letters, nor a specific number\nencoding format (especially true for floating point numbers).\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eWord separators - The space character is certainly not the only word\nseparator for textual data (in any language). The notion of words\nseparated by spaces imposes a restriction of the relevant languages.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eLeft to right or right to left - Notions like left or right to\ndenote the beginning or end of a string are certainly not language\nindependent. While strings in a language have a beginning and an end,\nthat beginning and end may be placed both to the left, the right or\neven at the top, bottom or center of the graphical representation. A\nstring manipulation module should not use naming implying a\nleft-to-right script, or any other type of script.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eNaming and duplicated functionality - The original \u003ccode\u003estring\u003c/code\u003e module\nhas been accused of having somewhat inconsistent naming and\nfunctionality duplicated. In fact the only duplicated functions are\n\u003ccode\u003esubstr\u003c/code\u003e and \u003ccode\u003esub_string\u003c/code\u003e. Some cleanup of the interface might\nbe needed.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eByte oriented versus character oriented return values - When dealing\nwith Unicode data, a character may take more than one byte, why\ni.e. counting the number of characters in a string tells you very\nlittle about the actual size of the string in bytes. Furthermore,\nlater processing of a binary might require byte-oriented\nmanipulation of a string rather than character oriented (i.e. you\nwant to manipulate the string using the \u003ccode\u003ebinary\u003c/code\u003e module or with\nbit-syntax), while characters are actually what constitutes a\nstring, not bytes. You would want both.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eNew or replaced functionality - New functionality have been suggested from several sources,\nmost notably \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e. For example the function \u003ccode\u003esplit\u003c/code\u003e suggested in \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e is very similar to \n\u003cc\u003estring:tokens/2\u003c/c\u003e. Should we keep \u003ccode\u003etokens\u003c/code\u003e anyway, for example?\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eI'll address the different issues below.\u003c/p\u003e\n\n\u003ch2\u003eUnicode\u003c/h2\u003e\n\n\u003cp\u003eThe interface has to support both ISO-Latin-1 and UTF-8. The \u003ccode\u003eunicode\u003c/code\u003e module supports even more encodings, but Erlang/OTP uses UTF-8 for all \"internal\" interfaces and UTF-8 is the expected encoding of a binary Unicode string. Even though UTF-8 is compatible with ISO-Latin-1 in the 7bit ASCII range, characters with codepoints between 128 and 255 are encoded differently in the \"plain\" ISO-Latin-1 encoding and in UTF-8. This means that all functions in the \u003ccode\u003ebstring\u003c/code\u003e module need to have the actual encoding as one or more extra parameters.\u003c/p\u003e\n\n\u003cp\u003eOne could invent a more abstract binary string format where the data is for example represented as a tuple with the string and the encoding packed together. However no other module supports such a string construct and I don't think that would really add something, neither functionality nor readability. Consider code like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebstring:tokens(Bin,latin1,[$ ,$\\n])\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecompared to:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebstring:tokens({Bin,latin1}, [$ ,$\\n]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor even:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebstring:tokens(#bstring{data = Bin, encoding = latin1}, [$ ,$\\n]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn many cases the extra information needs to be added in connection to the call, making the code no more readable or simple to write than with the separate extra argument. Consider if we had a default value for encoding. The code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(Data) -\u0026gt;\n       bstring:tokens(Data,[$ ,$\\n]).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewould not in any way indicate if \u003ccode\u003eData\u003c/code\u003e was supposed to be a binary with the default encoding or some kind of complex data structure indicating both the actual string and it's encoding. \u003c/p\u003e\n\n\u003cp\u003eI think the extra argument for the encoding is straight forward and simple, and it makes programming easier when using the binary string in other modules as well (i.e. \u003ccode\u003ere\u003c/code\u003e, \u003ccode\u003ebinary\u003c/code\u003e, \u003ccode\u003efile\u003c/code\u003e etc). I think we should simply not have a special string datatype for this module, character encoding should be supplied as a separate argument.\u003c/p\u003e\n\n\u003ch2\u003eMixed character encodings\u003c/h2\u003e\n\n\u003cp\u003eTo ease transition between character encodings, I think the interface should accept different encodings for both different parameters and the return value. This makes it possible to convert on the fly and for the functions to decide on the most efficient character conversion path for the supplied arguments and the return value. \u003c/p\u003e\n\n\u003cp\u003eThe downside of this approach is that some functions will take a lot of parameters telling different character encodings, for example a string concatenation routine could look like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e  concat(BString1, Encoding1, BString2, Encoding2, Encoding3) -\u0026gt; BString3\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ebeing called like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e  US = bstring:concat(SA,latin1, SB, latin1, unicode),\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhich might look a little awkward to write. On the other hand, conversion is made on the fly and you will not need to explicitly call the \u003ccode\u003eunicode\u003c/code\u003e module to convert the result. \u003c/p\u003e\n\n\u003cp\u003eI think implicit conversion is so useful that it is worth the extra arguments. For example a \u003ccode\u003econcat\u003c/code\u003e function would be more or less useless without it, the bit syntax would be much easier to use if no conversion should be allowed.\u003c/p\u003e\n\n\u003ch2\u003eDefault character encoding\u003c/h2\u003e\n\n\u003cp\u003eChoosing a default character encoding is not obvious. While ISO-Latin-1 is the default in Erlang (i.e. \u0026lt;\u0026lt;\"korvsmörgås\"\u003e\u003e gives a ISO-Latin-1 encoded binary string), UTF-8 usage is expected to grow in the future. \u003c/p\u003e\n\n\u003cp\u003eAlthough its tempting to select UTF-8 as the default encoding, I think we should stick to ISO-Latin-1 as the default even for this module. There are several reasons:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eWe need not, as a rule, impose new standards in every module we add\nto the standard library. Consistence certainly adds value, and both\nthe bit-syntax, the source code encoding and things like the\nio:format routine has ISO-Latin-1 as default. Lets not make this\nmodule inconsistent with the others.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe \u003ccode\u003estring\u003c/code\u003e module is often used to manipulate arbitrary lists\nof integers, not always actually representing textual data. In the\nsame way can \u003ccode\u003ebstring\u003c/code\u003e probably be used to manipulate arbitrary\nblobs of bytes if ISO-latin-1 versions are used. ISO-Latin-1 is\nactually the raw bytes uninterpreted, why any binary data can be\nworked on in a ISO-Latin-1 oriented routine. Using UTF-8 encoding as\ndefault would narrow the use for the default functions to only work\non real text data.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eThe pure ISO-Latin-1 implementations of the functions will be the\nmost efficient ones as no data checking at all is needed. Any byte\nvalue is acceptable in any version. Some functions are usable on\nUTF-8 strings even though they expect ISO-Latin-1 data. The\ndifference between the ISO-Latin-1 version and the UTF-8 version\nbeing only indata control. If the data given to, for example\n\u003ccode\u003ebstring:concat\u003c/code\u003e is already checked for correct UTF-8, the simpler\nISO-Latin-1 version of the function is both more efficient and\nguaranteed to give as correct output as the input:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    CorrectUtf8_1 = give_me_good_string(),\n    CorrectUtf8_2 = give_me_another_good_string(),\n    CorrectUtf8_3 = bstring:concat(CorrectUtf8_1, latin1, CorrectUtf8_2, latin1, latin1),\n    ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSimply put, ISO-Latin-1 versions of the functions are more generally\nuseful than pure UTF-8 versions and are also more efficient.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eA wrapper module providing pure UTF-8 interfaces can easily be\nwritten. The overhead of going via a wrapper would be relatively\nlower for an UTF-8 wrapper than for an ISO-Latin-1 ditto, as the\noverhead of character decoding/encoding of UTF-8 strings in the\nmodule would be quite high. Simply put, a wrapper would cost very\nlittle compared to the cost of checking the data for UTF-8\ncorrectness.\u003c/p\u003e\n\n\u003cp\u003eI actually suggest a module \u003ccode\u003eubstring\u003c/code\u003e that has the part of the\n\u003ccode\u003ebstring\u003c/code\u003e interface where a default encoding is implied, but with\nthe difference that UTF-8 is expected. For example, a function\n\u003ccode\u003eubstring:tokens/2\u003c/code\u003e would look like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003etokens(S,L) -\u0026gt; bstring:tokens(S,unicode,L).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eQuite simple.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTo conclude, I think all functions should exist in a version where no\nencoding is supplied and ISO-Latin-1 encoded data is expected.\u003c/p\u003e\n\n\u003ch2\u003eLanguages\u003c/h2\u003e\n\n\u003cp\u003eEven though Unicode characters can be used to express text in most\nknown, living and dead scripts, language and region knowledge is a\ncompletely different thing. String interfaces often impose language\nspecific properties of the string, like left-to-right writing\ndirection, the notion of words built up by space separated groups of\ncharacters, ways of representing numbers and decimal points etc. As\nErlang does not (yet) have a way of specifying such language-, or\nregion-specific properties of a string, the interface should not\ncontain language-dependent functionality. The \u003ccode\u003estring\u003c/code\u003e module did not\noriginally contain such functions (except that character alignment\nfunctions were named \u003ccode\u003eleft\u003c/code\u003e and \u003ccode\u003eright\u003c/code\u003e), but unfortunately\nfunctions like \u003ccode\u003eto_float\u003c/code\u003e and \u003ccode\u003eto_upper\u003c/code\u003e have been added.\u003c/p\u003e\n\n\u003cp\u003eI think that having language-dependent functions in the \u003ccode\u003estring\u003c/code\u003e\nmodule was a mistake and I do not want to make that mistake\nagain. Hence I have not included such functions or names in\n\u003ccode\u003ebstring\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eI rather suggest \"Locale\" functionality as a subject of a future\nEEP. For those who consider that simple, try to write a correct\n\u003ccode\u003eto_upper\u003c/code\u003e function for just all European languages, make sure it\nworks on all platforms that can run Erlang... Maybe not rocket science, but a\n\u003cem\u003elot\u003c/em\u003e of metadata is required. Data that is not always available in\nthe underlying OS, but probably needs to be distributed with Erlang/OTP for\nconsistent functionality. Definitely worth it's own EEP.\u003c/p\u003e\n\n\u003ch2\u003eWord separators\u003c/h2\u003e\n\n\u003cp\u003eIn connection with language independence, I think we should drop the\nnotion of \u003cem\u003ewords\u003c/em\u003e as a group of characters separated by space. The word\n\"token\" is more general and does not in the same way indicate language\nconstructs. The \u003ccode\u003estring\u003c/code\u003e module has the ASCII space character as a\ndefault for word separation, which I think should be dropped in\n\u003ccode\u003ebstring\u003c/code\u003e. Whatever should separate tokens should be supplied,\npossibly as alternatives. I therefore suggest the functions\n\u003ccode\u003ebstring:num_tokens\u003c/code\u003e and \u003ccode\u003ebstring:nth_token\u003c/code\u003e to fulfill the\nfunctionality of \u003ccode\u003estring:words\u003c/code\u003e and \u003ccode\u003estring:sub_word\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs in \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e, I suggest a new function \u003ccode\u003esplit\u003c/code\u003e to handle the case\nof multi-character separators for tokens. A compilation of \u003ccode\u003esplit\u003c/code\u003e\nand \u003ccode\u003ejoin\u003c/code\u003e makes a convenient \u003ccode\u003ereplace\u003c/code\u003e function too.\u003c/p\u003e\n\n\u003ch2\u003eLeft-to-right or Right-to-left\u003c/h2\u003e\n\n\u003cp\u003eAs mentioned earlier, I don't think direction of the graphical\nrepresentation should be implied in the interface, why I suggest using\nnotions like leading and trailing (meaning leading and trailing\ncharacters in the binary) rather than any directional notions. I also\nthink aligning strings (like in \u003ccode\u003estrings:right\u003c/code\u003e etc.) could be solved\nin one function \u003ccode\u003ealign\u003c/code\u003e, taking one of the atoms \u003ccode\u003eleading\u003c/code\u003e,\n\u003ccode\u003etrailing\u003c/code\u003e or \u003ccode\u003ecenter\u003c/code\u003e as a parameter, if it should at all be\nimplemented.\u003c/p\u003e\n\n\u003ch2\u003eNaming and duplicated functionality\u003c/h2\u003e\n\n\u003cp\u003eI definitely do not think we should have all interfaces from\n\u003ccode\u003estring\u003c/code\u003e duplicated to \u003ccode\u003ebstring\u003c/code\u003e. Especially interfaces that are\naliases should not be carried along to the \u003ccode\u003ebstring\u003c/code\u003e module. Most\nfunctions in the \u003ccode\u003estring\u003c/code\u003e module however have short and fairly\ndescribing names, often similar to names found in other languages. I\nthink using a \u003ccode\u003er\u003c/code\u003e prefix for functionality working from the end of\nthe string towards the beginning is a good choice, as is \u003ccode\u003ec\u003c/code\u003e for\ncomplement.\u003c/p\u003e\n\n\u003ch2\u003eByte oriented versus character oriented return values\u003c/h2\u003e\n\n\u003cp\u003eSome functions in \u003ccode\u003estring\u003c/code\u003e, that are certainly useful, return numbers\ndenoting character positions. The same functions should definitely be\npresent in the \u003ccode\u003ebstring\u003c/code\u003e module and the return values should\ndefinitely be character oriented. However byte offsets are definitely\nuseful, for example if we use a function like \u003ccode\u003espan\u003c/code\u003e to find the\nfirst character not in a set of characters, we might want the byte\noffset of that first character too.\u003c/p\u003e\n\n\u003cp\u003eI suggest adding some interfaces returning byte offsets, or \u003cem\u003epart()'s\u003c/em\u003e\nlike the ones used in the \u003ccode\u003ebinary\u003c/code\u003e module and by \u003ccode\u003ere\u003c/code\u003e, to cope\nwith the need for byte offsets and lengths in some circumstances. A\n\u003ccode\u003eb\u003c/code\u003e suffix to the function name could denote such functionality, so\nthat \u003ccode\u003ebstring:span\u003c/code\u003e returns a character position while\n\u003ccode\u003ebstring:spanb\u003c/code\u003e returns a byte position and \u003ccode\u003ebtring:str\u003c/code\u003e returns a\ncharacter position and \u003ccode\u003ebstring:strb\u003c/code\u003e returns a \u003cem\u003epart()\u003c/em\u003e. Although\nthis will in the end give rise to more functions in the interface,\nhaving return-type-changing options in an option list is not the way\nto go (I know, I have them in \u003ccode\u003ere\u003c/code\u003e, but it's still not generally a\ngood idea...).\u003c/p\u003e\n\n\u003ch2\u003eNew or replaced functionality\u003c/h2\u003e\n\n\u003cp\u003eWhen writing a general string module, there is no end to the new, more\nor less esoteric, functionality one could add. I think we, at least\nin an initial implementation, should stick to the functionality\noutlined in \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e, namely extending \u003ccode\u003estr\u003c/code\u003e and friends to\noptionally take a list of alternative strings to search for, add a\nfunction \u003ccode\u003esplit\u003c/code\u003e to take care of multi-character separators (as\nopposed to single character separators in the function \u003ccode\u003etokens\u003c/code\u003e) and\na substitution function, which I think should be named \u003ccode\u003ereplace\u003c/code\u003e as\nin other modules.\u003c/p\u003e\n\n\u003cp\u003eThe use of pre-compiled matches from the \u003ccode\u003ebinary\u003c/code\u003e module is however\nnot a good idea, as the \u003ccode\u003ebinary\u003c/code\u003e module has no notion of character\nencoding. Search strings need to be given in defined character\nencodings and both the \"haystacks\" and the \"needles\" encoding need to\nbe known when doing an efficient search. So - no pre-compiled search\nexpressions.\u003c/p\u003e\n\n\u003ch2\u003eExcerpt of a suggested manual page\u003c/h2\u003e\n\n\u003cp\u003eAs made obvious above, I prefer the name \u003ccode\u003ebstring\u003c/code\u003e for a binary\nstring module in favor of the more verbose name \u003ccode\u003ebinary_string\u003c/code\u003e\noriginally suggested. In that module \u003ccode\u003ebstring\u003c/code\u003e, I suggest the\nfollowing interfaces, expressed as in a manual page of OTP.\u003c/p\u003e\n\n\u003ch2\u003eDATA TYPES\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e    encoding() = latin1 | unicode | utf8\n      - The encoding of characters in the binary data, both input and output\n    bstring() \n      - Binary with characters encoded either in ISO-Latin-1 or UTF-8\n    unicode_char() = non_negative_integer() \n      - An integer representing a valid unicode codepoint\n    non_negative_integer()\n      - An integer \u0026gt;= 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eEXPORTS\u003c/h2\u003e\n\n\u003ch3\u003e\u003ccode\u003ealign(BString, Alignment, Number, Char) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ealign(BString, Encoding, Alignment, Number, Char) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = Result = bstring()\nEncoding = encoding()\nAlignment = leading | trailing | center\nNumber = non_negative_integer()\nChar = unicode_char()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAligns the characters in \u003ccode\u003eBString\u003c/code\u003e in a \u003ccode\u003eResult\u003c/code\u003e of \u003ccode\u003eNumber\u003c/code\u003e characters according to the \u003ccode\u003eAlignment\u003c/code\u003e parameter. Alignment is done by inserting the character \u003ccode\u003eChar\u003c/code\u003e in the beginning or end (or both) of the binary string. \u003c/p\u003e\n\n\u003cp\u003eThe resulting binary string will contain exactly \u003ccode\u003eNumber\u003c/code\u003e characters, the string is truncated if it contains more characters than \u003ccode\u003eNumber\u003c/code\u003e - either at the end if \u003ccode\u003eAlignment\u003c/code\u003e is \u003ccode\u003eleading\u003c/code\u003e, or at the beginning if \u003ccode\u003eAlignment\u003c/code\u003e is \u003ccode\u003etrailing\u003c/code\u003e, or at both ends if \u003ccode\u003eAlignment\u003c/code\u003e is \u003ccode\u003ecenter\u003c/code\u003e . If \u003ccode\u003eEncoding\u003c/code\u003e is \u003ccode\u003eunicode\u003c/code\u003e, the \u003ccode\u003eResult\u003c/code\u003e may well contain more bytes than \u003ccode\u003eNumber\u003c/code\u003e, as one character may require several bytes. \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:align(\u0026lt;\u0026lt;\"Hello\"\u0026gt;\u0026gt;, latin1, center, 10, $.).\n\u0026lt;\u0026lt;\"..Hello...\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, \u003ccode\u003eEncoding\u003c/code\u003e or \u003ccode\u003eAlignment\u003c/code\u003e has an invalid value, the character \u003ccode\u003eChar\u003c/code\u003e cannot be encoded in the character encoding given as \u003ccode\u003eEncoding\u003c/code\u003e or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003echr(BString, Character) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003echr(BString, Encoding, Character) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erchr(BString, Character) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erchr(BString, Encoding, Character) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = encoding()\nCharacter = unicode_char()\nPosition = integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the (zero-based) character position of the first/last occurrence of \u003ccode\u003eCharacter\u003c/code\u003e in \u003ccode\u003eBString\u003c/code\u003e . \u003ccode\u003e-1\u003c/code\u003e is returned if \u003ccode\u003eCharacter\u003c/code\u003e does not occur. \u003c/p\u003e\n\n\u003cp\u003eNote that the character position is not the same as the byte position. Use the \u003ccode\u003echrb\u003c/code\u003e and \u003ccode\u003erchrb\u003c/code\u003e functions to get the byte positions. \u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003eCharacter\u003c/code\u003e cannot be represented in the encoding, it is not an error, you are just certain to get \u003ccode\u003e-1\u003c/code\u003e as a return value. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if the searched part of \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003echrb(BString, Character) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003echrb(BString, Encoding, Character) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erchrb(BString, Character) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erchrb(BString, Encoding, Character) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = encoding()\nCharacter = unicode_char()\nBytePosition = integer()\nByteLength = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWorks as \u003ccode\u003echr\u003c/code\u003e and \u003ccode\u003erchr\u003c/code\u003e respectively, but returns the byte position and byte length of the character. \u003c/p\u003e\n\n\u003cp\u003eIf the character is not found, \u003ccode\u003e{-1,0}\u003c/code\u003e is returned. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003econcat(BString1, BString2) -\u0026gt; BString3\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003econcat(BString1, Encoding1, BString2, Encoding2, Encoding3) -\u0026gt; BString3\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString1 = BString2 = BString3 = bstring()\nEncoding1 = Encoding2 = Encoding3 = encoding()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConcatenates two binary strings to form a new string. Returns the new binary string in the encoding given by Encoding3. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if \u003ccode\u003eBString1\u003c/code\u003e or \u003ccode\u003eBstring2\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding1\u003c/code\u003e and \u003ccode\u003eEncoding2\u003c/code\u003e parameters, the encoding parameters has an invalid value, the codepoints in the in-parameters cannot be represented in the output encoding or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003eequal(BString1, BString2) -\u0026gt; bool()\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003eequal(BString1, Encoding1, BString2, Encoding2) -\u0026gt; bool()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString1 = BString2 = bstring()\nEncoding1 = Encoding2 = encoding()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTests whether two binary strings are equal. Returns \u003ccode\u003etrue\u003c/code\u003e if they are, otherwise \u003ccode\u003efalse\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eEncoding1\u003c/code\u003e is the encoding of \u003ccode\u003eBString1\u003c/code\u003e and \u003ccode\u003eEncoding2\u003c/code\u003e is the encoding of \u003ccode\u003eBString2\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eNote that the strings can have different encoding and that it is the character values encoded in the strings that are compared. The binary strings are scanned as long as they are equal, meaning that if the function returns \u003ccode\u003etrue\u003c/code\u003e, both strings are correctly encoded, while a return value of \u003ccode\u003efalse\u003c/code\u003e does not guarantee correct encoding in both binary strings. An exception is raised if faulty encoding is determined while comparing the strings, not if parts of the string not inspected contain encoding errors. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if wrongly encoded characters, according to the encoding parameters, are encountered during comparison, the encoding parameters has an invalid value or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003ejoin(BStringList, Separator) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ejoin(BStringList, BStringListEncoding, Separator, SeparatorEncoding, ResultEncoding) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBStringList = [bstring()]\nBStringListEncoding = SeparatorEncoding = ResultEncoding = encoding()\nSeparator = bstring()\nResult = bstring()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns a binary string with the elements of \u003ccode\u003eBStringList\u003c/code\u003e separated by the binary string in \u003ccode\u003eSeperator\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eAll the binary strings in \u003ccode\u003eBStringList\u003c/code\u003e should have the same encoding (given as \u003ccode\u003eBStringListEncoding\u003c/code\u003e . The \u003ccode\u003eSeparator\u003c/code\u003e can however have a different encoding (given as \u003ccode\u003eSeparatorEncoding\u003c/code\u003e ), as can the \u003ccode\u003eResult\u003c/code\u003e (given as \u003ccode\u003eResultEncoding\u003c/code\u003e ). \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:join([\u0026lt;\u0026lt;\"one\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"two\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"three\"\u0026gt;\u0026gt;], latin1, \u0026lt;\u0026lt;\", \"\u0026gt;\u0026gt;, latin1, latin1).\n\u0026lt;\u0026lt;\"one, two, three\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if binary strings in \u003ccode\u003eBStringList\u003c/code\u003e or the \u003ccode\u003eSeparator\u003c/code\u003e do not contain characters encoded according to the \u003ccode\u003eBStringListEncoding\u003c/code\u003e and \u003ccode\u003eSeparatorEncoding\u003c/code\u003e parameters respectively, the encoding parameters has an invalid value, the codepoints in the in-parameters cannot be represented in the output encoding \u003ccode\u003eResultEncoding\u003c/code\u003e or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003elen(BString) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003elen(BString, Encoding) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = encoding()\nLength = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the number of characters in the binary string. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003enth_token(BString, N, CharList) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003enth_token(BString, Encoding, N, CharList) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = Result = bstring()\nEncoding = encoding()\nCharList = [ unicode_char() ]\nN = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the token number \u003ccode\u003eN\u003c/code\u003e of \u003ccode\u003eBString\u003c/code\u003e (zero-based). Tokens are separated by the characters in \u003ccode\u003eCharList\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eThe returned token will have the same encoding as \u003ccode\u003eBString\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eFor example: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:nth_token(\u0026lt;\u0026lt;\" Hello old boy !\"\u0026gt;\u0026gt;,latin1,3,[$o, $ ]).\n\u0026lt;\u0026lt;\"ld b\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eCharList\u003c/code\u003e is to be viewed as a \u003cem\u003eset\u003c/em\u003e of characters, order is not significant. Codepoints given in \u003ccode\u003eCharList\u003c/code\u003e that cannot be represented by the \u003ccode\u003eEncoding\u003c/code\u003e, is not an error. \u003c/p\u003e\n\n\u003cp\u003eValues of \u003ccode\u003eN\u003c/code\u003e \u003e= number of tokens in \u003ccode\u003eBString\u003c/code\u003e will result in the empty binary string \u003ccode\u003e\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u003c/code\u003e being returned. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003enum_tokens(BString, CharList) -\u0026gt; Count\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003enum_tokens(BString, Encoding, CharList) -\u0026gt; Count\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = encoding()\nCharList = [ unicode_char() ]\nCount = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the number of tokens in \u003ccode\u003eString\u003c/code\u003e, separated by the characters in \u003ccode\u003eCharList\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eThe result is the same as for length(bstring:tokens(BString,Encoding,CharList)), but avoids building the result. \u003c/p\u003e\n\n\u003cp\u003eFor example: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; num_tokens(\u0026lt;\u0026lt;\" Hello old boy!\"\u0026gt;\u0026gt;, latin1, [$o, $ ]).\n4\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eCharList\u003c/code\u003e is to be viewed as a \u003cem\u003eset\u003c/em\u003e of characters, order is not significant. Codepoints given in \u003ccode\u003eCharList\u003c/code\u003e that cannot be represented by the \u003ccode\u003eEncoding\u003c/code\u003e, is not an error. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003espan(BString, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003espan(BString, Encoding, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erspan(BString, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erspan(BString, Encoding, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ecspan(BString, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ecspan(BString, Encoding, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ercspan(BString, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ercspan(BString, Encoding, Chars) -\u0026gt; Length\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = encoding()\nChars = [ integer() ]\nLength = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the length (in characters) of the maximum initial (span and cspan) or trailing (rspan and rcspan) segment of BString, which consists entirely of characters from (span and rspan), or not from (cspan and rcspan) Chars. \u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eChars\u003c/code\u003e is to be viewed as a \u003cem\u003eset\u003c/em\u003e of characters, order is not significant. Codepoints given in \u003ccode\u003eChar\u003c/code\u003e that cannot be represented by the \u003ccode\u003eEncoding\u003c/code\u003e, is not an error. \u003c/p\u003e\n\n\u003cp\u003eFor example: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:span(\u0026lt;\u0026lt;\"\\t    abcdef\"\u0026gt;\u0026gt;,latin1,\" \\t\").\n5\n\u0026gt; bstring:cspan((\u0026lt;\u0026lt;\"\\t    abcdef\"\u0026gt;\u0026gt;,latin1, \" \\t\").\n0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCodepoints in \u003ccode\u003eChars\u003c/code\u003e that can not be represented by \u003ccode\u003eEncoding\u003c/code\u003e is not considered an error. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if the searched part of \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003espanb(BString, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003espanb(BString, Encoding, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erspanb(BString, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erspanb(BString, Encoding, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ecspanb(BString, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ecspanb(BString, Encoding, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ercspanb(BString, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ercspanb(BString, Encoding, Chars) -\u0026gt; ByteLength\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = encoding()\nChars = [ integer() ]\nByteLength = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWork exactly as the functions \u003ccode\u003espan\u003c/code\u003e, \u003ccode\u003erspan\u003c/code\u003e, \u003ccode\u003ecspan\u003c/code\u003e and \u003ccode\u003ercspan\u003c/code\u003e respectively, but returns the number of bytes rather than the number of characters. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003esplit(BString, Separators, Where) -\u0026gt; Tokens\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003esplit(BString, Encoding, Separators, SepEncoding, Where, ReturnEncoding) -\u0026gt; Tokens\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eString = bstring()\nEncoding = SepEncoding = ReturnEncoding = encoding()\nSeparators = [ bstring() ]\nWhere = first | last | all\nTokens = [bstring()]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns a list of tokens in \u003ccode\u003eBString\u003c/code\u003e, separated by the binary strings in \u003ccode\u003eSeparators\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eTokens\u003c/code\u003e returned are encoded according to \u003ccode\u003eReturnEncoding\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:split(\u0026lt;\u0026lt;\"abc defxxghix jkl\"\u0026gt;\u0026gt;, latin1, [\u0026lt;\u0026lt;\"x\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\" \"\u0026gt;\u0026gt;],all,latin1).\n[\u0026lt;\u0026lt;\"abc\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"def\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"ghi\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"jkl\"\u0026gt;\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eSeparators\u003c/code\u003e is to be viewed as a \u003cem\u003eset\u003c/em\u003e of binary strings, order is not significant. Codepoints given in \u003ccode\u003eSeparators\u003c/code\u003e that cannot be represented by the \u003ccode\u003eEncoding\u003c/code\u003e, is not an error. \u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eWhere\u003c/code\u003e parameter specifies at which occurrence of any of the \u003ccode\u003eSeparators\u003c/code\u003e the binary string is to be split, either at the \u003ccode\u003efirst\u003c/code\u003e occurrence, the \u003ccode\u003elast\u003c/code\u003e occurrence or at \u003ccode\u003eall\u003c/code\u003e occurrences, in which case the \u003ccode\u003eTokens\u003c/code\u003e may be an arbitrary long list. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if \u003ccode\u003eBString\u003c/code\u003e or \u003ccode\u003eSeparators\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e and \u003ccode\u003eSepEncoding\u003c/code\u003e parameters respectively, the resulting tokens cannot be encoded in the \u003ccode\u003eReturnEncoding\u003c/code\u003e, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003estr(BString, SubBStrings) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003estr(BString, Encoding, SubBStrings, SubEnc) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erstr(BString, SubBStrings) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erstr(BString, Encoding, SubBStrings, SubEnc) -\u0026gt; Position\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nSubBString = bstring() | [ bstring() ]\nEncoding = SubEnc = encoding()\nPosition = integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the (zero-based) character position where the first/last occurrence of any of the \u003ccode\u003eSubBStrings\u003c/code\u003e begins in \u003ccode\u003eBString\u003c/code\u003e . \u003ccode\u003e-1\u003c/code\u003e is returned if \u003ccode\u003eSubBString\u003c/code\u003e does not exist in \u003ccode\u003eBString\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eNote that the \u003ccode\u003eCharacter\u003c/code\u003e position is not the same as the byte position. Use the \u003ccode\u003estrb\u003c/code\u003e and \u003ccode\u003erstrb\u003c/code\u003e functions to get the byte positions. \u003c/p\u003e\n\n\u003cp\u003eThe encoding need not be the same for \u003ccode\u003eBString\u003c/code\u003e and \u003ccode\u003eSubBStrings\u003c/code\u003e, however all strings in SubBStrings need to have the same encoding. \u003c/p\u003e\n\n\u003cp\u003eIf the codepoints in SubBString can not be represented in the encoding of BString, that is not an error, but will always result in the return value -1. \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:str(\u0026lt;\u0026lt;\" Hello Hello World World \"\u0026gt;\u0026gt;,latin1,\u0026lt;\u0026lt;\"Hello World\"\u0026gt;\u0026gt;,latin1).\n7\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNote that if both encodings are the same and repeated searches with the same \u003ccode\u003eSubBStrings\u003c/code\u003e are to be performed, it is more efficient to use the \u003ccode\u003ebinary:match/{2,3}\u003c/code\u003e functions with a precompiled pattern on the raw binary data. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if the searched part of \u003ccode\u003eBString\u003c/code\u003e or \u003ccode\u003eSubBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e and \u003ccode\u003eSubEnc\u003c/code\u003e parameters, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003estrb(BString, SubBStrings) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003estrb(BString, Encoding, SubBStrings, SubEnc) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erstrb(BString, SubBStrings) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003erstrb(BString, Encoding, SubBStrings, SubEnc) -\u0026gt; {BytePosition, ByteLength}\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nSubBString = bstring() | [ bstring() ]\nEncoding = SubEnc = encoding()\nBytePosition = integer()\nByteLength = non_negative_integer()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWorks as \u003ccode\u003estr\u003c/code\u003e and \u003ccode\u003erstr\u003c/code\u003e respectively, but returns the byte position and byte length of the found substring. \u003c/p\u003e\n\n\u003cp\u003eNote that \u003ccode\u003eByteLength\u003c/code\u003e is the length the found substring has in \u003ccode\u003eBString\u003c/code\u003e, regardless of the encoding in \u003ccode\u003eSubBStrings\u003c/code\u003e, so that \u003ccode\u003eByteLength\u003c/code\u003e may be both larger and smaller than \u003ccode\u003ebyte_size(SubBString)\u003c/code\u003e depending on the binary string's encoding. \u003c/p\u003e\n\n\u003cp\u003eIf the substring is not found, \u003ccode\u003e{-1,0}\u003c/code\u003e is returned. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003estrip(BString, Which, CharList) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003estrip(BString, Encoding, Which, CharList) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = Result = bstring()\nEncoding = encoding()\nWhich = leading | trailing | both\nCharList = [ unicode_char() ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRemoves leading (\u003ccode\u003eWhich\u003c/code\u003e = \u003ccode\u003eleading\u003c/code\u003e), trailing (\u003ccode\u003eWhich\u003c/code\u003e = \u003ccode\u003etrailing\u003c/code\u003e) or both leading and trailing (\u003ccode\u003eWhich\u003c/code\u003e = \u003ccode\u003eboth\u003c/code\u003e) characters belonging to the set indicated by \u003ccode\u003eCharList\u003c/code\u003e from the binary string \u003ccode\u003eBString\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eThis is essentially the same as using \u003ccode\u003espanb\u003c/code\u003e and/or \u003ccode\u003erspanb\u003c/code\u003e in combination with bit syntax to remove the characters. \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:strip(\u0026lt;\u0026lt;\"...He.llo.....\"\u0026gt;\u0026gt;, latin1, both, [$.]).\n\u0026lt;\u0026lt;\"He.llo\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if scanned part of \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, \u003ccode\u003eEncoding\u003c/code\u003e or \u003ccode\u003eWhich\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003ereplace(BString, Separators, Replacement, Where) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003ereplace(BString, Encoding, Separators, SeparatorsEncoding, Replacement, ReplacementEncoding, Where, ResultEncoding) -\u0026gt; Result\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = bstring()\nEncoding = SeparatorsEncoding = ReplacementEncoding, ResultEncoding = encoding()\nSeparators = [ bstring() ]\nReplacement = bstring()\nWhere = first | last | all\nResult = bstring()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eProduces the same result as \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebstring:join(bstring:split(BString,Encoding,Separators,SeparatorsEncoding,Where,\n                           unicode),\n             unicode,Replacement,ReplacementEncoding,ResultEncoding)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ebut with less overhead. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003esubstr(BString, Start, Length) -\u0026gt; SubBString\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003esubstr(BString, Encoding, Start, Length) -\u0026gt; SubBString\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBString = SubBString = bstring()\nEncoding = bstring()\nStart = integer()\nLength = non_negative_integer() | infinity\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns a substring of \u003ccode\u003eString\u003c/code\u003e, starting at the zero-based character position \u003ccode\u003eStart\u003c/code\u003e, and ending at the end of the binary string (if \u003ccode\u003eLength\u003c/code\u003e is \u003ccode\u003einfinity\u003c/code\u003e or up to, but not including, the character position \u003ccode\u003eStart+Length\u003c/code\u003e (if \u003ccode\u003eLength\u003c/code\u003e is a non negative integer). \u003c/p\u003e\n\n\u003cp\u003eThe returned \u003ccode\u003eSubBString\u003c/code\u003e will have the same encoding as \u003ccode\u003eBString\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"Hello World\"\u0026gt;\u0026gt;, latin1, 3, 5).\n\u0026lt;\u0026lt;\"lo Wo\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA negative value of \u003ccode\u003eStart\u003c/code\u003e denotes \u003ccode\u003eabs(Start)\u003c/code\u003e characters from the \u003cem\u003eend\u003c/em\u003e of \u003ccode\u003eBString\u003c/code\u003e, so that \u003ccode\u003e-1\u003c/code\u003e is the last character position in the binary string. \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"Hello World\"\u0026gt;\u0026gt;, latin1, -1, 3).\n\u0026lt;\u0026lt;\"rld\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs the true length of an UTF-8 encoded binary string is quite costly to determine ( \u003ccode\u003eO(N)\u003c/code\u003e, where \u003ccode\u003eN\u003c/code\u003e is the number of bytes in the binary), the function is very forgiving about positions given outside of the string, both \u003ccode\u003eStart\u003c/code\u003e s and \u003ccode\u003eLength\u003c/code\u003e s. Character positions outside of the string in either direction are collapsed to the empty binary string. \u003c/p\u003e\n\n\u003cp\u003eExamples: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"01234\"\u0026gt;\u0026gt;, latin1, 5, 5).\n\u0026lt;\u0026lt;\u0026gt;\u0026gt;\n\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"01234\"\u0026gt;\u0026gt;, latin1, 4, 5).\n\u0026lt;\u0026lt;\"4\"\u0026gt;\u0026gt;\n\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"01234\"\u0026gt;\u0026gt;, latin1, -5, 100).\n\u0026lt;\u0026lt;\"01234\"\u0026gt;\u0026gt;\n\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"01234\"\u0026gt;\u0026gt;, latin1, -6, 1).\n\u0026lt;\u0026lt;\u0026gt;\u0026gt;    \n\u0026gt; bstring:substr(\u0026lt;\u0026lt;\"01234\"\u0026gt;\u0026gt;, latin1, -6, 2).\n\u0026lt;\u0026lt;\"0\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if the searched part of \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003etokens(BString, SeparatorList) -\u0026gt; Tokens\u003c/code\u003e\u003c/h3\u003e\n\n\u003ch3\u003e\u003ccode\u003etokens(BString, Encoding, SeparatorList) -\u0026gt; Tokens\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eString = bstring()\nEncoding = encoding\nSeparatorList = [ non_negative_integer() ]\nTokens = [bstring()]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns a list of tokens in \u003ccode\u003eBString\u003c/code\u003e, separated by the characters in \u003ccode\u003eSeparatorList\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eTokens\u003c/code\u003e returned are encoded in the same character encoding as the \u003ccode\u003eBString\u003c/code\u003e . \u003c/p\u003e\n\n\u003cp\u003eExample: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026gt; bstring:tokens(\u0026lt;\u0026lt;\"abc defxxghix jkl\"\u0026gt;\u0026gt;, latin1, [$x,$ ]).\n[\u0026lt;\u0026lt;\"abc\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"def\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"ghi\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"jkl\"\u0026gt;\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eSeparatorList\u003c/code\u003e is to be viewed as a \u003cem\u003eset\u003c/em\u003e of characters, order is not significant. Codepoints given in \u003ccode\u003eSeparatorList\u003c/code\u003e that cannot be represented by the \u003ccode\u003eEncoding\u003c/code\u003e, is not an error. \u003c/p\u003e\n\n\u003cp\u003eIf the encoding is not given, it is assumed to be \u003ccode\u003elatin1\u003c/code\u003e, implying that no interpretation is given to the bytes in the binary string. \u003c/p\u003e\n\n\u003cp\u003eRaises a \u003ccode\u003ebadarg\u003c/code\u003e exception if the searched part of \u003ccode\u003eBString\u003c/code\u003e does not contain characters encoded according to the \u003ccode\u003eEncoding\u003c/code\u003e parameter, the \u003ccode\u003eEncoding\u003c/code\u003e has an invalid value, or any of the parameters are of the wrong type. \u003c/p\u003e\n\n\u003ch1\u003ePerformance\u003c/h1\u003e\n\n\u003cp\u003eThis module can, and probably should, be implemented entirely in\nErlang, no BIF's or NIF's are needed.  Both the \u003ccode\u003ebinary\u003c/code\u003e and\n\u003ccode\u003eunicode\u003c/code\u003e modules can be utilized to speed up conversion and indata\nchecking. The Unicode versions will definitely be slower than the\nISO-Latin-1 versions, as character encoding, decoding and checking is\nbound to produce overhead.\u003c/p\u003e\n\n\u003cp\u003eThe suggested wrapper \u003ccode\u003eubstring\u003c/code\u003e should not impose any significant\ncost compared to calling \u003ccode\u003ebstring\u003c/code\u003e with all encoding arguments set\nto \u003ccode\u003eunicode\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe idea is to make string manipulation using binaries convenient as\nit has a great positive impact on systems memory-wise. Increased speed\ncompared to list-oriented strings is not the goal, although it may\nwell be a side-effect.\u003c/p\u003e\n\n\u003ch1\u003eReference implementation\u003c/h1\u003e\n\n\u003cp\u003eNo specific reference implementation is made, the code will however be made available \non GitHub during any development. \u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document is licensed under the \u003ca href=\"http://creativecommons.org/licenses/by/3.0/\" title=\"Creative Commons Attribution 3.0 License\"\u003eCreative Commons license\u003c/a\u003e.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0035"},"buildId":"LNcThF2jK_Vf0EYibERT7","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/LNcThF2jK_Vf0EYibERT7/_buildManifest.js" async=""></script><script src="/_next/static/LNcThF2jK_Vf0EYibERT7/_ssgManifest.js" async=""></script></body></html>