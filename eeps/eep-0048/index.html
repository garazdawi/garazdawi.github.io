<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Jos√© Valim &lt;jose(dot)valim(at)gmail(dot)com&gt;, Eric Bailey, Radek Szymczyszyn
Status: Draft
Type: Standards Track
Created: 04-Jan-2018
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 48: <a href="eep-0048.md" title="EEP Source"> Documentation storage and format</a></h2>

<h1>Abstract</h1>

<p>This EEP proposes an official API documentation storage to be used by
by BEAM languages.  By standardizing how API documentation is stored,
it will be possible to write tools that work across languages.</p>

<h1>Rationale</h1>

<p>Currently, different programming languages and libraries running on
BEAM devise their own schemas for storing and accessing documentation. <br />
For example, Elixir and LFE provide a <code>h</code> helper in their shell that
can print the documentation of any module:</p>

<pre><code>iex&gt; h String
A String in Elixir is a UTF-8 encoded binary.
</code></pre>

<p>However, Elixir is only able to show docs for Elixir modules.  LFE is
only able to show docs for LFE functions and so on.  If documentation
is standardized, such features can be easily added to other languages
in a way that works consistently across all BEAM languages.</p>

<p>Furthermore, each language ends up building their own tools for
generating, processing and converting documentation.  We hope a unified
approach to documentation will improve the compatibility between tools.
For instance, an Erlang IDE will be able to show inline documentation
for any module and function, regardless if the function is part of OTP,
a library or even written in Elixir, LFE or Alpaca.</p>

<p><strong>Note</strong>: in this document, the word "documentation" refers exclusively
to the API documentation of modules and functions.  Guides, tutorials
and others materials are also essential to projects but not the focus
of this EEP.</p>

<p><strong>Note</strong>: This EEP is not about documentation format.  It is about a
mechanism for storing documentation to make it easier to produce other
formats.  For example, a tool can read the documentation and produce man
pages from it.</p>

<h1>Specification</h1>

<p>This EEP is divided in three parts.  The first defines the two
places the documentation can be stored, the second defines the shape of
the documentation and the third discusses integration with OTP.</p>

<h2>Part 1: the "Docs"storage</h2>

<p>There are two main mechanisms in which BEAM languages store documentation:
in the filesystem (usually in the <code>/doc</code> directory) and inside <code>.beam</code>
files. </p>

<p>This EEP recognizes both options and aim to support both.  To look for
documentation for a module name <code>example</code>, a tool should:</p>

<ol>
<li><p>Look for <code>example.beam</code> in the code path, parse the BEAM file and
 retrieve the <code>Docs</code> chunk</p></li>
<li><p>If the chunk is not available, it should look for "example.beam"
 in the code path and find the <code>doc/chunks/example.chunk</code> file in
 the application that defines the <code>example</code> module</p></li>
<li><p>If a <code>.chunk</code> file is not available, then documentation is not
 available</p></li>
</ol>

<p>The choice of using a chunk or the filesystem is completely up to the
language or library.  In both cases, the documentation can be added or
removed at any moment by stripping the <code>Docs</code> chunk or by removing the
<code>doc/chunks</code> directory.</p>

<p>For example, languages like Elixir and LFE attach the <code>Docs</code> chunk at
compilation time, which can be controlled via a compiler flag.  On the
other hand, projects like OTP itself will likely generate the <code>doc/chunks</code>
entries on a separate command, completely unrelated from code compilation.</p>

<h2>Part 2: the "Docs" format</h2>

<p>In both storages, the documentation is written in the exactly same
format: an Erlang term serialized to binary via <code>term_to_binary/1</code>.
The term may be optionally compressed when serialized and must follow
the type specification below:</p>

<pre><code>{docs_v1,
 Anno :: erl_anno:anno(),
 BeamLanguage :: atom(),
 Format :: mime_type(),
 ModuleDoc :: #{optional(DocLanguage) := DocValue} | none | hidden,
 Metadata :: map(),
 Docs ::
   [{{Kind, Name, Arity},
     Anno :: erl_anno:anno(),
     Signature :: [binary()],
     Doc :: #{optional(DocLanguage) := DocValue} | none | hidden,
     Metadata :: map()
    }]} when DocLanguage :: binary(),
             DocValue :: binary() | term()
</code></pre>

<p>where in the root tuple we have:</p>

<ul>
<li><p><code>Anno</code> - annotation (line, column, file) of the definition itself
(see <code>erl_anno</code>)</p></li>
<li><p><code>BeamLanguage</code> - an atom representing the language, for example:
<code>erlang</code>, <code>elixir</code>, <code>lfe</code>, <code>alpaca</code>, etc</p></li>
<li><p><code>Format</code> - the mime type of the documentation, such as "text/markdown"
or "application/erlang+html" (see the FAQ for a discussion on this field)</p></li>
<li><p><code>ModuleDoc</code> - a map with the documentation language as key, such as
<code>&lt;&lt;"en"&gt;&gt;</code> or <code>&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a binary value.
It may be the atom <code>none</code> in case there is no documentation or the
atom <code>hidden</code> if documentation has been explicitly disabled for this
entry</p></li>
<li><p><code>Metadata</code> - a map of atom keys with any term as value.  This can be
used to add annotations like the "authors" of a module, "deprecated",
or anything else a language or documentation tool may find relevant</p></li>
<li><p><code>Docs</code> - a list of documentation for other entities (such as
functions and types) in the module</p></li>
</ul>

<p>For each entry in <code>Docs</code>, we have:</p>

<ul>
<li><p><code>{Kind, Name, Arity}</code> - the kind, name and arity identifying the
function, callback, type, etc.  The official entities are: <code>function</code>,
<code>type</code> and <code>callback</code>.  Other languages will add their own. For
instance, Elixir and LFE may add <code>macro</code></p></li>
<li><p><code>Anno</code> - annotation (line, column, file) of the module documentation
or of the definition itself (see erl_anno)</p></li>
<li><p><code>Signature</code> - the signature of the entity.  It is is a list of
binaries. Each entry represents a binary in the signature that can
be joined with a whitespace or a newline.  For example,
<code>["binary_to_atom(Binary, Encoding)", "when is_binary(Binary)"]</code>
may be rendered as as a single line or two lines. It exists
exclusively for exhibition purposes</p></li>
<li><p><code>Doc</code> - a map with the documentation language as key, such as
<code>&lt;&lt;"en"&gt;&gt;</code> or <code>&lt;&lt;"pt_BR"&gt;&gt;</code>, and the documentation as a value.
The documentation may either be a binary or any Erlang term,
both described by <code>Format</code>. If it is an Erlang term, then the
<code>Format</code> must be "application/erlang+SUFFIX", such as
"application/erlang+html" when the documentation is an Erlang
representation of an HTML document. The <code>Doc</code> may also be the
atom <code>none</code> in case there is no documentation or the atom <code>hidden</code>
if documentation has been explicitly disabled for this entry</p></li>
<li><p><code>Metadata</code> - a map of atom keys with any term as value</p></li>
</ul>

<blockquote>
  <p>Note: the documentation map can be empty. In this case, a reference
to said function was added to the documentation index, making it
effectively public, but no documentation was written.</p>
</blockquote>

<p>This shared format is the heart of the EEP as it is what effectively
allows cross-language collaboration.</p>

<p>The <code>Metadata</code> field exists to allow languages, tools and libraries to
add custom information to each entry.  This EEP documents the
following metadata keys:</p>

<ul>
<li><p><code>authors := [binary()]</code> - a list of authors as binaries</p></li>
<li><p><code>cross_references := [module() | {module(), {Kind, Name, Arity}}]</code> -
a list of modules or module entries that can be used as cross
references when generating documentation</p></li>
<li><p><code>deprecated := binary()</code> - when present, it means the current entry
is deprecated with a binary that represents the reason for
deprecation and a recommendation to replace the deprecated code</p></li>
<li><p><code>since := binary()</code> - a binary representing the version such entry
was added, such as <code>&lt;&lt;"1.3.0"&gt;&gt;</code> or <code>&lt;&lt;"20.0"&gt;&gt;</code></p></li>
<li><p><code>edit_url := binary()</code> - a binary representing a URL to change to
change the documentation itself</p></li>
</ul>

<p>Any key may be added to Metadata at any time.  Keys that are frequently
used by the community can be standardized in future versions. </p>

<h2>Part 3: Integration with OTP</h2>

<p>The last part focuses on integrating the previous parts with OTP docs,
tools and workflows.  The items below are suggestions and are not
necessary for the adoption of this EEP, neither by OTP nor by any other
language or library.</p>

<p>At this point we should consider changes to OTP such as:</p>

<ul>
<li><p>Distributing the <code>doc/chunks/*.chunk</code> files as part of OTP and
changing the tools that ship with OTP to rely on them. For example,
<code>erl -man lists</code> could be changed to locate the <code>lists.chunk</code> file,
parsing the documentation out and then converting it to a man page
on the fly.  This task may require multiple changes, as OTP stores
documentation on XML files as well as directly in the source code.
<code>edoc</code> itself should likely be augmented with functions that spit
out <code>.chunk</code> files from the source code</p></li>
<li><p>Adding <code>h(Module)</code>, <code>h(Module, Function, Arity)</code>, and similar to
Erlang's shell to print the documentation of a module or of a
given function and arity. This should be able to print docs any
other library or language that implements this proposal</p></li>
</ul>

<h1>FAQ</h1>

<p><em>Q: Why do we have a Format entry in the documentation?</em></p>

<p>The main trade-off in the proposal is the documentation format.  We have
two options:</p>

<ul>
<li>Allow each language/library/tool to choose their own documentation
format</li>
<li>Impose a unified documentation format on all languages</li>
</ul>

<p>A unified format for documentation gives no flexibility to languages and
libraries in choosing how documentation is written.  As the ecosystem
gets more diverse, it will be unlikely to find a format that suits all.
For this reason we introduced a Format field that allows each language
and library to pick their documentation format.  The downside is that,
if the Elixir docs are written in Markdown and a language does not know
how to format Markdown, then the language will have to choose to either
not show the Elixir docs or show them raw (i.e. in Markdown).</p>

<p>Erlang is in a privileged position.  All languages will be able to
support whatever format is chosen for Erlang since all languages run on
Erlang and will have direct access to Erlang's tooling.</p>

<p><em>Q: If I have an Erlang/Elixir/LFE/Alpaca library that uses a custom
documentation toolkit, will I also be able to leverage this?</em></p>

<p>As long as the documentation ends up up in the <code>Docs</code> chunk or inside
the <code>doc/chunks</code> directory, we absolutely do not care how the
documentation was originally written.  If you use a custom format,
you may need to teach your language of choice how to render it though.
See the previous question.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0048","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Jos√© Valim \u0026lt;jose(dot)valim(at)gmail(dot)com\u0026gt;, Eric Bailey, Radek Szymczyszyn\nStatus: Draft\nType: Standards Track\nCreated: 04-Jan-2018\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 48: \u003ca href=\"eep-0048.md\" title=\"EEP Source\"\u003e Documentation storage and format\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes an official API documentation storage to be used by\nby BEAM languages.  By standardizing how API documentation is stored,\nit will be possible to write tools that work across languages.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eCurrently, different programming languages and libraries running on\nBEAM devise their own schemas for storing and accessing documentation. \u003cbr /\u003e\nFor example, Elixir and LFE provide a \u003ccode\u003eh\u003c/code\u003e helper in their shell that\ncan print the documentation of any module:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eiex\u0026gt; h String\nA String in Elixir is a UTF-8 encoded binary.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHowever, Elixir is only able to show docs for Elixir modules.  LFE is\nonly able to show docs for LFE functions and so on.  If documentation\nis standardized, such features can be easily added to other languages\nin a way that works consistently across all BEAM languages.\u003c/p\u003e\n\n\u003cp\u003eFurthermore, each language ends up building their own tools for\ngenerating, processing and converting documentation.  We hope a unified\napproach to documentation will improve the compatibility between tools.\nFor instance, an Erlang IDE will be able to show inline documentation\nfor any module and function, regardless if the function is part of OTP,\na library or even written in Elixir, LFE or Alpaca.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: in this document, the word \"documentation\" refers exclusively\nto the API documentation of modules and functions.  Guides, tutorials\nand others materials are also essential to projects but not the focus\nof this EEP.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e: This EEP is not about documentation format.  It is about a\nmechanism for storing documentation to make it easier to produce other\nformats.  For example, a tool can read the documentation and produce man\npages from it.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eThis EEP is divided in three parts.  The first defines the two\nplaces the documentation can be stored, the second defines the shape of\nthe documentation and the third discusses integration with OTP.\u003c/p\u003e\n\n\u003ch2\u003ePart 1: the \"Docs\"storage\u003c/h2\u003e\n\n\u003cp\u003eThere are two main mechanisms in which BEAM languages store documentation:\nin the filesystem (usually in the \u003ccode\u003e/doc\u003c/code\u003e directory) and inside \u003ccode\u003e.beam\u003c/code\u003e\nfiles. \u003c/p\u003e\n\n\u003cp\u003eThis EEP recognizes both options and aim to support both.  To look for\ndocumentation for a module name \u003ccode\u003eexample\u003c/code\u003e, a tool should:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eLook for \u003ccode\u003eexample.beam\u003c/code\u003e in the code path, parse the BEAM file and\n retrieve the \u003ccode\u003eDocs\u003c/code\u003e chunk\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf the chunk is not available, it should look for \"example.beam\"\n in the code path and find the \u003ccode\u003edoc/chunks/example.chunk\u003c/code\u003e file in\n the application that defines the \u003ccode\u003eexample\u003c/code\u003e module\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIf a \u003ccode\u003e.chunk\u003c/code\u003e file is not available, then documentation is not\n available\u003c/p\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe choice of using a chunk or the filesystem is completely up to the\nlanguage or library.  In both cases, the documentation can be added or\nremoved at any moment by stripping the \u003ccode\u003eDocs\u003c/code\u003e chunk or by removing the\n\u003ccode\u003edoc/chunks\u003c/code\u003e directory.\u003c/p\u003e\n\n\u003cp\u003eFor example, languages like Elixir and LFE attach the \u003ccode\u003eDocs\u003c/code\u003e chunk at\ncompilation time, which can be controlled via a compiler flag.  On the\nother hand, projects like OTP itself will likely generate the \u003ccode\u003edoc/chunks\u003c/code\u003e\nentries on a separate command, completely unrelated from code compilation.\u003c/p\u003e\n\n\u003ch2\u003ePart 2: the \"Docs\" format\u003c/h2\u003e\n\n\u003cp\u003eIn both storages, the documentation is written in the exactly same\nformat: an Erlang term serialized to binary via \u003ccode\u003eterm_to_binary/1\u003c/code\u003e.\nThe term may be optionally compressed when serialized and must follow\nthe type specification below:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{docs_v1,\n Anno :: erl_anno:anno(),\n BeamLanguage :: atom(),\n Format :: mime_type(),\n ModuleDoc :: #{optional(DocLanguage) := DocValue} | none | hidden,\n Metadata :: map(),\n Docs ::\n   [{{Kind, Name, Arity},\n     Anno :: erl_anno:anno(),\n     Signature :: [binary()],\n     Doc :: #{optional(DocLanguage) := DocValue} | none | hidden,\n     Metadata :: map()\n    }]} when DocLanguage :: binary(),\n             DocValue :: binary() | term()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere in the root tuple we have:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eAnno\u003c/code\u003e - annotation (line, column, file) of the definition itself\n(see \u003ccode\u003eerl_anno\u003c/code\u003e)\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eBeamLanguage\u003c/code\u003e - an atom representing the language, for example:\n\u003ccode\u003eerlang\u003c/code\u003e, \u003ccode\u003eelixir\u003c/code\u003e, \u003ccode\u003elfe\u003c/code\u003e, \u003ccode\u003ealpaca\u003c/code\u003e, etc\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eFormat\u003c/code\u003e - the mime type of the documentation, such as \"text/markdown\"\nor \"application/erlang+html\" (see the FAQ for a discussion on this field)\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eModuleDoc\u003c/code\u003e - a map with the documentation language as key, such as\n\u003ccode\u003e\u0026lt;\u0026lt;\"en\"\u0026gt;\u0026gt;\u003c/code\u003e or \u003ccode\u003e\u0026lt;\u0026lt;\"pt_BR\"\u0026gt;\u0026gt;\u003c/code\u003e, and the documentation as a binary value.\nIt may be the atom \u003ccode\u003enone\u003c/code\u003e in case there is no documentation or the\natom \u003ccode\u003ehidden\u003c/code\u003e if documentation has been explicitly disabled for this\nentry\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eMetadata\u003c/code\u003e - a map of atom keys with any term as value.  This can be\nused to add annotations like the \"authors\" of a module, \"deprecated\",\nor anything else a language or documentation tool may find relevant\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDocs\u003c/code\u003e - a list of documentation for other entities (such as\nfunctions and types) in the module\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eFor each entry in \u003ccode\u003eDocs\u003c/code\u003e, we have:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{Kind, Name, Arity}\u003c/code\u003e - the kind, name and arity identifying the\nfunction, callback, type, etc.  The official entities are: \u003ccode\u003efunction\u003c/code\u003e,\n\u003ccode\u003etype\u003c/code\u003e and \u003ccode\u003ecallback\u003c/code\u003e.  Other languages will add their own. For\ninstance, Elixir and LFE may add \u003ccode\u003emacro\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eAnno\u003c/code\u003e - annotation (line, column, file) of the module documentation\nor of the definition itself (see erl_anno)\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eSignature\u003c/code\u003e - the signature of the entity.  It is is a list of\nbinaries. Each entry represents a binary in the signature that can\nbe joined with a whitespace or a newline.  For example,\n\u003ccode\u003e[\"binary_to_atom(Binary, Encoding)\", \"when is_binary(Binary)\"]\u003c/code\u003e\nmay be rendered as as a single line or two lines. It exists\nexclusively for exhibition purposes\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eDoc\u003c/code\u003e - a map with the documentation language as key, such as\n\u003ccode\u003e\u0026lt;\u0026lt;\"en\"\u0026gt;\u0026gt;\u003c/code\u003e or \u003ccode\u003e\u0026lt;\u0026lt;\"pt_BR\"\u0026gt;\u0026gt;\u003c/code\u003e, and the documentation as a value.\nThe documentation may either be a binary or any Erlang term,\nboth described by \u003ccode\u003eFormat\u003c/code\u003e. If it is an Erlang term, then the\n\u003ccode\u003eFormat\u003c/code\u003e must be \"application/erlang+SUFFIX\", such as\n\"application/erlang+html\" when the documentation is an Erlang\nrepresentation of an HTML document. The \u003ccode\u003eDoc\u003c/code\u003e may also be the\natom \u003ccode\u003enone\u003c/code\u003e in case there is no documentation or the atom \u003ccode\u003ehidden\u003c/code\u003e\nif documentation has been explicitly disabled for this entry\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eMetadata\u003c/code\u003e - a map of atom keys with any term as value\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNote: the documentation map can be empty. In this case, a reference\nto said function was added to the documentation index, making it\neffectively public, but no documentation was written.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eThis shared format is the heart of the EEP as it is what effectively\nallows cross-language collaboration.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode\u003eMetadata\u003c/code\u003e field exists to allow languages, tools and libraries to\nadd custom information to each entry.  This EEP documents the\nfollowing metadata keys:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eauthors := [binary()]\u003c/code\u003e - a list of authors as binaries\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ecross_references := [module() | {module(), {Kind, Name, Arity}}]\u003c/code\u003e -\na list of modules or module entries that can be used as cross\nreferences when generating documentation\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003edeprecated := binary()\u003c/code\u003e - when present, it means the current entry\nis deprecated with a binary that represents the reason for\ndeprecation and a recommendation to replace the deprecated code\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003esince := binary()\u003c/code\u003e - a binary representing the version such entry\nwas added, such as \u003ccode\u003e\u0026lt;\u0026lt;\"1.3.0\"\u0026gt;\u0026gt;\u003c/code\u003e or \u003ccode\u003e\u0026lt;\u0026lt;\"20.0\"\u0026gt;\u0026gt;\u003c/code\u003e\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eedit_url := binary()\u003c/code\u003e - a binary representing a URL to change to\nchange the documentation itself\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAny key may be added to Metadata at any time.  Keys that are frequently\nused by the community can be standardized in future versions. \u003c/p\u003e\n\n\u003ch2\u003ePart 3: Integration with OTP\u003c/h2\u003e\n\n\u003cp\u003eThe last part focuses on integrating the previous parts with OTP docs,\ntools and workflows.  The items below are suggestions and are not\nnecessary for the adoption of this EEP, neither by OTP nor by any other\nlanguage or library.\u003c/p\u003e\n\n\u003cp\u003eAt this point we should consider changes to OTP such as:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eDistributing the \u003ccode\u003edoc/chunks/*.chunk\u003c/code\u003e files as part of OTP and\nchanging the tools that ship with OTP to rely on them. For example,\n\u003ccode\u003eerl -man lists\u003c/code\u003e could be changed to locate the \u003ccode\u003elists.chunk\u003c/code\u003e file,\nparsing the documentation out and then converting it to a man page\non the fly.  This task may require multiple changes, as OTP stores\ndocumentation on XML files as well as directly in the source code.\n\u003ccode\u003eedoc\u003c/code\u003e itself should likely be augmented with functions that spit\nout \u003ccode\u003e.chunk\u003c/code\u003e files from the source code\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eAdding \u003ccode\u003eh(Module)\u003c/code\u003e, \u003ccode\u003eh(Module, Function, Arity)\u003c/code\u003e, and similar to\nErlang's shell to print the documentation of a module or of a\ngiven function and arity. This should be able to print docs any\nother library or language that implements this proposal\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003eFAQ\u003c/h1\u003e\n\n\u003cp\u003e\u003cem\u003eQ: Why do we have a Format entry in the documentation?\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe main trade-off in the proposal is the documentation format.  We have\ntwo options:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eAllow each language/library/tool to choose their own documentation\nformat\u003c/li\u003e\n\u003cli\u003eImpose a unified documentation format on all languages\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eA unified format for documentation gives no flexibility to languages and\nlibraries in choosing how documentation is written.  As the ecosystem\ngets more diverse, it will be unlikely to find a format that suits all.\nFor this reason we introduced a Format field that allows each language\nand library to pick their documentation format.  The downside is that,\nif the Elixir docs are written in Markdown and a language does not know\nhow to format Markdown, then the language will have to choose to either\nnot show the Elixir docs or show them raw (i.e. in Markdown).\u003c/p\u003e\n\n\u003cp\u003eErlang is in a privileged position.  All languages will be able to\nsupport whatever format is chosen for Erlang since all languages run on\nErlang and will have direct access to Erlang's tooling.\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eQ: If I have an Erlang/Elixir/LFE/Alpaca library that uses a custom\ndocumentation toolkit, will I also be able to leverage this?\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eAs long as the documentation ends up up in the \u003ccode\u003eDocs\u003c/code\u003e chunk or inside\nthe \u003ccode\u003edoc/chunks\u003c/code\u003e directory, we absolutely do not care how the\ndocumentation was originally written.  If you use a custom format,\nyou may need to teach your language of choice how to render it though.\nSee the previous question.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0048"},"buildId":"7cVY434Wa3Wl232pkfXk2","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_buildManifest.js" async=""></script><script src="/_next/static/7cVY434Wa3Wl232pkfXk2/_ssgManifest.js" async=""></script></body></html>