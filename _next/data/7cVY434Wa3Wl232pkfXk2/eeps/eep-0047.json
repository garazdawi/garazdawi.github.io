{"pageProps":{"index":{"id":"0047","content":"<pre><code>Author: Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;\nStatus: Final/21.0 Proposal is to be included in OTP release 21.0\nType: Standards Track\nCreated: 23-Nov-2017\nErlang-Version: 21\nPost-History: 24-Nov-2017, 30-Nov-2017\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 47: <a href=\"eep-0047.md\" title=\"EEP Source\"> Add syntax in try/catch to retrieve the stacktrace directly</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP proposes an extension to the <code>try/catch</code> statement to allow\nthe call stack back-trace (<strong>stacktrace</strong>) to be retrieved without\ncalling <code>erlang:get_stacktrace/0</code>.</p>\n\n<h1>Specification</h1>\n\n<p>We will introduce new syntax to retrieve the call stack back-trace\n(hereafter called <strong>stacktrace</strong>).  Currently,\n<code>erlang:get_stacktrace/0</code> can be called at any time to retrieve the\nstacktrace from the last exception that occurred in the current\nprocess.</p>\n\n<p>The current syntax for <code>try/catch</code> is:</p>\n\n<pre><code>try\n  Exprs\ncatch\n    [Class1:]ExceptionPattern1 [when ExceptionGuardSeq1] -&gt;\n        ExceptionBody1;\n    [ClassN:]ExceptionPatternN [when ExceptionGuardSeqN] -&gt;\n        ExceptionBodyN\nend\n</code></pre>\n\n<p>We propose the following extension of the syntax for exception clause\nheads:</p>\n\n<pre><code>Class:ExceptionPattern:Stacktrace [when ExceptionGuardSeq] -&gt;\n</code></pre>\n\n<p><code>Stacktrace</code> must be a variable name, not a pattern.  Furthermore,\n<code>Stacktrace</code> must not be previously bound and it must not be\nreferenced in <code>ExceptionGuardSeq</code>.</p>\n\n<p>Here is an example:</p>\n\n<pre><code>try\n  Exprs\ncatch\n  something_was_thrown -&gt;\n    %% The default class is 'throw'.\n    .\n    .\n    .\n  throw:something_else_was_thrown -&gt;\n    .\n    .\n    .\n  throw:thrown_with_interesting_stacktrace:Stk -&gt;\n    %% The class 'throw' must be explicitly given when\n    %% the stacktrace is to be retrieved.\n    .\n    .\n    .\n  error:undef -&gt;\n    %% Handle an undefined function specially.\n    .\n    .\n    .\n  C:E:Stk -&gt;\n    %% Log any other exception and rethrow it.\n    log_exception(C, E, Stk),\n    raise(C, E, Stk)\nend.\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>The main motivation for this feature is to be able to deprecate\n(and ultimately remove) <code>erlang:get_stacktrace/0</code>.</p>\n\n<p>The problem with <code>erlang:get_stacktrace/0</code> is that it forces the\nstacktrace from the latest exception in a process to be retained\nuntil another exception occurs or the process terminates.  The\nstacktrace often includes the arguments for the last function\ncall, BIF call, or (in OTP 21) operator that failed.  The arguments\ncan be of any size.</p>\n\n<p>Here is an example:</p>\n\n<pre><code>1&gt; catch abs(lists:seq(1, 1000)).\n{'EXIT',{badarg,\n      [{erlang,abs,\n                 [[1,2,3,4,5,6,7,8,9,10,11,12,13,\n                   14,15,16,17,18,19,20|...]],\n                 []},\n          {erl_eval,do_apply,6,[{file,\"erl_eval.erl\"},{line,674}]},\n          {erl_eval,expr,5,[{file,\"erl_eval.erl\"},{line,431}]},\n          {shell,exprs,7,[{file,\"shell.erl\"},{line,687}]},\n          {shell,eval_exprs,7,[{file,\"shell.erl\"},{line,642}]},\n          {shell,eval_loop,3,[{file,\"shell.erl\"},{line,627}]}]}}\n2&gt;\n</code></pre>\n\n<p>The list containing the integers from 1 through 1000 will be kept\nin the process that caused the exception until another exception\noccurs in the same process.</p>\n\n<p>In a future release, where <code>erlang:get_stacktrace/0</code> has either been\nchanged to always return <code>[]</code> or been removed, it is no longer\nnecessary to keep the stacktrace in the process indefinitely.</p>\n\n<p>Another motivation is that pitfalls such as the one in the following\nexample are impossible:</p>\n\n<pre><code>try\n  Expr\ncatch\n  C:E -&gt;\n    do_something(),\n    log_exception(C, E, erlang:get_stacktrace())\nend\n</code></pre>\n\n<p>If <code>do_something()</code> generates and catches an exception, the call\nto <code>erlang:get_stacktrace/0</code> will retrieve the wrong stacktrace.</p>\n\n<h1>Rationale</h1>\n\n<h2>The Syntax</h2>\n\n<p>Regarding the syntax, we did consider using another token instead of\ncolon before the stacktrace variable.  That would continue to allow\nmaking the class <code>throw</code> implicit even when retrieving the stacktrace.\nThat is, you could write an exception pattern, followed by some\nspecial token, followed by the name of the stacktrace variable, and\nthe class <code>throw</code> would be implicitly understood.</p>\n\n<p>We rejected that for two reasons:</p>\n\n<ul>\n<li><p>We could not find a suitable separator token.  Our best suggestion\nwas <code>@</code>, and that will not work because <code>@</code> is allowed in atoms.\nTokens like <code>/</code> could confuse at least the parser (and possibly human\nreaders) because patterns are allowed to contain constant expressions.\nA double colon (<code>::</code>) would not cause any ambiguitiy issues, but\neveryone immediately associated it with a type declaration.</p></li>\n<li><p>In practice, when catching an exception of class <code>throw</code>, one is\nalmost never interested in the stacktrace.</p></li>\n</ul>\n\n<h2>Why Not Allow Matching On The Stacktrace?</h2>\n\n<p><code>Stacktrace</code> must be a variable, not a pattern.  There are two\nreasons:</p>\n\n<ul>\n<li><p>In general, pattern matching on the stacktrace is discouraged.  The\nintention is that it should be inspected by a human to aid in\ndebugging.</p></li>\n<li><p>Allowing pattern matching on the stacktrace would be expensive.\nWhen an exception occurs, a raw stacktrace is saved.  The raw\nstacktrace contains a limited number of continuation pointers\n(by default 8) collected from the stack and possibly the arguments\nfor the function call or BIF call that failed.  To convert the\nraw stacktrace to the symbolic form that can be matched or shown is\nquite expensive; by only allowing a variable, that conversion will\nonly happen when a clause has matched and its body is about to\nbe executed.</p></li>\n</ul>\n\n<h2>Limiting The Scope Of erlang:get_stacktrace/0 Instead?</h2>\n\n<p>In OTP 20, we introduced a new warning in the documentation for\n<code>erlang:get_stacktrace/0</code>:</p>\n\n<blockquote>\n  <p><code>erlang:get_stacktrace/0</code> is only guaranteed to return a stacktrace if\n  called (directly or indirectly) from within the scope of a try\n  expression.</p>\n</blockquote>\n\n<p>Our intention was that by limiting the scope, the stacktrace could be\ncleared when exiting the scope.  For example, the following code would\ncontinue to work, but the stacktrace would be cleared when leaving\n<code>try/catch</code>:</p>\n\n<pre><code>try Expr\ncatch\n  C:R -&gt;\n   {C,R,helper()}\nend\n\nhelper() -&gt;\n  erlang:get_stacktrace().\n</code></pre>\n\n<p>Unfortunately, the following slightly different example would force\na hard choice upon us:</p>\n\n<pre><code>try Expr\ncatch\n  C:R -&gt;\n   helper(C, R)\nend\n\nhelper(C, R) -&gt;\n  {C,R,erlang:get_stacktrace()}.\n</code></pre>\n\n<p>The call to <code>helper/2</code> is tail-recursive.  If we are to keep the call\ntail-recursive, we cannot clear the stacktrace.  Conversely, if we are\nto clear the stacktrace, the call can no longer be tail-recursive.</p>\n\n<p>Another problem is that the compiler cannot warn for all instances of\ncalls to <code>erlang:get_stacktrace/0</code> that would not return a stacktrace.\nAll it can do is to warn for obvious calls that will not work such as\nin the following example:</p>\n\n<pre><code>try Expr\ncatch\n  C:R -&gt;\n    .\n    .\n    .\nend,\nStk = erlang:get_stacktrace(),\n.\n.\n.\n</code></pre>\n\n<p>That is, the compiler can only warn if there is a use of <code>try/catch</code>\nor <code>catch</code> followed by a call to <code>erlang:get_stacktrace/0</code> in the same\nfunction.</p>\n\n<p>We could limit the useful scope of <code>erlang:get_stacktrace/0</code> to\njust the syntactic scope of the clause within the <code>try/catch</code>.\nFor example:</p>\n\n<pre><code>try\n  Expr\ncatch\n  C:E -&gt;\n    Stk = erlang:get_stacktrace(),\n    log_exception(C, E, Stk)\nend\n</code></pre>\n\n<p>It does not seem to be any advantage of that solution compared\nto introducing the new syntax.  Developers would still have to\nupdate their programs (eliminating calls to <code>erlang:get_stacktrace/0</code>\nfrom helper functions and moving them into the syntactic scope of\nthe <code>try/catch</code>).</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Since the new syntax would cause a compilation error in OTP 20\nand previous releases, no existing source code can be affected.</p>\n\n<p>The abstract format already includes a variable (with the name <code>_</code>)\nfor the stacktrace in exception clauses.  That means that many\ntools that manipulate the abstract Erlang code will continue to\nwork without any change.</p>\n\n<p>The <code>erlang:get_stacktrace/0</code> BIF can be deprecated in several\nstages to minimize the impact of the change.</p>\n\n<p>For example:</p>\n\n<ul>\n<li><p>In OTP 21, there will be a compiler warning that\n<code>erlang:get_stacktrace/0</code> is deprecated.</p></li>\n<li><p>In OTP 23 (or possibly OTP 22), <code>erlang:get_stacktrace/0</code> will start\nreturning <code>[]</code>.  Many programs that have not been updated will\ncontinue to work, except that if an exception is raised no stacktrace\nwill be available to aid in debugging.</p></li>\n<li><p>In some future release (OTP 42?), <code>erlang:get_stacktrace/0</code> can be\nremoved.</p></li>\n</ul>\n\n<h1>Implementation</h1>\n\n<p>The implementation can be found in <a href=\"https://github.com/erlang/otp/pull/1634\" title=\"#1634: Add syntax in try/catch to retrieve the stacktrace directly\">PR #1634</a>.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}