<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/compiler-lost-in-translation/">Lost in Translation (Exploring the Compiler&#x27;s Front End)</a></h3><p><em>Thursday, 26 April 2018<!-- --> - <!-- -->Bj√∂rn Gustavsson</em></p><p>In this blog post, we will explore the compiler passes that make up
the compiler&#x27;s front end.</p><p>In the <a href="http://blog.erlang.org/compiler-time-option/">previous blog post</a>
we showed how the <code>time</code> option shows information about the compiler passes
being executed:</p><pre><code>$ erlc +time trivial.erl
Compiling &quot;trivial&quot;
 remove_file                   :      0.000 s       3.7 kB
 parse_module                  :      0.000 s       5.5 kB
 transform_module              :      0.000 s       5.5 kB
 lint_module                   :      0.002 s       5.5 kB
 expand_records                :      0.000 s       5.3 kB
     .
     .
     .</code></pre><p>We explained what the <code>remove_file</code> pass does in the previous
blog post. In today&#x27;s blog post, we will discuss the other passes
listed in the output above.</p><p>Those passes makes up the compiler&#x27;s front end. The implementation
modules for those passes are not in the <strong>compiler</strong> application, but
in <strong>STDLIB</strong>. The reason is that the Erlang shell also uses those
modules. That means that the shell will work in an embedded system
that does not include the <strong>compiler</strong> application.</p><p>The front end passes operate on the <strong>abstract format</strong>. The abstract
format is fairly close to the original Erlang source code. In fact, by
pretty-printing the abstract format, we can reconstruct the original
source code, albeit not perfectly.</p><h2>Lost in translation</h2><p>To see how much we will lose in translation, we will compile and
pretty-print this module:</p><pre><code>-module(trivial).
-export([example/4]).
-record(rec, {mod,func,result}).

%% Example to help explore the compiler front end.
example(A, B, C, D) -&gt;
    #rec{mod=?MODULE,func=?FUNCTION_NAME,result=A + (B*C*(D+42))}.</code></pre><p>We use <code>-P</code> option to run the <code>parse_module</code> pass and produce
a listing of the result:</p><pre><code>$ erlc -P +time trivial.erl
Compiling &quot;trivial&quot;
 parse_module                  :      0.000 s       5.5 kB
 transform_module              :      0.000 s       5.5 kB
 lint_module                   :      0.003 s       5.5 kB
 listing                       :      0.001 s       5.5 kB</code></pre><p>For the moment, ignore the <code>transform_module</code> and <code>erl_lint</code> passes.
They don&#x27;t change the abstract code for this module. The <code>listing</code>
pass pretty prints the abstract format, converting it back to Erlang
source code and creating the file <code>trivial.P</code>.</p><pre><code>$ cat trivial.P
-file(&quot;trivial.erl&quot;, 1).

-module(trivial).

-export([example/4]).

-record(rec,{mod,func,result}).

example(A, B, C, D) -&gt;
    #rec{mod = trivial,func = example,result = A + B * C * (D + 42)}.</code></pre><p>Comparing the <code>trivial.P</code> file to the original, we can see what was
lost in translation:</p><ul><li><p>The <code>?MODULE</code> and <code>?FUNCTION_NAME</code> macro invocations have been
replaced with <code>trival</code> and <code>example</code>, respectively. That was done by
the preprocessor.</p></li><li><p>The comment has disappeared. There are also several differences in the
amount of whitespace surrounding variables and operators. The abstract format
does not include whitepace or comments in its representation.</p></li><li><p>Also note that a redundant pair of parentheses has been omitted in the
expression <code>A + (B*C*(D+42))</code>. The parentheses around <code>D+42</code> are still there
because otherwise the value of the expression would change. The abstract
format has no direct representation of parenheses.</p></li></ul><h2>Looking closer at the parse_module pass</h2><p>Now that we have seen what is lost in translation, we will take a
closer look at the abstract format.</p><p>We will use the expression <code>A+(B*C*(D+42))</code> as an example and
translate it to the abstract format using the same modules that the
<code>parse_module</code> pass uses to do its work.</p><h3>Tokenizing using erl_scan</h3><p>The first step in the translation from Erlang source code is to group
the characters into logical groups called <strong>tokens</strong>. This process is
called <strong>tokenization</strong> or <strong>scanning</strong>, and is done by the <code>erl_scan</code>
module.</p><p>We will use <code>erl_scan:string/1</code> to tokenize our example. (The
compiler will use other functions in <code>erl_scan</code>, but the principle
is the same.)</p><pre><code>1&gt; {ok,Tokens,_} = erl_scan:string(&quot;A + (B*C*(D+42)).&quot;), Tokens.
[{var,1,&#x27;A&#x27;},
 {&#x27;+&#x27;,1},
 {&#x27;(&#x27;,1},
 {var,1,&#x27;B&#x27;},
 {&#x27;*&#x27;,1},
 {var,1,&#x27;C&#x27;},
 {&#x27;*&#x27;,1},
 {&#x27;(&#x27;,1},
 {var,1,&#x27;D&#x27;},
 {&#x27;+&#x27;,1},
 {integer,1,42},
 {&#x27;)&#x27;,1},
 {&#x27;)&#x27;,1},
 {dot,1}]</code></pre><p>The output is a list of tokens. The second element in each tuple
is the line number. The first element is the category of the token.
If there is a third element, it is the symbol within that category.</p><p>We can see that whitespace has already been lost. Had there been
a comment, it would have been lost too.</p><p>To read more details about tokens, see <a href="http://erlang.org/doc/man/erl_scan.html#string-1">erl_scan:string/1</a>.</p><h3>Preprocessing the tokens</h3><p>In the compiler, the next step would be to run the preprocessor
on the tokens. In this example, there are no macro invocations
and thus nothing to preprocess, so we will skip to the next step.</p><h3>Parsing using erl_parse</h3><p>The next step is to <strong>parse</strong> the tokens to produce the abstract
format:</p><pre><code>2&gt; {ok,Abstract} = erl_parse:parse_exprs(Tokens), Abstract.
[{op,1,&#x27;+&#x27;,
     {var,1,&#x27;A&#x27;},
     {op,1,&#x27;*&#x27;,
         {op,1,&#x27;*&#x27;,{var,1,&#x27;B&#x27;},{var,1,&#x27;C&#x27;}},
         {op,1,&#x27;+&#x27;,{var,1,&#x27;D&#x27;},{integer,1,42}}}}]</code></pre><p>The result is a list with one expression. The expression is not a
list, but a <strong>parse tree</strong>. It can be visualized like this:</p><p><img src="../images/compiler-2018-04-26.svg" alt="Abstract format visualized"/></p><p>The parentheses have been lost, because the structure of the tree
makes the evaluation order unambiguous.</p><p>See <a href="http://erlang.org/doc/apps/erts/absform.html">The Abstract Format</a> for more details about the abstract format.</p><h3>Pretty-printing using erl_pp</h3><p>The <code>listing</code> pass uses the <a href="http://erlang.org/doc/man/erl_pp.html">erl_pp</a> module to pretty print the
abstract format to produce a listing file.</p><p>We can pretty print the abstract format of the example:</p><pre><code>3&gt; lists:flatten(erl_pp:exprs(Abstract)).
&quot;A + B * C * (D + 42)&quot;</code></pre><p>Here the pretty printer has inserted one pair of parentheses, but the
redundant pair of parentheses in the original expression has been lost.
The whitespace is also different from the original.</p><h3>A quick look at the preprocessor</h3><p>A mentioned in passing, the preprocessor (the <a href="http://erlang.org/doc/man/epp.html">epp</a> module) is run
after tokenization and before parsing.</p><p>The preprocessor goes through the tokens, looking for a question
mark followed by a variable or atom. For example, <code>?MODULE</code> in
a source file would be tokenized like this by <code>erl_scan</code>:</p><pre><code>[{&#x27;?&#x27;,1},{var,1,&#x27;MODULE&#x27;}]</code></pre><p>Assuming that the module name is <code>trivial</code>, the preprocessor will
replace those tokens with the token:</p><pre><code>[{atom,1,trivial}]</code></pre><h2>The other passes operating on the abstract format</h2><p>Now that <code>parse_module</code> has been explained, let&#x27;s take quick look at the
other passes in the front end.</p><h3>The transform_module pass</h3><p>The <code>transform_module</code> pass runs parse transforms, for example
for <a href="http://erlang.org/doc/man/qlc.html">QLC</a> or <a href="http://erlang.org/doc/man/ms_transform.html">ms_transform</a>.</p><h3>The lint_module pass</h3><p>The <code>lint_module</code> pass verifies that the code is semantically
correct. That is, variables must be bound before they are used,
all clauses for a function must have the same number of arguments,
and so on.</p><p>When we compile a module with problems, <a href="http://erlang.org/doc/man/erl_lint.html">erl_lint</a> will print
error messages and terminate the compilation:</p><pre><code>$ cat bug.erl
-module(bug).
-export([main/0]).

main() -&gt;
    A+B.
$ erlc +time bug.erl
Compiling &quot;bug&quot;
 remove_file                   :      0.000 s       2.1 kB
 parse_module                  :      0.000 s       2.7 kB
 transform_module              :      0.000 s       2.7 kB
 lint_module                   :      0.004 s       2.4 kB
bug.erl:5: variable &#x27;A&#x27; is unbound
bug.erl:5: variable &#x27;B&#x27; is unbound
$</code></pre><h3>Translating records</h3><p>The <code>expand_records</code> pass uses <a href="http://erlang.org/doc/man/erl_expand_records.html">erl_expand_records</a> to translate
records:</p><pre><code>$ erlc -E +time trivial.erl
Compiling &quot;trivial&quot;
 parse_module                  :      0.000 s       5.5 kB
 transform_module              :      0.000 s       5.5 kB
 lint_module                   :      0.002 s       5.5 kB
 expand_records                :      0.000 s       5.3 kB
 listing                       :      0.001 s       5.3 kB
$ cat trivial.E
-file(&quot;trivial.erl&quot;, 1).

-module(trivial).

-export([example/4]).

-record(rec,{mod,func,result}).

example(A, B, C, D) -&gt;
    {rec,trivial,example,A + B * C * (D + 42)}.</code></pre><p>The <code>-E</code> option produces a listing of the abstract format
produced by the <code>expand_records</code> pass.</p><p>The <code>-record()</code> declaration is still there, but the construction of
the record has been replaced with construction of a tuple. Similarly,
matching of records will be translated to matching of tuples.</p><h2>Tip: Producing a single source file using -P</h2><p>The <code>-P</code> option can be used to package a source file that includes
multiple include files into a single self-contained source file.</p><p>Having a self-contained source file is useful if you want to report
a compiler bug, but don&#x27;t have the time to minimize the source code
to a minimum example.</p><p>Here is an example. The <code>compile.erl</code> file includes two header files.
Compiling it directly like this will not work:</p><pre><code>$ cd lib/compiler/src
$ erlc compile.erl
compile.erl:36: can&#x27;t find include file &quot;erl_compile.hrl&quot;
   .
   .
   .
$</code></pre><p>We must give the path to the <code>include</code> directories of both
Kernel and STDLIB:</p><pre><code>$ erlc -I ../../kernel/include -I ../../stdlib/include compile.erl
$</code></pre><p>To package the source from <code>compile.erl</code> as well as the contents
of the header files, use the <code>-P</code> option to generate <code>compile.P</code>:</p><pre><code>$ erlc -P -I ../../kernel/include -I ../../stdlib/include compile.erl</code></pre><p><code>compile.P</code> can be renamed to <code>compile.erl</code> and successfully
compiled without any additional options:</p><pre><code>$ mv compile.P $HOME/compile.erl
$ cd $HOME
$ erlc compile.erl
$</code></pre><h2>Points to Ponder</h2><p>The preprocessor is run after tokenization, before running the
parser.</p><p>So how are the <code>?FUNCTION_NAME</code> and <code>?FUNCTION_ARITY</code> macros implemented?</p><p>Here is an example of how tokens for a simple function looks like:</p><pre><code>1&gt; {ok,T,_} = erl_scan:string(&quot;foo({tag,X,Y}) -&gt; ?FUNCTION_ARITY.&quot;), T.
[{atom,1,foo},
 {&#x27;(&#x27;,1},
 {&#x27;{&#x27;,1},
 {atom,1,tag},
 {&#x27;,&#x27;,1},
 {var,1,&#x27;X&#x27;},
 {&#x27;,&#x27;,1},
 {var,1,&#x27;Y&#x27;},
 {&#x27;}&#x27;,1},
 {&#x27;)&#x27;,1},
 {&#x27;-&gt;&#x27;,1},
 {&#x27;?&#x27;,1},
 {var,1,&#x27;FUNCTION_ARITY&#x27;},
 {dot,1}]</code></pre></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"compiler-lost-in-translation","title":"Lost in Translation (Exploring the Compiler's Front End)","author":"Bj√∂rn Gustavsson","excerpt":"\nIn this blog post, we will explore the compiler passes that make up\nthe compiler's front end.\n\n[erl_scan:string/1]: http://erlang.org/doc/man/erl_scan.html#string-1,\n[The Abstract Format]: http://erlang.org/doc/apps/erts/absform.html,\n[parse tree]: ../images/compiler-2018-04-26.svg,\n[erl_pp]: http://erlang.org/doc/man/erl_pp.html,\n[epp]: http://erlang.org/doc/man/epp.html,\n[QLC]: http://erlang.org/doc/man/qlc.html,\n[ms_transform]: http://erlang.org/doc/man/ms_transform.html,\n[erl_lint]: http://erlang.org/doc/man/erl_lint.html,\n[erl_expand_records]: http://erlang.org/doc/man/erl_expand_records.html","article_date":1524700800000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Lost in Translation (Exploring the Compiler's Front End)","tags":"compiler BEAM","author":"Bj√∂rn Gustavsson"},"content":"\nIn this blog post, we will explore the compiler passes that make up\nthe compiler's front end.\n\nIn the [previous blog post](http://blog.erlang.org/compiler-time-option/)\nwe showed how the `time` option shows information about the compiler passes\nbeing executed:\n\n\n```\n$ erlc +time trivial.erl\nCompiling \"trivial\"\n remove_file                   :      0.000 s       3.7 kB\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.002 s       5.5 kB\n expand_records                :      0.000 s       5.3 kB\n     .\n     .\n     .\n```\n\nWe explained what the `remove_file` pass does in the previous\nblog post. In today's blog post, we will discuss the other passes\nlisted in the output above.\n\nThose passes makes up the compiler's front end. The implementation\nmodules for those passes are not in the **compiler** application, but\nin **STDLIB**. The reason is that the Erlang shell also uses those\nmodules. That means that the shell will work in an embedded system\nthat does not include the **compiler** application.\n\nThe front end passes operate on the **abstract format**. The abstract\nformat is fairly close to the original Erlang source code. In fact, by\npretty-printing the abstract format, we can reconstruct the original\nsource code, albeit not perfectly.\n\n## Lost in translation ##\n\nTo see how much we will lose in translation, we will compile and\npretty-print this module:\n\n```\n-module(trivial).\n-export([example/4]).\n-record(rec, {mod,func,result}).\n\n%% Example to help explore the compiler front end.\nexample(A, B, C, D) -\u003e\n    #rec{mod=?MODULE,func=?FUNCTION_NAME,result=A + (B*C*(D+42))}.\n```\n\nWe use `-P` option to run the `parse_module` pass and produce\na listing of the result:\n\n```\n$ erlc -P +time trivial.erl\nCompiling \"trivial\"\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.003 s       5.5 kB\n listing                       :      0.001 s       5.5 kB\n```\n\nFor the moment, ignore the `transform_module` and `erl_lint` passes.\nThey don't change the abstract code for this module. The `listing`\npass pretty prints the abstract format, converting it back to Erlang\nsource code and creating the file `trivial.P`.\n\n\n```\n$ cat trivial.P\n-file(\"trivial.erl\", 1).\n\n-module(trivial).\n\n-export([example/4]).\n\n-record(rec,{mod,func,result}).\n\nexample(A, B, C, D) -\u003e\n    #rec{mod = trivial,func = example,result = A + B * C * (D + 42)}.\n```\n\nComparing the `trivial.P` file to the original, we can see what was\nlost in translation:\n\n* The `?MODULE` and `?FUNCTION_NAME` macro invocations have been\nreplaced with `trival` and `example`, respectively. That was done by\nthe preprocessor.\n\n* The comment has disappeared. There are also several differences in the\namount of whitespace surrounding variables and operators. The abstract format\ndoes not include whitepace or comments in its representation.\n\n* Also note that a redundant pair of parentheses has been omitted in the\nexpression `A + (B*C*(D+42))`. The parentheses around `D+42` are still there\nbecause otherwise the value of the expression would change. The abstract\nformat has no direct representation of parenheses.\n\n## Looking closer at the parse_module pass ##\n\nNow that we have seen what is lost in translation, we will take a\ncloser look at the abstract format.\n\nWe will use the expression `A+(B*C*(D+42))` as an example and\ntranslate it to the abstract format using the same modules that the\n`parse_module` pass uses to do its work.\n\n### Tokenizing using erl_scan ###\n\nThe first step in the translation from Erlang source code is to group\nthe characters into logical groups called **tokens**. This process is\ncalled **tokenization** or **scanning**, and is done by the `erl_scan`\nmodule.\n\nWe will use `erl_scan:string/1` to tokenize our example. (The\ncompiler will use other functions in `erl_scan`, but the principle\nis the same.)\n\n```\n1\u003e {ok,Tokens,_} = erl_scan:string(\"A + (B*C*(D+42)).\"), Tokens.\n[{var,1,'A'},\n {'+',1},\n {'(',1},\n {var,1,'B'},\n {'*',1},\n {var,1,'C'},\n {'*',1},\n {'(',1},\n {var,1,'D'},\n {'+',1},\n {integer,1,42},\n {')',1},\n {')',1},\n {dot,1}]\n```\n\nThe output is a list of tokens. The second element in each tuple\nis the line number. The first element is the category of the token.\nIf there is a third element, it is the symbol within that category.\n\nWe can see that whitespace has already been lost. Had there been\na comment, it would have been lost too.\n\nTo read more details about tokens, see [erl_scan:string/1].\n\n[erl_scan:string/1]: http://erlang.org/doc/man/erl_scan.html#string-1\n\n### Preprocessing the tokens ###\n\nIn the compiler, the next step would be to run the preprocessor\non the tokens. In this example, there are no macro invocations\nand thus nothing to preprocess, so we will skip to the next step.\n\n### Parsing using erl_parse ###\n\nThe next step is to **parse** the tokens to produce the abstract\nformat:\n\n```\n2\u003e {ok,Abstract} = erl_parse:parse_exprs(Tokens), Abstract.\n[{op,1,'+',\n     {var,1,'A'},\n     {op,1,'*',\n         {op,1,'*',{var,1,'B'},{var,1,'C'}},\n         {op,1,'+',{var,1,'D'},{integer,1,42}}}}]\n```\n\nThe result is a list with one expression. The expression is not a\nlist, but a **parse tree**. It can be visualized like this:\n\n![Abstract format visualized](../images/compiler-2018-04-26.svg)\n\nThe parentheses have been lost, because the structure of the tree\nmakes the evaluation order unambiguous.\n\nSee [The Abstract Format] for more details about the abstract format.\n\n[The Abstract Format]: http://erlang.org/doc/apps/erts/absform.html\n[parse tree]: ../images/compiler-2018-04-26.svg\n\n### Pretty-printing using erl_pp ###\n\nThe `listing` pass uses the [erl_pp] module to pretty print the\nabstract format to produce a listing file.\n\nWe can pretty print the abstract format of the example:\n\n```\n3\u003e lists:flatten(erl_pp:exprs(Abstract)).\n\"A + B * C * (D + 42)\"\n```\n\nHere the pretty printer has inserted one pair of parentheses, but the\nredundant pair of parentheses in the original expression has been lost.\nThe whitespace is also different from the original.\n\n[erl_pp]: http://erlang.org/doc/man/erl_pp.html\n\n### A quick look at the preprocessor ###\n\nA mentioned in passing, the preprocessor (the [epp] module) is run\nafter tokenization and before parsing.\n\nThe preprocessor goes through the tokens, looking for a question\nmark followed by a variable or atom. For example, `?MODULE` in\na source file would be tokenized like this by `erl_scan`:\n\n    [{'?',1},{var,1,'MODULE'}]\n\nAssuming that the module name is `trivial`, the preprocessor will\nreplace those tokens with the token:\n\n    [{atom,1,trivial}]\n\n[epp]: http://erlang.org/doc/man/epp.html\n\n\n## The other passes operating on the abstract format ##\n\nNow that `parse_module` has been explained, let's take quick look at the\nother passes in the front end.\n\n### The transform_module pass ###\n\nThe `transform_module` pass runs parse transforms, for example\nfor [QLC] or [ms_transform].\n\n[QLC]: http://erlang.org/doc/man/qlc.html\n[ms_transform]: http://erlang.org/doc/man/ms_transform.html\n\n### The lint_module pass ###\n\nThe `lint_module` pass verifies that the code is semantically\ncorrect. That is, variables must be bound before they are used,\nall clauses for a function must have the same number of arguments,\nand so on.\n\nWhen we compile a module with problems, [erl_lint] will print\nerror messages and terminate the compilation:\n\n```\n$ cat bug.erl\n-module(bug).\n-export([main/0]).\n\nmain() -\u003e\n    A+B.\n$ erlc +time bug.erl\nCompiling \"bug\"\n remove_file                   :      0.000 s       2.1 kB\n parse_module                  :      0.000 s       2.7 kB\n transform_module              :      0.000 s       2.7 kB\n lint_module                   :      0.004 s       2.4 kB\nbug.erl:5: variable 'A' is unbound\nbug.erl:5: variable 'B' is unbound\n$\n```\n\n[erl_lint]: http://erlang.org/doc/man/erl_lint.html\n\n### Translating records ###\n\nThe `expand_records` pass uses [erl_expand_records] to translate\nrecords:\n\n```\n$ erlc -E +time trivial.erl\nCompiling \"trivial\"\n parse_module                  :      0.000 s       5.5 kB\n transform_module              :      0.000 s       5.5 kB\n lint_module                   :      0.002 s       5.5 kB\n expand_records                :      0.000 s       5.3 kB\n listing                       :      0.001 s       5.3 kB\n$ cat trivial.E\n-file(\"trivial.erl\", 1).\n\n-module(trivial).\n\n-export([example/4]).\n\n-record(rec,{mod,func,result}).\n\nexample(A, B, C, D) -\u003e\n    {rec,trivial,example,A + B * C * (D + 42)}.\n```\n\nThe `-E` option produces a listing of the abstract format\nproduced by the `expand_records` pass.\n\nThe `-record()` declaration is still there, but the construction of\nthe record has been replaced with construction of a tuple. Similarly,\nmatching of records will be translated to matching of tuples.\n\n[erl_expand_records]: http://erlang.org/doc/man/erl_expand_records.html\n\n## Tip: Producing a single source file using -P ##\n\nThe `-P` option can be used to package a source file that includes\nmultiple include files into a single self-contained source file.\n\nHaving a self-contained source file is useful if you want to report\na compiler bug, but don't have the time to minimize the source code\nto a minimum example.\n\nHere is an example. The `compile.erl` file includes two header files.\nCompiling it directly like this will not work:\n\n```\n$ cd lib/compiler/src\n$ erlc compile.erl\ncompile.erl:36: can't find include file \"erl_compile.hrl\"\n   .\n   .\n   .\n$\n```\n\nWe must give the path to the `include` directories of both\nKernel and STDLIB:\n\n```\n$ erlc -I ../../kernel/include -I ../../stdlib/include compile.erl\n$\n```\n\nTo package the source from `compile.erl` as well as the contents\nof the header files, use the `-P` option to generate `compile.P`:\n\n\n```\n$ erlc -P -I ../../kernel/include -I ../../stdlib/include compile.erl\n```\n\n`compile.P` can be renamed to `compile.erl` and successfully\ncompiled without any additional options:\n\n```\n$ mv compile.P $HOME/compile.erl\n$ cd $HOME\n$ erlc compile.erl\n$\n```\n\n## Points to Ponder ##\n\nThe preprocessor is run after tokenization, before running the\nparser.\n\nSo how are the `?FUNCTION_NAME` and `?FUNCTION_ARITY` macros implemented?\n\nHere is an example of how tokens for a simple function looks like:\n\n```\n1\u003e {ok,T,_} = erl_scan:string(\"foo({tag,X,Y}) -\u003e ?FUNCTION_ARITY.\"), T.\n[{atom,1,foo},\n {'(',1},\n {'{',1},\n {atom,1,tag},\n {',',1},\n {var,1,'X'},\n {',',1},\n {var,1,'Y'},\n {'}',1},\n {')',1},\n {'-\u003e',1},\n {'?',1},\n {var,1,'FUNCTION_ARITY'},\n {dot,1}]\n```\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"compiler-lost-in-translation"},"buildId":"aoeL97fiGQMaunPBLLCoJ","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_buildManifest.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_ssgManifest.js" async=""></script></body></html>