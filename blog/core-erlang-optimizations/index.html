<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/core-erlang-optimizations/">Core Erlang Optimizations</a></h3><p><em>Friday, 18 May 2018<!-- --> - <!-- -->Bj√∂rn Gustavsson</em></p><p>This blog post continues the exploration of Core Erlang by
looking at some optimizations done by the <code>sys_core_fold</code>
compiler pass. The Core Erlang language was introduced in
the <a href="http://blog.erlang.org/core-erlang-by-example/">previous blog post</a>.</p><p>To prepare the examples in this blog post I used two
commands.</p><pre><code>$ erlc +time +dcore core_fold_example.erl
Compiling &quot;core_fold_example&quot;
 parse_module                  :      0.000 s       9.4 kB
 transform_module              :      0.000 s       9.4 kB
 lint_module                   :      0.005 s       9.4 kB
 expand_records                :      0.000 s       9.4 kB
 core                          :      0.000 s      59.3 kB
 listing                       :      0.003 s      59.3 kB</code></pre><p>The <code>dcore</code> option produces the file <code>core_fold_example.core</code>
containing a listing of the Core Erlang code produced by the <code>core</code>
parse (implemented by the module <code>v3_core</code>).</p><pre><code>$ erlc +time +dcopt core_fold_example.erl
Compiling &quot;core_fold_example&quot;
 parse_module                  :      0.000 s       9.4 kB
 transform_module              :      0.000 s       9.4 kB
 lint_module                   :      0.002 s       9.4 kB
 expand_records                :      0.000 s       9.4 kB
 core                          :      0.000 s      59.3 kB
 sys_core_fold                 :      0.000 s      25.3 kB
 core_transforms               :      0.000 s      25.3 kB
 listing                       :      0.002 s      25.3 kB</code></pre><p>The <code>dcopt</code> option produces the file <code>core_fold_example.copt</code>
containing a listing of the Core Erlang code as it looks
after optimization by the <code>sys_core_fold</code> pass.</p><p>As was mentioned in my first blog post about the compiler,
<code>compile:options()</code> will print most of the hidden options for
the compiler.</p><h2>The most basic optimization</h2><p>The most basic optimization done by <code>sys_core_fold</code> is constant propagation.</p><p>Consider this Erlang function:</p><pre><code class="language-erlang">a() -&gt;
    A = 42,
    {ok,A}.</code></pre><p>It can be translated to Core Erlang like this:</p><pre><code>&#x27;a&#x27;/0 =
    fun () -&gt;
       let &lt;A&gt; = 42
       in {&#x27;ok&#x27;,A}</code></pre><p>The variable <code>A</code> is bound to a constant (as opposed to an expression such
as function call). We can replace all occurrences of the variable <code>A</code> with
the constant value <code>42</code> and eliminate the <code>let</code>:</p><pre><code>&#x27;a&#x27;/0 =
    fun () -&gt;
	{&#x27;ok&#x27;,42}</code></pre><h2>Optimizing <code>case</code> expressions</h2><p>Actually, the first version of <code>a/0</code> that I showed was already
slightly optimized by me.</p><p>Here is the actual Core Erlang code (only slightly edited to
remove annotations and unnecessary line breaks):</p><pre><code>&#x27;a&#x27;/0 =
    fun () -&gt;
        case &lt;&gt; of
	  &lt;&gt; when &#x27;true&#x27; -&gt;
	      let &lt;A&gt; = 42
	      in {&#x27;ok&#x27;,A}
	  &lt;&gt; when &#x27;true&#x27; -&gt;
		primop &#x27;match_fail&#x27;({&#x27;function_clause&#x27;})
	end</code></pre><p>The <code>let</code> has been wrapped in a useless outer <code>case</code>. The
<code>case</code> would serve some purpose if there had been some function
arguments, but why complicate the code generator if <code>sys_core_fold</code> is
perfectly capable of simplifying this code?</p><p><code>sys_core_fold</code> will simplify the code in several steps.</p><p>First it will look at each clause. If a clause can&#x27;t possibly
be executed (for example, it its guard is <code>false</code>) it will be
dropped. If a clause will always match, all clauses following
the clause will be dropped.</p><p>In this case, the first clause will always match, because the
pattern is a list of no variables that can&#x27;t fail to match, and
the guard is <code>true</code>. Thus the second clause is unreachable and
is dropped:</p><pre><code>&#x27;a&#x27;/0 =
    fun () -&gt;
        case &lt;&gt; of
	  &lt;&gt; when &#x27;true&#x27; -&gt;
	      let &lt;A&gt; = 42
	      in {&#x27;ok&#x27;,A}
	end</code></pre><p>The next step is to see if there is only one clause remaining.
If it is, the body of the clause can be kept and the <code>case</code>
eliminated:</p><pre><code>&#x27;a&#x27;/0 =
    fun () -&gt;
       let &lt;A&gt; = 42
       in {&#x27;ok&#x27;,A}</code></pre><h2>Another case example</h2><p>Let&#x27;s see how a more complicated function can be optimized
following the steps just described. Consider this Erlang
function:</p><pre><code class="language-erlang">aa() -&gt;
    case {a,tuple} of
	[List] -&gt; List;
	{A,B} -&gt;  {tuple,A,B};
	_ -&gt;      something_else
    end.</code></pre><p>Translated to Core Erlang code (with the outer <code>case</code> and
annotations removed) it will look this:</p><pre><code>&#x27;aa&#x27;/0 =
    fun () -&gt;
      case {&#x27;a&#x27;,&#x27;tuple&#x27;} of
	&lt;[List|[]]&gt; when &#x27;true&#x27; -&gt;
	    List
	&lt;{A,B}&gt; when &#x27;true&#x27; -&gt;
	    {&#x27;tuple&#x27;,A,B}
	&lt;_@c1&gt; when &#x27;true&#x27; -&gt;
	    &#x27;something_else&#x27;
	&lt;_@c0&gt; when &#x27;true&#x27; -&gt;
	    primop &#x27;match_fail&#x27;({&#x27;case_clause&#x27;,_@c0})
      end</code></pre><p>Let&#x27;s go through the clauses one by one:</p><ul><li><p>The first clause will only match a list with exactly one element.
The <code>case</code> expression is a tuple, so the first clause can&#x27;t
possibly match. It will be dropped.</p></li><li><p>The second clause will match a tuple with (any) two elements.
The case expression is a tuple with two elements, so this clause
will always match.</p></li><li><p>There is no need to look at the remaining clauses, since the
second clause will always match. The remaining clauses are dropped.</p></li></ul><p>We now have:</p><pre><code>&#x27;aa&#x27;/0 =
    fun () -&gt;
      case {&#x27;a&#x27;,&#x27;tuple&#x27;} of
	&lt;{A,B}&gt; when &#x27;true&#x27; -&gt;
	    {&#x27;tuple&#x27;,A,B}
      end</code></pre><p>This is a <code>case</code> with just one clause, so we can keep
the body of the clause and remove the <code>case</code>. But there is
a problem if we do that naively:</p><pre><code>&#x27;aa&#x27;/0 =
    fun () -&gt;
       {&#x27;tuple&#x27;,A,B}</code></pre><p>The variables <code>A</code> and <code>B</code> are used, but they don&#x27;t have
any values bound to them. We must use a <code>let</code> to bind
the variables before they can be used:</p><pre><code>&#x27;aa&#x27;/0 =
    fun () -&gt;
      let &lt;A,B&gt; = &lt;&#x27;a&#x27;,&#x27;tuple&#x27;&gt;
      in {&#x27;tuple&#x27;,A,B}</code></pre><p>Propagating constants, the final code is:</p><pre><code>&#x27;aa&#x27;/0 =
    fun () -&gt;
	{&#x27;tuple&#x27;,&#x27;a&#x27;,&#x27;tuple&#x27;}</code></pre><h2>Avoiding tuple building</h2><p>Here is an example of a common pattern of matching
several expressions in parallel:</p><pre><code class="language-erlang">b(A, B) -&gt;
    case {A,B} of
	{true,false} -&gt; ok;
	{false,true} -&gt; not_ok;
	{_,_} -&gt; error
    end.</code></pre><p>The unoptimized Core Erlang code looks like this:</p><pre><code>&#x27;b&#x27;/2 =
    fun (_@c1,_@c0) -&gt;
	case &lt;_@c1,_@c0&gt; of
	  &lt;A,B&gt; when &#x27;true&#x27; -&gt;
	      case {A,B} of
		&lt;{&#x27;true&#x27;,&#x27;false&#x27;}&gt; when &#x27;true&#x27; -&gt;
		    &#x27;ok&#x27;
		&lt;{&#x27;false&#x27;,&#x27;true&#x27;}&gt; when &#x27;true&#x27; -&gt;
		    &#x27;not_ok&#x27;
		&lt;{_@c5,_@c6}&gt; when &#x27;true&#x27; -&gt;
		    &#x27;error&#x27;
		&lt;_@c2&gt; when &#x27;true&#x27; -&gt;
		      primop &#x27;match_fail&#x27;({&#x27;case_clause&#x27;,_@c2})
	      end
	end</code></pre><p>The <code>case</code> expression is <code>{A,B}</code>. When executing the <code>case</code>
a tuple will built, and then almost immediately discarded.
That is wasteful. Therefore <code>sys_core_fold</code> rewrites the
code to eliminate the tuple building:</p><pre><code>&#x27;b&#x27;/2 =
    fun (_@c1,_@c0) -&gt;
	case &lt;_@c1,_@c0&gt; of
	  &lt;&#x27;true&#x27;,&#x27;false&#x27;&gt; when &#x27;true&#x27; -&gt;
	      &#x27;ok&#x27;
	  &lt;&#x27;false&#x27;,&#x27;true&#x27;&gt; when &#x27;true&#x27; -&gt;
	      &#x27;not_ok&#x27;
	  &lt;_@c5,_@c6&gt; when &#x27;true&#x27; -&gt;
	      &#x27;error&#x27;
	end</code></pre><p>Here a value list is used instead of a tuple. (See
<a href="http://blog.erlang.org/core-erlang-by-example/">previous blog post</a>
for several examples of value lists.)</p><p>Another common pattern where tuples are built and immediately
discarded is shown in this example:</p><pre><code class="language-erlang">c(X) -&gt;
    {A,B} = case X of
		a1 -&gt; {10,1};
		b2 -&gt; {20,2};
		_ -&gt;  {100,42}
	    end,
    A+B.</code></pre><p>The unoptimized Core Erlang code looks like this:</p><pre><code>&#x27;c&#x27;/1 =
    fun (_@c0) -&gt;
	case _@c0 of
	  &lt;X&gt; when &#x27;true&#x27; -&gt;
	      let &lt;_@c2&gt; =
		  case X of
		    &lt;&#x27;a1&#x27;&gt; when &#x27;true&#x27; -&gt;
			{10,1}
		    &lt;&#x27;b2&#x27;&gt; when &#x27;true&#x27; -&gt;
			{20,2}
		    &lt;_@c5&gt; when &#x27;true&#x27; -&gt;
			{100,42}
		    &lt;_@c1&gt; when &#x27;true&#x27; -&gt;
			  primop &#x27;match_fail&#x27;({&#x27;case_clause&#x27;,_@c1})
		  end
	      in
		  case _@c2 of
		    &lt;{A,B}&gt; when &#x27;true&#x27; -&gt;
			call &#x27;erlang&#x27;:&#x27;+&#x27;(A, B)
		    &lt;_@c3&gt; when &#x27;true&#x27; -&gt;
			  primop &#x27;match_fail&#x27;({&#x27;badmatch&#x27;,_@c3})
		  end
	  &lt;_@c4&gt; when &#x27;true&#x27; -&gt;
		  primop &#x27;match_fail&#x27;({&#x27;function_clause&#x27;,_@c4})
	end</code></pre><p>Here a tuple is built and assigned to <code>_@c2</code>. It is then matched
in a <code>case</code>.</p><p>First the code is optimized like this to eliminate the tuple building
in each clause of the first <code>case</code>:</p><pre><code>&#x27;c&#x27;/1 =
    fun (_@c0) -&gt;
	let &lt;_@f4,_@f5&gt; =
	    case _@c0 of
	      &lt;&#x27;a1&#x27;&gt; when &#x27;true&#x27; -&gt;
		  &lt;10,1&gt;
	      &lt;&#x27;b2&#x27;&gt; when &#x27;true&#x27; -&gt;
		  &lt;20,2&gt;
	      &lt;_@c5&gt; when &#x27;true&#x27; -&gt;
		  &lt;100,42&gt;
	    end
	in
            let &lt;_@c2&gt; = {_@f4,_@f5}
            in
	          case _@c2 of
		    &lt;{A,B}&gt; when &#x27;true&#x27; -&gt;
			call &#x27;erlang&#x27;:&#x27;+&#x27;(A, B)
		    &lt;_@c3&gt; when &#x27;true&#x27; -&gt;
			  primop &#x27;match_fail&#x27;({&#x27;badmatch&#x27;,_@c3})
		  end
	end</code></pre><p>Applying all of the optimizations previously described,
the remaining tuple building and matching can be eliminated:</p><pre><code>&#x27;c&#x27;/1 =
    fun (_@c0) -&gt;
	let &lt;_@f4,_@f5&gt; =
	    case _@c0 of
	      &lt;&#x27;a1&#x27;&gt; when &#x27;true&#x27; -&gt;
		  &lt;10,1&gt;
	      &lt;&#x27;b2&#x27;&gt; when &#x27;true&#x27; -&gt;
		  &lt;20,2&gt;
	      &lt;_@c5&gt; when &#x27;true&#x27; -&gt;
		  &lt;100,42&gt;
	    end
	in
	    call &#x27;erlang&#x27;:&#x27;+&#x27;(_@f4, _@f5)</code></pre><h2>Conclusion</h2><p>That was a quick look at some of the optimizations done by
<code>sys_core_fold</code>.</p><p>Some of the optimizations are very simple. The power of the
<code>sys_core_fold</code> pass comes from the combination of optimizations.  One
optimization gives opportunities for other optimizations, as could be
seen in the examples.</p><h2>Points to Ponder</h2><p>Why is the optimization pass called <code>sys_core_fold</code>?</p><p>A hint can be found in the title of this Wikipedia article:
<a href="https://en.wikipedia.org/wiki/Constant_folding">Constant folding</a>.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"core-erlang-optimizations","title":"Core Erlang Optimizations","author":"Bj√∂rn Gustavsson","excerpt":"\nThis blog post continues the exploration of Core Erlang by\nlooking at some optimizations done by the `sys_core_fold`\ncompiler pass. The Core Erlang language was introduced in\nthe [previous blog post](http://blog.erlang.org/core-erlang-by-example/).","article_date":1526601600000,"tags":["compiler","BEAM"],"frontmatter":{"layout":"post","title":"Core Erlang Optimizations","tags":"compiler BEAM","author":"Bj√∂rn Gustavsson"},"content":"\nThis blog post continues the exploration of Core Erlang by\nlooking at some optimizations done by the `sys_core_fold`\ncompiler pass. The Core Erlang language was introduced in\nthe [previous blog post](http://blog.erlang.org/core-erlang-by-example/).\n\nTo prepare the examples in this blog post I used two\ncommands.\n\n```\n$ erlc +time +dcore core_fold_example.erl\nCompiling \"core_fold_example\"\n parse_module                  :      0.000 s       9.4 kB\n transform_module              :      0.000 s       9.4 kB\n lint_module                   :      0.005 s       9.4 kB\n expand_records                :      0.000 s       9.4 kB\n core                          :      0.000 s      59.3 kB\n listing                       :      0.003 s      59.3 kB\n```\n\nThe `dcore` option produces the file `core_fold_example.core`\ncontaining a listing of the Core Erlang code produced by the `core`\nparse (implemented by the module `v3_core`).\n\n```\n$ erlc +time +dcopt core_fold_example.erl\nCompiling \"core_fold_example\"\n parse_module                  :      0.000 s       9.4 kB\n transform_module              :      0.000 s       9.4 kB\n lint_module                   :      0.002 s       9.4 kB\n expand_records                :      0.000 s       9.4 kB\n core                          :      0.000 s      59.3 kB\n sys_core_fold                 :      0.000 s      25.3 kB\n core_transforms               :      0.000 s      25.3 kB\n listing                       :      0.002 s      25.3 kB\n```\n\nThe `dcopt` option produces the file `core_fold_example.copt`\ncontaining a listing of the Core Erlang code as it looks\nafter optimization by the `sys_core_fold` pass.\n\nAs was mentioned in my first blog post about the compiler,\n`compile:options()` will print most of the hidden options for\nthe compiler.\n\n## The most basic optimization\n\nThe most basic optimization done by `sys_core_fold` is constant propagation.\n\nConsider this Erlang function:\n\n```erlang\na() -\u003e\n    A = 42,\n    {ok,A}.\n```\n\nIt can be translated to Core Erlang like this:\n\n```\n'a'/0 =\n    fun () -\u003e\n       let \u003cA\u003e = 42\n       in {'ok',A}\n```\n\nThe variable `A` is bound to a constant (as opposed to an expression such\nas function call). We can replace all occurrences of the variable `A` with\nthe constant value `42` and eliminate the `let`:\n\n```\n'a'/0 =\n    fun () -\u003e\n\t{'ok',42}\n```\n\n## Optimizing `case` expressions\n\nActually, the first version of `a/0` that I showed was already\nslightly optimized by me.\n\nHere is the actual Core Erlang code (only slightly edited to\nremove annotations and unnecessary line breaks):\n\n```\n'a'/0 =\n    fun () -\u003e\n        case \u003c\u003e of\n\t  \u003c\u003e when 'true' -\u003e\n\t      let \u003cA\u003e = 42\n\t      in {'ok',A}\n\t  \u003c\u003e when 'true' -\u003e\n\t\tprimop 'match_fail'({'function_clause'})\n\tend\n```\n\nThe `let` has been wrapped in a useless outer `case`. The\n`case` would serve some purpose if there had been some function\narguments, but why complicate the code generator if `sys_core_fold` is\nperfectly capable of simplifying this code?\n\n`sys_core_fold` will simplify the code in several steps.\n\nFirst it will look at each clause. If a clause can't possibly\nbe executed (for example, it its guard is `false`) it will be\ndropped. If a clause will always match, all clauses following\nthe clause will be dropped.\n\nIn this case, the first clause will always match, because the\npattern is a list of no variables that can't fail to match, and\nthe guard is `true`. Thus the second clause is unreachable and\nis dropped:\n\n\n```\n'a'/0 =\n    fun () -\u003e\n        case \u003c\u003e of\n\t  \u003c\u003e when 'true' -\u003e\n\t      let \u003cA\u003e = 42\n\t      in {'ok',A}\n\tend\n```\n\nThe next step is to see if there is only one clause remaining.\nIf it is, the body of the clause can be kept and the `case`\neliminated:\n\n\n```\n'a'/0 =\n    fun () -\u003e\n       let \u003cA\u003e = 42\n       in {'ok',A}\n```\n\n## Another case example\n\nLet's see how a more complicated function can be optimized\nfollowing the steps just described. Consider this Erlang\nfunction:\n\n```erlang\naa() -\u003e\n    case {a,tuple} of\n\t[List] -\u003e List;\n\t{A,B} -\u003e  {tuple,A,B};\n\t_ -\u003e      something_else\n    end.\n```\n\nTranslated to Core Erlang code (with the outer `case` and\nannotations removed) it will look this:\n\n```\n'aa'/0 =\n    fun () -\u003e\n      case {'a','tuple'} of\n\t\u003c[List|[]]\u003e when 'true' -\u003e\n\t    List\n\t\u003c{A,B}\u003e when 'true' -\u003e\n\t    {'tuple',A,B}\n\t\u003c_@c1\u003e when 'true' -\u003e\n\t    'something_else'\n\t\u003c_@c0\u003e when 'true' -\u003e\n\t    primop 'match_fail'({'case_clause',_@c0})\n      end\n```\n\nLet's go through the clauses one by one:\n\n* The first clause will only match a list with exactly one element.\nThe `case` expression is a tuple, so the first clause can't\npossibly match. It will be dropped.\n\n* The second clause will match a tuple with (any) two elements.\nThe case expression is a tuple with two elements, so this clause\nwill always match.\n\n* There is no need to look at the remaining clauses, since the\nsecond clause will always match. The remaining clauses are dropped.\n\nWe now have:\n\n```\n'aa'/0 =\n    fun () -\u003e\n      case {'a','tuple'} of\n\t\u003c{A,B}\u003e when 'true' -\u003e\n\t    {'tuple',A,B}\n      end\n```\n\nThis is a `case` with just one clause, so we can keep\nthe body of the clause and remove the `case`. But there is\na problem if we do that naively:\n\n```\n'aa'/0 =\n    fun () -\u003e\n       {'tuple',A,B}\n```\n\nThe variables `A` and `B` are used, but they don't have\nany values bound to them. We must use a `let` to bind\nthe variables before they can be used:\n\n```\n'aa'/0 =\n    fun () -\u003e\n      let \u003cA,B\u003e = \u003c'a','tuple'\u003e\n      in {'tuple',A,B}\n```\n\nPropagating constants, the final code is:\n\n```\n'aa'/0 =\n    fun () -\u003e\n\t{'tuple','a','tuple'}\n```\n\n## Avoiding tuple building\n\nHere is an example of a common pattern of matching\nseveral expressions in parallel:\n\n```erlang\nb(A, B) -\u003e\n    case {A,B} of\n\t{true,false} -\u003e ok;\n\t{false,true} -\u003e not_ok;\n\t{_,_} -\u003e error\n    end.\n```\n\nThe unoptimized Core Erlang code looks like this:\n\n```\n'b'/2 =\n    fun (_@c1,_@c0) -\u003e\n\tcase \u003c_@c1,_@c0\u003e of\n\t  \u003cA,B\u003e when 'true' -\u003e\n\t      case {A,B} of\n\t\t\u003c{'true','false'}\u003e when 'true' -\u003e\n\t\t    'ok'\n\t\t\u003c{'false','true'}\u003e when 'true' -\u003e\n\t\t    'not_ok'\n\t\t\u003c{_@c5,_@c6}\u003e when 'true' -\u003e\n\t\t    'error'\n\t\t\u003c_@c2\u003e when 'true' -\u003e\n\t\t      primop 'match_fail'({'case_clause',_@c2})\n\t      end\n\tend\n```\n\nThe `case` expression is `{A,B}`. When executing the `case`\na tuple will built, and then almost immediately discarded.\nThat is wasteful. Therefore `sys_core_fold` rewrites the\ncode to eliminate the tuple building:\n\n```\n'b'/2 =\n    fun (_@c1,_@c0) -\u003e\n\tcase \u003c_@c1,_@c0\u003e of\n\t  \u003c'true','false'\u003e when 'true' -\u003e\n\t      'ok'\n\t  \u003c'false','true'\u003e when 'true' -\u003e\n\t      'not_ok'\n\t  \u003c_@c5,_@c6\u003e when 'true' -\u003e\n\t      'error'\n\tend\n```\n\nHere a value list is used instead of a tuple. (See\n[previous blog post](http://blog.erlang.org/core-erlang-by-example/)\nfor several examples of value lists.)\n\nAnother common pattern where tuples are built and immediately\ndiscarded is shown in this example:\n\n```erlang\nc(X) -\u003e\n    {A,B} = case X of\n\t\ta1 -\u003e {10,1};\n\t\tb2 -\u003e {20,2};\n\t\t_ -\u003e  {100,42}\n\t    end,\n    A+B.\n```\n\nThe unoptimized Core Erlang code looks like this:\n\n```\n'c'/1 =\n    fun (_@c0) -\u003e\n\tcase _@c0 of\n\t  \u003cX\u003e when 'true' -\u003e\n\t      let \u003c_@c2\u003e =\n\t\t  case X of\n\t\t    \u003c'a1'\u003e when 'true' -\u003e\n\t\t\t{10,1}\n\t\t    \u003c'b2'\u003e when 'true' -\u003e\n\t\t\t{20,2}\n\t\t    \u003c_@c5\u003e when 'true' -\u003e\n\t\t\t{100,42}\n\t\t    \u003c_@c1\u003e when 'true' -\u003e\n\t\t\t  primop 'match_fail'({'case_clause',_@c1})\n\t\t  end\n\t      in\n\t\t  case _@c2 of\n\t\t    \u003c{A,B}\u003e when 'true' -\u003e\n\t\t\tcall 'erlang':'+'(A, B)\n\t\t    \u003c_@c3\u003e when 'true' -\u003e\n\t\t\t  primop 'match_fail'({'badmatch',_@c3})\n\t\t  end\n\t  \u003c_@c4\u003e when 'true' -\u003e\n\t\t  primop 'match_fail'({'function_clause',_@c4})\n\tend\n```\n\nHere a tuple is built and assigned to `_@c2`. It is then matched\nin a `case`.\n\nFirst the code is optimized like this to eliminate the tuple building\nin each clause of the first `case`:\n\n```\n'c'/1 =\n    fun (_@c0) -\u003e\n\tlet \u003c_@f4,_@f5\u003e =\n\t    case _@c0 of\n\t      \u003c'a1'\u003e when 'true' -\u003e\n\t\t  \u003c10,1\u003e\n\t      \u003c'b2'\u003e when 'true' -\u003e\n\t\t  \u003c20,2\u003e\n\t      \u003c_@c5\u003e when 'true' -\u003e\n\t\t  \u003c100,42\u003e\n\t    end\n\tin\n            let \u003c_@c2\u003e = {_@f4,_@f5}\n            in\n\t          case _@c2 of\n\t\t    \u003c{A,B}\u003e when 'true' -\u003e\n\t\t\tcall 'erlang':'+'(A, B)\n\t\t    \u003c_@c3\u003e when 'true' -\u003e\n\t\t\t  primop 'match_fail'({'badmatch',_@c3})\n\t\t  end\n\tend\n```\n\nApplying all of the optimizations previously described,\nthe remaining tuple building and matching can be eliminated:\n\n```\n'c'/1 =\n    fun (_@c0) -\u003e\n\tlet \u003c_@f4,_@f5\u003e =\n\t    case _@c0 of\n\t      \u003c'a1'\u003e when 'true' -\u003e\n\t\t  \u003c10,1\u003e\n\t      \u003c'b2'\u003e when 'true' -\u003e\n\t\t  \u003c20,2\u003e\n\t      \u003c_@c5\u003e when 'true' -\u003e\n\t\t  \u003c100,42\u003e\n\t    end\n\tin\n\t    call 'erlang':'+'(_@f4, _@f5)\n```\n\n## Conclusion\n\nThat was a quick look at some of the optimizations done by\n`sys_core_fold`.\n\nSome of the optimizations are very simple. The power of the\n`sys_core_fold` pass comes from the combination of optimizations.  One\noptimization gives opportunities for other optimizations, as could be\nseen in the examples.\n\n## Points to Ponder\n\nWhy is the optimization pass called `sys_core_fold`?\n\nA hint can be found in the title of this Wikipedia article:\n[Constant folding](https://en.wikipedia.org/wiki/Constant_folding).\n\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"core-erlang-optimizations"},"buildId":"mwcz5f45UeFOBiRtaG40v","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_buildManifest.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_ssgManifest.js" async=""></script></body></html>