{"pageProps":{"index":{"id":"0052","content":"<pre><code>Author: Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;\nStatus: Accepted/23.0 Proposal is to be implemented in OTP release 23.0\nType: Standards Track\nCreated: 28-Jan-2020\nErlang-Version: 23\nPost-History: 28-Jan-2020\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 52: <a href=\"eep-0052.md\" title=\"EEP Source\"> Allow key and size expressions in map and binary matching</a></h2>\n\n<h1>Abstract</h1>\n\n<p>This EEP proposes an extension to matching of binaries to allow the\nsize of a segment to be a guard expression and to the matching of maps\nto allow the key to be a guard expression.</p>\n\n<h1>Specification</h1>\n\n<p>We propose that in binary matching the size of a binary segment can be\na guard expression.  Here is an example:</p>\n\n<pre><code>example1(&lt;&lt;Size:8,Payload:((Size-1)*8)/binary,Rest/binary&gt;&gt;) -&gt;\n   {Payload,Rest}.\n</code></pre>\n\n<p>The same expressions as in guards are allowed, except that the\nold-style type tests (such a <code>list/1</code> or <code>tuple/1</code>) are not\nallowed.  Unless the expression consists of a single number or single\nvariable is must be enclosed in parentheses.  Any variables used in the\nexpression must have been previously bound, or become bound in the\nsame binary pattern as the expression.  That is, the following example\nis illegal:</p>\n\n<pre><code>illegal_example2(N, &lt;&lt;X:N,T/binary&gt;&gt;) -&gt;\n    {X,T}.\n</code></pre>\n\n<p>A binary pattern will fail to match, if size expression in any of its\nsegments does not evaluate successfully or evaluates to a non-integer\nvalue.  For example:</p>\n\n<pre><code>example3(&lt;&lt;X:(1/0)&gt;&gt;) -&gt; X;\nexample3(&lt;&lt;X:not_integer&gt;&gt;) -&gt; X;\nexample3(_) -&gt; no_match.\n</code></pre>\n\n<p>The first clause will not match because the evaluation of <code>1/0</code> fails.\nThe second clause will not match because the size evaluates to an atom.</p>\n\n<p>In the current map matching syntax, the keys in a map pattern must be\na single value or a literal.  That leads to unnatural code if the keys\nin a map are complex terms.  For example:</p>\n\n<pre><code>example4(M, X) -&gt;\n    Key = {tag,X},\n    #{Key := Value} = M,\n    Value.\n</code></pre>\n\n<p>We propose that the key in a map pattern can be a guard expression.\nThat will allow the previous example to be written like this:</p>\n\n<pre><code>example5(M, X) -&gt;\n    #{{tag,X} := Value} = M,\n    Value.\n</code></pre>\n\n<p>All variables used in a key expression must be previously bound.\nThus, the following example is illegal:</p>\n\n<pre><code>illegal_example6(Key, #{Key := Value}) -&gt; Value.\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>The current limitations of map keys are surprising.  A literal tuple\nsuch as <code>{a,b}</code> is allowed as a key, while a tuple with a variable\nsuch as <code>{a,Var}</code> is not.</p>\n\n<p>In binary matching, it has always been possible to multiply a matched\nout number by  a small constant using the <code>unit:</code> modifier.  The proposed\nextension makes is possible in more circumstances to match both header\nand payload in the same binary pattern.</p>\n\n<h1>Rationale</h1>\n\n<h2>Why allow guard expressions?</h2>\n\n<p>We did consider only allowing term construction and expressions using\narithmetic operators.  There are two reasons we went with guard\nexpression instead:</p>\n\n<ul>\n<li><p>It is easy to explain and understand exactly what expression are\nallowed as segment sizes and as map keys, because the same type of\nexpressions are allowed in guards.</p></li>\n<li><p>When calculating the size of binary segment, a subset of guard BIFs\ncould conceivable be useful in practice.  For example: <code>ceiling/1</code>,\n<code>round/1</code>, <code>byte_size/1</code>, <code>bit_size/1</code>, and <code>map_get/2</code>.  We did not\nwant an arbitrary list of allowed BIFs in size expressions, so the\nonly logical thing is to allow full guard expressions.</p></li>\n</ul>\n\n<h2>Why are not absurd size expressions compilation errors?</h2>\n\n<p>Size expressions that obviously never evaluates to an integer will\nnot cause a compilation error (but may cause a warning).  For example:</p>\n\n<pre><code>example6(Bin, V) -&gt;\n    &lt;&lt;X:(is_list(V))&gt;&gt; = Bin,\n    X.\n</code></pre>\n\n<p>The reason is that rules for what is a legal Erlang program should be\nsimple and unambigous, to help both people and tools that generate\nErlang programs.</p>\n\n<h2>Why are parentheses required around non-trivial size expressions?</h2>\n\n<p>For the same reason that they are required when constructing binaries,\nnamely that language grammar would be ambiguous without the\nparentheses, since binary patterns use the characters <code>:</code>, <code>/</code>, and\n<code>-</code> with a different meaning than in the rest of the language.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Using the extended expressions segment size and map keys would cause a\ncompilation error in OTP 22 and previous releases.  Therefore, no\nexisting source code can be affected.</p>\n\n<p>However, there are changes to the semantics of Core Erlang that may\nmake it necessary to update languages compilers or tools that generate\nCore Erlang code.</p>\n\n<p>There are two major changes:</p>\n\n<ul>\n<li><p>A binary pattern in Core Erlang is no longer allowed to bind and use\na variable in the same binary pattern.</p></li>\n<li><p>To fully support binary matching in receives, receives must be lowered\nto more primitive operations.</p></li>\n</ul>\n\n<h2>Binary matching in Core Erlang</h2>\n\n<p>In Erlang, a variable can be bound in a binary pattern and used later\nin the same pattern as the size of a segment:</p>\n\n<pre><code>foo(&lt;&lt;Sz:16,X:Sz&gt;&gt;) -&gt; X.\n</code></pre>\n\n<p>In OTP 22 and previous releases, the translation to Core Erlang is\nstraightforward:</p>\n\n<pre><code>'foo'/1 =\n    fun (_0) -&gt;\n        case _0 of\n          &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),\n             #&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n              X\n          &lt;_1&gt; when 'true' -&gt;\n              %% Raise function_clause exception.\n              .\n              .\n              .\n        end\n</code></pre>\n\n<p>While the translation is straightforward, all Core Erlang passes would need\nto handle binding and using a variable in the same scope.  That would become\neven more complicated if we were to allow expressions as segment sizes.</p>\n\n<p>In OTP 23, all variables used in a segment size expression must be already\nbound in the enclosing environment.  The previous example must be rewritten\nlike this using nested cases:</p>\n\n<pre><code>'foo'/1 =\n    fun (_0) -&gt;\n          case _0 of\n              &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),\n               #&lt;_2&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n                  case _2 of\n                     &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n                         X\n                     &lt;_3&gt; when 'true' -&gt;\n                         %% Raise function_clause exception.\n                         .\n                         .\n                         .\n                    end\n               &lt;_4&gt; when 'true' -&gt;\n                    %% Raise function_clause exception.\n                    .\n                    .\n                    .\n              end\n</code></pre>\n\n<p>However, as can be seen from the example, the code for raising the <code>function_clause</code>\nexception has been duplicated.  The code duplication is no big deal in this simple\nexample, but it would be in a function where the binary matching clause was followed\nby many other clauses.  To avoid the code duplication, we must use <code>letrec</code> with\nthe <code>letrec_goto</code> annotation:</p>\n\n<pre><code>'foo'/1 =\n    fun (_0) -&gt;\n        ( letrec\n              'label^0'/0 =\n                  fun () -&gt;\n                        case _0 of\n                          &lt;_1&gt; when 'true' -&gt;\n                                %% Raise function_clause exception.\n                                .\n                                .\n                                .\n                        end\n          in  case _0 of\n                &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),\n                   #&lt;_2&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n                    case _2 of\n                      &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n                          X\n                      &lt;_3&gt; when 'true' -&gt;\n                            apply 'label^0'/0()\n                    end\n                &lt;_4&gt; when 'true' -&gt;\n                      apply 'label^0'/0()\n              end\n          -| ['letrec_goto'] )\n</code></pre>\n\n<p>When a <code>letrec</code> has been given the annotation <code>letrec_goto</code>, it will be\nspecially translated.  The <code>apply</code> operations will be translated to a goto\ninstead of a call to a local function.</p>\n\n<h2>Translating receive to Core Erlang</h2>\n\n<p>Consider this example:</p>\n\n<pre><code>bar(Timeout) -&gt;\n    receive\n        {tag,Msg} -&gt; Msg\n    after\n        Timeout -&gt;\n            no_message\n    end.\n</code></pre>\n\n<p>In a OTP 22 and earlier, the translation to Core Erlang was straightforward:</p>\n\n<pre><code>'bar'/1 =\n    fun (Timeout) -&gt;\n        receive\n          &lt;{'tag',Msg}&gt; when 'true' -&gt;\n              Msg\n        after Timeout -&gt;\n          'no_message'\n</code></pre>\n\n<p>In order to fully support binary matching in OTP 23, a <code>receive</code> in Erlang\nhas now been lowered to more primitive operations in Core Erlang:</p>\n\n<pre><code>'foo'/1 =\n    fun (Timeout) -&gt;\n        ( letrec\n              'recv$^0'/0 =\n                  fun () -&gt;\n                      let &lt;PeekSucceeded,Message&gt; =\n                          primop 'recv_peek_message'()\n                      in  case PeekSucceeded of\n                            &lt;'true'&gt; when 'true' -&gt;\n                                case Message of\n                                  &lt;{'tag',Msg}&gt; when 'true' -&gt;\n                                      do  primop 'remove_message'()\n                                          Msg\n                                  &lt;Other&gt; when 'true' -&gt;\n                                      do  primop 'recv_next'()\n                                            apply 'recv$^0'/0()\n                                end\n                            &lt;'false'&gt; when 'true' -&gt;\n                                let &lt;TimedOut&gt; =\n                                    primop 'recv_wait_timeout'(Timeout)\n                                in  case TimedOut of\n                                      &lt;'true'&gt; when 'true' -&gt;\n                                          do  primop 'timeout'()\n                                              'no_message'\n                                      &lt;'false'&gt; when 'true' -&gt;\n                                          apply 'recv$^0'/0()\n                                    end\n                          end\n          in  apply 'recv$^0'/0()\n          -| ['letrec_goto'] )\n</code></pre>\n\n<p>When compiling from Core Erlang code in OTP 23, the compiler will\naccept Core Erlang code that uses the <code>receive</code> construct and\nautomatically lower it to the more primitive operations.  That is,\nfor the example above, the Core Erlang translation from OTP 22 will\nbe accepted as input to the compiler in OTP 23.</p>\n\n<p>Here is another example where the Core Erlang code from OTP 22\nwill not be accepted.  Here is the Erlang code:</p>\n\n<pre><code>foobar() -&gt;\n    receive\n        &lt;&lt;Sz:16,X:Sz&gt;&gt; -&gt; X\n    end.\n</code></pre>\n\n<p>In OTP 22, this would be translated to Core Erlang code like this:</p>\n\n<pre><code>'foobar'/0 =\n    fun () -&gt;\n        receive\n          &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),\n             #&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n              X\n        after 'infinity' -&gt;\n          'true'\n</code></pre>\n\n<p>That translation will not be accepted by the compiler in OTP 23.  The <code>receive</code>\nmust be lowered to more primitive operations, and the binary matching must be\nrewritten using nested cases:</p>\n\n<pre><code>'foobar'/0 =\n    fun () -&gt;\n        ( letrec\n              'recv$^0'/0 =\n                  fun () -&gt;\n                      let &lt;_5,_0&gt; =\n                          primop 'recv_peek_message'()\n                      in  case _5 of\n                            &lt;'true'&gt; when 'true' -&gt;\n                                ( letrec\n                                      'label^0'/0 =\n                                          fun () -&gt;\n                                                do  primop 'recv_next'()\n                                                    apply 'recv$^0'/0()\n                                  in  case _0 of\n                                        &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),\n                                           #&lt;_1&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n                                            case _1 of\n                                              &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;\n                                                  do  primop 'remove_message'()\n                                                      X\n                                              &lt;_2&gt; when 'true' -&gt;\n                                                    apply 'label^0'/0()\n                                            end\n                                        &lt;_3&gt; when 'true' -&gt;\n                                              apply 'label^0'/0()\n                                      end\n                                  -| ['letrec_goto'] )\n                            &lt;'false'&gt; when 'true' -&gt;\n                                  let &lt;_4&gt; =\n                                      primop 'recv_wait_timeout'\n                                          ('infinity')\n                                  in  case _4 of\n                                        &lt;'true'&gt; when 'true' -&gt;\n                                            do  primop 'timeout'()\n                                                'true'\n                                        &lt;'false'&gt; when 'true' -&gt;\n                                            apply 'recv$^0'/0()\n                                      end\n                          end\n          in apply 'recv$^0'/0() )\n          -| ['letrec_goto']\n</code></pre>\n\n<h1>Implementation</h1>\n\n<p>The implementation can be found in <a href=\"https://github.com/erlang/otp/pull/2521\" title=\"#2521: Allow key and size expressions in map and binary matching\">PR #2521</a>.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}