<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Björn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;
Status: Accepted/23.0 Proposal is to be implemented in OTP release 23.0
Type: Standards Track
Created: 28-Jan-2020
Erlang-Version: 23
Post-History: 28-Jan-2020
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 52: <a href="eep-0052.md" title="EEP Source"> Allow key and size expressions in map and binary matching</a></h2>

<h1>Abstract</h1>

<p>This EEP proposes an extension to matching of binaries to allow the
size of a segment to be a guard expression and to the matching of maps
to allow the key to be a guard expression.</p>

<h1>Specification</h1>

<p>We propose that in binary matching the size of a binary segment can be
a guard expression.  Here is an example:</p>

<pre><code>example1(&lt;&lt;Size:8,Payload:((Size-1)*8)/binary,Rest/binary&gt;&gt;) -&gt;
   {Payload,Rest}.
</code></pre>

<p>The same expressions as in guards are allowed, except that the
old-style type tests (such a <code>list/1</code> or <code>tuple/1</code>) are not
allowed.  Unless the expression consists of a single number or single
variable is must be enclosed in parentheses.  Any variables used in the
expression must have been previously bound, or become bound in the
same binary pattern as the expression.  That is, the following example
is illegal:</p>

<pre><code>illegal_example2(N, &lt;&lt;X:N,T/binary&gt;&gt;) -&gt;
    {X,T}.
</code></pre>

<p>A binary pattern will fail to match, if size expression in any of its
segments does not evaluate successfully or evaluates to a non-integer
value.  For example:</p>

<pre><code>example3(&lt;&lt;X:(1/0)&gt;&gt;) -&gt; X;
example3(&lt;&lt;X:not_integer&gt;&gt;) -&gt; X;
example3(_) -&gt; no_match.
</code></pre>

<p>The first clause will not match because the evaluation of <code>1/0</code> fails.
The second clause will not match because the size evaluates to an atom.</p>

<p>In the current map matching syntax, the keys in a map pattern must be
a single value or a literal.  That leads to unnatural code if the keys
in a map are complex terms.  For example:</p>

<pre><code>example4(M, X) -&gt;
    Key = {tag,X},
    #{Key := Value} = M,
    Value.
</code></pre>

<p>We propose that the key in a map pattern can be a guard expression.
That will allow the previous example to be written like this:</p>

<pre><code>example5(M, X) -&gt;
    #{{tag,X} := Value} = M,
    Value.
</code></pre>

<p>All variables used in a key expression must be previously bound.
Thus, the following example is illegal:</p>

<pre><code>illegal_example6(Key, #{Key := Value}) -&gt; Value.
</code></pre>

<h1>Motivation</h1>

<p>The current limitations of map keys are surprising.  A literal tuple
such as <code>{a,b}</code> is allowed as a key, while a tuple with a variable
such as <code>{a,Var}</code> is not.</p>

<p>In binary matching, it has always been possible to multiply a matched
out number by  a small constant using the <code>unit:</code> modifier.  The proposed
extension makes is possible in more circumstances to match both header
and payload in the same binary pattern.</p>

<h1>Rationale</h1>

<h2>Why allow guard expressions?</h2>

<p>We did consider only allowing term construction and expressions using
arithmetic operators.  There are two reasons we went with guard
expression instead:</p>

<ul>
<li><p>It is easy to explain and understand exactly what expression are
allowed as segment sizes and as map keys, because the same type of
expressions are allowed in guards.</p></li>
<li><p>When calculating the size of binary segment, a subset of guard BIFs
could conceivable be useful in practice.  For example: <code>ceiling/1</code>,
<code>round/1</code>, <code>byte_size/1</code>, <code>bit_size/1</code>, and <code>map_get/2</code>.  We did not
want an arbitrary list of allowed BIFs in size expressions, so the
only logical thing is to allow full guard expressions.</p></li>
</ul>

<h2>Why are not absurd size expressions compilation errors?</h2>

<p>Size expressions that obviously never evaluates to an integer will
not cause a compilation error (but may cause a warning).  For example:</p>

<pre><code>example6(Bin, V) -&gt;
    &lt;&lt;X:(is_list(V))&gt;&gt; = Bin,
    X.
</code></pre>

<p>The reason is that rules for what is a legal Erlang program should be
simple and unambigous, to help both people and tools that generate
Erlang programs.</p>

<h2>Why are parentheses required around non-trivial size expressions?</h2>

<p>For the same reason that they are required when constructing binaries,
namely that language grammar would be ambiguous without the
parentheses, since binary patterns use the characters <code>:</code>, <code>/</code>, and
<code>-</code> with a different meaning than in the rest of the language.</p>

<h1>Backwards Compatibility</h1>

<p>Using the extended expressions segment size and map keys would cause a
compilation error in OTP 22 and previous releases.  Therefore, no
existing source code can be affected.</p>

<p>However, there are changes to the semantics of Core Erlang that may
make it necessary to update languages compilers or tools that generate
Core Erlang code.</p>

<p>There are two major changes:</p>

<ul>
<li><p>A binary pattern in Core Erlang is no longer allowed to bind and use
a variable in the same binary pattern.</p></li>
<li><p>To fully support binary matching in receives, receives must be lowered
to more primitive operations.</p></li>
</ul>

<h2>Binary matching in Core Erlang</h2>

<p>In Erlang, a variable can be bound in a binary pattern and used later
in the same pattern as the size of a segment:</p>

<pre><code>foo(&lt;&lt;Sz:16,X:Sz&gt;&gt;) -&gt; X.
</code></pre>

<p>In OTP 22 and previous releases, the translation to Core Erlang is
straightforward:</p>

<pre><code>'foo'/1 =
    fun (_0) -&gt;
        case _0 of
          &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
             #&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
              X
          &lt;_1&gt; when 'true' -&gt;
              %% Raise function_clause exception.
              .
              .
              .
        end
</code></pre>

<p>While the translation is straightforward, all Core Erlang passes would need
to handle binding and using a variable in the same scope.  That would become
even more complicated if we were to allow expressions as segment sizes.</p>

<p>In OTP 23, all variables used in a segment size expression must be already
bound in the enclosing environment.  The previous example must be rewritten
like this using nested cases:</p>

<pre><code>'foo'/1 =
    fun (_0) -&gt;
          case _0 of
              &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
               #&lt;_2&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                  case _2 of
                     &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                         X
                     &lt;_3&gt; when 'true' -&gt;
                         %% Raise function_clause exception.
                         .
                         .
                         .
                    end
               &lt;_4&gt; when 'true' -&gt;
                    %% Raise function_clause exception.
                    .
                    .
                    .
              end
</code></pre>

<p>However, as can be seen from the example, the code for raising the <code>function_clause</code>
exception has been duplicated.  The code duplication is no big deal in this simple
example, but it would be in a function where the binary matching clause was followed
by many other clauses.  To avoid the code duplication, we must use <code>letrec</code> with
the <code>letrec_goto</code> annotation:</p>

<pre><code>'foo'/1 =
    fun (_0) -&gt;
        ( letrec
              'label^0'/0 =
                  fun () -&gt;
                        case _0 of
                          &lt;_1&gt; when 'true' -&gt;
                                %% Raise function_clause exception.
                                .
                                .
                                .
                        end
          in  case _0 of
                &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
                   #&lt;_2&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                    case _2 of
                      &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                          X
                      &lt;_3&gt; when 'true' -&gt;
                            apply 'label^0'/0()
                    end
                &lt;_4&gt; when 'true' -&gt;
                      apply 'label^0'/0()
              end
          -| ['letrec_goto'] )
</code></pre>

<p>When a <code>letrec</code> has been given the annotation <code>letrec_goto</code>, it will be
specially translated.  The <code>apply</code> operations will be translated to a goto
instead of a call to a local function.</p>

<h2>Translating receive to Core Erlang</h2>

<p>Consider this example:</p>

<pre><code>bar(Timeout) -&gt;
    receive
        {tag,Msg} -&gt; Msg
    after
        Timeout -&gt;
            no_message
    end.
</code></pre>

<p>In a OTP 22 and earlier, the translation to Core Erlang was straightforward:</p>

<pre><code>'bar'/1 =
    fun (Timeout) -&gt;
        receive
          &lt;{'tag',Msg}&gt; when 'true' -&gt;
              Msg
        after Timeout -&gt;
          'no_message'
</code></pre>

<p>In order to fully support binary matching in OTP 23, a <code>receive</code> in Erlang
has now been lowered to more primitive operations in Core Erlang:</p>

<pre><code>'foo'/1 =
    fun (Timeout) -&gt;
        ( letrec
              'recv$^0'/0 =
                  fun () -&gt;
                      let &lt;PeekSucceeded,Message&gt; =
                          primop 'recv_peek_message'()
                      in  case PeekSucceeded of
                            &lt;'true'&gt; when 'true' -&gt;
                                case Message of
                                  &lt;{'tag',Msg}&gt; when 'true' -&gt;
                                      do  primop 'remove_message'()
                                          Msg
                                  &lt;Other&gt; when 'true' -&gt;
                                      do  primop 'recv_next'()
                                            apply 'recv$^0'/0()
                                end
                            &lt;'false'&gt; when 'true' -&gt;
                                let &lt;TimedOut&gt; =
                                    primop 'recv_wait_timeout'(Timeout)
                                in  case TimedOut of
                                      &lt;'true'&gt; when 'true' -&gt;
                                          do  primop 'timeout'()
                                              'no_message'
                                      &lt;'false'&gt; when 'true' -&gt;
                                          apply 'recv$^0'/0()
                                    end
                          end
          in  apply 'recv$^0'/0()
          -| ['letrec_goto'] )
</code></pre>

<p>When compiling from Core Erlang code in OTP 23, the compiler will
accept Core Erlang code that uses the <code>receive</code> construct and
automatically lower it to the more primitive operations.  That is,
for the example above, the Core Erlang translation from OTP 22 will
be accepted as input to the compiler in OTP 23.</p>

<p>Here is another example where the Core Erlang code from OTP 22
will not be accepted.  Here is the Erlang code:</p>

<pre><code>foobar() -&gt;
    receive
        &lt;&lt;Sz:16,X:Sz&gt;&gt; -&gt; X
    end.
</code></pre>

<p>In OTP 22, this would be translated to Core Erlang code like this:</p>

<pre><code>'foobar'/0 =
    fun () -&gt;
        receive
          &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
             #&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
              X
        after 'infinity' -&gt;
          'true'
</code></pre>

<p>That translation will not be accepted by the compiler in OTP 23.  The <code>receive</code>
must be lowered to more primitive operations, and the binary matching must be
rewritten using nested cases:</p>

<pre><code>'foobar'/0 =
    fun () -&gt;
        ( letrec
              'recv$^0'/0 =
                  fun () -&gt;
                      let &lt;_5,_0&gt; =
                          primop 'recv_peek_message'()
                      in  case _5 of
                            &lt;'true'&gt; when 'true' -&gt;
                                ( letrec
                                      'label^0'/0 =
                                          fun () -&gt;
                                                do  primop 'recv_next'()
                                                    apply 'recv$^0'/0()
                                  in  case _0 of
                                        &lt;#{#&lt;Sz&gt;(16,1,'integer',['unsigned'|['big']]),
                                           #&lt;_1&gt;('all',1,'binary',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                                            case _1 of
                                              &lt;#{#&lt;X&gt;(Sz,1,'integer',['unsigned'|['big']])}#&gt; when 'true' -&gt;
                                                  do  primop 'remove_message'()
                                                      X
                                              &lt;_2&gt; when 'true' -&gt;
                                                    apply 'label^0'/0()
                                            end
                                        &lt;_3&gt; when 'true' -&gt;
                                              apply 'label^0'/0()
                                      end
                                  -| ['letrec_goto'] )
                            &lt;'false'&gt; when 'true' -&gt;
                                  let &lt;_4&gt; =
                                      primop 'recv_wait_timeout'
                                          ('infinity')
                                  in  case _4 of
                                        &lt;'true'&gt; when 'true' -&gt;
                                            do  primop 'timeout'()
                                                'true'
                                        &lt;'false'&gt; when 'true' -&gt;
                                            apply 'recv$^0'/0()
                                      end
                          end
          in apply 'recv$^0'/0() )
          -| ['letrec_goto']
</code></pre>

<h1>Implementation</h1>

<p>The implementation can be found in <a href="https://github.com/erlang/otp/pull/2521" title="#2521: Allow key and size expressions in map and binary matching">PR #2521</a>.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0052","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Björn Gustavsson \u0026lt;bjorn(at)erlang(dot)org\u0026gt;\nStatus: Accepted/23.0 Proposal is to be implemented in OTP release 23.0\nType: Standards Track\nCreated: 28-Jan-2020\nErlang-Version: 23\nPost-History: 28-Jan-2020\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 52: \u003ca href=\"eep-0052.md\" title=\"EEP Source\"\u003e Allow key and size expressions in map and binary matching\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes an extension to matching of binaries to allow the\nsize of a segment to be a guard expression and to the matching of maps\nto allow the key to be a guard expression.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eWe propose that in binary matching the size of a binary segment can be\na guard expression.  Here is an example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexample1(\u0026lt;\u0026lt;Size:8,Payload:((Size-1)*8)/binary,Rest/binary\u0026gt;\u0026gt;) -\u0026gt;\n   {Payload,Rest}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same expressions as in guards are allowed, except that the\nold-style type tests (such a \u003ccode\u003elist/1\u003c/code\u003e or \u003ccode\u003etuple/1\u003c/code\u003e) are not\nallowed.  Unless the expression consists of a single number or single\nvariable is must be enclosed in parentheses.  Any variables used in the\nexpression must have been previously bound, or become bound in the\nsame binary pattern as the expression.  That is, the following example\nis illegal:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eillegal_example2(N, \u0026lt;\u0026lt;X:N,T/binary\u0026gt;\u0026gt;) -\u0026gt;\n    {X,T}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA binary pattern will fail to match, if size expression in any of its\nsegments does not evaluate successfully or evaluates to a non-integer\nvalue.  For example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexample3(\u0026lt;\u0026lt;X:(1/0)\u0026gt;\u0026gt;) -\u0026gt; X;\nexample3(\u0026lt;\u0026lt;X:not_integer\u0026gt;\u0026gt;) -\u0026gt; X;\nexample3(_) -\u0026gt; no_match.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe first clause will not match because the evaluation of \u003ccode\u003e1/0\u003c/code\u003e fails.\nThe second clause will not match because the size evaluates to an atom.\u003c/p\u003e\n\n\u003cp\u003eIn the current map matching syntax, the keys in a map pattern must be\na single value or a literal.  That leads to unnatural code if the keys\nin a map are complex terms.  For example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexample4(M, X) -\u0026gt;\n    Key = {tag,X},\n    #{Key := Value} = M,\n    Value.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe propose that the key in a map pattern can be a guard expression.\nThat will allow the previous example to be written like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexample5(M, X) -\u0026gt;\n    #{{tag,X} := Value} = M,\n    Value.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAll variables used in a key expression must be previously bound.\nThus, the following example is illegal:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eillegal_example6(Key, #{Key := Value}) -\u0026gt; Value.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThe current limitations of map keys are surprising.  A literal tuple\nsuch as \u003ccode\u003e{a,b}\u003c/code\u003e is allowed as a key, while a tuple with a variable\nsuch as \u003ccode\u003e{a,Var}\u003c/code\u003e is not.\u003c/p\u003e\n\n\u003cp\u003eIn binary matching, it has always been possible to multiply a matched\nout number by  a small constant using the \u003ccode\u003eunit:\u003c/code\u003e modifier.  The proposed\nextension makes is possible in more circumstances to match both header\nand payload in the same binary pattern.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003ch2\u003eWhy allow guard expressions?\u003c/h2\u003e\n\n\u003cp\u003eWe did consider only allowing term construction and expressions using\narithmetic operators.  There are two reasons we went with guard\nexpression instead:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eIt is easy to explain and understand exactly what expression are\nallowed as segment sizes and as map keys, because the same type of\nexpressions are allowed in guards.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eWhen calculating the size of binary segment, a subset of guard BIFs\ncould conceivable be useful in practice.  For example: \u003ccode\u003eceiling/1\u003c/code\u003e,\n\u003ccode\u003eround/1\u003c/code\u003e, \u003ccode\u003ebyte_size/1\u003c/code\u003e, \u003ccode\u003ebit_size/1\u003c/code\u003e, and \u003ccode\u003emap_get/2\u003c/code\u003e.  We did not\nwant an arbitrary list of allowed BIFs in size expressions, so the\nonly logical thing is to allow full guard expressions.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eWhy are not absurd size expressions compilation errors?\u003c/h2\u003e\n\n\u003cp\u003eSize expressions that obviously never evaluates to an integer will\nnot cause a compilation error (but may cause a warning).  For example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexample6(Bin, V) -\u0026gt;\n    \u0026lt;\u0026lt;X:(is_list(V))\u0026gt;\u0026gt; = Bin,\n    X.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe reason is that rules for what is a legal Erlang program should be\nsimple and unambigous, to help both people and tools that generate\nErlang programs.\u003c/p\u003e\n\n\u003ch2\u003eWhy are parentheses required around non-trivial size expressions?\u003c/h2\u003e\n\n\u003cp\u003eFor the same reason that they are required when constructing binaries,\nnamely that language grammar would be ambiguous without the\nparentheses, since binary patterns use the characters \u003ccode\u003e:\u003c/code\u003e, \u003ccode\u003e/\u003c/code\u003e, and\n\u003ccode\u003e-\u003c/code\u003e with a different meaning than in the rest of the language.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eUsing the extended expressions segment size and map keys would cause a\ncompilation error in OTP 22 and previous releases.  Therefore, no\nexisting source code can be affected.\u003c/p\u003e\n\n\u003cp\u003eHowever, there are changes to the semantics of Core Erlang that may\nmake it necessary to update languages compilers or tools that generate\nCore Erlang code.\u003c/p\u003e\n\n\u003cp\u003eThere are two major changes:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eA binary pattern in Core Erlang is no longer allowed to bind and use\na variable in the same binary pattern.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eTo fully support binary matching in receives, receives must be lowered\nto more primitive operations.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2\u003eBinary matching in Core Erlang\u003c/h2\u003e\n\n\u003cp\u003eIn Erlang, a variable can be bound in a binary pattern and used later\nin the same pattern as the size of a segment:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efoo(\u0026lt;\u0026lt;Sz:16,X:Sz\u0026gt;\u0026gt;) -\u0026gt; X.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn OTP 22 and previous releases, the translation to Core Erlang is\nstraightforward:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'foo'/1 =\n    fun (_0) -\u0026gt;\n        case _0 of\n          \u0026lt;#{#\u0026lt;Sz\u0026gt;(16,1,'integer',['unsigned'|['big']]),\n             #\u0026lt;X\u0026gt;(Sz,1,'integer',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n              X\n          \u0026lt;_1\u0026gt; when 'true' -\u0026gt;\n              %% Raise function_clause exception.\n              .\n              .\n              .\n        end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhile the translation is straightforward, all Core Erlang passes would need\nto handle binding and using a variable in the same scope.  That would become\neven more complicated if we were to allow expressions as segment sizes.\u003c/p\u003e\n\n\u003cp\u003eIn OTP 23, all variables used in a segment size expression must be already\nbound in the enclosing environment.  The previous example must be rewritten\nlike this using nested cases:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'foo'/1 =\n    fun (_0) -\u0026gt;\n          case _0 of\n              \u0026lt;#{#\u0026lt;Sz\u0026gt;(16,1,'integer',['unsigned'|['big']]),\n               #\u0026lt;_2\u0026gt;('all',1,'binary',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n                  case _2 of\n                     \u0026lt;#{#\u0026lt;X\u0026gt;(Sz,1,'integer',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n                         X\n                     \u0026lt;_3\u0026gt; when 'true' -\u0026gt;\n                         %% Raise function_clause exception.\n                         .\n                         .\n                         .\n                    end\n               \u0026lt;_4\u0026gt; when 'true' -\u0026gt;\n                    %% Raise function_clause exception.\n                    .\n                    .\n                    .\n              end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eHowever, as can be seen from the example, the code for raising the \u003ccode\u003efunction_clause\u003c/code\u003e\nexception has been duplicated.  The code duplication is no big deal in this simple\nexample, but it would be in a function where the binary matching clause was followed\nby many other clauses.  To avoid the code duplication, we must use \u003ccode\u003eletrec\u003c/code\u003e with\nthe \u003ccode\u003eletrec_goto\u003c/code\u003e annotation:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'foo'/1 =\n    fun (_0) -\u0026gt;\n        ( letrec\n              'label^0'/0 =\n                  fun () -\u0026gt;\n                        case _0 of\n                          \u0026lt;_1\u0026gt; when 'true' -\u0026gt;\n                                %% Raise function_clause exception.\n                                .\n                                .\n                                .\n                        end\n          in  case _0 of\n                \u0026lt;#{#\u0026lt;Sz\u0026gt;(16,1,'integer',['unsigned'|['big']]),\n                   #\u0026lt;_2\u0026gt;('all',1,'binary',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n                    case _2 of\n                      \u0026lt;#{#\u0026lt;X\u0026gt;(Sz,1,'integer',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n                          X\n                      \u0026lt;_3\u0026gt; when 'true' -\u0026gt;\n                            apply 'label^0'/0()\n                    end\n                \u0026lt;_4\u0026gt; when 'true' -\u0026gt;\n                      apply 'label^0'/0()\n              end\n          -| ['letrec_goto'] )\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen a \u003ccode\u003eletrec\u003c/code\u003e has been given the annotation \u003ccode\u003eletrec_goto\u003c/code\u003e, it will be\nspecially translated.  The \u003ccode\u003eapply\u003c/code\u003e operations will be translated to a goto\ninstead of a call to a local function.\u003c/p\u003e\n\n\u003ch2\u003eTranslating receive to Core Erlang\u003c/h2\u003e\n\n\u003cp\u003eConsider this example:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ebar(Timeout) -\u0026gt;\n    receive\n        {tag,Msg} -\u0026gt; Msg\n    after\n        Timeout -\u0026gt;\n            no_message\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn a OTP 22 and earlier, the translation to Core Erlang was straightforward:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'bar'/1 =\n    fun (Timeout) -\u0026gt;\n        receive\n          \u0026lt;{'tag',Msg}\u0026gt; when 'true' -\u0026gt;\n              Msg\n        after Timeout -\u0026gt;\n          'no_message'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn order to fully support binary matching in OTP 23, a \u003ccode\u003ereceive\u003c/code\u003e in Erlang\nhas now been lowered to more primitive operations in Core Erlang:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'foo'/1 =\n    fun (Timeout) -\u0026gt;\n        ( letrec\n              'recv$^0'/0 =\n                  fun () -\u0026gt;\n                      let \u0026lt;PeekSucceeded,Message\u0026gt; =\n                          primop 'recv_peek_message'()\n                      in  case PeekSucceeded of\n                            \u0026lt;'true'\u0026gt; when 'true' -\u0026gt;\n                                case Message of\n                                  \u0026lt;{'tag',Msg}\u0026gt; when 'true' -\u0026gt;\n                                      do  primop 'remove_message'()\n                                          Msg\n                                  \u0026lt;Other\u0026gt; when 'true' -\u0026gt;\n                                      do  primop 'recv_next'()\n                                            apply 'recv$^0'/0()\n                                end\n                            \u0026lt;'false'\u0026gt; when 'true' -\u0026gt;\n                                let \u0026lt;TimedOut\u0026gt; =\n                                    primop 'recv_wait_timeout'(Timeout)\n                                in  case TimedOut of\n                                      \u0026lt;'true'\u0026gt; when 'true' -\u0026gt;\n                                          do  primop 'timeout'()\n                                              'no_message'\n                                      \u0026lt;'false'\u0026gt; when 'true' -\u0026gt;\n                                          apply 'recv$^0'/0()\n                                    end\n                          end\n          in  apply 'recv$^0'/0()\n          -| ['letrec_goto'] )\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen compiling from Core Erlang code in OTP 23, the compiler will\naccept Core Erlang code that uses the \u003ccode\u003ereceive\u003c/code\u003e construct and\nautomatically lower it to the more primitive operations.  That is,\nfor the example above, the Core Erlang translation from OTP 22 will\nbe accepted as input to the compiler in OTP 23.\u003c/p\u003e\n\n\u003cp\u003eHere is another example where the Core Erlang code from OTP 22\nwill not be accepted.  Here is the Erlang code:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efoobar() -\u0026gt;\n    receive\n        \u0026lt;\u0026lt;Sz:16,X:Sz\u0026gt;\u0026gt; -\u0026gt; X\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn OTP 22, this would be translated to Core Erlang code like this:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'foobar'/0 =\n    fun () -\u0026gt;\n        receive\n          \u0026lt;#{#\u0026lt;Sz\u0026gt;(16,1,'integer',['unsigned'|['big']]),\n             #\u0026lt;X\u0026gt;(Sz,1,'integer',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n              X\n        after 'infinity' -\u0026gt;\n          'true'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat translation will not be accepted by the compiler in OTP 23.  The \u003ccode\u003ereceive\u003c/code\u003e\nmust be lowered to more primitive operations, and the binary matching must be\nrewritten using nested cases:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'foobar'/0 =\n    fun () -\u0026gt;\n        ( letrec\n              'recv$^0'/0 =\n                  fun () -\u0026gt;\n                      let \u0026lt;_5,_0\u0026gt; =\n                          primop 'recv_peek_message'()\n                      in  case _5 of\n                            \u0026lt;'true'\u0026gt; when 'true' -\u0026gt;\n                                ( letrec\n                                      'label^0'/0 =\n                                          fun () -\u0026gt;\n                                                do  primop 'recv_next'()\n                                                    apply 'recv$^0'/0()\n                                  in  case _0 of\n                                        \u0026lt;#{#\u0026lt;Sz\u0026gt;(16,1,'integer',['unsigned'|['big']]),\n                                           #\u0026lt;_1\u0026gt;('all',1,'binary',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n                                            case _1 of\n                                              \u0026lt;#{#\u0026lt;X\u0026gt;(Sz,1,'integer',['unsigned'|['big']])}#\u0026gt; when 'true' -\u0026gt;\n                                                  do  primop 'remove_message'()\n                                                      X\n                                              \u0026lt;_2\u0026gt; when 'true' -\u0026gt;\n                                                    apply 'label^0'/0()\n                                            end\n                                        \u0026lt;_3\u0026gt; when 'true' -\u0026gt;\n                                              apply 'label^0'/0()\n                                      end\n                                  -| ['letrec_goto'] )\n                            \u0026lt;'false'\u0026gt; when 'true' -\u0026gt;\n                                  let \u0026lt;_4\u0026gt; =\n                                      primop 'recv_wait_timeout'\n                                          ('infinity')\n                                  in  case _4 of\n                                        \u0026lt;'true'\u0026gt; when 'true' -\u0026gt;\n                                            do  primop 'timeout'()\n                                                'true'\n                                        \u0026lt;'false'\u0026gt; when 'true' -\u0026gt;\n                                            apply 'recv$^0'/0()\n                                      end\n                          end\n          in apply 'recv$^0'/0() )\n          -| ['letrec_goto']\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eImplementation\u003c/h1\u003e\n\n\u003cp\u003eThe implementation can be found in \u003ca href=\"https://github.com/erlang/otp/pull/2521\" title=\"#2521: Allow key and size expressions in map and binary matching\"\u003ePR #2521\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0052"},"buildId":"aoeL97fiGQMaunPBLLCoJ","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_buildManifest.js" async=""></script><script src="/_next/static/aoeL97fiGQMaunPBLLCoJ/_ssgManifest.js" async=""></script></body></html>