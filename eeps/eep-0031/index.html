<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author:         Patrik Nyblom &lt;pan(at)erlang(dot)org&gt;,
            Fredrik Svahn &lt;Fredrik(dot)Svahn(at)gmail&gt;
Status:         Final/R14A Proposal is implemented in OTP release R14A
Type:           Standards Track
Created:        28-Nov-2009
Erlang-Version: R13B03
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 31: <a href="eep-0031.md" title="EEP Source"> Binary manipulation and searching module</a></h2>

<h1>Abstract</h1>

<p>This EEP contains developed suggestions regarding the module <code>binary</code>
first suggested in <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>. </p>

<p><a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> suggests several modules and is partially superseded by later
EEP's (i.e. <a href="/eeps/eep-0011" title="EEP 11, intresting extensions to EEP 9">EEP 11</a>), while still containing valuable suggestions not
yet implemented. The remaining modules from <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a> will therefore
appear in separate EEP's. This construction is made in agreement with
the original author of <a href="/eeps/eep-0009" title="EEP 9, the original work from which this EEP is derived">EEP 9</a>.</p>

<p>The module <code>binary</code> is suggested to contain fast searching
algorithms together with some common operations on binaries already
present for lists (in the lists module).</p>

<h1>Motivation</h1>

<p>While efficient searching is already present in the <code>re</code> library,
dedicated search functions can further speed up searching in
binaries, given an efficient implementation (i.e. Boyer-More
and Aho-Corassick algorithm). Another important advantage of
separate searching algorithms are ease of use to the programmer,
as the suggested interfaces do not require knowledge about regular
expression syntax and special characters in the binaries need not
be escaped. It's interesting to note how often regular expressions
are used for simple sub-string searching or replacement, which can
with this suggested module be done easily.</p>

<p>Decomposition of binaries are usually done by using bit-syntax.
However some common operations are useful to have as ordinary functions,
both for performance and to support a more traditiona functional
programming style.</p>

<p>Some operations for converting lists to binaries and v.v. are today in
the erlang module. BIFs concerning binaries now present have varied
view of zero vs. one-based positioning in binaries. I.e.
<code>binary_to_list/3</code> uses one-based while <code>split_binary/2</code> uses
zero-based. As the convention is to use zero-based, new functions for
converting binaries to lists and v.v. are needed.</p>

<p>Binaries are in fact a shared data-type, with small binaries often
referencing parts of larger binaries in a way not controllable by
the programmer in a simple way. The bitstring data-type further
complicate things to the programmer in a way hard to easily
manage. I therefore also suggest some low level functions to
inspect binary representation and to clone binaries to ensure a
minimal representation.</p>

<p>As matching is not allowed in guard expressions, I furthermore suggest
that a function for extracting parts of binaries is added to the set
of guard BIFs. This would be consistent with the function element/2
being allowed in guards.</p>

<h1>Rationale</h1>

<p>For the lists data type there is a help library providing functions for
common operations such as searching and splitting lists.  This EEP suggests
that a similar set of library functions should be created for binaries.
Many of the proposed functions are based on answers to questions regarding
binaries on the erlang-questions mailing list, e.g. "how do I convert a
number to a binary?". This EEP therefore suggests the addition of one
module in stdlib, namely a module <code>binary</code> which will implement the
requested functionality in an efficient way. Most of this module will
need to be implemented in native code (residing in the virtual
machine) why the proposed implementation will be delivered as "beta"
functionality in a forthcoming Erlang release.</p>

<p>The functionality suggested is the following:</p>

<ul>
<li><p>Functionality for searching, splitting and replacing in
binaries. The functionality in some ways will overlap that of the
regular expression library already present in Erlang, but will be
even more efficient and will have a simpler interface. </p></li>
<li><p>Common operations on binaries that have their counterparts for lists
already in the stdlib module <code>lists</code>. While not all interfaces in
the <code>lists</code> module are applicable to binaries, many are. This module
also provides a good place for future operations on binaries,
operations that are not applicable to lists or that we still don't
know the need for.</p></li>
<li><p>Functions for converting lists to binaries and v.v. These functions
should have a consistent view of zero-based indexing in binaries.</p></li>
<li><p>Operations on binaries concerning their internal
representation. This functionality is sometimes necessary to avoid
extensive use of memory due to the shared nature of the binaries. As
operations on binaries do not involve copying when binaries are
taken apart, programs can unknowingly (or at least unintentionally)
keep references to large binaries by holding seemingly small amounts
of data in the process. The O(1) nature of many operations on
binaries makes the data sharing necessary, but the effects can
sometimes be surprising. On the other hand, O(n) complexity and
instant memory explosions when splitting a binary would be even more
surprising, why the current behavior need to be retained. It is suggested
that functions for both inspecting the nature of sharing of a binary
and to clone a copy of a binary to avoid sharing effects is present
in this suggested module.</p></li>
</ul>

<p>All functionality is to be applied to byte oriented binaries, never
bitstrings that do not have a bitlength that is a multiple of
eight. All binaries supplied to and returned by these functions should
pass the <code>is_binary/1</code> test, otherwise an error will be raised.</p>

<h2>Suggested module reference</h2>

<p>I suggest the following functionality (presented as an excerpt of an Erlang
manual pages). A discussion about the interface can be found below.</p>

<h3>DATA TYPES</h3>

<pre><code>cp()
</code></pre>

<p>Opaque data-type representing a compiled search-pattern.
guaranteed to be a tuple() to allow programs to distinguish it from
non precompiled search patterns.</p>

<pre><code>part() = {Pos,Length}

Start = int()
Length = int()
</code></pre>

<p>A representaion of a part (or range) in a binary. <code>Start</code> is a
zero-based offset into a binary() and Length is the length of that
part. As input to functions in this module, a reverse part
specification is allowed, constructed with a negative <code>Length</code>, so
that the part of the binary begins at <code>Start</code> + <code>Length</code> and is
-<code>Length</code> long. This is useful for referencing the last N bytes
of a binary as <code>{size(Binary), -N}</code>. The functions in this module
always return part()'s with positive <code>Length</code>.</p>

<h3>EXPORTS</h3>

<h4><code>compile_pattern(Pattern) -&gt; cp()</code></h4>

<p>Types:</p>

<pre><code>Pattern = binary() | [ binary() ]
</code></pre>

<p>Builds an internal structure representing a compilation of a
search-pattern, later to be used in the find, split or replace
functions. The cp() returned is guaranteed to be a tuple() to allow
programs to distinguish it from non precompiled search patterns</p>

<p>When a list of binaries is given, it denotes a <em>set</em> of alternative
binaries to search for. I.e if <code>[&lt;&lt;"functional"&gt;&gt;, &lt;&lt;"programming"&gt;&gt;]</code> 
is given as <code>Pattern</code>, this means ''either <code>&lt;&lt;"functional"&gt;&gt;</code> <em>or</em>
<code>&lt;&lt;"programming"&gt;&gt;</code>''. The pattern is a <em>set</em> of alternatives; when
only a single binary is given, the set has only one element. </p>

<p>If pattern is not a binary or a flat proper list of binaries, a <code>badarg</code>
exception will be raised.</p>

<h4><code>match(Subject, Pattern) -&gt; Found | no</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = part()
</code></pre>

<p>The same as <code>match(Subject, Pattern, [])</code>.</p>

<h4><code>match(Subject,Pattern,Options) -&gt; Found | no</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = part()
Options = [ Option ]
Option = {scope, part()}
</code></pre>

<p>Searches for the first occurrence of <code>Pattern</code> in <code>Subject</code> and returns
the position and length.</p>

<p>The function will return
<code>{Pos,Length}</code> for the binary in <code>Pattern</code> starting at
the lowest position in <code>Subject</code>.</p>

<p>Example::</p>

<pre><code>1&gt; binary:find(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"cd"&gt;&gt;],[]).
{1,4}
</code></pre>

<p>Even though <code>&lt;&lt;"cd"&gt;&gt;</code> ends before <code>&lt;&lt;"bcde"&gt;&gt;</code>, <code>&lt;&lt;"bcde"&gt;&gt;</code>
begins first and is therefore the first match. If two overlapping
matches begins at the same position, the longest is returned.</p>

<p>Summary of the options:</p>

<ul>
<li><p><code>{scope, {Start, Length}}</code> <br />
Only the given part is searched. Return values still have offsets
from the beginning of <code>Subject</code>. A negative <code>Length</code> is
allowed as described in the <strong>TYPES</strong> section of this manual.</p>

<p>The found part() is returned, if none of the strings in <code>Pattern</code> is
found, the atom <code>no</code> is returned.</p>

<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>

<p>If <code>{scope, {Start,Length}}</code> is given in the options such that
<code>Start</code> is larger than the size of <code>Subject</code>, <code>Start</code> +
<code>Length</code> is less than zero or <code>Start</code> + <code>Length</code> is larger than
the size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p></li>
</ul>

<h4><code>matches(Subject, Pattern) -&gt; Found</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = [ part() ] | []
</code></pre>

<p>The same as <code>matches(Subject, Pattern, [])</code>.</p>

<h4><code>matches(Subject,Pattern,Options) -&gt; Found</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Found = [ part() ] | []
Options = [ Option ]
Option = {scope, part()}
</code></pre>

<p>Works like match, but the <code>Subject</code> is search until exhausted and
a list of all non-overlapping parts present in Pattern are returned (in order).</p>

<p>The first and <em>longest</em> match is preferred
to a shorter, which is illustrated by the following example::</p>

<pre><code>1&gt; binary:matches(&lt;&lt;"abcde"&gt;&gt;, [&lt;&lt;"bcde"&gt;&gt;,&lt;&lt;"bc"&gt;&gt;&gt;,&lt;&lt;"de"&gt;&gt;],[]).
[{1,4}]
</code></pre>

<p>The result shows that <code>&lt;&lt;"bcde"&gt;&gt;&gt;</code> is selected instead of the
shorter match <code>&lt;&lt;"bc"&gt;&gt;</code> (which would have given raise to one more
match,<code>&lt;&lt;"de"&gt;&gt;</code>). This corresponds to the behavior of
posix regular expressions (and programs like <code>awk</code>), but is not
consistent with alternative matches in <code>re</code> (and Perl), where
instead lexical ordering in the search pattern selects which string
matches.</p>

<p>If none of the strings in pattern is found, an empty list is returned.</p>

<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code> and for a
desctioption of available options, see <code>match/3</code>.</p>

<p>If <code>{scope, {Start,Length}}</code> is given in the options such that
<code>Start</code> is larger than the size of <code>Subject</code>, <code>Start</code> +
<code>Length</code> is less than zero or <code>Start</code> + <code>Length</code> is larger than
the size of <code>Subject</code>, a <code>badarg</code> exception is raised.</p>

<h4><code>split(Subject,Pattern) -&gt; Parts</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Parts = [ binary() ]
</code></pre>

<p>The same as <code>split(Subject, Pattern, [])</code>.</p>

<h4><code>split(Subject,Pattern,Options) -&gt; Parts</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Parts = [ binary() ]
Options = [ Option ]
Option = {scope, part()} | trim | global
</code></pre>

<p>Splits Binary into a list of binaries based on <code>Pattern</code>. If the
option <code>global</code> is not given, only the first occurrence of
<code>Pattern</code> in <code>Subject</code> will give rise to a split. </p>

<p>The parts of <code>Pattern</code> actually found in <code>Subject</code> are not included
in the result.</p>

<p>Example::</p>

<pre><code>1&gt; binary:split(&lt;&lt;1,255,4,0,0,0,2,3&gt;&gt;, [&lt;&lt;0,0,0&gt;&gt;,&lt;&lt;2&gt;&gt;],[]).
[&lt;&lt;1,255,4&gt;&gt;, &lt;&lt;2,3&gt;&gt;] 
2&gt; binary:split(&lt;&lt;0,1,0,0,4,255,255,9&gt;&gt;, [&lt;&lt;0,0&gt;&gt;, &lt;&lt;255,255&gt;&gt;],[global]).
[&lt;&lt;0,1&gt;&gt;,&lt;&lt;4&gt;&gt;,&lt;&lt;9&gt;&gt;]
</code></pre>

<p>Summary of options:</p>

<ul>
<li><p><code>{scope, part()}</code> <br />
Works as in <code>binary:match/3</code> and <code>binary:matches/3</code>. Note
that this only defines the scope of the search for matching
strings, it does not cut the binary before splitting. The
bytes before and after the scope will be kept in the result.
See example below.</p></li>
<li><p><code>trim</code> <br />
Removes trailing empty parts of the result (as does <code>trim</code>
in <code>re:split/3</code>)</p></li>
<li><p><code>global</code> <br />
Repeats the split until the <code>Subject</code> is
exhausted. Conceptually the <code>global</code> option makes <code>split</code>
work on the positions returned by <code>binary:matches/3</code>, while
it normally works on the position returned by
<code>binary:match/3</code>.</p></li>
</ul>

<p>Example of the difference between a <code>scope</code> and taking the binary apart 
before splitting::</p>

<pre><code>1&gt; binary:split(&lt;&lt;"banana"&gt;&gt;,[&lt;&lt;"a"&gt;&gt;],[{scope,{2,3}}]).
[&lt;&lt;"ban"&gt;&gt;,&lt;&lt;"na"&gt;&gt;]
2&gt; binary:split(binary:part(&lt;&lt;"banana"&gt;&gt;,{2,3}),[&lt;&lt;"a"&gt;&gt;],[]).
[&lt;&lt;"n"&gt;&gt;,&lt;&lt;"n"&gt;&gt;]
</code></pre>

<p>The return type is always a list of binaries which are all referencing
<code>Subject</code>. This means that the data in <code>Subject</code> is not actually
copied to new binaries and that <code>Subject</code> cannot be garbage
collected until the results of the split are no longer referenced.</p>

<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>

<h4><code>replace(Subject,Pattern,Replacement) -&gt; Result</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Replacement = binary()
Result = binary()
</code></pre>

<p>The same as <code>replace(Subject,Pattern,Replacement,[])</code>.</p>

<h4><code>replace(Subject,Pattern,Replacement,Options) -&gt; Result</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pattern = binary() | [ binary() ] | cp()
Replacement = binary()
Result = binary()
Options = [ Option ]
Option = global | {scope, part()} | {insert_replaced, InsPos}
InsPos = OnePos | [ OnePos ]
OnePos = int() =&lt; byte_size(Replacement)
</code></pre>

<p>Constructs a new binary by replacing the parts in <code>Subject</code> matching
<code>Pattern</code> with the content of <code>Replacement</code>.</p>

<p>If the matching sub-part of <code>Subject</code> giving raise to the
replacement is to be inserted in the result, the option
<code>{insert_replaced, InsPos}</code> will insert the matching part into
<code>Replacement</code> at the given position (or positions) before actually
inserting <code>Replacement</code> into the Subject. Example::</p>

<pre><code>1&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,&lt;&lt;"b"&gt;&gt;,&lt;&lt;"[]"&gt;&gt;,[{insert_replaced,1}]).
&lt;&lt;"a[b]cde"&gt;&gt;
2&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,
                 [global,{insert_replaced,1}]).
&lt;&lt;"a[b]c[d]e"&gt;&gt;
3&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[]"&gt;&gt;,
                 [global,{insert_replaced,[1,1]}]).
&lt;&lt;"a[bb]c[dd]e"&gt;&gt;
4&gt; binary:replace(&lt;&lt;"abcde"&gt;&gt;,[&lt;&lt;"b"&gt;&gt;,&lt;&lt;"d"&gt;&gt;],&lt;&lt;"[-]"&gt;&gt;,
                 [global,{insert_replaced,[1,2]}]).
&lt;&lt;"a[b-b]c[d-d]e"&gt;&gt;
</code></pre>

<p>If any position given in <code>InsPos</code> is greater than the size of
the replacement binary, a <code>badarg</code> exception is raised.</p>

<p>The options <code>global</code> and <code>{scope, part()}</code> works as for
<code>binary:split/3</code>. The return type is always a binary.</p>

<p>For a descrition of <code>Pattern</code>, see <code>compile_pattern/1</code>.</p>

<h4><code>longest_common_prefix(Binaries) -&gt; int()</code></h4>

<p>Types:</p>

<pre><code>Binaries = [ binary() ]
</code></pre>

<p>Returns the length of the longest common prefix of the binaries in the
list <code>Binaries</code>. Example::</p>

<pre><code>1&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"ergonomy"&gt;&gt;]).
2
2&gt; binary:longest_common_prefix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"perl"&gt;&gt;]).
0
</code></pre>

<p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception
is raised. </p>

<h4><code>longest_common_suffix(Binaries) -&gt; int()</code></h4>

<p>Types:</p>

<pre><code>Binaries = [ binary() ]
</code></pre>

<p>Returns the length of the longest common suffix of the binaries in the
list <code>Binaries</code>. Example::</p>

<pre><code>1&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"fang"&gt;&gt;]).
3
2&gt; binary:longest_common_suffix([&lt;&lt;"erlang"&gt;&gt;,&lt;&lt;"perl"&gt;&gt;]).
0
</code></pre>

<p>If <code>Binaries</code> is not a flat list of binaries, a <code>badarg</code> exception
is raised. </p>

<h4><code>first(Subject) -&gt; int()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
</code></pre>

<p>Returns the first byte of the binary as an integer. If the binary
length is zero, a <code>badarg</code> exception is raised.</p>

<h4><code>last(Subject) -&gt; int()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
</code></pre>

<p>Returns the last byte of the binary as an integer. If the binary
length is zero, a <code>badarg</code> exception is raised.</p>

<h4><code>at(Subject, Pos) -&gt; int()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pos = int() &gt;= 0
</code></pre>

<p>Returns the byte at position <code>Pos</code> (zero-based) in the binary
<code>Subject</code> as an integer. If <code>Pos</code> >= <code>byte_size(Subject)</code>, a
<code>badarg</code> exception is raised.</p>

<h4><code>part(Subject, PosLen) -&gt; binary()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
PosLen = part()
</code></pre>

<p>Extracts the part of the binary described by <code>PosLen</code>. </p>

<p>Negative length can be used to extract bytes at the end of a binary::</p>

<pre><code>1&gt; Bin = &lt;&lt;1,2,3,4,5,6,7,8,9,10&gt;&gt;.
2&gt; binary:part(Bin,{byte_size(Bin), -5)).
&lt;&lt;6,7,8,9,10&gt;&gt;
</code></pre>

<p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code>
exception is raised.</p>

<h4><code>part(Subject, Pos, Len) -&gt; binary()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Pos = int()
Len = int()
</code></pre>

<p>The same as <code>part(Subject, {Pos, Len})</code>.</p>

<h4><code>bin_to_list(Subject) -&gt; list()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
</code></pre>

<p>The same as <code>bin_to_list(Subject,{0,byte_size(Subject)})</code>.</p>

<h4><code>bin_to_list(Subject, PosLen) -&gt; list()</code></h4>

<pre><code>Subject = binary()
PosLen = part()
</code></pre>

<p>Converts <code>Subject</code> to a list of int(), each int representing the
value of one byte. The <code>part()</code> denotes which part of the
<code>binary()</code> to convert. Example::</p>

<pre><code>1&gt; binary:bin_to_list(&lt;&lt;"erlang"&gt;&gt;,{1,3}).
"rla"
%% or [114,108,97] in list notation.
</code></pre>

<p>If <code>PosLen</code> in any way references outside the binary, a <code>badarg</code>
exception is raised.</p>

<h3><code>bin_to_list(Subject, Pos, Len) -&gt; list()</code></h3>

<p>Types:</p>

<pre><code>Subject = binary()
Pos = int()
Len = int()
</code></pre>

<p>The same as <code>bin_to_list(Subject,{Pos,Len})</code>.</p>

<h4><code>list_to_bin(ByteList) -&gt; binary()</code></h4>

<p>Types:</p>

<pre><code>ByteList = iodata() (see module erlang)
</code></pre>

<p>Works exactly like <code>erlang:list_to_binary/1</code>, added for completeness.</p>

<h4><code>copy(Subject) -&gt; binary()</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
</code></pre>

<p>The same as <code>copy(Subject, 1)</code>.</p>

<h3><code>copy(Subject,N) -&gt; binary()</code></h3>

<p>Types:</p>

<pre><code>Subject = binary()
N = int() &gt;= 0
</code></pre>

<p>Creates a binary with the content of <code>Subject</code> duplicated <code>N</code>
times. </p>

<p>This function will always create a new binary, even if <code>N</code> = 1. By
using <code>copy/1</code> on a binary referencing a larger binary, one might
free up the larger binary for garbage collection.  </p>

<blockquote>
  <p>NOTE! By deliberately copying a single binary to avoid referencing a
larger binary, one might, instead of freeing up the larger binary for
later garbage collection, create much more binary data than
needed. Sharing binary data is usually good. Only in special cases,
when small parts reference large binaries and the large binaries are
no longer used <em>in any process</em>, deliberate copying might be a good idea.</p>
</blockquote>

<p>If <code>N</code> &lt; 0, a <code>badarg</code> exception is raised.</p>

<h4><code>referenced_byte_size(binary()) -&gt; int()</code></h4>

<p>If a binary references a larger binary (often described as being a
sub-binary), it can be useful to get the size of the actual referenced
binary. This function can be used in a program to trigger the
use of <code>copy/1</code>. By copying a binary, one might dereference the
original, possibly large, binary which a smaller binary is a reference
to.</p>

<p>Example::</p>

<pre><code>store(Binary, GBSet) -&gt;
  NewBin = 
      case binary:referenced_byte_size(Binary) of
          Large when Large &gt; 2 * byte_size(Binary) -&gt;
             binary:copy(Binary);
          _ -&gt;
         Binary
      end,
  gb_sets:insert(NewBin,GBSet).
</code></pre>

<p>In this example, we chose to copy the binary content before inserting
it in the <code>gb_set()</code> if it references a binary more than twice the size
of the data we're going to keep. Of course different rules for when
copying will apply to different programs.</p>

<p>Binary sharing will occur whenever binaries are taken apart, this is
the fundamental reason why binaries are fast, decomposition can always
be done with O(1) complexity. In rare circumstances this data sharing
is however undesirable, why this function together with <code>copy/1</code>
might be useful when optimizing for memory use.  </p>

<p>Example of binary sharing::</p>

<pre><code>1&gt; A = binary:copy(&lt;&lt;1&gt;&gt;,100).
&lt;&lt;1,1,1,1,1 ...
2&gt; byte_size(A).
100
3&gt; binary:referenced_byte_size(A)
100
4&gt; &lt;&lt;_:10/binary,B:10/binary,_/binary&gt;&gt; = A.
&lt;&lt;1,1,1,1,1 ...
5&gt; byte_size(B).
10
6&gt; binary:referenced_byte_size(B)
100
</code></pre>

<blockquote>
  <p>NOTE! Binary data is shared among processes. If another process still
references the larger binary, copying the part this process uses only
consumes more memory and will not free up the larger binary for garbage
collection. Use this kind of intrusive functions with extreme care,
and only if a <em>real</em> problem is detected.</p>
</blockquote>

<h4><code>encode_unsigned(Unsigned) -&gt; binary()</code></h4>

<p>Types:</p>

<pre><code>Unsigned = int() &gt;= 0
</code></pre>

<p>The same as <code>encode_unsigned(Unsigned,big)</code>.</p>

<h4><code>encode_unsigned(Unsigned,Endianess) -&gt; binary()</code></h4>

<p>Types:</p>

<pre><code>Unsigned = int() &gt;= 0
Endianess = big | little
</code></pre>

<p>Converts a positive integer to the smallest possible representation
in in a binary digit representation, either big or little endian.</p>

<p>Example:</p>

<pre><code>1&gt; binary:encode_unsigned(11111111,big). 
&lt;&lt;169,138,199&gt;&gt;
</code></pre>

<h4><code>decode_unsigned(Subject) -&gt; Unsigned</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Unsigned = int() &gt;= 0
</code></pre>

<p>The same as <code>encode_unsigned(Subject,big)</code>.</p>

<h4><code>decode_unsigned(Subject, Endianess) -&gt; Unsigned</code></h4>

<p>Types:</p>

<pre><code>Subject = binary()
Endianess = big | little
Unsigned = int() &gt;= 0
</code></pre>

<p>Converts the binary digit representation, in big or little endian, of
a positive integer in <code>Subject</code> to an Erlang int().</p>

<p>Example::</p>

<pre><code>1&gt; binary:decode_unsigned(&lt;&lt;169,138,199&gt;&gt;,big). 
11111111
</code></pre>

<h2>Guard BIF</h2>

<p>I suggest adding the functions <code>binary:part/2</code> and <code>binary:part/3</code>
to the set of BIFs allowed in guard tests. As guard BIFs are traditionally
put in the erlang module, the following names for the guard BIFs are
suggested::</p>

<pre><code>erlang:binary_part/2
erlang:binary_part/3
</code></pre>

<p>They should both work exactly as their counterparts in the binary module.</p>

<h2>Interface design discussion</h2>

<p>As with all modules, there are a lot of arguments about the actual
interface, sometimes more than about the functionality. In this case a
number of parameters has to be considered.</p>

<ul>
<li><p>Effectiveness - The interface should be constructed so that fast
implementation is possible and so that code using the interface can
be written in an effective way. To not create unnecessary garbage is
one parameter, to allow for general code is another. </p></li>
<li><p>Parameter ordering - I've chosen to make the binary subject the
first parameter in all applicable calls. Putting the subject first
corresponds to the <code>re</code> interface. The <code>lists</code> module, however,
usually has the subject as last parameter. We could go for that
instead, but unfortunately the <code>lists:sublist/{2,3}</code> interface,
which corresponds to the <code>part</code> function, has the subject
first, why following the conventions of <code>lists</code> would not only
break conformance with <code>re</code>, it would also give us a generally
non-stringent interface. The effect of not conforming to the
<code>lists</code> interface is that using function names from that module
would lead to confusion and therefore is avoided.</p></li>
<li><p>Function naming - We have two related modules to take into account
when naming functions here. The module <code>re</code> is related to the
searching function (<code>match</code>, <code>replace</code> etc), while the <code>lists</code>
module is related to the decomposition functions (<code>first</code>,
<code>last</code> etc). </p>

<p>I've basically retained the names from <code>re</code> when I find the
functionality, both in concept and interface to be similar
enough. The nature of regular expressions as small executable
programs, which is to much to say for a collection of binaries as
the patterns are in this module, prohibits the use of the function
name <code>run</code> for actually doing the searching. We use <code>match</code> and 
<code>matches</code> instead of <code>run</code>. </p>

<p>As this module is more general than <code>re</code>, a function name like
<code>compile</code> is not really good. <code>re:compile</code> means "compile a
regular expression", but what would <code>binary:compile</code> mean?
Therefore the pre-processing function is instead called
<code>compile_pattern</code>.</p>

<p>When it comes to the <code>lists</code> module, the parameter ordering has
prevented me from reusing any function names but <code>last</code>, which
only takes one parameter in <code>lists</code> and there is no real
alternative there.</p></li>
<li><p>Options or multiple functions - I believe a good rule of thumb is to
not have options that change the return type of the function, which
would have been the case if we i.e. had a <code>global</code> option to
<code>match/3</code> instead of a separate <code>matches/3</code> function.</p>

<p>The fact that there are a manageable set of possible return types
for the searching and decomposition functions allows us to follow
that rule of thumb.</p>

<p>(Unfortunately that rule could not be easilly followed in <code>re</code>, as the
rich assortment of options would have given rise to a non-manageable
amount of function names). </p></li>
</ul>

<h1>Performance</h1>

<p>Although the decomposition functions are not really faster than using
bit-syntax for decomposition, they create slightly less garbage than
the bit syntax. As they are not slower than bit-syntax, they also have
a purpose in allowing for a different programming style.</p>

<p>The match/replace/split functionality should be compared to similar
functionality in the <code>re</code> module. Implementation methods has to be
chosen so that this modules search functions are faster, or possibly
even significantly faster, than <code>re</code>.</p>

<h1>Reference implementation</h1>

<p>A reference implementation was available on GitHub development branch 
before the final inclusion in R14A. </p>

<h1>Copyright</h1>

<p>This document is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons Attribution 3.0 License">Creative Commons license</a>.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0031","content":"\u003cpre\u003e\u003ccode\u003eAuthor:         Patrik Nyblom \u0026lt;pan(at)erlang(dot)org\u0026gt;,\n            Fredrik Svahn \u0026lt;Fredrik(dot)Svahn(at)gmail\u0026gt;\nStatus:         Final/R14A Proposal is implemented in OTP release R14A\nType:           Standards Track\nCreated:        28-Nov-2009\nErlang-Version: R13B03\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 31: \u003ca href=\"eep-0031.md\" title=\"EEP Source\"\u003e Binary manipulation and searching module\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP contains developed suggestions regarding the module \u003ccode\u003ebinary\u003c/code\u003e\nfirst suggested in \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e. \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e suggests several modules and is partially superseded by later\nEEP's (i.e. \u003ca href=\"/eeps/eep-0011\" title=\"EEP 11, intresting extensions to EEP 9\"\u003eEEP 11\u003c/a\u003e), while still containing valuable suggestions not\nyet implemented. The remaining modules from \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e will therefore\nappear in separate EEP's. This construction is made in agreement with\nthe original author of \u003ca href=\"/eeps/eep-0009\" title=\"EEP 9, the original work from which this EEP is derived\"\u003eEEP 9\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThe module \u003ccode\u003ebinary\u003c/code\u003e is suggested to contain fast searching\nalgorithms together with some common operations on binaries already\npresent for lists (in the lists module).\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eWhile efficient searching is already present in the \u003ccode\u003ere\u003c/code\u003e library,\ndedicated search functions can further speed up searching in\nbinaries, given an efficient implementation (i.e. Boyer-More\nand Aho-Corassick algorithm). Another important advantage of\nseparate searching algorithms are ease of use to the programmer,\nas the suggested interfaces do not require knowledge about regular\nexpression syntax and special characters in the binaries need not\nbe escaped. It's interesting to note how often regular expressions\nare used for simple sub-string searching or replacement, which can\nwith this suggested module be done easily.\u003c/p\u003e\n\n\u003cp\u003eDecomposition of binaries are usually done by using bit-syntax.\nHowever some common operations are useful to have as ordinary functions,\nboth for performance and to support a more traditiona functional\nprogramming style.\u003c/p\u003e\n\n\u003cp\u003eSome operations for converting lists to binaries and v.v. are today in\nthe erlang module. BIFs concerning binaries now present have varied\nview of zero vs. one-based positioning in binaries. I.e.\n\u003ccode\u003ebinary_to_list/3\u003c/code\u003e uses one-based while \u003ccode\u003esplit_binary/2\u003c/code\u003e uses\nzero-based. As the convention is to use zero-based, new functions for\nconverting binaries to lists and v.v. are needed.\u003c/p\u003e\n\n\u003cp\u003eBinaries are in fact a shared data-type, with small binaries often\nreferencing parts of larger binaries in a way not controllable by\nthe programmer in a simple way. The bitstring data-type further\ncomplicate things to the programmer in a way hard to easily\nmanage. I therefore also suggest some low level functions to\ninspect binary representation and to clone binaries to ensure a\nminimal representation.\u003c/p\u003e\n\n\u003cp\u003eAs matching is not allowed in guard expressions, I furthermore suggest\nthat a function for extracting parts of binaries is added to the set\nof guard BIFs. This would be consistent with the function element/2\nbeing allowed in guards.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eFor the lists data type there is a help library providing functions for\ncommon operations such as searching and splitting lists.  This EEP suggests\nthat a similar set of library functions should be created for binaries.\nMany of the proposed functions are based on answers to questions regarding\nbinaries on the erlang-questions mailing list, e.g. \"how do I convert a\nnumber to a binary?\". This EEP therefore suggests the addition of one\nmodule in stdlib, namely a module \u003ccode\u003ebinary\u003c/code\u003e which will implement the\nrequested functionality in an efficient way. Most of this module will\nneed to be implemented in native code (residing in the virtual\nmachine) why the proposed implementation will be delivered as \"beta\"\nfunctionality in a forthcoming Erlang release.\u003c/p\u003e\n\n\u003cp\u003eThe functionality suggested is the following:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eFunctionality for searching, splitting and replacing in\nbinaries. The functionality in some ways will overlap that of the\nregular expression library already present in Erlang, but will be\neven more efficient and will have a simpler interface. \u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eCommon operations on binaries that have their counterparts for lists\nalready in the stdlib module \u003ccode\u003elists\u003c/code\u003e. While not all interfaces in\nthe \u003ccode\u003elists\u003c/code\u003e module are applicable to binaries, many are. This module\nalso provides a good place for future operations on binaries,\noperations that are not applicable to lists or that we still don't\nknow the need for.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFunctions for converting lists to binaries and v.v. These functions\nshould have a consistent view of zero-based indexing in binaries.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eOperations on binaries concerning their internal\nrepresentation. This functionality is sometimes necessary to avoid\nextensive use of memory due to the shared nature of the binaries. As\noperations on binaries do not involve copying when binaries are\ntaken apart, programs can unknowingly (or at least unintentionally)\nkeep references to large binaries by holding seemingly small amounts\nof data in the process. The O(1) nature of many operations on\nbinaries makes the data sharing necessary, but the effects can\nsometimes be surprising. On the other hand, O(n) complexity and\ninstant memory explosions when splitting a binary would be even more\nsurprising, why the current behavior need to be retained. It is suggested\nthat functions for both inspecting the nature of sharing of a binary\nand to clone a copy of a binary to avoid sharing effects is present\nin this suggested module.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAll functionality is to be applied to byte oriented binaries, never\nbitstrings that do not have a bitlength that is a multiple of\neight. All binaries supplied to and returned by these functions should\npass the \u003ccode\u003eis_binary/1\u003c/code\u003e test, otherwise an error will be raised.\u003c/p\u003e\n\n\u003ch2\u003eSuggested module reference\u003c/h2\u003e\n\n\u003cp\u003eI suggest the following functionality (presented as an excerpt of an Erlang\nmanual pages). A discussion about the interface can be found below.\u003c/p\u003e\n\n\u003ch3\u003eDATA TYPES\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003ecp()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOpaque data-type representing a compiled search-pattern.\nguaranteed to be a tuple() to allow programs to distinguish it from\nnon precompiled search patterns.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epart() = {Pos,Length}\n\nStart = int()\nLength = int()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA representaion of a part (or range) in a binary. \u003ccode\u003eStart\u003c/code\u003e is a\nzero-based offset into a binary() and Length is the length of that\npart. As input to functions in this module, a reverse part\nspecification is allowed, constructed with a negative \u003ccode\u003eLength\u003c/code\u003e, so\nthat the part of the binary begins at \u003ccode\u003eStart\u003c/code\u003e + \u003ccode\u003eLength\u003c/code\u003e and is\n-\u003ccode\u003eLength\u003c/code\u003e long. This is useful for referencing the last N bytes\nof a binary as \u003ccode\u003e{size(Binary), -N}\u003c/code\u003e. The functions in this module\nalways return part()'s with positive \u003ccode\u003eLength\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003eEXPORTS\u003c/h3\u003e\n\n\u003ch4\u003e\u003ccode\u003ecompile_pattern(Pattern) -\u0026gt; cp()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ePattern = binary() | [ binary() ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBuilds an internal structure representing a compilation of a\nsearch-pattern, later to be used in the find, split or replace\nfunctions. The cp() returned is guaranteed to be a tuple() to allow\nprograms to distinguish it from non precompiled search patterns\u003c/p\u003e\n\n\u003cp\u003eWhen a list of binaries is given, it denotes a \u003cem\u003eset\u003c/em\u003e of alternative\nbinaries to search for. I.e if \u003ccode\u003e[\u0026lt;\u0026lt;\"functional\"\u0026gt;\u0026gt;, \u0026lt;\u0026lt;\"programming\"\u0026gt;\u0026gt;]\u003c/code\u003e \nis given as \u003ccode\u003ePattern\u003c/code\u003e, this means ''either \u003ccode\u003e\u0026lt;\u0026lt;\"functional\"\u0026gt;\u0026gt;\u003c/code\u003e \u003cem\u003eor\u003c/em\u003e\n\u003ccode\u003e\u0026lt;\u0026lt;\"programming\"\u0026gt;\u0026gt;\u003c/code\u003e''. The pattern is a \u003cem\u003eset\u003c/em\u003e of alternatives; when\nonly a single binary is given, the set has only one element. \u003c/p\u003e\n\n\u003cp\u003eIf pattern is not a binary or a flat proper list of binaries, a \u003ccode\u003ebadarg\u003c/code\u003e\nexception will be raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ematch(Subject, Pattern) -\u0026gt; Found | no\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = part()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003ematch(Subject, Pattern, [])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ematch(Subject,Pattern,Options) -\u0026gt; Found | no\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = part()\nOptions = [ Option ]\nOption = {scope, part()}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSearches for the first occurrence of \u003ccode\u003ePattern\u003c/code\u003e in \u003ccode\u003eSubject\u003c/code\u003e and returns\nthe position and length.\u003c/p\u003e\n\n\u003cp\u003eThe function will return\n\u003ccode\u003e{Pos,Length}\u003c/code\u003e for the binary in \u003ccode\u003ePattern\u003c/code\u003e starting at\nthe lowest position in \u003ccode\u003eSubject\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eExample::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:find(\u0026lt;\u0026lt;\"abcde\"\u0026gt;\u0026gt;, [\u0026lt;\u0026lt;\"bcde\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"cd\"\u0026gt;\u0026gt;],[]).\n{1,4}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eEven though \u003ccode\u003e\u0026lt;\u0026lt;\"cd\"\u0026gt;\u0026gt;\u003c/code\u003e ends before \u003ccode\u003e\u0026lt;\u0026lt;\"bcde\"\u0026gt;\u0026gt;\u003c/code\u003e, \u003ccode\u003e\u0026lt;\u0026lt;\"bcde\"\u0026gt;\u0026gt;\u003c/code\u003e\nbegins first and is therefore the first match. If two overlapping\nmatches begins at the same position, the longest is returned.\u003c/p\u003e\n\n\u003cp\u003eSummary of the options:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{scope, {Start, Length}}\u003c/code\u003e \u003cbr /\u003e\nOnly the given part is searched. Return values still have offsets\nfrom the beginning of \u003ccode\u003eSubject\u003c/code\u003e. A negative \u003ccode\u003eLength\u003c/code\u003e is\nallowed as described in the \u003cstrong\u003eTYPES\u003c/strong\u003e section of this manual.\u003c/p\u003e\n\n\u003cp\u003eThe found part() is returned, if none of the strings in \u003ccode\u003ePattern\u003c/code\u003e is\nfound, the atom \u003ccode\u003eno\u003c/code\u003e is returned.\u003c/p\u003e\n\n\u003cp\u003eFor a descrition of \u003ccode\u003ePattern\u003c/code\u003e, see \u003ccode\u003ecompile_pattern/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003e{scope, {Start,Length}}\u003c/code\u003e is given in the options such that\n\u003ccode\u003eStart\u003c/code\u003e is larger than the size of \u003ccode\u003eSubject\u003c/code\u003e, \u003ccode\u003eStart\u003c/code\u003e +\n\u003ccode\u003eLength\u003c/code\u003e is less than zero or \u003ccode\u003eStart\u003c/code\u003e + \u003ccode\u003eLength\u003c/code\u003e is larger than\nthe size of \u003ccode\u003eSubject\u003c/code\u003e, a \u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003e\u003ccode\u003ematches(Subject, Pattern) -\u0026gt; Found\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = [ part() ] | []\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003ematches(Subject, Pattern, [])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ematches(Subject,Pattern,Options) -\u0026gt; Found\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nFound = [ part() ] | []\nOptions = [ Option ]\nOption = {scope, part()}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWorks like match, but the \u003ccode\u003eSubject\u003c/code\u003e is search until exhausted and\na list of all non-overlapping parts present in Pattern are returned (in order).\u003c/p\u003e\n\n\u003cp\u003eThe first and \u003cem\u003elongest\u003c/em\u003e match is preferred\nto a shorter, which is illustrated by the following example::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:matches(\u0026lt;\u0026lt;\"abcde\"\u0026gt;\u0026gt;, [\u0026lt;\u0026lt;\"bcde\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"bc\"\u0026gt;\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"de\"\u0026gt;\u0026gt;],[]).\n[{1,4}]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe result shows that \u003ccode\u003e\u0026lt;\u0026lt;\"bcde\"\u0026gt;\u0026gt;\u0026gt;\u003c/code\u003e is selected instead of the\nshorter match \u003ccode\u003e\u0026lt;\u0026lt;\"bc\"\u0026gt;\u0026gt;\u003c/code\u003e (which would have given raise to one more\nmatch,\u003ccode\u003e\u0026lt;\u0026lt;\"de\"\u0026gt;\u0026gt;\u003c/code\u003e). This corresponds to the behavior of\nposix regular expressions (and programs like \u003ccode\u003eawk\u003c/code\u003e), but is not\nconsistent with alternative matches in \u003ccode\u003ere\u003c/code\u003e (and Perl), where\ninstead lexical ordering in the search pattern selects which string\nmatches.\u003c/p\u003e\n\n\u003cp\u003eIf none of the strings in pattern is found, an empty list is returned.\u003c/p\u003e\n\n\u003cp\u003eFor a descrition of \u003ccode\u003ePattern\u003c/code\u003e, see \u003ccode\u003ecompile_pattern/1\u003c/code\u003e and for a\ndesctioption of available options, see \u003ccode\u003ematch/3\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode\u003e{scope, {Start,Length}}\u003c/code\u003e is given in the options such that\n\u003ccode\u003eStart\u003c/code\u003e is larger than the size of \u003ccode\u003eSubject\u003c/code\u003e, \u003ccode\u003eStart\u003c/code\u003e +\n\u003ccode\u003eLength\u003c/code\u003e is less than zero or \u003ccode\u003eStart\u003c/code\u003e + \u003ccode\u003eLength\u003c/code\u003e is larger than\nthe size of \u003ccode\u003eSubject\u003c/code\u003e, a \u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003esplit(Subject,Pattern) -\u0026gt; Parts\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nParts = [ binary() ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003esplit(Subject, Pattern, [])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003esplit(Subject,Pattern,Options) -\u0026gt; Parts\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nParts = [ binary() ]\nOptions = [ Option ]\nOption = {scope, part()} | trim | global\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSplits Binary into a list of binaries based on \u003ccode\u003ePattern\u003c/code\u003e. If the\noption \u003ccode\u003eglobal\u003c/code\u003e is not given, only the first occurrence of\n\u003ccode\u003ePattern\u003c/code\u003e in \u003ccode\u003eSubject\u003c/code\u003e will give rise to a split. \u003c/p\u003e\n\n\u003cp\u003eThe parts of \u003ccode\u003ePattern\u003c/code\u003e actually found in \u003ccode\u003eSubject\u003c/code\u003e are not included\nin the result.\u003c/p\u003e\n\n\u003cp\u003eExample::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:split(\u0026lt;\u0026lt;1,255,4,0,0,0,2,3\u0026gt;\u0026gt;, [\u0026lt;\u0026lt;0,0,0\u0026gt;\u0026gt;,\u0026lt;\u0026lt;2\u0026gt;\u0026gt;],[]).\n[\u0026lt;\u0026lt;1,255,4\u0026gt;\u0026gt;, \u0026lt;\u0026lt;2,3\u0026gt;\u0026gt;] \n2\u0026gt; binary:split(\u0026lt;\u0026lt;0,1,0,0,4,255,255,9\u0026gt;\u0026gt;, [\u0026lt;\u0026lt;0,0\u0026gt;\u0026gt;, \u0026lt;\u0026lt;255,255\u0026gt;\u0026gt;],[global]).\n[\u0026lt;\u0026lt;0,1\u0026gt;\u0026gt;,\u0026lt;\u0026lt;4\u0026gt;\u0026gt;,\u0026lt;\u0026lt;9\u0026gt;\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSummary of options:\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e{scope, part()}\u003c/code\u003e \u003cbr /\u003e\nWorks as in \u003ccode\u003ebinary:match/3\u003c/code\u003e and \u003ccode\u003ebinary:matches/3\u003c/code\u003e. Note\nthat this only defines the scope of the search for matching\nstrings, it does not cut the binary before splitting. The\nbytes before and after the scope will be kept in the result.\nSee example below.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003etrim\u003c/code\u003e \u003cbr /\u003e\nRemoves trailing empty parts of the result (as does \u003ccode\u003etrim\u003c/code\u003e\nin \u003ccode\u003ere:split/3\u003c/code\u003e)\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eglobal\u003c/code\u003e \u003cbr /\u003e\nRepeats the split until the \u003ccode\u003eSubject\u003c/code\u003e is\nexhausted. Conceptually the \u003ccode\u003eglobal\u003c/code\u003e option makes \u003ccode\u003esplit\u003c/code\u003e\nwork on the positions returned by \u003ccode\u003ebinary:matches/3\u003c/code\u003e, while\nit normally works on the position returned by\n\u003ccode\u003ebinary:match/3\u003c/code\u003e.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eExample of the difference between a \u003ccode\u003escope\u003c/code\u003e and taking the binary apart \nbefore splitting::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:split(\u0026lt;\u0026lt;\"banana\"\u0026gt;\u0026gt;,[\u0026lt;\u0026lt;\"a\"\u0026gt;\u0026gt;],[{scope,{2,3}}]).\n[\u0026lt;\u0026lt;\"ban\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"na\"\u0026gt;\u0026gt;]\n2\u0026gt; binary:split(binary:part(\u0026lt;\u0026lt;\"banana\"\u0026gt;\u0026gt;,{2,3}),[\u0026lt;\u0026lt;\"a\"\u0026gt;\u0026gt;],[]).\n[\u0026lt;\u0026lt;\"n\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"n\"\u0026gt;\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe return type is always a list of binaries which are all referencing\n\u003ccode\u003eSubject\u003c/code\u003e. This means that the data in \u003ccode\u003eSubject\u003c/code\u003e is not actually\ncopied to new binaries and that \u003ccode\u003eSubject\u003c/code\u003e cannot be garbage\ncollected until the results of the split are no longer referenced.\u003c/p\u003e\n\n\u003cp\u003eFor a descrition of \u003ccode\u003ePattern\u003c/code\u003e, see \u003ccode\u003ecompile_pattern/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ereplace(Subject,Pattern,Replacement) -\u0026gt; Result\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nReplacement = binary()\nResult = binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003ereplace(Subject,Pattern,Replacement,[])\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ereplace(Subject,Pattern,Replacement,Options) -\u0026gt; Result\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPattern = binary() | [ binary() ] | cp()\nReplacement = binary()\nResult = binary()\nOptions = [ Option ]\nOption = global | {scope, part()} | {insert_replaced, InsPos}\nInsPos = OnePos | [ OnePos ]\nOnePos = int() =\u0026lt; byte_size(Replacement)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConstructs a new binary by replacing the parts in \u003ccode\u003eSubject\u003c/code\u003e matching\n\u003ccode\u003ePattern\u003c/code\u003e with the content of \u003ccode\u003eReplacement\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf the matching sub-part of \u003ccode\u003eSubject\u003c/code\u003e giving raise to the\nreplacement is to be inserted in the result, the option\n\u003ccode\u003e{insert_replaced, InsPos}\u003c/code\u003e will insert the matching part into\n\u003ccode\u003eReplacement\u003c/code\u003e at the given position (or positions) before actually\ninserting \u003ccode\u003eReplacement\u003c/code\u003e into the Subject. Example::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:replace(\u0026lt;\u0026lt;\"abcde\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"b\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"[]\"\u0026gt;\u0026gt;,[{insert_replaced,1}]).\n\u0026lt;\u0026lt;\"a[b]cde\"\u0026gt;\u0026gt;\n2\u0026gt; binary:replace(\u0026lt;\u0026lt;\"abcde\"\u0026gt;\u0026gt;,[\u0026lt;\u0026lt;\"b\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"d\"\u0026gt;\u0026gt;],\u0026lt;\u0026lt;\"[]\"\u0026gt;\u0026gt;,\n                 [global,{insert_replaced,1}]).\n\u0026lt;\u0026lt;\"a[b]c[d]e\"\u0026gt;\u0026gt;\n3\u0026gt; binary:replace(\u0026lt;\u0026lt;\"abcde\"\u0026gt;\u0026gt;,[\u0026lt;\u0026lt;\"b\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"d\"\u0026gt;\u0026gt;],\u0026lt;\u0026lt;\"[]\"\u0026gt;\u0026gt;,\n                 [global,{insert_replaced,[1,1]}]).\n\u0026lt;\u0026lt;\"a[bb]c[dd]e\"\u0026gt;\u0026gt;\n4\u0026gt; binary:replace(\u0026lt;\u0026lt;\"abcde\"\u0026gt;\u0026gt;,[\u0026lt;\u0026lt;\"b\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"d\"\u0026gt;\u0026gt;],\u0026lt;\u0026lt;\"[-]\"\u0026gt;\u0026gt;,\n                 [global,{insert_replaced,[1,2]}]).\n\u0026lt;\u0026lt;\"a[b-b]c[d-d]e\"\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf any position given in \u003ccode\u003eInsPos\u003c/code\u003e is greater than the size of\nthe replacement binary, a \u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\n\n\u003cp\u003eThe options \u003ccode\u003eglobal\u003c/code\u003e and \u003ccode\u003e{scope, part()}\u003c/code\u003e works as for\n\u003ccode\u003ebinary:split/3\u003c/code\u003e. The return type is always a binary.\u003c/p\u003e\n\n\u003cp\u003eFor a descrition of \u003ccode\u003ePattern\u003c/code\u003e, see \u003ccode\u003ecompile_pattern/1\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003elongest_common_prefix(Binaries) -\u0026gt; int()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBinaries = [ binary() ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the length of the longest common prefix of the binaries in the\nlist \u003ccode\u003eBinaries\u003c/code\u003e. Example::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:longest_common_prefix([\u0026lt;\u0026lt;\"erlang\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"ergonomy\"\u0026gt;\u0026gt;]).\n2\n2\u0026gt; binary:longest_common_prefix([\u0026lt;\u0026lt;\"erlang\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"perl\"\u0026gt;\u0026gt;]).\n0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf \u003ccode\u003eBinaries\u003c/code\u003e is not a flat list of binaries, a \u003ccode\u003ebadarg\u003c/code\u003e exception\nis raised. \u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003elongest_common_suffix(Binaries) -\u0026gt; int()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBinaries = [ binary() ]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the length of the longest common suffix of the binaries in the\nlist \u003ccode\u003eBinaries\u003c/code\u003e. Example::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:longest_common_suffix([\u0026lt;\u0026lt;\"erlang\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"fang\"\u0026gt;\u0026gt;]).\n3\n2\u0026gt; binary:longest_common_suffix([\u0026lt;\u0026lt;\"erlang\"\u0026gt;\u0026gt;,\u0026lt;\u0026lt;\"perl\"\u0026gt;\u0026gt;]).\n0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf \u003ccode\u003eBinaries\u003c/code\u003e is not a flat list of binaries, a \u003ccode\u003ebadarg\u003c/code\u003e exception\nis raised. \u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003efirst(Subject) -\u0026gt; int()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the first byte of the binary as an integer. If the binary\nlength is zero, a \u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003elast(Subject) -\u0026gt; int()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the last byte of the binary as an integer. If the binary\nlength is zero, a \u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003eat(Subject, Pos) -\u0026gt; int()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPos = int() \u0026gt;= 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the byte at position \u003ccode\u003ePos\u003c/code\u003e (zero-based) in the binary\n\u003ccode\u003eSubject\u003c/code\u003e as an integer. If \u003ccode\u003ePos\u003c/code\u003e \u003e= \u003ccode\u003ebyte_size(Subject)\u003c/code\u003e, a\n\u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003epart(Subject, PosLen) -\u0026gt; binary()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPosLen = part()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eExtracts the part of the binary described by \u003ccode\u003ePosLen\u003c/code\u003e. \u003c/p\u003e\n\n\u003cp\u003eNegative length can be used to extract bytes at the end of a binary::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; Bin = \u0026lt;\u0026lt;1,2,3,4,5,6,7,8,9,10\u0026gt;\u0026gt;.\n2\u0026gt; binary:part(Bin,{byte_size(Bin), -5)).\n\u0026lt;\u0026lt;6,7,8,9,10\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf \u003ccode\u003ePosLen\u003c/code\u003e in any way references outside the binary, a \u003ccode\u003ebadarg\u003c/code\u003e\nexception is raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003epart(Subject, Pos, Len) -\u0026gt; binary()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPos = int()\nLen = int()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003epart(Subject, {Pos, Len})\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ebin_to_list(Subject) -\u0026gt; list()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003ebin_to_list(Subject,{0,byte_size(Subject)})\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ebin_to_list(Subject, PosLen) -\u0026gt; list()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPosLen = part()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConverts \u003ccode\u003eSubject\u003c/code\u003e to a list of int(), each int representing the\nvalue of one byte. The \u003ccode\u003epart()\u003c/code\u003e denotes which part of the\n\u003ccode\u003ebinary()\u003c/code\u003e to convert. Example::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:bin_to_list(\u0026lt;\u0026lt;\"erlang\"\u0026gt;\u0026gt;,{1,3}).\n\"rla\"\n%% or [114,108,97] in list notation.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf \u003ccode\u003ePosLen\u003c/code\u003e in any way references outside the binary, a \u003ccode\u003ebadarg\u003c/code\u003e\nexception is raised.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003ebin_to_list(Subject, Pos, Len) -\u0026gt; list()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nPos = int()\nLen = int()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003ebin_to_list(Subject,{Pos,Len})\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003elist_to_bin(ByteList) -\u0026gt; binary()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eByteList = iodata() (see module erlang)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWorks exactly like \u003ccode\u003eerlang:list_to_binary/1\u003c/code\u003e, added for completeness.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ecopy(Subject) -\u0026gt; binary()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003ecopy(Subject, 1)\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003ecopy(Subject,N) -\u0026gt; binary()\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nN = int() \u0026gt;= 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCreates a binary with the content of \u003ccode\u003eSubject\u003c/code\u003e duplicated \u003ccode\u003eN\u003c/code\u003e\ntimes. \u003c/p\u003e\n\n\u003cp\u003eThis function will always create a new binary, even if \u003ccode\u003eN\u003c/code\u003e = 1. By\nusing \u003ccode\u003ecopy/1\u003c/code\u003e on a binary referencing a larger binary, one might\nfree up the larger binary for garbage collection.  \u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNOTE! By deliberately copying a single binary to avoid referencing a\nlarger binary, one might, instead of freeing up the larger binary for\nlater garbage collection, create much more binary data than\nneeded. Sharing binary data is usually good. Only in special cases,\nwhen small parts reference large binaries and the large binaries are\nno longer used \u003cem\u003ein any process\u003c/em\u003e, deliberate copying might be a good idea.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIf \u003ccode\u003eN\u003c/code\u003e \u0026lt; 0, a \u003ccode\u003ebadarg\u003c/code\u003e exception is raised.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003ereferenced_byte_size(binary()) -\u0026gt; int()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eIf a binary references a larger binary (often described as being a\nsub-binary), it can be useful to get the size of the actual referenced\nbinary. This function can be used in a program to trigger the\nuse of \u003ccode\u003ecopy/1\u003c/code\u003e. By copying a binary, one might dereference the\noriginal, possibly large, binary which a smaller binary is a reference\nto.\u003c/p\u003e\n\n\u003cp\u003eExample::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003estore(Binary, GBSet) -\u0026gt;\n  NewBin = \n      case binary:referenced_byte_size(Binary) of\n          Large when Large \u0026gt; 2 * byte_size(Binary) -\u0026gt;\n             binary:copy(Binary);\n          _ -\u0026gt;\n         Binary\n      end,\n  gb_sets:insert(NewBin,GBSet).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn this example, we chose to copy the binary content before inserting\nit in the \u003ccode\u003egb_set()\u003c/code\u003e if it references a binary more than twice the size\nof the data we're going to keep. Of course different rules for when\ncopying will apply to different programs.\u003c/p\u003e\n\n\u003cp\u003eBinary sharing will occur whenever binaries are taken apart, this is\nthe fundamental reason why binaries are fast, decomposition can always\nbe done with O(1) complexity. In rare circumstances this data sharing\nis however undesirable, why this function together with \u003ccode\u003ecopy/1\u003c/code\u003e\nmight be useful when optimizing for memory use.  \u003c/p\u003e\n\n\u003cp\u003eExample of binary sharing::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; A = binary:copy(\u0026lt;\u0026lt;1\u0026gt;\u0026gt;,100).\n\u0026lt;\u0026lt;1,1,1,1,1 ...\n2\u0026gt; byte_size(A).\n100\n3\u0026gt; binary:referenced_byte_size(A)\n100\n4\u0026gt; \u0026lt;\u0026lt;_:10/binary,B:10/binary,_/binary\u0026gt;\u0026gt; = A.\n\u0026lt;\u0026lt;1,1,1,1,1 ...\n5\u0026gt; byte_size(B).\n10\n6\u0026gt; binary:referenced_byte_size(B)\n100\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNOTE! Binary data is shared among processes. If another process still\nreferences the larger binary, copying the part this process uses only\nconsumes more memory and will not free up the larger binary for garbage\ncollection. Use this kind of intrusive functions with extreme care,\nand only if a \u003cem\u003ereal\u003c/em\u003e problem is detected.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch4\u003e\u003ccode\u003eencode_unsigned(Unsigned) -\u0026gt; binary()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eUnsigned = int() \u0026gt;= 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003eencode_unsigned(Unsigned,big)\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003eencode_unsigned(Unsigned,Endianess) -\u0026gt; binary()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eUnsigned = int() \u0026gt;= 0\nEndianess = big | little\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConverts a positive integer to the smallest possible representation\nin in a binary digit representation, either big or little endian.\u003c/p\u003e\n\n\u003cp\u003eExample:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:encode_unsigned(11111111,big). \n\u0026lt;\u0026lt;169,138,199\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch4\u003e\u003ccode\u003edecode_unsigned(Subject) -\u0026gt; Unsigned\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nUnsigned = int() \u0026gt;= 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe same as \u003ccode\u003eencode_unsigned(Subject,big)\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch4\u003e\u003ccode\u003edecode_unsigned(Subject, Endianess) -\u0026gt; Unsigned\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eSubject = binary()\nEndianess = big | little\nUnsigned = int() \u0026gt;= 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConverts the binary digit representation, in big or little endian, of\na positive integer in \u003ccode\u003eSubject\u003c/code\u003e to an Erlang int().\u003c/p\u003e\n\n\u003cp\u003eExample::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e1\u0026gt; binary:decode_unsigned(\u0026lt;\u0026lt;169,138,199\u0026gt;\u0026gt;,big). \n11111111\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eGuard BIF\u003c/h2\u003e\n\n\u003cp\u003eI suggest adding the functions \u003ccode\u003ebinary:part/2\u003c/code\u003e and \u003ccode\u003ebinary:part/3\u003c/code\u003e\nto the set of BIFs allowed in guard tests. As guard BIFs are traditionally\nput in the erlang module, the following names for the guard BIFs are\nsuggested::\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eerlang:binary_part/2\nerlang:binary_part/3\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThey should both work exactly as their counterparts in the binary module.\u003c/p\u003e\n\n\u003ch2\u003eInterface design discussion\u003c/h2\u003e\n\n\u003cp\u003eAs with all modules, there are a lot of arguments about the actual\ninterface, sometimes more than about the functionality. In this case a\nnumber of parameters has to be considered.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eEffectiveness - The interface should be constructed so that fast\nimplementation is possible and so that code using the interface can\nbe written in an effective way. To not create unnecessary garbage is\none parameter, to allow for general code is another. \u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eParameter ordering - I've chosen to make the binary subject the\nfirst parameter in all applicable calls. Putting the subject first\ncorresponds to the \u003ccode\u003ere\u003c/code\u003e interface. The \u003ccode\u003elists\u003c/code\u003e module, however,\nusually has the subject as last parameter. We could go for that\ninstead, but unfortunately the \u003ccode\u003elists:sublist/{2,3}\u003c/code\u003e interface,\nwhich corresponds to the \u003ccode\u003epart\u003c/code\u003e function, has the subject\nfirst, why following the conventions of \u003ccode\u003elists\u003c/code\u003e would not only\nbreak conformance with \u003ccode\u003ere\u003c/code\u003e, it would also give us a generally\nnon-stringent interface. The effect of not conforming to the\n\u003ccode\u003elists\u003c/code\u003e interface is that using function names from that module\nwould lead to confusion and therefore is avoided.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eFunction naming - We have two related modules to take into account\nwhen naming functions here. The module \u003ccode\u003ere\u003c/code\u003e is related to the\nsearching function (\u003ccode\u003ematch\u003c/code\u003e, \u003ccode\u003ereplace\u003c/code\u003e etc), while the \u003ccode\u003elists\u003c/code\u003e\nmodule is related to the decomposition functions (\u003ccode\u003efirst\u003c/code\u003e,\n\u003ccode\u003elast\u003c/code\u003e etc). \u003c/p\u003e\n\n\u003cp\u003eI've basically retained the names from \u003ccode\u003ere\u003c/code\u003e when I find the\nfunctionality, both in concept and interface to be similar\nenough. The nature of regular expressions as small executable\nprograms, which is to much to say for a collection of binaries as\nthe patterns are in this module, prohibits the use of the function\nname \u003ccode\u003erun\u003c/code\u003e for actually doing the searching. We use \u003ccode\u003ematch\u003c/code\u003e and \n\u003ccode\u003ematches\u003c/code\u003e instead of \u003ccode\u003erun\u003c/code\u003e. \u003c/p\u003e\n\n\u003cp\u003eAs this module is more general than \u003ccode\u003ere\u003c/code\u003e, a function name like\n\u003ccode\u003ecompile\u003c/code\u003e is not really good. \u003ccode\u003ere:compile\u003c/code\u003e means \"compile a\nregular expression\", but what would \u003ccode\u003ebinary:compile\u003c/code\u003e mean?\nTherefore the pre-processing function is instead called\n\u003ccode\u003ecompile_pattern\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWhen it comes to the \u003ccode\u003elists\u003c/code\u003e module, the parameter ordering has\nprevented me from reusing any function names but \u003ccode\u003elast\u003c/code\u003e, which\nonly takes one parameter in \u003ccode\u003elists\u003c/code\u003e and there is no real\nalternative there.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eOptions or multiple functions - I believe a good rule of thumb is to\nnot have options that change the return type of the function, which\nwould have been the case if we i.e. had a \u003ccode\u003eglobal\u003c/code\u003e option to\n\u003ccode\u003ematch/3\u003c/code\u003e instead of a separate \u003ccode\u003ematches/3\u003c/code\u003e function.\u003c/p\u003e\n\n\u003cp\u003eThe fact that there are a manageable set of possible return types\nfor the searching and decomposition functions allows us to follow\nthat rule of thumb.\u003c/p\u003e\n\n\u003cp\u003e(Unfortunately that rule could not be easilly followed in \u003ccode\u003ere\u003c/code\u003e, as the\nrich assortment of options would have given rise to a non-manageable\namount of function names). \u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003ePerformance\u003c/h1\u003e\n\n\u003cp\u003eAlthough the decomposition functions are not really faster than using\nbit-syntax for decomposition, they create slightly less garbage than\nthe bit syntax. As they are not slower than bit-syntax, they also have\na purpose in allowing for a different programming style.\u003c/p\u003e\n\n\u003cp\u003eThe match/replace/split functionality should be compared to similar\nfunctionality in the \u003ccode\u003ere\u003c/code\u003e module. Implementation methods has to be\nchosen so that this modules search functions are faster, or possibly\neven significantly faster, than \u003ccode\u003ere\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eReference implementation\u003c/h1\u003e\n\n\u003cp\u003eA reference implementation was available on GitHub development branch \nbefore the final inclusion in R14A. \u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document is licensed under the \u003ca href=\"http://creativecommons.org/licenses/by/3.0/\" title=\"Creative Commons Attribution 3.0 License\"\u003eCreative Commons license\u003c/a\u003e.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0031"},"buildId":"92Ploa_JRk4A9mAiRpquq","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_buildManifest.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_ssgManifest.js" async=""></script></body></html>