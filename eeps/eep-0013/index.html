<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/f91c265ba4ec340e076d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f91c265ba4ec340e076d.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-4
Created: 09-Jul-2008
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 13: <a href="eep-0013.md" title="EEP Source"> -enum declarations</a></h2>

<h1>Abstract</h1>

<p>Erlang programs often need to process data streams using data
formats devised without reference to Erlang.  For this reason
OTP supports ASN.1 and CORBA, amongst other interface techniques.
Binary data streams often contain "symbolic" values that are
represented in the original description by some kind of
enumeration declaration, often literally a C "enum" declaration.</p>

<p>This EEP proposes an "<code>-enum</code>" declaration for Erlang for
convenient mapping between atoms on one side of an interface and
integers on the other, especially in the bit syntax.</p>

<p>This replaces some uses of the preprocessor with something that
permits the clearer expression of the programmer's intent.</p>

<h1>Specification</h1>

<p>A new form of declaration is added, four new guard BIFs, and a
new type specifier for bit syntax.</p>

<h2>Declaration</h2>

<pre><code>'-' 'enum' '(' identifier-and-size ',' '{' enum-binding
    {',' enum-binding}* ')' '.'
</code></pre>

<p>where identifier-and-size is</p>

<pre><code>identifier
</code></pre>

<p>or</p>

<pre><code>identifier : size
</code></pre>

<p>or</p>

<pre><code>identifier / type-specifier-list
</code></pre>

<p>or</p>

<pre><code>identifier : size / type-specifier-list
</code></pre>

<p>and enum-binding is</p>

<pre><code>identifier '=' constant-integer-expression
</code></pre>

<p>or</p>

<pre><code>identifier
</code></pre>

<p>size and type-specifier-list are as in the bit syntax,
except that the type-specifier-list may not include a Type.
If the size is missing, it will be the first of [8,16,32,64]
that is compatible with the integer values, as described later.
If the size is present, it must be an integer that is compatible 
with the integer values.  Signedness, if present, must agree
with the integer values.</p>

<h2>Example</h2>

<pre><code>-enum(colour, {red,orange,yellow,green,blue}).
-enum(fruit:32,  {quandong,lime,banana,orange,apple}).
</code></pre>

<p>The identifier following the left parenthesis is called the
"enumeration identifier" and the identifiers bound by the
bindings are called "enumerals".</p>

<p>After <code>-include</code> and <code>-if</code> processing, there should be at most one
enum declaration for any identifier.  The identifier must not
be one of</p>

<pre><code>integer | float | binary | bytes | bitstring | bits
</code></pre>

<p>Such a declaration only has significance within the constructs
defined in this EEP; the only existing notation which is affected
is the bit syntax.</p>

<p>Within a single enum declaration, an enumeral may not be bound in
two or more bindings.</p>

<p>If the first binding does not have an integer-constant-expression,
it is as if "= 0" appeared.  If a later binding does not have an
integer-constant-expression, it is as if "= N" appeared, where N
is one more than the integer value of the previous binding.</p>

<p>Within a single enum declaration, an integer value may not be used
in two or more bindings, whether implicitly or explicitly.</p>

<h2>Built-in functions</h2>

<h3><code>is_enum_atom(Atom, Enumeration_Identifier)</code></h3>

<ul>
<li><code>true</code> when Enumeration_Identifier is an atom that is declared
as an enumeration identifier and Atom is one of the enumerals
in that declaration,</li>
<li><code>false</code> otherwise.</li>
</ul>

<p>May be used as a guard test provided
Enumeration_Identifier is a literal atom,
with a compile-time error if it has no enum declaration.</p>

<h3><code>is_enum_integer(Integer, Enumeration_Identifier)</code></h3>

<ul>
<li><code>true</code> when Enumeration_Identifier is an atom that is declared
as an enumeration identifier and Integer is an integer that
is used as the value in one of the bindings in that
declaration,</li>
<li><code>false</code> otherwise.</li>
</ul>

<p>May be used as a guard test provided
Enumeration_Identifier is a literal atom,
with a compile-time error if it has no enum declaration.</p>

<h3><code>enum_to_atom(Integer, Enumeration_Identifier)</code></h3>

<ul>
<li>when <code>is_enum_integer(Integer, Enumeration_Identifier)</code> -> <br />
the enumeral bound to Integer in the
declaration of Enumeration_Identifier</li>
<li>otherwise exits with <code>badarg</code>.</li>
</ul>

<p>May be used in a guard expression provided
Enumeration_Identifier is a literal atom,
with a compile-time error if it has no enum declaration.</p>

<h3><code>enum_to_integer(Atom, Enumeration_Identifier)</code></h3>

<ul>
<li>when <code>is_enum_atom(Atom, Enumeration_Identifier)</code> -> <br />
the integer value that Atom is bound to in the
declaration of Enumeration_Identifier</li>
<li>otherwise exits with <code>badarg</code>.</li>
</ul>

<p>May be used in a guard expression provided
Enumeration_Identifier is a literal atom,
with a compile-time error if it has no enum declaration.</p>

<p>All four of these functions are expected to take O(1) time
and to allocate no storage at run time.</p>

<h2>Bit syntax extension</h2>

<p>The Type in a segment of the bit syntax may additionally be
an Enumeration_Identifier, and the corresponding Value will
then be an atom.  The value in the bit string that is being
matched or constructed is or will be the integer bound to
the atom; as such the Size, Endianness, Signedness, and Unit
are interpreted as for the <code>integer</code> Type.</p>

<p>In constructing a bit string,</p>

<pre><code>    V / Enumeration_Identifier ...
or  V : Size / Enumeration_Identifier ...
</code></pre>

<p>acts as if</p>

<pre><code>    enum_to_integer(V, Enumeration_Identifier) / integer ...
or  enum_to_integer(V, Enumeration_Identifier) : Size / integer ...
</code></pre>

<p>had been written, with one exception, which is now described.</p>

<p>If all the integer values in an enum declaration are non-negative,
let k be the smallest integer such that 2^k is greater than all
of them. If some are negative, let k be the smallest integer such
that 2^(k-1) is greater than all of them and -(2^(k-1)) is less
than or equal to all of them. The size of a segment for an
enumeration value must then be at least k bits, whatever the
actual value. A programmer who finds a need to bypass this can
do the enumeral&lt;->integer conversion manually; what this limit
does is to prevent accidental mis-specification. The size given
in the enum declaration must be at least k. If no size is given
in the bit syntax, the size given (or defaulted) in the enum
declaration will be used.</p>

<p>When such a segment is used in pattern matching, it is as if</p>

<ul>
<li>first an integer is extracted as if the Type had been <code>integer</code>,</li>
<li>then the value is converted to an atom as if by <code>enum_to_atom</code>,</li>
<li>and finally the atom is matched to whatever pattern appeared.</li>
</ul>

<p>One expects that cases where the value V is an explicit atom
will be translated completely at compile time, therefore having
no overhead compared with using macros and <code>/integer</code>.</p>

<h1>Motivation</h1>

<p>This was inspired by thinking about PADS and other data
description languages.  Imagine a C program doing something like</p>

<pre><code>enum seriousness {
    not_serious = 'N',
    hospitalised = 'H',
    life_threatening = 'L',
    congenital_abnormality = 'C',
    persisting_disability = 'P',
    intervention_required = 'I',
    death = 'D'
};
struct Message {
    char tag;                       /* a seriousness */
    union {
        int   number_of_days;       /* H */
        float extent_of_disability; /* C or P */
        char  procedure_code[5];    /* I */
    } supplement;
};
</code></pre>

<p>(The Message structure has been considerably simplified.) <br />
Now imagine matching it.</p>

<pre><code>-define(NOT_SERIOUS, $N).
-define(HOSPITALISED, $H).
-define(LIFE_THREATENING, $L).
-define(CONGENITAL_ABNORMALITY, $C).
-define(PERSISTING_DISABILITY, $P).
-define(INTERVENTION_REQUIRED, $I).
-define(DEATH, $D).

decode_message(B0) -&gt;
    case B0
      of &lt;&lt;?NOT_SERIOUS, B1/binary&gt;&gt; -&gt;
            {{not_serious}, B1}
       ; &lt;&lt;?HOSPITALISED, NDays:32, B1/binary&gt;&gt; -&gt;
            {{hospitalised,NDays}, B1}
       ; &lt;&lt;?LIFE_THREATENING, B1/binary&gt;&gt; -&gt;
            {{life_threatening}, B1}
       ; &lt;&lt;?CONGENITAL_ABNORMALITY, Extent/float, B1/binary&gt;&gt; -&gt;
            {{congenital_abnormality,Extent}, B1}
       ; &lt;&lt;?PERSISTING_DISABILITY, Extent/float, B1/binary&gt;&gt; -&gt;
            {{persisting_abnormality,Extent}, B1}
       ; &lt;&lt;?INTERVENTION_REQUIRED, Code:5/bytes, B1/binary&gt;&gt; -&gt;
            {{intervention_required,Code}, B1}
       ; &lt;&lt;?DEATH, B1/binary&gt;&gt; -&gt;
            {{death}, B1}
    end.
</code></pre>

<p>There are a number of problems with this.</p>

<ul>
<li>You have to use macros; functions are not allowed in patterns.</li>
<li>There is nothing to link these macros together as a group.</li>
<li>So there is no help checking that you are using the right ones.</li>
<li>There is no word to relate them back to the original enum.</li>
<li>If the size isn't 8, it must be repeated in each pattern.</li>
<li>If the Endianness isn't <code>big</code>, it must be repeated in each
pattern. </li>
<li>If the size is wrong, too bad.</li>
<li>If a macro from the wrong list is used, too bad.</li>
<li>You cannot use the same enumeral name for more than one
enumeration, unless it happens to have the same value in both.</li>
<li>If you pass the macros around in a computation, they look
just like numbers to tracers and debuggers; they have no
run-time symbolic value.</li>
</ul>

<p>Now here's the version using <code>-enum</code>.</p>

<pre><code>-enum(seriousness : 8, {
    not_serious = $N,
    hospitalised = $H
    life_threatening = $L,
    congenital_abnormality = $C,
    persisting_disability = $P,
    intervention_required = $I,
    death = $D
}).

decode_message(B0) -&gt;
    case B0
      of &lt;&lt;not_serious/seriousness,
          B1/binary&gt;&gt; -&gt;
            {{not_serious}, B1}
       ; &lt;&lt;hospitalised/seriousness,
           NDays:32, B1/binary&gt;&gt; -&gt;
            {{hospitalised,NDays}, B1}
       ; &lt;&lt;life_threatening/seriousness,
           B1/binary&gt;&gt; -&gt;
            {{life_threatening}, B1}
       ; &lt;&lt;congenital_abnormality/seriousness,
           Extent/float, B1/binary&gt;&gt; -&gt;
            {{congenital_abnormality,Extent}, B1}
       ; &lt;&lt;persisting_disability/seriousness,
            Extent/float, B1/binary&gt;&gt; -&gt;
            {{persisting_abnormality,Extent}, B1}
       ; &lt;&lt;intervention_required/seriousness,
            Code:5/bytes, B1/binary&gt;&gt; -&gt;
            {{intervention_required,Code}, B1}
       ; &lt;&lt;death/seriousness,
           B1/binary&gt;&gt; -&gt;
            {{death}, B1}
    end.
</code></pre>

<p>Rather fortuitously, this feature also provides a way of
accepting any of a set of atoms or integers with a single
guard test.  Let's restructure the previous example to
first extract the seriousness and then match the body, but
this time, have just one body of each shape.</p>

<pre><code>-enum(seriousness, {
    not_serious = $N,
    hospitalised = $H
    life_threatening = $L,
    congenital_abnormality = $C,
    persisting_disability = $P,
    intervention_required = $I,
    death = $D
}).
-enum(no_more_info, {
    not_serious = $N,
    life_threatening = $L,
    death = $D
}).
-enum(extent_of_impairment, {
    congenital_abnormality = $C,
    persisting_disability = $P
}).

decode_message(&lt;&lt;Seriousness/seriousness, B0/binary&gt;&gt;) -&gt;
    if is_enum_atom(Seriousness, no_more_info) -&gt;
       {{Seriousness}, B0}
     ; is_enum_atom(Seriousness, extent_of_impairment) -&gt;
       &lt;&lt;Extent/float, B1/binary&gt;&gt; = B0,
       {{Seriousness,Extent}, B1}
     ; Seriousness =:= hospitalised -&gt;
       &lt;&lt;NDays:32, B1/binary&gt;&gt; = B0,
       {{Seriousness,NDays}, B1}
     ; Seriousness =:= intervention_required -&gt;
       &lt;&lt;Code:5/bytes, B1/binary&gt;&gt; = B0,
       {{Seriousness,Code}, B1}
    end.
</code></pre>

<h1>Rationale</h1>

<p>Since this is supposed to make it easy to convert descriptions <br />
from C or PADS or similar forms, an enum declaration looks like
a C enum declaration.</p>

<p>Since size, signedness, and endianness may be needed in multiple
places, it makes sense to put them all in the declaration so that
they don't have to be repeated (and therefore cannot be repeated
incorrectly).</p>

<p>The order of the arguments in the new BIFs is chosen to match
the order of the arguments in <code>is_record/2</code>, so as to be familiar
to Erlang programmers.</p>

<p>The new BIFs are needed to explain the extended bit syntax.
The only abbreviation in their names is <code>enum</code>, which exactly
matches the keyword in the declaration.</p>

<p>The new BIFs can also be used to implement the extended bit
syntax by source-to-source transformation; no actual change to
the bit syntax machinery is required.</p>

<h1>Backwards Compatibility</h1>

<p>Code that uses any of the four new BIFs will be affected.
The nearest that the Erlang/OTP sources come to mentioning
any of those atoms is <code>enum_to_int</code>, which is used.
Code that does use any of these BIFs can be found using
cross-reference tools.</p>

<p>A simple approach would be to say that the BIFs <code>is_enum_atom/2</code>,
<code>is_enum_integer/2</code>, <code>enum_to_atom/2</code>, <code>and enum_to_integer/2</code>
are in scope in a module if and only if there is an <code>-enum</code>
declaration in that module, in which case existing code would
be entirely unaffected.</p>

<p>The effect on the bit syntax is that previously illegal
forms (where Type is not one of the existing numeric or bit
string types or Value is an atom) become legal, but only if
licensed by appropriate <code>-enum</code> declarations.</p>

<h1>Reference Implementation</h1>

<p>There is none.  However, we can sketch one.
The four new BIFs are all simple table lookups of the kind that
the Erlang compiler already has to be able to generate for
indexed clause selection.  As such, they are safe to call in
guards.  Since the Type in the bit syntax may only be an
enumeration name when it is a literal atom known to the compiler
as an enumeration name, the constructor</p>

<pre><code>&lt;&lt;... V : S / T X ...&gt;&gt;
</code></pre>

<p>can be translated as</p>

<pre><code>( V1 = enum_to_integer(V, X), &lt;&lt;... V1 : S / integer X ...&gt;&gt;)
</code></pre>

<p>and the pattern</p>

<pre><code>&lt;&lt;... V : S / T X ...&gt;&gt;
</code></pre>

<p>can be translated to</p>

<pre><code>&lt;&lt;... V' : S / integer X ...&gt;&gt;
</code></pre>

<p>by adding</p>

<pre><code>V =:= enum_to_atom(V', T)
</code></pre>

<p>to the guard if V occurs elsewhere in the pattern or will be
bound in the context, or</p>

<pre><code>   V = enum_to_atom(V', T)
if V would not otherwise become bound.
</code></pre>

<p>Binding like this should be allowed in guards anyway,
but in this case it is perfectly safe because it is O(1) and
does not require any dynamic storage allocation (unlike, say,
arithmetic).</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0013","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 09-Jul-2008\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 13: \u003ca href=\"eep-0013.md\" title=\"EEP Source\"\u003e -enum declarations\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eErlang programs often need to process data streams using data\nformats devised without reference to Erlang.  For this reason\nOTP supports ASN.1 and CORBA, amongst other interface techniques.\nBinary data streams often contain \"symbolic\" values that are\nrepresented in the original description by some kind of\nenumeration declaration, often literally a C \"enum\" declaration.\u003c/p\u003e\n\n\u003cp\u003eThis EEP proposes an \"\u003ccode\u003e-enum\u003c/code\u003e\" declaration for Erlang for\nconvenient mapping between atoms on one side of an interface and\nintegers on the other, especially in the bit syntax.\u003c/p\u003e\n\n\u003cp\u003eThis replaces some uses of the preprocessor with something that\npermits the clearer expression of the programmer's intent.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eA new form of declaration is added, four new guard BIFs, and a\nnew type specifier for bit syntax.\u003c/p\u003e\n\n\u003ch2\u003eDeclaration\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e'-' 'enum' '(' identifier-and-size ',' '{' enum-binding\n    {',' enum-binding}* ')' '.'\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere identifier-and-size is\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eidentifier\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eidentifier : size\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eidentifier / type-specifier-list\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eidentifier : size / type-specifier-list\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand enum-binding is\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eidentifier '=' constant-integer-expression\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eidentifier\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003esize and type-specifier-list are as in the bit syntax,\nexcept that the type-specifier-list may not include a Type.\nIf the size is missing, it will be the first of [8,16,32,64]\nthat is compatible with the integer values, as described later.\nIf the size is present, it must be an integer that is compatible \nwith the integer values.  Signedness, if present, must agree\nwith the integer values.\u003c/p\u003e\n\n\u003ch2\u003eExample\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e-enum(colour, {red,orange,yellow,green,blue}).\n-enum(fruit:32,  {quandong,lime,banana,orange,apple}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe identifier following the left parenthesis is called the\n\"enumeration identifier\" and the identifiers bound by the\nbindings are called \"enumerals\".\u003c/p\u003e\n\n\u003cp\u003eAfter \u003ccode\u003e-include\u003c/code\u003e and \u003ccode\u003e-if\u003c/code\u003e processing, there should be at most one\nenum declaration for any identifier.  The identifier must not\nbe one of\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003einteger | float | binary | bytes | bitstring | bits\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSuch a declaration only has significance within the constructs\ndefined in this EEP; the only existing notation which is affected\nis the bit syntax.\u003c/p\u003e\n\n\u003cp\u003eWithin a single enum declaration, an enumeral may not be bound in\ntwo or more bindings.\u003c/p\u003e\n\n\u003cp\u003eIf the first binding does not have an integer-constant-expression,\nit is as if \"= 0\" appeared.  If a later binding does not have an\ninteger-constant-expression, it is as if \"= N\" appeared, where N\nis one more than the integer value of the previous binding.\u003c/p\u003e\n\n\u003cp\u003eWithin a single enum declaration, an integer value may not be used\nin two or more bindings, whether implicitly or explicitly.\u003c/p\u003e\n\n\u003ch2\u003eBuilt-in functions\u003c/h2\u003e\n\n\u003ch3\u003e\u003ccode\u003eis_enum_atom(Atom, Enumeration_Identifier)\u003c/code\u003e\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etrue\u003c/code\u003e when Enumeration_Identifier is an atom that is declared\nas an enumeration identifier and Atom is one of the enumerals\nin that declaration,\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efalse\u003c/code\u003e otherwise.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMay be used as a guard test provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003eis_enum_integer(Integer, Enumeration_Identifier)\u003c/code\u003e\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etrue\u003c/code\u003e when Enumeration_Identifier is an atom that is declared\nas an enumeration identifier and Integer is an integer that\nis used as the value in one of the bindings in that\ndeclaration,\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efalse\u003c/code\u003e otherwise.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMay be used as a guard test provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003eenum_to_atom(Integer, Enumeration_Identifier)\u003c/code\u003e\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003ewhen \u003ccode\u003eis_enum_integer(Integer, Enumeration_Identifier)\u003c/code\u003e -\u003e \u003cbr /\u003e\nthe enumeral bound to Integer in the\ndeclaration of Enumeration_Identifier\u003c/li\u003e\n\u003cli\u003eotherwise exits with \u003ccode\u003ebadarg\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMay be used in a guard expression provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.\u003c/p\u003e\n\n\u003ch3\u003e\u003ccode\u003eenum_to_integer(Atom, Enumeration_Identifier)\u003c/code\u003e\u003c/h3\u003e\n\n\u003cul\u003e\n\u003cli\u003ewhen \u003ccode\u003eis_enum_atom(Atom, Enumeration_Identifier)\u003c/code\u003e -\u003e \u003cbr /\u003e\nthe integer value that Atom is bound to in the\ndeclaration of Enumeration_Identifier\u003c/li\u003e\n\u003cli\u003eotherwise exits with \u003ccode\u003ebadarg\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMay be used in a guard expression provided\nEnumeration_Identifier is a literal atom,\nwith a compile-time error if it has no enum declaration.\u003c/p\u003e\n\n\u003cp\u003eAll four of these functions are expected to take O(1) time\nand to allocate no storage at run time.\u003c/p\u003e\n\n\u003ch2\u003eBit syntax extension\u003c/h2\u003e\n\n\u003cp\u003eThe Type in a segment of the bit syntax may additionally be\nan Enumeration_Identifier, and the corresponding Value will\nthen be an atom.  The value in the bit string that is being\nmatched or constructed is or will be the integer bound to\nthe atom; as such the Size, Endianness, Signedness, and Unit\nare interpreted as for the \u003ccode\u003einteger\u003c/code\u003e Type.\u003c/p\u003e\n\n\u003cp\u003eIn constructing a bit string,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    V / Enumeration_Identifier ...\nor  V : Size / Enumeration_Identifier ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eacts as if\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e    enum_to_integer(V, Enumeration_Identifier) / integer ...\nor  enum_to_integer(V, Enumeration_Identifier) : Size / integer ...\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ehad been written, with one exception, which is now described.\u003c/p\u003e\n\n\u003cp\u003eIf all the integer values in an enum declaration are non-negative,\nlet k be the smallest integer such that 2^k is greater than all\nof them. If some are negative, let k be the smallest integer such\nthat 2^(k-1) is greater than all of them and -(2^(k-1)) is less\nthan or equal to all of them. The size of a segment for an\nenumeration value must then be at least k bits, whatever the\nactual value. A programmer who finds a need to bypass this can\ndo the enumeral\u0026lt;-\u003einteger conversion manually; what this limit\ndoes is to prevent accidental mis-specification. The size given\nin the enum declaration must be at least k. If no size is given\nin the bit syntax, the size given (or defaulted) in the enum\ndeclaration will be used.\u003c/p\u003e\n\n\u003cp\u003eWhen such a segment is used in pattern matching, it is as if\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003efirst an integer is extracted as if the Type had been \u003ccode\u003einteger\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003ethen the value is converted to an atom as if by \u003ccode\u003eenum_to_atom\u003c/code\u003e,\u003c/li\u003e\n\u003cli\u003eand finally the atom is matched to whatever pattern appeared.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOne expects that cases where the value V is an explicit atom\nwill be translated completely at compile time, therefore having\nno overhead compared with using macros and \u003ccode\u003e/integer\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eThis was inspired by thinking about PADS and other data\ndescription languages.  Imagine a C program doing something like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eenum seriousness {\n    not_serious = 'N',\n    hospitalised = 'H',\n    life_threatening = 'L',\n    congenital_abnormality = 'C',\n    persisting_disability = 'P',\n    intervention_required = 'I',\n    death = 'D'\n};\nstruct Message {\n    char tag;                       /* a seriousness */\n    union {\n        int   number_of_days;       /* H */\n        float extent_of_disability; /* C or P */\n        char  procedure_code[5];    /* I */\n    } supplement;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e(The Message structure has been considerably simplified.) \u003cbr /\u003e\nNow imagine matching it.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(NOT_SERIOUS, $N).\n-define(HOSPITALISED, $H).\n-define(LIFE_THREATENING, $L).\n-define(CONGENITAL_ABNORMALITY, $C).\n-define(PERSISTING_DISABILITY, $P).\n-define(INTERVENTION_REQUIRED, $I).\n-define(DEATH, $D).\n\ndecode_message(B0) -\u0026gt;\n    case B0\n      of \u0026lt;\u0026lt;?NOT_SERIOUS, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{not_serious}, B1}\n       ; \u0026lt;\u0026lt;?HOSPITALISED, NDays:32, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{hospitalised,NDays}, B1}\n       ; \u0026lt;\u0026lt;?LIFE_THREATENING, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{life_threatening}, B1}\n       ; \u0026lt;\u0026lt;?CONGENITAL_ABNORMALITY, Extent/float, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{congenital_abnormality,Extent}, B1}\n       ; \u0026lt;\u0026lt;?PERSISTING_DISABILITY, Extent/float, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{persisting_abnormality,Extent}, B1}\n       ; \u0026lt;\u0026lt;?INTERVENTION_REQUIRED, Code:5/bytes, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{intervention_required,Code}, B1}\n       ; \u0026lt;\u0026lt;?DEATH, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{death}, B1}\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere are a number of problems with this.\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003eYou have to use macros; functions are not allowed in patterns.\u003c/li\u003e\n\u003cli\u003eThere is nothing to link these macros together as a group.\u003c/li\u003e\n\u003cli\u003eSo there is no help checking that you are using the right ones.\u003c/li\u003e\n\u003cli\u003eThere is no word to relate them back to the original enum.\u003c/li\u003e\n\u003cli\u003eIf the size isn't 8, it must be repeated in each pattern.\u003c/li\u003e\n\u003cli\u003eIf the Endianness isn't \u003ccode\u003ebig\u003c/code\u003e, it must be repeated in each\npattern. \u003c/li\u003e\n\u003cli\u003eIf the size is wrong, too bad.\u003c/li\u003e\n\u003cli\u003eIf a macro from the wrong list is used, too bad.\u003c/li\u003e\n\u003cli\u003eYou cannot use the same enumeral name for more than one\nenumeration, unless it happens to have the same value in both.\u003c/li\u003e\n\u003cli\u003eIf you pass the macros around in a computation, they look\njust like numbers to tracers and debuggers; they have no\nrun-time symbolic value.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eNow here's the version using \u003ccode\u003e-enum\u003c/code\u003e.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-enum(seriousness : 8, {\n    not_serious = $N,\n    hospitalised = $H\n    life_threatening = $L,\n    congenital_abnormality = $C,\n    persisting_disability = $P,\n    intervention_required = $I,\n    death = $D\n}).\n\ndecode_message(B0) -\u0026gt;\n    case B0\n      of \u0026lt;\u0026lt;not_serious/seriousness,\n          B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{not_serious}, B1}\n       ; \u0026lt;\u0026lt;hospitalised/seriousness,\n           NDays:32, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{hospitalised,NDays}, B1}\n       ; \u0026lt;\u0026lt;life_threatening/seriousness,\n           B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{life_threatening}, B1}\n       ; \u0026lt;\u0026lt;congenital_abnormality/seriousness,\n           Extent/float, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{congenital_abnormality,Extent}, B1}\n       ; \u0026lt;\u0026lt;persisting_disability/seriousness,\n            Extent/float, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{persisting_abnormality,Extent}, B1}\n       ; \u0026lt;\u0026lt;intervention_required/seriousness,\n            Code:5/bytes, B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{intervention_required,Code}, B1}\n       ; \u0026lt;\u0026lt;death/seriousness,\n           B1/binary\u0026gt;\u0026gt; -\u0026gt;\n            {{death}, B1}\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRather fortuitously, this feature also provides a way of\naccepting any of a set of atoms or integers with a single\nguard test.  Let's restructure the previous example to\nfirst extract the seriousness and then match the body, but\nthis time, have just one body of each shape.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-enum(seriousness, {\n    not_serious = $N,\n    hospitalised = $H\n    life_threatening = $L,\n    congenital_abnormality = $C,\n    persisting_disability = $P,\n    intervention_required = $I,\n    death = $D\n}).\n-enum(no_more_info, {\n    not_serious = $N,\n    life_threatening = $L,\n    death = $D\n}).\n-enum(extent_of_impairment, {\n    congenital_abnormality = $C,\n    persisting_disability = $P\n}).\n\ndecode_message(\u0026lt;\u0026lt;Seriousness/seriousness, B0/binary\u0026gt;\u0026gt;) -\u0026gt;\n    if is_enum_atom(Seriousness, no_more_info) -\u0026gt;\n       {{Seriousness}, B0}\n     ; is_enum_atom(Seriousness, extent_of_impairment) -\u0026gt;\n       \u0026lt;\u0026lt;Extent/float, B1/binary\u0026gt;\u0026gt; = B0,\n       {{Seriousness,Extent}, B1}\n     ; Seriousness =:= hospitalised -\u0026gt;\n       \u0026lt;\u0026lt;NDays:32, B1/binary\u0026gt;\u0026gt; = B0,\n       {{Seriousness,NDays}, B1}\n     ; Seriousness =:= intervention_required -\u0026gt;\n       \u0026lt;\u0026lt;Code:5/bytes, B1/binary\u0026gt;\u0026gt; = B0,\n       {{Seriousness,Code}, B1}\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eSince this is supposed to make it easy to convert descriptions \u003cbr /\u003e\nfrom C or PADS or similar forms, an enum declaration looks like\na C enum declaration.\u003c/p\u003e\n\n\u003cp\u003eSince size, signedness, and endianness may be needed in multiple\nplaces, it makes sense to put them all in the declaration so that\nthey don't have to be repeated (and therefore cannot be repeated\nincorrectly).\u003c/p\u003e\n\n\u003cp\u003eThe order of the arguments in the new BIFs is chosen to match\nthe order of the arguments in \u003ccode\u003eis_record/2\u003c/code\u003e, so as to be familiar\nto Erlang programmers.\u003c/p\u003e\n\n\u003cp\u003eThe new BIFs are needed to explain the extended bit syntax.\nThe only abbreviation in their names is \u003ccode\u003eenum\u003c/code\u003e, which exactly\nmatches the keyword in the declaration.\u003c/p\u003e\n\n\u003cp\u003eThe new BIFs can also be used to implement the extended bit\nsyntax by source-to-source transformation; no actual change to\nthe bit syntax machinery is required.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eCode that uses any of the four new BIFs will be affected.\nThe nearest that the Erlang/OTP sources come to mentioning\nany of those atoms is \u003ccode\u003eenum_to_int\u003c/code\u003e, which is used.\nCode that does use any of these BIFs can be found using\ncross-reference tools.\u003c/p\u003e\n\n\u003cp\u003eA simple approach would be to say that the BIFs \u003ccode\u003eis_enum_atom/2\u003c/code\u003e,\n\u003ccode\u003eis_enum_integer/2\u003c/code\u003e, \u003ccode\u003eenum_to_atom/2\u003c/code\u003e, \u003ccode\u003eand enum_to_integer/2\u003c/code\u003e\nare in scope in a module if and only if there is an \u003ccode\u003e-enum\u003c/code\u003e\ndeclaration in that module, in which case existing code would\nbe entirely unaffected.\u003c/p\u003e\n\n\u003cp\u003eThe effect on the bit syntax is that previously illegal\nforms (where Type is not one of the existing numeric or bit\nstring types or Value is an atom) become legal, but only if\nlicensed by appropriate \u003ccode\u003e-enum\u003c/code\u003e declarations.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eThere is none.  However, we can sketch one.\nThe four new BIFs are all simple table lookups of the kind that\nthe Erlang compiler already has to be able to generate for\nindexed clause selection.  As such, they are safe to call in\nguards.  Since the Type in the bit syntax may only be an\nenumeration name when it is a literal atom known to the compiler\nas an enumeration name, the constructor\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;... V : S / T X ...\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecan be translated as\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e( V1 = enum_to_integer(V, X), \u0026lt;\u0026lt;... V1 : S / integer X ...\u0026gt;\u0026gt;)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand the pattern\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;... V : S / T X ...\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecan be translated to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e\u0026lt;\u0026lt;... V' : S / integer X ...\u0026gt;\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eby adding\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eV =:= enum_to_atom(V', T)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eto the guard if V occurs elsewhere in the pattern or will be\nbound in the context, or\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e   V = enum_to_atom(V', T)\nif V would not otherwise become bound.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eBinding like this should be allowed in guards anyway,\nbut in this case it is perfectly safe because it is O(1) and\ndoes not require any dynamic storage allocation (unlike, say,\narithmetic).\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0013"},"buildId":"mwcz5f45UeFOBiRtaG40v","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-79f3144d8877c67ce98b.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_buildManifest.js" async=""></script><script src="/_next/static/mwcz5f45UeFOBiRtaG40v/_ssgManifest.js" async=""></script></body></html>