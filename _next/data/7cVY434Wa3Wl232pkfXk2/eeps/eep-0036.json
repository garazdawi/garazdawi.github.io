{"pageProps":{"index":{"id":"0036","content":"<pre><code>Author: Bj√∂rn Gustavsson &lt;bjorn(at)erlang(dot)org&gt;\nStatus: Final/R15B Proposal is implemented in OTP release R15B\nType: Standards Track\nCreated: 01-Mar-2011\nErlang-Version: R15A\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 36: <a href=\"eep-0036.md\" title=\"EEP Source\"> Line numbers in exceptions</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Extend each entry in the call stack backtrace (hereafter called\n<strong>stacktrace</strong>) returned from the <code>erlang:get_stacktrace/0</code> BIF and from the\n<code>catch</code> operator with filenames and line number information.</p>\n\n<h1>Specification</h1>\n\n<p>Currently a stack trace returned from <code>erlang:get_stacktrace/0</code>\n(and the <code>catch</code> operator) is a list of three-tuples, where\neach tuple looks like:</p>\n\n<pre><code>{Module,Function,Arity}\n</code></pre>\n\n<p>(In some cases, the third element may be a list of arguments instead\nof the function arity.)</p>\n\n<p>We propose to change each tuple to:</p>\n\n<pre><code>{Module,Function,Arity,LocationInfo}\n</code></pre>\n\n<p><code>LocationInfo</code> is a property list (a list of two-tuples) that\ncontains filename and line number information. If there is\nline number information available, the list will look like:</p>\n\n<pre><code>[{file,FilenameString},{line,LineNumber}]\n</code></pre>\n\n<p>The list should be accessed using <code>proplists:get_value/3</code> or\n<code>lists:keyfind/3</code>, not by direct matching, since a future release\nmay add more items to the list or change the order.</p>\n\n<p>The filename is usually the same as the module with the extension\n\".erl\" added, but if function definitions have been placed in a header\nfile, the filename will be the name of the header file.  The filename\nwill also be different if the Erlang source file has been generated by\na code generator such as yecc.</p>\n\n<p>The line number will never be zero; instead <code>LocationInfo</code> will be\nset to an empty list.</p>\n\n<p>The list will be empty if there is no location information available.\nHere are some reasons that location information may be missing:</p>\n\n<ul>\n<li><p>The module has been compiled with an older BEAM compiler that does\nnot support generation of line number information.</p></li>\n<li><p>The module was created by calling <code>compile:forms/1,2</code> with forms\nthat did not contain non-zero line numbers and/or filenames.</p></li>\n<li><p>A parse transform created abstract forms having the line number zero.</p></li>\n<li><p>The module was created using an alternate compiler that did not\nprovide filenames and/or (non-zero) line numbers.</p></li>\n<li><p>The line number information may have been stripped from\nthe BEAM file.</p></li>\n<li><p>The exception occurs in a BIF (implemented in C in the run-time\nsystem).</p></li>\n</ul>\n\n<h2>Implementation requirements</h2>\n\n<p>This EEP does not specify exactly how line number information should\nbe implemented, but it does impose some requirements on the\nimplementation:</p>\n\n<ul>\n<li><p>The presence of line number information should have (virtually) no\nimpact on the execution time for a program if no exceptions occur.  In\npractice, that means that an implementation is <em>not</em> allowed to add\nextra instructions or BIF calls that will be executed when no\nexception occurs.</p></li>\n<li><p>Line number information should not be dependent on debug information\nbeing present in the BEAM file.</p></li>\n<li><p>Line number information should be included by default in BEAM files.\n(There could be options to turn off the inclusion of line number\ninformation.)</p></li>\n<li><p>Loading line number information should be the default. There may be\nan option to turn off loading of line number information in order to\nsave memory.</p></li>\n</ul>\n\n<h2>Example</h2>\n\n<p>In the examples, we will use the following module:</p>\n\n<pre><code>-module(example).\n-export([m/1]).\n-include(\"header.hrl\").\n\nm(L) -&gt;\n    {ok,lists:map(fun f/1, L)}.  %Line 6\n</code></pre>\n\n<p>and the header file header.hrl:</p>\n\n<pre><code>f(X) -&gt;\n    abs(X) + 1.        %Line 2\n</code></pre>\n\n<p>Using R14B01 to call our example module, we get the following\nresult:</p>\n\n<pre><code>1&gt; example:m([-1,0,1,2]).\n{ok,[2,1,2,3]}\n2&gt; example:m([-1,0,1,2,not_a_number]).\n** exception error: bad argument\n     in function  abs/1\n        called as abs(not_a_number)\n     in call from example:f/1\n     in call from lists:map/2\n     in call from lists:map/2\n     in call from example:m/1\n3&gt; catch example:m([-1,0,1,2,not_a_number]).\n{'EXIT',{badarg,[{erlang,abs,[not_a_number]},\n                 {example,f,1},\n                 {lists,map,2},\n                 {lists,map,2},\n                 {example,m,1},\n                 {erl_eval,do_apply,5},\n                 {erl_eval,expr,5},\n                 {shell,exprs,7}]}}\n</code></pre>\n\n<p>In a system with line number information enabled, we get:</p>\n\n<pre><code>1&gt; example:m([-1,0,1,2]).             \n{ok,[2,1,2,3]}\n2&gt; example:m([-1,0,1,2,not_a_number]).\n** exception error: bad argument\n     in function  abs/1\n        called as abs(not_a_number)\n     in call from example:f/1 (header.hrl, line 2)\n     in call from lists:map/2 (lists.erl, line 948)\n     in call from lists:map/2 (lists.erl, line 948)\n     in call from example:m/1 (example.erl, line 6)\n3&gt; catch example:m([-1,0,1,2,not_a_number]).\n{'EXIT',{badarg,[{erlang,abs,[not_a_number],[]},\n                 {example,f,1,[{file,\"header.hrl\"},{line,2}]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {example,m,1,[{file,\"example.erl\"},{line,6}]},\n                 {erl_eval,do_apply,5,[{file,\"erl_eval.erl\"},{line,482}]},\n                 {erl_eval,expr,5,[{file,\"erl_eval.erl\"},{line,276}]},\n                 {shell,exprs,7,[{file,\"shell.erl\"},{line,666}]}]}}\n</code></pre>\n\n<p>If we compile the <code>example</code> module using the BEAM compiler in R14B01,\nthere will not be any line number information for that module:</p>\n\n<pre><code>1&gt; example:m([-1,0,1,2,not_a_number]).\n** exception error: bad argument\n     in function  abs/1\n        called as abs(not_a_number)\n     in call from example:f/1 \n     in call from lists:map/2 (lists.erl, line 948)\n     in call from lists:map/2 (lists.erl, line 948)\n     in call from example:m/1 \n2&gt; catch example:m([-1,0,1,2,not_a_number]).\n{'EXIT',{badarg,[{erlang,abs,[not_a_number],[]},\n                 {example,f,1,[]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {lists,map,2,[{file,\"lists.erl\"},{line,948}]},\n                 {example,m,1,[]},\n                 {erl_eval,do_apply,5,[{file,\"erl_eval.erl\"},{line,482}]},\n                 {erl_eval,expr,5,[{file,\"erl_eval.erl\"},{line,276}]},\n                 {shell,exprs,7,[{file,\"shell.erl\"},{line,666}]}]}}\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>The lack of line number information in exceptions is a major stumbling\nblock for many beginners, and is a time waster for experienced Erlang\nprogrammers.</p>\n\n<p>An often repeated piece of advice to mitigate the lack of line number\ninformation is to write smaller functions.  To some extent, that is\ngood advice, but some functions are most naturally written as a single\nfunction with many clauses.  One example is the <code>handle_call/3</code>\ncallback for a <code>gen_server</code> process.  Another example is test suites.\nIn a typical test suite, every line tests a condition and can\npotentially fail.  It is not practical to put every line that may fail\nin a separate function.</p>\n\n<p>Test suites based on <code>common_test</code> are automatically run through a\nparse transform that provides line number information when an\nexception occurs.  The parse transform inserts before every line code\nthat saves the current function name and line number in the process\ndictionary.  When an exception occurs, the line number can be\nretrieved and presented.</p>\n\n<p>One problem with this approach is that the test suite will run slower,\nwhich can cause test cases to fail if timeouts expire in the system\nbeing tested.  Another problem is that by default the parse transform\nis only run on the test modules themselves, and therefore exceptions\nthat occur in other parts of the code (support libraries for testing\nor the product itself) does not have any line information.</p>\n\n<h1>Rationale</h1>\n\n<p>We have chosen to let <code>erlang:get_stacktrace/0</code> and the <code>catch</code>\noperator return stacktraces with filename and line number information\n(instead of introducing a new function called, for example,\n<code>erlang:get_full_stacktrace/3</code>).  That means that code that simply\npasses on the stacktrace (to <code>erlang:raise/3</code>) does not need to be\nupdated.  For example, the following code that catches an exception,\nlogs it, and pass it on does not need to be updated:</p>\n\n<pre><code>try\n    some_call_that_may_fail()\ncatch\n    Class:Reason -&gt;\n        Stk = erlang:get_stacktrace(),\n        log(Class, Reason, Stk),\n        erlang:raise(Class, Reason, Stk)\nend\n</code></pre>\n\n<p>One the other hand, that means that code that assumes that the\nstacktrace only may contain three-tuples will no longer work and needs\nto be updated.</p>\n\n<p>There are several reasons for the requirement that the line number\ninformation should be loaded by default (rather than ordered by\ngiving an option).</p>\n\n<ul>\n<li><p>In real systems, code size is usually not an issue since it is\novershadowed by the memory used for process heaps, off-heap binaries,\nand ETS table.  Therefore, the 10 percent increase of the code size\n(as measured in the reference implementation) is not an issue for\nmost users, but the benefit of having line number information is\npotentially huge.</p></li>\n<li><p>Newcomers to Erlang have the most need for line number information\nand they should get it without giving any special option. If an option\nis needed, questions to the mailing lists about how to find from which\nsource line an exception was caused will continue to waste time.</p></li>\n<li><p>If an option must be given, even developers that know about it may\nforget to give it and might therefore end up having to investigate an\nexception without line number information. (Which may waste a lot of\ntime if the problem is not easily reproduce-able.)</p></li>\n</ul>\n\n<p>Therefore it is better that the developers that cannot afford any\nincrease in the size of the loaded code are the ones that must give an\noption to turn off loading of line number information.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>Applications that examine the stacktrace and assume that it contains\nthree-tuples must be updated. The <code>erlang:raise/3</code> BIF still accepts\nthree-tuples (it will translate those to four tuples with an empty\nlist in the fourth element); thus it is not mandatory to update calls\nto <code>erlang:raise/3</code>.</p>\n\n<h1>Implementation</h1>\n\n<p>The reference implementation can be fetched from Github like this:</p>\n\n<pre><code>git fetch git://github.com/bjorng/otp.git bjorn/line-numbers-in-exceptions\n</code></pre>\n\n<p>Here is an overview of the implementation:</p>\n\n<p>The BEAM compiler inserts a <code>line</code> instruction before every construct\nthat may generate an exception and before every call that will be\nincluded in the stacktrace. (Local tail-recursive calls need no <code>line</code>\ninstruction, but external tail-recursive calls need a <code>line</code>\ninstruction because they may be calls to BIFs.)</p>\n\n<p>The <code>line</code> instruction has a single operand, an index into a line\nnumber table.  The line number table is stored in the \"Line\" chunk in\nthe BEAM file.  The \"Line\" chunk and line instructions increase the\nfile size of BEAM files by about five percent.</p>\n\n<p>The loader will remove the <code>line</code> instructions from the code that will\nbe executed, but will remember their location and create a table\nsorted in address order mapping from program counter to line number\ninformation.  When a stacktrace needs to be built, the run-time system\nwill do a binary search for the program counter of exception-causing\ninstruction and each continuation pointer.</p>\n\n<p>For the benefit of embedded system that run in a very constrained\nmemory space, the run-time system can be started with the '+L' option\nto disable loading of the line number information.  The code will\nstill be about one percent larger than code compiled without line\nnumber information, because the compiler was unable to do code sharing\noptimizations on instructions that cause exceptions (such as the\n<code>badmatch</code> instruction).</p>\n\n<p>In the current implementation, the line number information increases\nthe size of the loaded code by roughly ten percent.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}