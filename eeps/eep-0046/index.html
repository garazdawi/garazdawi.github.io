<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Walter Weinmann &lt;walter.weinmann@gmail.com&gt;
Status: Draft
Type: Standards Track
Created: 06-Dec-2016
Erlang-Version: OTP 20.0
Post-History: 6-Dec-2016
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 46: <a href="eep-0046.md" title="EEP Source"> B-trees: balanced search trees of order n</a></h2>

<h1>Abstract</h1>

<p>This EEP proposes the creation of a new module named b_trees for the 
administration of b-trees.  Both the optional persistence and the sort 
order should be implemented by pluggable functionality.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>

<h1>Specification</h1>

<h2>Data Structure</h2>

<pre><code>{MinimumSubtrees, 
 MaximumKeys, 
 SizeKeyValues, 
 SortFunction/2, 
 State, 
 Tree}
</code></pre>

<p><code>Tree</code> is composed of nodes of the form </p>

<pre><code>{KeyNumber, 
 SubtreeNumber, 
 [{Key, Value}], 
 [Tree]}
</code></pre>

<p>and the "empty b-tree" node </p>

<pre><code>nil
</code></pre>

<p><code>State</code> is a tuple composed of the following parameters: </p>

<pre><code>{StateTarget, 
 DeleteFunction/3, 
 InsertFunction/3, 
 LookupFunction/3}
</code></pre>

<p>Since the b-trees are always balanced, there is no need for a balance 
operation.</p>

<h2>DATA TYPES</h2>

<pre><code>b_tree() = {pos_integer(), 
            pos_integer(), 
            non_neg_integer(), 
            sort_function(), 
            state(), 
            tree()}
</code></pre>

<p>A general balanced tree.</p>

<pre><code>iterator() = [{key_values(), subtrees()}]
</code></pre>

<p>A general balanced tree iterator.</p>

<h2>EXPORTS</h2>

<h3>copy(Tree1, Tree2) -> Tree3</h3>

<p>Types:</p>

<pre><code>Tree1 = Tree2 = Tree3 = b_tree() | gb_trees:tree()
</code></pre>

<p>Copies tree Tree1 to an empty tree Tree2. Both trees may be either 
of type b-tree or binary tree (gb_trees). Returns the new tree 
Tree3 of the same type as tree Tree2.</p>

<h3>delete(Key, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, 
crashes otherwise.</p>

<h3>delete_any (Key, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 if key Key is present 
in b-tree B-Tree1, otherwise does nothing.  Returns the new b-tree B-Tree2.</p>

<h3>empty (Order) -> B-Tree</h3>

<p>Types:</p>

<pre><code>Order = pos_integer()
B-Tree = b_tree()
</code></pre>

<p>Returns a new empty b-tree.  The order is defined as the maximum number 
of children nodes a non-leaf node may hold.</p>

<h3>enter (Key, Value, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
Value = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Inserts key Key with value Value into b-tree B-Tree1 if key Key is not 
present in b-tree B-Tree1, otherwise updates the current value of key Key 
to value Value in b-tree B-Tree1.  Returns a new b-tree B-Tree2.</p>

<h3>from_dict (B-Tree1, List) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>B-Tree1 = B-Tree2 = b_tree()
List = [{Key, Value}]
</code></pre>

<p>Turns an ordered list List of key value tuples into a b-tree.  The given 
b-tree B-Tree1 must be empty.  The list must not contain duplicate keys.</p>

<h3>get (Key, B-Tree) -> Value</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree = b_tree()
Value = any()
</code></pre>

<p>Retrieves the value stored with key Key in b-tree B-Tree.  Assumes that 
key Key is present in b-tree B-Tree, crashes otherwise.</p>

<h3>height (B-Tree) -> integer() >= 0</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
</code></pre>

<p>Returns the height of b-tree B-Tree as an integer.  Assumes that b-tree 
B-Tree is non-empty.</p>

<h3>insert (Key, Value, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
Value = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Inserts key Key with value Value into b-tree  B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is <strong>not</strong> present in b-tree B-Tree1, 
crashes otherwise.</p>

<h3>is_defined (Key, B-Tree) -> boolean()</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree = b_tree()
</code></pre>

<p>Returns <code>true</code> if key Key is present in b-tree B-Tree, otherwise <code>false</code>.</p>

<h3>is_empty (B-Tree) -> boolean()</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
</code></pre>

<p>Returns <code>true</code> if b-tree B-Tree is an empty b-tree, otherwise <code>false</code>.</p>

<h3>iterator (B-Tree) -> Iterator</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
Iterator = iterator()
</code></pre>

<p>Returns iterator Iterator that can be used for traversing the entries 
of b-tree B-Tree; see <code>next/1</code>.  The implementation of this iterator is 
very efficient; traversing the whole b-tree using <code>next/1</code> is only slightly
slower than getting the list of all key-value pairs using <code>to_list/1</code> 
and traversing that.  The main advantage of the iterator approach is that 
it does not require the complete list of all key-value pairs to be built 
in memory at one time.</p>

<h3>iterator_from (Key, B-Tree) -> Iterator</h3>

<p>Types:</p>

<pre><code>Key = any(9
B-Tree = b_tree()
Iterator = iterator()
</code></pre>

<p>Returns iterator Iterator that can be used for traversing the entries 
of b-tree B-Tree; see <code>next/1</code>.  The difference, as compared to the 
iterator returned by iterator/1, is that the first key greater than 
or equal to key Key is returned.</p>

<h3>keys (B-Tree) -> [Key]</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
Key = any()
</code></pre>

<p>Returns the keys in b-tree B-Tree as an ordered list.</p>

<h3>largest (B-Tree) -> {Key, Value}</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns a tuple {Key, Value}, where Key is the largest key in b-tree 
B-Tree, and Value is the value associated with this key.  Assumes that 
b-tree B-Tree is not empty.</p>

<h3>lookup (Key, B-Tree) -> none | {value, Value}</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree = b_tree()
Value = any()
</code></pre>

<p>Looks up key Key in b-tree B-Tree. Returns {value, Value}, or none if 
key Key is not present.</p>

<h3>map (Function, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Function = fun((Key, Value1) -&gt; Value2)
B-Tree1 = B-Tree2 = b_tree()
Key = any()
Value1 = Value2 = any()
</code></pre>

<p>Maps function Function(Key, Value1) -> Value2 to all key value pairs of 
b-tree B-Tree1.  Returns the new b-tree B-Tree2 with the same set of 
keys as b-tree B-Tree1 and the new set of values.</p>

<h3>next (Iterator1) -> 'none' | {Key, Value, Iterator2}</h3>

<p>Types:</p>

<pre><code>Iterator1 = Iterator2 = iterator()
Key = any()
Value = any()
</code></pre>

<p>Returns the tuple {Key, Value, Iterator2}, where Key is the smallest 
key referred to by iterator Iterator1, and iterator Iterator2 is the 
new iterator to be used for traversing the remaining nodes, or the 
atom '<strong>none</strong>' if no nodes remain.</p>

<h3>set_parameter (B-Tree1, Name, Value) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>B-Tree1 = B-Tree2 = b_tree()
Name : Value = sort  : Function = fun((Key1, Key2) -&gt; equal | 
                                                      greater | 
                                                      less)
             | state : {StateTarget, 
                        Function = fun(StateTarget, delete, Key) 
                                 -&gt; true,
                        Function = fun(StateTarget, insert, Subtrees) 
                                 -&gt; Key,
                        Function = fun(StateTarget, lookup, Key) 
                                 -&gt; Subtrees}
</code></pre>

<p>Sets the parameter Name to value Value in the empty b-tree B-Tree1 and 
returns the new b-tree B-Tree2.  This function can only be used in 
conjunction with an empty b-tree.</p>

<h3>size_key_values (B-Tree) -> integer() >= 0</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
</code></pre>

<p>Returns the number of key value pairs in b-tree B-Tree as an integer. <br />
Returns 0 (zero) if b-tree B-Tree is empty.</p>

<h3>size_nodes (B-Tree) -> {integer() >= 0, integer() >= 0}</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
</code></pre>

<p>Returns the number of total nodes and the number of leaf nodes in b-tree 
B-Tree as a tuple of two integers.  Returns {0, 0} (zero) if b-tree B-Tree 
is empty.</p>

<h3>smallest (B-Tree) -> {Key, Value}</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns tuple {Key, Value}, where Key is the smallest key in b-tree 
B-Tree, and Value is the value associated with this key.  Assumes that 
b-tree B-Tree is not empty.</p>

<h3>sort_ascending (Key1, Key2) -> 'equal' | 'greater' | 'less'</h3>

<p>Types:</p>

<pre><code>Key1 = Key2  = any()
equal = greater = less = atom()
</code></pre>

<p>Returns the atom '<strong>greater</strong>' if Key1 > Key2, the atom '<strong>less</strong>' 
if Key1 &lt; Key2 and otherwise the atom '<strong>equal</strong>'.</p>

<h3>sort_descending (Key1, Key2) -> 'equal' | 'greater' | 'less'</h3>

<p>Types:</p>

<pre><code>Key1 = Key2  = any()
equal = greater = less = atom()
</code></pre>

<p>Returns the atom '<strong>less</strong>' if Key1 > Key2, the atom '<strong>greater</strong>' 
if Key1 &lt; Key2 and otherwise the atom '<strong>equal</strong>'.</p>

<h3>take(Key, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, 
crashes otherwise.</p>

<h3>delete_any (Key, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Removes the node with key Key from b-tree B-Tree1 if key Key is present 
in b-tree B-Tree1, otherwise does nothing. Returns the new b-tree B-Tree2.</p>

<h3>take_largest (B-Tree1) -> {Key, Value, B-Tree2}</h3>

<p>Types:</p>

<pre><code>B-Tree1 = B-Tree2 = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns tuple {Key, Value, B-Tree2}, where Key is the largest key in 
b-tree B-Tree1, Value is the value associated with this key, and b-tree 
B-Tree2 is this b-tree with the corresponding key value pair deleted. <br />
Assumes that b-tree B-Tree1 is not empty.</p>

<h3>take_smallest (B-Tree1) -> {Key, Value, B-Tree2}</h3>

<p>Types:</p>

<pre><code>B-Tree1 = B-Tree2 = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Returns tuple {Key, Value, B-Tree2}, where Key is the smallest key in 
b-tree B-Tree1, Value is the value associated with this key, and b-tree 
B-Tree2 is this b-tree with the corresponding key value pair deleted. <br />
Assumes that b-tree B-Tree1 is not empty.</p>

<h3>to_list (B-Tree) -> [{Key, Value}]</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
Key = any()
Value = any()
</code></pre>

<p>Converts b-tree B-Tree into an ordered list of key value tuples.</p>

<h3>update (Key, Value, B-Tree1) -> B-Tree2</h3>

<p>Types:</p>

<pre><code>Key = any()
Value = any()
B-Tree1 = B-Tree2 = b_tree()
</code></pre>

<p>Updates key Key to value Value in b-tree B-Tree1 and returns the new 
b-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1.</p>

<h3>values (B-Tree) -> [Value]</h3>

<p>Types:</p>

<pre><code>B-Tree = b_tree()
Value = any()
</code></pre>

<p>Returns the values in b-tree B-Tree as an ordered list, sorted by their 
corresponding keys.  Duplicates are not removed.</p>

<h2>Pluggable Persistence Functionality</h2>

<h3>Format:</h3>

<pre><code>{StateTarget, DeleteFunction, InsertFunction, LookupFunction}

StateTarget = any()

DeleteFunction(StateTarget, delete, Key) -&gt; true

InsertFunction(StateTarget, insert, Subtrees) -&gt; Key

LookupFunction(StateTarget, lookup, Key) -&gt; Subtrees
</code></pre>

<p>Examples for state targets are a Dets table or a Mnesia table.  The delete 
function takes a state target, the atom <code>delete</code> and a key as arguments 
and returns the atom <code>true</code> if successful.  The insert function takes a 
state target, the atom <code>insert</code> and a subtrees data structure as arguments 
and returns a key if successful.  The lookup function takes a state target, 
the atom <code>lookup</code> and a key as arguments and returns a subtrees data 
structure if successful.</p>

<h3>Example functions:</h3>

<p>The following examples are based on Mnesia.</p>

<pre><code>persistence_by_mnesia(_, delete, SubtreesKey) 
                     when is_list(SubtreesKey) -&gt;
    true;
persistence_by_mnesia(StateTarget, delete, SubtreesKey) -&gt;
    F = fun() -&gt;
        ok = mnesia:delete({StateTarget, SubtreesKey}),
        true
    end,
    mnesia:activity(transaction, F);

persistence_by_mnesia(_, insert, []) -&gt;
    [];
persistence_by_mnesia(StateTarget, insert, 
                      [{_, _, [{Key, _} | _], _} | _] = Subtrees) -&gt;
    SubtreesKey = list_to_binary(Key),
    F = fun() -&gt;
        ok = mnesia:write(StateTarget, 
                          #subtrees{subtreesKey = SubtreesKey, 
                          subtrees = Subtrees}, write),
        SubtreesKey
    end,
    mnesia:activity(transaction, F);

persistence_by_mnesia(_, lookup, SubtreesKey) 
                     when is_list(SubtreesKey) -&gt;
    SubtreesKey;
persistence_by_mnesia(StateTarget, lookup, SubtreesKey) -&gt;
    F = fun() -&gt;
        [{subtrees, SubtreesKey, Subtrees}] = mnesia:read(StateTarget, 
                                                          SubtreesKey),
        Subtrees
    end,
mnesia:activity(transaction, F).
</code></pre>

<h3>Example usage:</h3>

<p>Creating the Mnesia table:</p>

<pre><code>-record(subtrees, {subtreesKey, subtrees}).

{atomic, ok} = mnesia:create_table(StateTargetName, [{record_name, 
                                                      subtrees}]),
</code></pre>

<p>Creating the b-tree:</p>

<pre><code>BTree1 = b_trees:empty(500),
BTree2 = b_trees:set_parameter(BTree1, state, 
                               {StateTargetName, 
                                fun persistence_by_mnesia/3, 
                                fun persistence_by_mnesia/3, 
                                fun persistence_by_mnesia/3}),
</code></pre>

<h2>Pluggable Sort Functionality</h2>

<h3>Format:</h3>

<pre><code>FunctionName(Key1, Key2) -&gt; equal | greater | less

Key1 = Key2 = any()
</code></pre>

<p>The sort function takes two keys as arguments and returns the atom <code>less</code> 
if Key1 &lt; Key2, the atom <code>greater</code> if Key1 > Key2 and otherwise the 
atom <code>equal</code>.</p>

<h3>Example function:</h3>

<pre><code>-spec sort_descending(key(), key()) -&gt; sort_result().

sort_descending(Key_1, Key_2) -&gt;
if
    Key_1 &lt; Key_2 -&gt; greater;
    Key_1 &gt; Key_2 -&gt; less;
    true -&gt; equal
end.
</code></pre>

<h3>Example usage:</h3>

<pre><code>BTree1 = b_trees:empty(500),
BTree2 = b_trees:set_parameter(BTree1, sort, fun sort_descending/2),
</code></pre>

<h1>Motivation</h1>

<p>B-trees are self-balancing tree data structures that keep data sorted 
and allow searches, sequential access, insertions, and deletions in 
logarithmic time.  B-trees are a generalization of a binary search 
trees in that a node can have more than two children.  Unlike self-balancing 
binary search trees, the b-tree is optimized for systems that read and 
write large blocks of data.  B-trees are a good example of a data structure 
for external memory.</p>

<h1>Rationale</h1>

<p>The functional design of the module b_trees is based on the module gb_trees:  </p>

<pre><code> b_trees          | gb_trees
------------------|---------
 n/a              | balance/1
 copy/2           | n/a
 delete/2         | delete/2
 delete_any/2     | delete_any/2
 empty/1          | empty/0
 enter/3          | enter/3
 from_dict/2      | from_orddict/1
 get/2            | get/2
 height/1         | n/a
 insert/3         | insert/3
 is_defined/2     | is_defined/2
 is_empty/1       | is_empty/1
 iterator/1       | iterator/1
 iterator_from/2  | iterator_from/2
 keys/1           | keys/1
 largest/1        | largest/1
 lookup/2         | lookup/2
 map/2            | map/2
 next/1           | next/1
 set_parameter/3  | n/a
 size_key_values/1| size/1
 size_nodes/1     | n/a
 smallest/1       | smallest/1
 sort_ascending/2 | n/a
 sort_descending/2| n/a
 take/2           | take/2
 take_any/2       | take_any/2
 take_largest/1   | take_largest/1
 take_smallest/1  | take_smallest/1
 to_list/1        | to_list/1
 update/3         | update/3
 values/1         | values/1
</code></pre>

<p>The functions <code>delete/2</code> and <code>insert/3</code> are implementations of the algorithms 
of Cormen, Thomas; Leiserson, Charles; Rivest, Ronald; Stein, Clifford (2009), 
Introduction to Algorithms (Third ed.), MIT Press and McGraw-Hill, pp. 484-504, 
ISBN 0-262-03384-4. Chapter 18: B-Trees.</p>

<h1>Backwards Compatibility</h1>

<p>No issues - except module name collisions.</p>

<h1>Reference Implementation</h1>

<p>The reference implementation can be fetched from Github:</p>

<pre><code>https://github.com/walter-weinmann/b_trees
</code></pre>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0046","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Walter Weinmann \u0026lt;walter.weinmann@gmail.com\u0026gt;\nStatus: Draft\nType: Standards Track\nCreated: 06-Dec-2016\nErlang-Version: OTP 20.0\nPost-History: 6-Dec-2016\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 46: \u003ca href=\"eep-0046.md\" title=\"EEP Source\"\u003e B-trees: balanced search trees of order n\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eThis EEP proposes the creation of a new module named b_trees for the \nadministration of b-trees.  Both the optional persistence and the sort \norder should be implemented by pluggable functionality.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003ch2\u003eData Structure\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003e{MinimumSubtrees, \n MaximumKeys, \n SizeKeyValues, \n SortFunction/2, \n State, \n Tree}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eTree\u003c/code\u003e is composed of nodes of the form \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{KeyNumber, \n SubtreeNumber, \n [{Key, Value}], \n [Tree]}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eand the \"empty b-tree\" node \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003enil\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e\u003ccode\u003eState\u003c/code\u003e is a tuple composed of the following parameters: \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{StateTarget, \n DeleteFunction/3, \n InsertFunction/3, \n LookupFunction/3}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSince the b-trees are always balanced, there is no need for a balance \noperation.\u003c/p\u003e\n\n\u003ch2\u003eDATA TYPES\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003eb_tree() = {pos_integer(), \n            pos_integer(), \n            non_neg_integer(), \n            sort_function(), \n            state(), \n            tree()}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA general balanced tree.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eiterator() = [{key_values(), subtrees()}]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA general balanced tree iterator.\u003c/p\u003e\n\n\u003ch2\u003eEXPORTS\u003c/h2\u003e\n\n\u003ch3\u003ecopy(Tree1, Tree2) -\u003e Tree3\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eTree1 = Tree2 = Tree3 = b_tree() | gb_trees:tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCopies tree Tree1 to an empty tree Tree2. Both trees may be either \nof type b-tree or binary tree (gb_trees). Returns the new tree \nTree3 of the same type as tree Tree2.\u003c/p\u003e\n\n\u003ch3\u003edelete(Key, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRemoves the node with key Key from b-tree B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, \ncrashes otherwise.\u003c/p\u003e\n\n\u003ch3\u003edelete_any (Key, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRemoves the node with key Key from b-tree B-Tree1 if key Key is present \nin b-tree B-Tree1, otherwise does nothing.  Returns the new b-tree B-Tree2.\u003c/p\u003e\n\n\u003ch3\u003eempty (Order) -\u003e B-Tree\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eOrder = pos_integer()\nB-Tree = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns a new empty b-tree.  The order is defined as the maximum number \nof children nodes a non-leaf node may hold.\u003c/p\u003e\n\n\u003ch3\u003eenter (Key, Value, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nValue = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eInserts key Key with value Value into b-tree B-Tree1 if key Key is not \npresent in b-tree B-Tree1, otherwise updates the current value of key Key \nto value Value in b-tree B-Tree1.  Returns a new b-tree B-Tree2.\u003c/p\u003e\n\n\u003ch3\u003efrom_dict (B-Tree1, List) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree1 = B-Tree2 = b_tree()\nList = [{Key, Value}]\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eTurns an ordered list List of key value tuples into a b-tree.  The given \nb-tree B-Tree1 must be empty.  The list must not contain duplicate keys.\u003c/p\u003e\n\n\u003ch3\u003eget (Key, B-Tree) -\u003e Value\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree = b_tree()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRetrieves the value stored with key Key in b-tree B-Tree.  Assumes that \nkey Key is present in b-tree B-Tree, crashes otherwise.\u003c/p\u003e\n\n\u003ch3\u003eheight (B-Tree) -\u003e integer() \u003e= 0\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the height of b-tree B-Tree as an integer.  Assumes that b-tree \nB-Tree is non-empty.\u003c/p\u003e\n\n\u003ch3\u003einsert (Key, Value, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nValue = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eInserts key Key with value Value into b-tree  B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is \u003cstrong\u003enot\u003c/strong\u003e present in b-tree B-Tree1, \ncrashes otherwise.\u003c/p\u003e\n\n\u003ch3\u003eis_defined (Key, B-Tree) -\u003e boolean()\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns \u003ccode\u003etrue\u003c/code\u003e if key Key is present in b-tree B-Tree, otherwise \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003eis_empty (B-Tree) -\u003e boolean()\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns \u003ccode\u003etrue\u003c/code\u003e if b-tree B-Tree is an empty b-tree, otherwise \u003ccode\u003efalse\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003eiterator (B-Tree) -\u003e Iterator\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\nIterator = iterator()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns iterator Iterator that can be used for traversing the entries \nof b-tree B-Tree; see \u003ccode\u003enext/1\u003c/code\u003e.  The implementation of this iterator is \nvery efficient; traversing the whole b-tree using \u003ccode\u003enext/1\u003c/code\u003e is only slightly\nslower than getting the list of all key-value pairs using \u003ccode\u003eto_list/1\u003c/code\u003e \nand traversing that.  The main advantage of the iterator approach is that \nit does not require the complete list of all key-value pairs to be built \nin memory at one time.\u003c/p\u003e\n\n\u003ch3\u003eiterator_from (Key, B-Tree) -\u003e Iterator\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any(9\nB-Tree = b_tree()\nIterator = iterator()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns iterator Iterator that can be used for traversing the entries \nof b-tree B-Tree; see \u003ccode\u003enext/1\u003c/code\u003e.  The difference, as compared to the \niterator returned by iterator/1, is that the first key greater than \nor equal to key Key is returned.\u003c/p\u003e\n\n\u003ch3\u003ekeys (B-Tree) -\u003e [Key]\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\nKey = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the keys in b-tree B-Tree as an ordered list.\u003c/p\u003e\n\n\u003ch3\u003elargest (B-Tree) -\u003e {Key, Value}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\nKey = any()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns a tuple {Key, Value}, where Key is the largest key in b-tree \nB-Tree, and Value is the value associated with this key.  Assumes that \nb-tree B-Tree is not empty.\u003c/p\u003e\n\n\u003ch3\u003elookup (Key, B-Tree) -\u003e none | {value, Value}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree = b_tree()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLooks up key Key in b-tree B-Tree. Returns {value, Value}, or none if \nkey Key is not present.\u003c/p\u003e\n\n\u003ch3\u003emap (Function, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eFunction = fun((Key, Value1) -\u0026gt; Value2)\nB-Tree1 = B-Tree2 = b_tree()\nKey = any()\nValue1 = Value2 = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eMaps function Function(Key, Value1) -\u003e Value2 to all key value pairs of \nb-tree B-Tree1.  Returns the new b-tree B-Tree2 with the same set of \nkeys as b-tree B-Tree1 and the new set of values.\u003c/p\u003e\n\n\u003ch3\u003enext (Iterator1) -\u003e 'none' | {Key, Value, Iterator2}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eIterator1 = Iterator2 = iterator()\nKey = any()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the tuple {Key, Value, Iterator2}, where Key is the smallest \nkey referred to by iterator Iterator1, and iterator Iterator2 is the \nnew iterator to be used for traversing the remaining nodes, or the \natom '\u003cstrong\u003enone\u003c/strong\u003e' if no nodes remain.\u003c/p\u003e\n\n\u003ch3\u003eset_parameter (B-Tree1, Name, Value) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree1 = B-Tree2 = b_tree()\nName : Value = sort  : Function = fun((Key1, Key2) -\u0026gt; equal | \n                                                      greater | \n                                                      less)\n             | state : {StateTarget, \n                        Function = fun(StateTarget, delete, Key) \n                                 -\u0026gt; true,\n                        Function = fun(StateTarget, insert, Subtrees) \n                                 -\u0026gt; Key,\n                        Function = fun(StateTarget, lookup, Key) \n                                 -\u0026gt; Subtrees}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSets the parameter Name to value Value in the empty b-tree B-Tree1 and \nreturns the new b-tree B-Tree2.  This function can only be used in \nconjunction with an empty b-tree.\u003c/p\u003e\n\n\u003ch3\u003esize_key_values (B-Tree) -\u003e integer() \u003e= 0\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the number of key value pairs in b-tree B-Tree as an integer. \u003cbr /\u003e\nReturns 0 (zero) if b-tree B-Tree is empty.\u003c/p\u003e\n\n\u003ch3\u003esize_nodes (B-Tree) -\u003e {integer() \u003e= 0, integer() \u003e= 0}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the number of total nodes and the number of leaf nodes in b-tree \nB-Tree as a tuple of two integers.  Returns {0, 0} (zero) if b-tree B-Tree \nis empty.\u003c/p\u003e\n\n\u003ch3\u003esmallest (B-Tree) -\u003e {Key, Value}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\nKey = any()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns tuple {Key, Value}, where Key is the smallest key in b-tree \nB-Tree, and Value is the value associated with this key.  Assumes that \nb-tree B-Tree is not empty.\u003c/p\u003e\n\n\u003ch3\u003esort_ascending (Key1, Key2) -\u003e 'equal' | 'greater' | 'less'\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey1 = Key2  = any()\nequal = greater = less = atom()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the atom '\u003cstrong\u003egreater\u003c/strong\u003e' if Key1 \u003e Key2, the atom '\u003cstrong\u003eless\u003c/strong\u003e' \nif Key1 \u0026lt; Key2 and otherwise the atom '\u003cstrong\u003eequal\u003c/strong\u003e'.\u003c/p\u003e\n\n\u003ch3\u003esort_descending (Key1, Key2) -\u003e 'equal' | 'greater' | 'less'\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey1 = Key2  = any()\nequal = greater = less = atom()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the atom '\u003cstrong\u003eless\u003c/strong\u003e' if Key1 \u003e Key2, the atom '\u003cstrong\u003egreater\u003c/strong\u003e' \nif Key1 \u0026lt; Key2 and otherwise the atom '\u003cstrong\u003eequal\u003c/strong\u003e'.\u003c/p\u003e\n\n\u003ch3\u003etake(Key, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRemoves the node with key Key from b-tree B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1, \ncrashes otherwise.\u003c/p\u003e\n\n\u003ch3\u003edelete_any (Key, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eRemoves the node with key Key from b-tree B-Tree1 if key Key is present \nin b-tree B-Tree1, otherwise does nothing. Returns the new b-tree B-Tree2.\u003c/p\u003e\n\n\u003ch3\u003etake_largest (B-Tree1) -\u003e {Key, Value, B-Tree2}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree1 = B-Tree2 = b_tree()\nKey = any()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns tuple {Key, Value, B-Tree2}, where Key is the largest key in \nb-tree B-Tree1, Value is the value associated with this key, and b-tree \nB-Tree2 is this b-tree with the corresponding key value pair deleted. \u003cbr /\u003e\nAssumes that b-tree B-Tree1 is not empty.\u003c/p\u003e\n\n\u003ch3\u003etake_smallest (B-Tree1) -\u003e {Key, Value, B-Tree2}\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree1 = B-Tree2 = b_tree()\nKey = any()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns tuple {Key, Value, B-Tree2}, where Key is the smallest key in \nb-tree B-Tree1, Value is the value associated with this key, and b-tree \nB-Tree2 is this b-tree with the corresponding key value pair deleted. \u003cbr /\u003e\nAssumes that b-tree B-Tree1 is not empty.\u003c/p\u003e\n\n\u003ch3\u003eto_list (B-Tree) -\u003e [{Key, Value}]\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\nKey = any()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eConverts b-tree B-Tree into an ordered list of key value tuples.\u003c/p\u003e\n\n\u003ch3\u003eupdate (Key, Value, B-Tree1) -\u003e B-Tree2\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eKey = any()\nValue = any()\nB-Tree1 = B-Tree2 = b_tree()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eUpdates key Key to value Value in b-tree B-Tree1 and returns the new \nb-tree B-Tree2.  Assumes that key Key is present in b-tree B-Tree1.\u003c/p\u003e\n\n\u003ch3\u003evalues (B-Tree) -\u003e [Value]\u003c/h3\u003e\n\n\u003cp\u003eTypes:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eB-Tree = b_tree()\nValue = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eReturns the values in b-tree B-Tree as an ordered list, sorted by their \ncorresponding keys.  Duplicates are not removed.\u003c/p\u003e\n\n\u003ch2\u003ePluggable Persistence Functionality\u003c/h2\u003e\n\n\u003ch3\u003eFormat:\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003e{StateTarget, DeleteFunction, InsertFunction, LookupFunction}\n\nStateTarget = any()\n\nDeleteFunction(StateTarget, delete, Key) -\u0026gt; true\n\nInsertFunction(StateTarget, insert, Subtrees) -\u0026gt; Key\n\nLookupFunction(StateTarget, lookup, Key) -\u0026gt; Subtrees\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eExamples for state targets are a Dets table or a Mnesia table.  The delete \nfunction takes a state target, the atom \u003ccode\u003edelete\u003c/code\u003e and a key as arguments \nand returns the atom \u003ccode\u003etrue\u003c/code\u003e if successful.  The insert function takes a \nstate target, the atom \u003ccode\u003einsert\u003c/code\u003e and a subtrees data structure as arguments \nand returns a key if successful.  The lookup function takes a state target, \nthe atom \u003ccode\u003elookup\u003c/code\u003e and a key as arguments and returns a subtrees data \nstructure if successful.\u003c/p\u003e\n\n\u003ch3\u003eExample functions:\u003c/h3\u003e\n\n\u003cp\u003eThe following examples are based on Mnesia.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003epersistence_by_mnesia(_, delete, SubtreesKey) \n                     when is_list(SubtreesKey) -\u0026gt;\n    true;\npersistence_by_mnesia(StateTarget, delete, SubtreesKey) -\u0026gt;\n    F = fun() -\u0026gt;\n        ok = mnesia:delete({StateTarget, SubtreesKey}),\n        true\n    end,\n    mnesia:activity(transaction, F);\n\npersistence_by_mnesia(_, insert, []) -\u0026gt;\n    [];\npersistence_by_mnesia(StateTarget, insert, \n                      [{_, _, [{Key, _} | _], _} | _] = Subtrees) -\u0026gt;\n    SubtreesKey = list_to_binary(Key),\n    F = fun() -\u0026gt;\n        ok = mnesia:write(StateTarget, \n                          #subtrees{subtreesKey = SubtreesKey, \n                          subtrees = Subtrees}, write),\n        SubtreesKey\n    end,\n    mnesia:activity(transaction, F);\n\npersistence_by_mnesia(_, lookup, SubtreesKey) \n                     when is_list(SubtreesKey) -\u0026gt;\n    SubtreesKey;\npersistence_by_mnesia(StateTarget, lookup, SubtreesKey) -\u0026gt;\n    F = fun() -\u0026gt;\n        [{subtrees, SubtreesKey, Subtrees}] = mnesia:read(StateTarget, \n                                                          SubtreesKey),\n        Subtrees\n    end,\nmnesia:activity(transaction, F).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eExample usage:\u003c/h3\u003e\n\n\u003cp\u003eCreating the Mnesia table:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-record(subtrees, {subtreesKey, subtrees}).\n\n{atomic, ok} = mnesia:create_table(StateTargetName, [{record_name, \n                                                      subtrees}]),\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eCreating the b-tree:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eBTree1 = b_trees:empty(500),\nBTree2 = b_trees:set_parameter(BTree1, state, \n                               {StateTargetName, \n                                fun persistence_by_mnesia/3, \n                                fun persistence_by_mnesia/3, \n                                fun persistence_by_mnesia/3}),\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003ePluggable Sort Functionality\u003c/h2\u003e\n\n\u003ch3\u003eFormat:\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003eFunctionName(Key1, Key2) -\u0026gt; equal | greater | less\n\nKey1 = Key2 = any()\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe sort function takes two keys as arguments and returns the atom \u003ccode\u003eless\u003c/code\u003e \nif Key1 \u0026lt; Key2, the atom \u003ccode\u003egreater\u003c/code\u003e if Key1 \u003e Key2 and otherwise the \natom \u003ccode\u003eequal\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3\u003eExample function:\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003e-spec sort_descending(key(), key()) -\u0026gt; sort_result().\n\nsort_descending(Key_1, Key_2) -\u0026gt;\nif\n    Key_1 \u0026lt; Key_2 -\u0026gt; greater;\n    Key_1 \u0026gt; Key_2 -\u0026gt; less;\n    true -\u0026gt; equal\nend.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3\u003eExample usage:\u003c/h3\u003e\n\n\u003cpre\u003e\u003ccode\u003eBTree1 = b_trees:empty(500),\nBTree2 = b_trees:set_parameter(BTree1, sort, fun sort_descending/2),\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eB-trees are self-balancing tree data structures that keep data sorted \nand allow searches, sequential access, insertions, and deletions in \nlogarithmic time.  B-trees are a generalization of a binary search \ntrees in that a node can have more than two children.  Unlike self-balancing \nbinary search trees, the b-tree is optimized for systems that read and \nwrite large blocks of data.  B-trees are a good example of a data structure \nfor external memory.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThe functional design of the module b_trees is based on the module gb_trees:  \u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e b_trees          | gb_trees\n------------------|---------\n n/a              | balance/1\n copy/2           | n/a\n delete/2         | delete/2\n delete_any/2     | delete_any/2\n empty/1          | empty/0\n enter/3          | enter/3\n from_dict/2      | from_orddict/1\n get/2            | get/2\n height/1         | n/a\n insert/3         | insert/3\n is_defined/2     | is_defined/2\n is_empty/1       | is_empty/1\n iterator/1       | iterator/1\n iterator_from/2  | iterator_from/2\n keys/1           | keys/1\n largest/1        | largest/1\n lookup/2         | lookup/2\n map/2            | map/2\n next/1           | next/1\n set_parameter/3  | n/a\n size_key_values/1| size/1\n size_nodes/1     | n/a\n smallest/1       | smallest/1\n sort_ascending/2 | n/a\n sort_descending/2| n/a\n take/2           | take/2\n take_any/2       | take_any/2\n take_largest/1   | take_largest/1\n take_smallest/1  | take_smallest/1\n to_list/1        | to_list/1\n update/3         | update/3\n values/1         | values/1\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe functions \u003ccode\u003edelete/2\u003c/code\u003e and \u003ccode\u003einsert/3\u003c/code\u003e are implementations of the algorithms \nof Cormen, Thomas; Leiserson, Charles; Rivest, Ronald; Stein, Clifford (2009), \nIntroduction to Algorithms (Third ed.), MIT Press and McGraw-Hill, pp. 484-504, \nISBN 0-262-03384-4. Chapter 18: B-Trees.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eNo issues - except module name collisions.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eThe reference implementation can be fetched from Github:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ehttps://github.com/walter-weinmann/b_trees\n\u003c/code\u003e\u003c/pre\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0046"},"buildId":"Ouo7gQeKiYSKAal9g8wsl","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/Ouo7gQeKiYSKAal9g8wsl/_buildManifest.js" async=""></script><script src="/_next/static/Ouo7gQeKiYSKAal9g8wsl/_ssgManifest.js" async=""></script></body></html>