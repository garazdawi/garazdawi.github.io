{"pageProps":{"index":{"id":"0023","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Final/R12B-4 Proposal is implemented in OTP release R12B-4\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 08-Aug-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 23: <a href=\"eep-0023.md\" title=\"EEP Source\"> Allow variables in <code>fun M:F/A</code></a></h2>\n\n<h1>Abstract</h1>\n\n<p><code>fun M:F/A</code> should allow <code>M</code>, <code>F</code>, and/or <code>A</code> to be a variable.</p>\n\n<h1>Specification</h1>\n\n<p>The form <code>fun M:F/A</code> currently requires <code>M</code> to be an atom,\n<code>F</code> to be an atom, and <code>A</code> to be a non-negative integer.\nThis is generalised to allow any or all of them to be\nvariables.</p>\n\n<h1>Motivation</h1>\n\n<p>Representing functions by tuples <code>{M,F,A}</code> is now deprecated.\nYet there are times when some of this information is not\navailable until run time.  For example, a behaviour's author\nmight wish to refer to the <code>start/0</code> function in the Callback\nmodule, but there might be any number of Callback modules at\nrun time.</p>\n\n<p>It is absurd that the module name and function name in a call\nof the form <code>M:F(E1, ..., En)</code> may be either atoms or variables,\nbut that they may not be variables in <code>fun M:F/A</code>.</p>\n\n<p>It turns out that <code>fun M:F/A</code> is currently implemented as a call\nto <code>erlang:make_fun(M, F, A)</code>, so the ability to create such\nfuns given run-time data already exists.  All that is missing\nis to wrap some syntax around it.</p>\n\n<h1>Rationale</h1>\n\n<p>The gap that's being filled here is one that has been felt in\npractice.  See a September 2008 thread in the Erlang mailing list.\nThe proposal generalises an existing form, but not more than the\nexisting function call syntax has already been generalised.</p>\n\n<p>It is perhaps the limits of this proposal that need explaining.</p>\n\n<p>First, the extension is from constants to constants or variables,\nnot to arbitrary expressions.  This is mainly to avoid confusing\nparsers and people.  The effect of <code>fun (E1):(E2)/(E3)</code> can be had\nby writing <code>M = E1, F = E2, A = E3, fun M:F/A</code>, so there is no loss\nof expressiveness.  Since Erlang's equivalent of a lambda form\nbegins with \"<code>fun (</code>\", <code>fun (E1):...</code> would be tricky to parse and\nvery confusing to people.</p>\n\n<p>Second, the extension is for <code>fun M:F/A</code> only, and not for <code>fun F/A</code>.\nThat's because there is no <code>erlang:make_fun/2</code> to call; the\nimplementation of <code>fun F/A</code> is surprisingly tricky and involves\ncreating a special-purpose glue function.  For many purposes,\n<code>fun ?MODULE:F/A</code> will serve instead.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All existing Erlang code remains acceptable with unchanged\nsemantics.  No new functions or instructions are added, so\nBEAM files produced with the new parser will work in older\nreleases.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>The auxiliary file <a href=\"eep-0023-1.diff\" title=\"Diff to apply to erl_parse.yrl\">eep-0023-1.diff</a>\nis a patch file to be applied to erl_parse.yrl.\nThe patched file has been checked by yecc, which is happy\nwith it, and the resulting .erl file compiles cleanly.\nHowever, that's all the testing that has been done.</p>\n\n<p>All that the implementation does is to</p>\n\n<ol>\n<li>accept <code>fun M:F/A</code> where <code>M</code>, <code>F</code>, and <code>A</code> are constants or\nvariables,</li>\n<li>generate the same abstract syntax term that was\ngenerated in the past when they are all constants,</li>\n<li>pretend that <code>erlang:make_fun(M, F, A)</code> had been written\nwhen at least one is a variable.\nOnly the parser is involved.</li>\n</ol>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}