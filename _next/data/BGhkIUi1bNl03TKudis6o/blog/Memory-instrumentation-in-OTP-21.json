{"pageProps":{"item":{"id":"Memory-instrumentation-in-OTP-21","title":"Memory instrumentation in OTP 21","author":"John Högberg","excerpt":"\nThe memory instrumentation module was rewritten for Erlang/OTP 21 to make it\neasier to use. In this post I'll describe the rationale behind the new features\nand how to make use of them.","article_date":1525219200000,"tags":["erts memory instrumentation"],"frontmatter":{"layout":"post","title":"Memory instrumentation in OTP 21","tags":"erts memory instrumentation","author":"John Högberg"},"content":"\nThe memory instrumentation module was rewritten for Erlang/OTP 21 to make it\neasier to use. In this post I'll describe the rationale behind the new features\nand how to make use of them.\n\nOne of the most important features that a diagnostic tool can have is the\nability to work on the fly. If it requires a restart then the condition you're\ntrying to diagnose might vanish, and you can't use it to troubleshoot issues on\n\"production\" systems.\n\nThe previous implementation had a few major issues to this effect; you had to\nstart the Erlang VM with a certain flag, accept considerable overhead, and\nworst of all suspend the VM while it collected all its data.\n\nThe amount of data it collected was also quite problematic; with one entry for\nevery single allocation it was difficult to tell what was hiding in all that\ninformation, and since there was no way to tell whether a gap between two\nallocations was mapped or not it was needlessly difficult to use when trying\nto troubleshoot memory fragmentation.\n\nThe new implementation tackles these problems by scanning existing data\nstructures to lower its overhead to the point it can be turned on by default,\nand tries to collect information in a manner that doesn't harm the\nresponsiveness of the system.\n\n## Carriers and memory fragmentation\n\nThe VM allocates memory in large segments we call \"carriers\" and then allocates\nblocks within those. This has many benefits; since each carrier is completely\nseparate from the others it's easy to determine when they can be returned to\nthe operating system, and they scale very well since we can guarantee that\nthey're only modified by per-thread instances which makes allocation and\ndeallocation wait-free in most cases.\n\nThere are two types of carriers; single-block which always contain one large\nblock, and multi-block that can contain several smaller blocks. While both of\nthese rely on the operating system to minimize address space fragmentation, the\nlatter kind can also become internally fragmented which will result in new\ncarriers being created if no existing multi-block carrier can satisfy an\nallocation, even if the amount of unused memory exceeds the request.\n\nWhile you can glean some information about average carrier utilization from\n`erlang:system_info({allocator, Alloc})` and use `pmap` (or similar) to get an\nidea of how fragmented the address space is, it has always been a pain to get\ninformation about the individual carriers. Starting in OTP 21 you can ask the\nsystem for a list of all carriers without having to start the VM with any\nparticular flags. The list contains information about each carrier's total\nsize, combined allocation size, allocation count, whether it's in the migration\npool, and a histogram over free block sizes.\n\nWe chose to represent the free blocks with histograms (log2, starting at 512 by\ndefault) as they make it easy to tell at a glance whether a carrier has\nfragmentation issues; if there's a lot of free blocks clustered along the left\nside then it's pretty safe to say there's a problem.\n\nIn the example below, the `ll_alloc` carrier has no free blocks at all, the\n`binary_alloc` and `eheap_alloc` ones look healthy with a few very large\nblocks, and the `fix_alloc` carrier is somewhat fragmented with ~3KB free split\ninto 22 blocks smaller than 512 bytes (although this is not a problem for this\nallocator type).\n\n```erlang\n1> instrument:carriers().\n{ok,{512,\n     [{ll_alloc,1048576,0,1048344,71,false,{0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n      {binary_alloc,1048576,0,324640,13,false,{3,0,0,1,0,0,0,2,0,0,0,0,0,0}},\n      {eheap_alloc,2097152,0,1037200,45,false,{2,1,1,3,4,3,2,2,0,0,0,0,0,0}},\n      {fix_alloc,32768,0,29544,82,false,{22,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n      {...}|...]}}\n```\n\n(`instrument:carriers/1` can be used to tweak the histograms and which\nallocators to look in.)\n\n## Allocations and memory utilization\n\nThose who have used `erlang:memory()` are probably familiar with how annoyingly\ngeneral the `system` category can be. It's possible to get a bit more\ninformation by using `erlang:system_info({allocator, Alloc})` but the most it\nwill do is tell you that it's (say) `driver_alloc` that eats all that memory\nand leave you with no clue which one.\n\nWhile it's often easy to tell which driver or NIF is causing problems while\nyou're developing, it's not as easy when it's used in anger alongside half a\ndozen others. The new \"allocation tagging\" feature will help you figure out\nwhere the memory went at the cost of one word per allocation. The allocations\nare presented as block size histograms (similar to carrier information)\ngrouped by their origin and type:\n\n```erlang\n2> instrument:allocations()\n{ok,{128,0,\n     #{udp_inet =>\n           #{driver_event_state => {0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0}},\n       tty_sl =>\n           #{io_queue => {0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             drv_internal => {0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0}},\n       system =>\n           #{db_segment => {0,0,0,0,0,18,0,0,1,0,0,0,0,0,0,0,0,0},\n             heap => {0,0,0,0,20,4,2,2,2,3,0,1,0,0,1,0,0,0},\n             thr_prgr_data => {38,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             db_term => {271,3,1,52,80,1,0,0,0,0,0,0,0,0,0,0,0,0},\n             code => {0,0,0,5,3,6,11,22,19,20,10,2,1,0,0,0,0,0},\n             binary => {18,0,0,0,7,0,0,1,0,0,0,0,0,0,0,0,0,0},\n             atom_entry => {8681,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             message => {0,40,78,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             ... }\n       spawn_forker =>\n           #{driver_select_data_state =>\n                 {1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n       ram_file_drv => #{drv_binary => {0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0}},\n       prim_file =>\n           #{process_specific_data => {2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             nif_trap_export_entry => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             monitor_extended => {0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             drv_binary => {0,0,0,0,0,0,1,0,3,5,0,0,0,1,0,0,0,0},\n             binary => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}},\n       prim_buffer =>\n           #{nif_internal => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},\n             binary => {0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}}}}}\n```\n\nThe above example was taken with allocation tagging turned on for all\nallocators (`+Muatags true` command line argument) to give you a better idea of\nwhat it can do. By default it will only be turned on for driver/NIF allocations\nand binaries since those are the most common culprits, and their allocations\nare generally so large that the overhead of a single word is a drop in the\nbucket.\n\n(As with carriers, `instrument:allocations/1` can be used to tweak the\nhistograms and which allocators to look in.)\n\n## Further reading\n\nFor those who'd like to know more about how our memory allocators work, Lukas\nLarsson's [talk at EUC 2014](https://erlangcentral.org/videos/euc-2014-lukas-larsson-memory-allocators-in-the-vm-memory-management-battle-stories/) is a good primer. Our internal\ndocumentation on [carrier migration](https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/CarrierMigration.md) and [inter-thread deallocation](https://github.com/erlang/otp/blob/master/erts/emulator/internal_doc/DelayedDealloc.md) may also be of interest.\n\nThe PR implementing this change can be found [here](https://github.com/erlang/otp/pull/1790), and the documentation for the old instrumentation module can be found [here](http://erlang.org/documentation/doc-9.3/lib/tools-2.11.2/doc/html/instrument.html).\n"}},"__N_SSG":true}