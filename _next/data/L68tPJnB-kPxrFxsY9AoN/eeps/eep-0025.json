{"pageProps":{"index":{"id":"0025","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 28-Nov-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 25: <a href=\"eep-0025.md\" title=\"EEP Source\"> Unnesting cases</a></h2>\n\n<h1>Abstract</h1>\n\n<p>Erlang 'case' expressions should adopt/adapt an idea from\nAlgol 68 that in Erlang would strictly generalise 'cond'.</p>\n\n<h1>Specification</h1>\n\n<p>Currently a 'case' expression has the form</p>\n\n<pre><code>'case' Expression 'of'\n      Pattern ['when' Guard] '-&gt;' Expression\n {';' Pattern ['when' Guard] '-&gt;' Expression}...\n'end'\n</code></pre>\n\n<p>It is well known that Algol 68 had</p>\n\n<pre><code>if .. then .. {elif .. then ..}... [else ..] fi\n</code></pre>\n\n<p>expressions.  It is less well known that it had a similar\nconstruction for case expression,</p>\n\n<pre><code>case .. in ... {ouse .. in ..}... [out ..] esac\n</code></pre>\n\n<p>where \"ouse\" (from \"OUt caSE\") let you iterate the case\nmatching process and only need one 'esac'.</p>\n\n<p>This proposal adopts the Algol 68 idea.\nThe revised form is</p>\n\n<pre><code>'case' Expression 'of'\n      Pattern ['when' Guard] '-&gt;' Expression\n {';' Pattern ['when' Guard] '-&gt;' Expression}...\n{';' 'or' 'case' Expression 'of'    \n      Pattern ['when' Guard] '-&gt;' Expression\n {';' Pattern ['when' Guard] '-&gt;' Expression}...}...\n'end'\n</code></pre>\n\n<h1>Motivation</h1>\n\n<p>Consider this example:</p>\n\n<pre><code>suffix(P, Suffix, List)\n  when is_function(P, 2), is_list(Suffix) -&gt;\nsuffix_loop(P, Suffix, List).\n\nsuffix_loop(P, Suffix, List) -&gt;\ncase equal(P, Suffix, List)\n  of true  -&gt; true\n   ; false -&gt; case List\n        of [_|Tail] -&gt; suffix_loop(P, Suffix, Tail)\n         ; []       -&gt; false\n          end\nend.\n</code></pre>\n\n<p>With this proposal we could write</p>\n\n<pre><code>suffix_loop(P, Suffix, List) -&gt;\ncase equal(P, Suffix, List)\n  of true     -&gt; true\n; or case List\n      of [_|Tail] -&gt; suffix_loop(P, Suffix, Tail)\n   ; []       -&gt; false\nend.\n</code></pre>\n\n<p>where all the alternatives to be selected have the same\nindentation.</p>\n\n<p>The old proposal for a Lisp-like 'cond' is no longer really\nneeded.  Instead of</p>\n\n<pre><code>cond\n    C1 -&gt; B1\n  ; C2 -&gt; B2\n  ...\n  ; Cn -&gt; Bn\nend\n</code></pre>\n\n<p>one writes</p>\n\n<pre><code>case      C1 of true -&gt; B1\n; or case C2 of true -&gt; B2\n...\n; or case Cn of true -&gt; Bn\nend\n</code></pre>\n\n<p>What one loses here is the check that a result that is not\n'true' must be 'false', but that job can these days be done\nby the Dialyzer.  This is certainly clumsier than 'cond',\nbut it achieves the main aim, that of selecting from a bunch\nof choices at the same logical (and therefore at the same\nindentation) level by means of a series of Boolean-valued\nexpressions, but it is strictly more general.  It allows you\nto combine Boolean-valued expressions with guards (including\nany future generalisations of guards), and it allows you to\nmake a choice based on any kind of pattern matching, not just\nBoolean.</p>\n\n<p>This is clumsier than 'cond', but over-using Boolean when some\nmore intention-revealing enumeration should be used is an\nanti-pattern that has been recognised for over 20 years.  If\n'cond' existed, there would be a strong pressure for people\nto write functions that return a Boolean result when something\nelse might be more useful, just so they could use 'cond'. <br />\nAs an example, suppose that we want to continue if the voltage\nis nominal, shut the device off if the voltage is low and there\nis not an emergency, or set the speed slow if the voltage is\nlow and there is an emergency.</p>\n\n<p>With cond:</p>\n\n<pre><code>cond voltage_nominal() -&gt; continue_operations()\n   ; in_emergency()    -&gt; set_speed_slow()\n   ; true              -&gt; shut_device_down()\nend\n</code></pre>\n\n<p>With case:</p>\n\n<pre><code>case      voltage() of nominal  -&gt; continue_operations()\n; or case status() of emergency -&gt; set_speed_slow()\n                    ; normal    -&gt; shut_device_down()\nend\n</code></pre>\n\n<p>When expressed this way, I for one find it easier to realise\nthat \"low\" is not the opposite of \"nominal\"; a voltage that is\nnot nominal might be high.  So we really should have</p>\n\n<pre><code>case      voltage() of nominal   -&gt; continue_operations()\n                     ; high      -&gt; WHAT DO WE DO HERE?\n; or case status()  of emergency -&gt; set_speed_slow()\n             ; normal    -&gt; shut_device_down()\nend\n</code></pre>\n\n<p>So an approach that gives you the \"flat\" structure of 'cond'\nwhile subtly encouraging the multiway thinking of 'case' has\nmerit.  You could say that I am not so much for 'ouse' as\nagainst 'cond' and over-use of Boolean.</p>\n\n<h1>Rationale</h1>\n\n<p>I read one too many \"why doesn't Erlang have an if\" e-message,\nand suddently remember \"Algol 68 could do that with 'case'\".</p>\n\n<p>The main issue is how to spell 'ouse' in Erlang.  My first\npreference was for 'or case', but that can't work.  I do not\nlove \"; or case\", and would be very happy to see something\nbetter.  Indeed, \"; case\" might do the job, I just felt that\nthat was a bit too error-prone.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>All existing Erlang code remains acceptable with unchanged\nsemantics.  The implementation will be entirely in the parser,\nso even tools that examine ASTs will be unaffected.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None yet.  It will be entirely in the parser.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}