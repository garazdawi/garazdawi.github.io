{"pageProps":{"item":{"id":"ssa-history","title":"SSA History","author":"Björn Gustavsson","excerpt":"\nThis blog post looks back on the development of\nthe [SSA-based intermediate representation][pr1935]\nfrom the beginning of this year to the end\nof August when the branch was merged.","article_date":1538092800000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"SSA History","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nThis blog post looks back on the development of\nthe [SSA-based intermediate representation][pr1935]\nfrom the beginning of this year to the end\nof August when the branch was merged.\n\n## January 2018\n\nIn January this year we realized that we have reached\nthe limit of the optimizations that we could do working\non BEAM code.\n\n[John][john] had finished the work on extending [`beam_bsm`][beam_bsm]\n(a pass that attempts to [delay creation of sub\nbinaries][bin_matching]). The extended `beam_bsm` pass could apply the\noptimization in a few more cases than it could before, but the amount\nof code in `beam_bsm` to achieve that modest improvement of the\noptimization was insane.\n\nJohn, [Lukas][lukas], and I discussed what we should do about\nit. Clearly, we needed a better intermediate format. But what should\nit be? Could we use the existing BEAM code but with variables instead of\nBEAM registers and do register allocation later? That would solve\nsome of the problems but not all of them. The irregular nature of\nBEAM instructions makes it cumbersome to traverse and analyze\nBEAM code.\n\nSo we decided to do like most modern compilers and use an [SSA][ssa]-based\nintermediate format.\n\n### Rewrites are scary!\n\nIntroducing a new intermediate format would require rewriting at\nleast some parts of the compiler. The problem with rewrites is\nthat they always take longer time than expected and that they often\nget abandoned before they are finished.\n\nTo increase the odds that this rewrite would be successful, we come\nup with this plan to do the minimum amount of work to get something working\nas soon as possible:\n\n1. Write a new pass that translates from [Kernel Erlang][kernel] to SSA code.\n\n2. Write a new pass that translates from SSA code to BEAM code.\n\n3. Keep all existing optimization passes.\n\n4. Rewrite the optimization passes one at a time.\n\nIt didn't quite work out according to the plan, as will soon be evident.\n\n## February 2018\n\nI made the first the commit February 1 this year.\n\n### beam_kernel_to_ssa\n\nThe first pass I wrote was the translator from Kernel Erlang to SSA code.\nWe named it `beam_kernel_to_ssa`.\n\nMy first thought was to write the pass from scratch, as opposed to\nbase it on `v3_codegen`. After all, there are fundamental differences\nbetween BEAM code and SSA code. BEAM code is a flat list of instructions.\nSSA code consists of blocks of numbered blocks stored in a map, and there\nare also the phi nodes.\n\nOn the other hand, the input for both `v3_codegen` and\n`beam_kernel_to_ssa` was Kernel Erlang. There was nothing wrong with\nthe code that handled the Kernel Erlang records and I didn't want to\nrewrite that code from scratch.  Instead, I rewrote the part of the\ncode that produced a list of BEAM instructions to produce a list of\nSSA instructions.  I then wrote a simple pass (about 100 lines of\ncode) that [packaged the SSA instructions into blocks and added the\nphi nodes][beam_kernel_to_ssa_finalize].\n\n### Testing beam_kernel_to_ssa\n\nI prefer to test the code I write a soon as possible after writing it.\nIt is much easier to find and fix bugs in code that has been recently\nwritten.\n\nHow can one test `beam_kernel_to_ssa` before the code generator for\nBEAM code has been written?\n\nOne cannot, not completely, but there are ways to find major problems.\n\nOne such way is [smoke testing][software_smoke_testing]. I modified\nthe compiler so that it would first run `beam_kernel_to_ssa` but\ndiscard its output, then run `v3_codegen` and the rest of the compiler\npasses. That allowed me to run the entire compiler test suite, and\nif the `beam_kernel_to_ssa` pass crashed, I've had found a bug.\n\nAnother way was to write a validator or linter of the SSA code.\n[John][john] wrote the `beam_ssa_lint` pass (actually called\n`beam_ssa_validator` at that time and later renamed), which would\nverify that a variable was only defined once, that variables were\ndefined before they were used, that labels in terminators and phi\nnodes referred to defined blocks, and so on. It helped me find a\nfew bugs.\n\n[Dialyzer][dialyzer] also helped me find some bugs. I made sure\nthat I added types for all fields in all new records and\nspecifications for all exported functions. Dialyzer pointed out\nsome bugs when I ran it and thinking about the types when writing\nthe `-type` declarations was also useful.\n\n### Finishing beam_kernel_to_ssa\n\nI am not sure exactly how long time I spent on the initial\nimplementation of `beam_kernel_to_ssa`, but it was probably less\nthan two weeks. There were a few snags along the way, most of\nthem bugs in `v3_kernel` that did not cause any problems\nwith the old `v3_codegen`.\n\nHere is an example. I chose to fix it in OTP 21 even though it was\nharmless in that release:\n\n[v3_kernel: Stop ensuring one return value in #k_try{}][v3_kernel_bug]\n\n### beam_ssa_pre_codegen\n\nNext up was the translation from SSA code to BEAM code.\n\nI have already decided that the translation was sufficiently complicated\nthat to better be split into two major passes.\n\nThe first pass of those passes,\n[`beam_ssa_pre_codegen`][beam_ssa_pre_codegen], would work on the SSA\ncode, rewriting it, and adding annotations for another pass that would\ngenerate the BEAM code, but the output would still be valid SSA code\nso that `ssa_lint` could be used to validate the output. The pretty-printed\nSSA code also includes the annotations to facilitate debugging.\n\nThe `dprecg` option can be used to produce a pretty-printed listing of\nthe SSA code. The following command will create the file `blog.precodegen`:\n\n```\nerlc +dprecg blog.erl\n```\n\nThe next section will dig deeper into the workings of `beam_ssa_pre_codegen`.\nOn a first reading, you might want to skip that section and jump ahead to\nthe section about [beam_ssa_codegen](#beam_ssa_codegen).\n\n### Digging deeper in beam_ssa_pre_codegen\n\nTo provide some context for the description of `beam_ssa_pre_codegen`,\nwe will first look at some BEAM code and talk about stack frames and\nY registers.\n\nHere is the example in Erlang:\n\n```erlang\nfoo(C, L) ->\n    Sum = lists:sum(L),\n    C + Sum.\n```\n\nThe BEAM code looks like this:\n\n    {allocate,1,2}.\n    {move,{x,0},{y,0}}.\n    {move,{x,1},{x,0}}.\n    {line,[{location,\"blog.erl\",5}]}.\n    {call_ext,1,{extfunc,lists,sum,1}}.\n    {line,[{location,\"blog.erl\",6}]}.\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n    {deallocate,1}.\n    return.\n\nAs usual, we will walk through the code one or a few lines at a time.\n\n    {allocate,1,2}.\n\nThe `allocate` instruction allocates a stack frame. The `1` operand\nmeans that there should be room for one slot in the stack frame for\nstoring one value.  The slots in the stack frame are called *Y\nregisters*.\n\nThe `2` operand means that two X registers (`{x,0}` and `{x,1}`) are\nlive and must be preserved if `allocate` needs to do a garbage\ncollection in order to allocate space for the stack frame.\n\n    {move,{x,0},{y,0}}.\n\nThe `C` argument for `foo/2` is in `{x,0}`. The `move` instruction\ncopies the value of `{x,0}` to `{y,0}`, which is the zeroth slot\nin the stack frame. The reason for doing this copy will soon become\nclear.\n\n    {move,{x,1},{x,0}}.\n\nPreparing for the call of `lists:sum/1`, the value of `L` in `{x,1}`\nis copied to `{x,0}`.\n\n    {line,[{location,\"blog.erl\",5}]}.\n    {call_ext,1,{extfunc,lists,sum,1}}.\n\nHere `lists:sum/1` is called. The argument is in `{x,0}`. The result\n(the sum of all numbers in the list) is returned in `{x,0}`. Also,\nthe contents of all other X registers are destroyed. That means that\nany value that is to be used after a function call must be saved to\na Y register.\n\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\nThis instruction calculates the sum of `C` (in `{y,0}`) and `Sum` (in `{x,0}`),\nstoring the result in `{x,0}`.\n\n    {deallocate,1}.\n\nPreparing to return from the function, the `deallocate` instruction\nremoves the stack frame that `allocate` created.\n\n    return.\n\n`return` returns from the function. The return value is in `{x,0}`.\n\nHere is the SSA code for the function:\n\n```\nfunction blog:foo(_0, _1) {\n0:\n  %% blog.erl:5\n  _2 = call remote (literal lists):(literal sum)/1, _1\n\n  %% blog.erl:5\n  _3 = bif:'+' _0, _2\n  @ssa_bool = succeeded _3\n  br @ssa_bool, label 3, label 1\n\n3:\n  ret _3\n\n1:\n  @ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  ret @ssa_ret\n}\n```\n\nAfter running `beam_ssa_pre_codegen`, the SSA code looks like this:\n\n```\nfunction blog:foo(x0/_0, x1/_1) {\n  %% _0: 0..1\n  %% _1: 0..1 0..3\n%% #{frame_size => 1,yregs => [0]}\n0:\n  %% _0:4: 1..5\n  [1] y0/_0:4 = copy x0/_0\n\n  %% blog.erl:5\n  %% _2: 3..5\n  [3] x0/_2 = call remote (literal lists):(literal sum)/1, x1/_1\n\n  %% blog.erl:5\n  %% _3: 5..11\n  [5] x0/_3 = bif:'+' y0/_0:4, x0/_2\n\n  %% @ssa_bool: 7..9\n  [7] z0/@ssa_bool = succeeded x0/_3\n  [9] br z0/@ssa_bool, label 3, label 1\n\n3:\n  [11] ret x0/_3\n\n1:\n  %% @ssa_ret: 13..15\n  [13] x0/@ssa_ret = call remote (literal erlang):(literal error)/1, literal badarg\n  [15] ret x0/@ssa_ret\n}\n```\n\nWe will describe what the important (for this example) sub passes of\n`beam_ssa_pre_codegen` do, and point to the relevant part of code while\ndoing so.\n\nThe sub pass [place_frames] determines where stack frames should be allocated.\nIn the example, block 0 needs a stack frame.\n\nThe sub pass [find_yregs] determines which variables that are to be\nplaced in Y registers. The result will be a `yregs` annotation added\nto each block that allocates a stack frame. For this example, the\nannotation will look like:\n\n<pre class=\"highlight\">\n    %% #{frame_size => 1,<b>yregs => [0]</b>}\n</pre>\n\nVariable `_0` is `C` from the Erlang code. It needs to be saved across the\ncall to `lists:sum/1`.\n\nThe sub pass [reserve_yregs] uses the `yregs` annotations and inserts `copy` instructions\nto copy each variable that needs saving to a new variable. For the example,\nthe following instruction will be added\n\n```\n  [1] y0/_0:4 = copy x0/_0\n```\nIt copies the value of `_0` to `_0:4`.\n\nThe sub pass [number_instructions] numbers all instructions as a preparation for register\nallocation. In the listing, those numbers are in brackets before each instruction:\n`[1]`, `[3]`, `[5]`, and so on.\n\nThe sub pass [live_intervals] calculates the intervals in which each variable is live.\nIn the listing, the live intervals are shown as comments before the definition\nof the variable:\n\n```\n  %% _0:4: 1..5\n  [1] y0/_0:4 = copy x0/_0\n```\n\nThe variable `_0:4` is live from instruction `[1]` (its definition) to\n`[5]` (its last use).\n\nThe sub pass [linear_scan] uses the [linear scan][linear_scan_polleto] algorithm\nto allocate registers for each variable. The result is saved as annotation\nfor the function. In the listing of the SSA code, the register will be added\nto the definition and each use of a variable. For example:\n\n```\n  [1] y0/_0:4 = copy x0/_0\n```\n\nVariable `_0` (the argument `L`) is in `{x,0}`. Its copy in `_0:4` is in\n`{y,0}`.\n\nBut what is `z0`?\n\n<pre class=\"highlight\">\n      [7] <b>z0</b>/@ssa_bool = succeeded x0/_3\n      [9] br <b>z0</b>/@ssa_bool, label 3, label 1\n</pre>\n\n`succeeded` is not a BEAM instruction. It will be combined with the previous\ninstruction (`bif:+` in this example) and the `br` instruction that follows it\nto the following BEAM instruction:\n\n    {gc_bif,'+',{f,0},1,[{y,0},{x,0}],{x,0}}.\n\nThus, the value `@ssa_bool` is never explicitly stored in a BEAM\nregister.  Before I invented Z registers, `@ssa_bool` would have been\nassigned to an X register.  That worked most of the time, but sometimes\nan X register would seem to be occupied when it was not, and prevent\nanother instruction from using that register.\n\nHere are the [references that I used when implementing linear scan][linear_scan_references].\n\nThe sub pass [frame_size] uses the information from the linear scan pass to calculate the size\nof each stack frame. The result is stored as an annotation:\n\n<pre class=\"highlight\">\n    %% #{<b>frame_size => 1</b>,yregs => [0]}\n</pre>\n\n[place_frames]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L715\n\n[find_yregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1114\n\n[reserve_yregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1645\n\n[number_instructions]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1487\n\n[live_intervals]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1515\n\n[linear_scan]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L2118\n\n[frame_size]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1741\n\n### beam_ssa_codegen\n\nThe [`beam_ssa_codegen`][beam_ssa_codegen] pass generates BEAM code\nfrom the annotated SSA code. Testing of this pass was easier, because\nI could compile some sample code and try to run it.\n\nOften I did not even have to run the code to know that it was wrong.\nThe compiler would tell me, loudly:\n\n{% raw %}\n```\nblog: function bar/2+4:\n  Internal consistency check failed - please report this bug.\n  Instruction: {test_heap,2,3}\n  Error:       {{x,2},not_live}:\n```\n{% endraw %}\n\nIt's time to introduce the `beam_validator` pass.\n\n#### beam_validator\n\nThe [`beam_validator`][beam_validator] pass was introduced in one of\nthe R10B releases (probably in 2006). It is run directly before the\nBEAM code is packaged into a binary and written to a BEAM file. The\npurpose of `beam_validator` is to find unsafe instructions that\ncould crash the runtime system or cause it to misbehave in other\nways.\n\nLet's look at a simple example:\n\n```erlang\nbar(H, T) ->\n    [H|T].\n```\n\nHere is the BEAM code, but edited by me to contain an unsafe instruction:\n\n<pre class=\"highlight\">\n      {label,4}.\n        {test_heap,2,<b>3</b>}.\n        {put_list,{x,0},{x,1},{x,0}}.\n        return.\n</pre>\n\nThe number of live registers is here given as `3` instead of `2`.\nThat means that `{x,0}`, `{x,1}`, and `{x,2}` are supposed to contain\nvalid Erlang terms. Because `bar/2` is only called with two arguments,\n`{x,2}` can contain any old garbage.\n\nWhen running this code, it could crash the runtime system, or it could\nbe completely harmless. It depends on whether there will be a garbage\ncollection during execution of the `test_heap` instruction, and on the\nexact nature of the garbage in `{x,2}`. For example, if the garbage\nhappens to be an atom nothing bad will happen. That means that this\ntype of compiler bug is difficult to reliably catch in a test case.\n\n`beam_validator` will find this bug immediately. It keeps track of\nwhich registers are initialized at any point in the function. If it\nfinds a reference to a register that is not initialized it will\ncomplain:\n\n{% raw %}\n```\nblog: function bar/2+4:\n  Internal consistency check failed - please report this bug.\n  Instruction: {test_heap,2,3}\n  Error:       {{x,2},not_live}:\n```\n{% endraw %}\n\n#### Friend and foe\n\nDuring the implementation of `beam_ssa_codegen`, the `beam_validator`\npass pointed out many bugs for me. It was my friend.\n\nIt was also my foe, sort of. It would complain that some perfectly safe\ncode was unsafe. When that happened, I had to thoroughly investigate the\ncode to make doubly sure it was safe, and then extend `beam_validator`\nto make it smarter so that it would understand that the code was safe.\n\nHere is one example where I had to make `beam_validator` smarter.\nConsider this code:\n\n    {move,{x,0},{y,0}}.\n    {test,is_map,{f,777},[{x,0}]}.\n    {put_map_assoc,{f,0},{y,0},...}.\n\nThe `move` instruction stores a copy of `{x,0}` in `{y,0}` (a location\non the stack). The following `test` instruction tests whether `{x,0}`\nis a map and branches to label 777 if not. The `put_map_assoc` instruction\nupdates the map in `{y,0}`.\n\nThe `put_map_assoc` instruction will crash if its source argument is\nnot a map.  Therefore, `beam_validator` complains if `put_map_assoc` is\nused with a source argument that is not a map. In this example,\n`beam_validator` had not seen a `test` instruction that ensured that\n`{y,0}` was a map, so it complained. It is obvious (for a human) that\n`{y,0}` is a map because it is a copy of `{x,0}`, which is a map.\n\n`v3_codegen` never generated such code; in fact, it explicitly\n[avoided generating such code][v3_codegen_kludge].\nI did not want to add similar kludges to the new code generator, so\n[`beam_validator` had to become smarter][beam_validator_maps].\n\n[v3_codegen_kludge]: https://github.com/erlang/otp/blob/64422fcac9c602641dcf24ef2d35e3491376304d/lib/compiler/src/v3_codegen.erl#L1600\n\n#### Unsafe optimization passes\n\nSome of the unsafe code that `beam_validator` found was really unsafe,\nbut it was not the fault of my new compiler passes, but of the\noptimization passes that optimized the generated BEAM code.\n\nThe problem was that some of the optimization passes had implicit\nassumptions of the kind of code that `v3_codegen` would generate\n(or, rather, would **not** generate). The new code generator broke\nthose assumptions.\n\nAt first, when I saw those bugs, I removed the broken part of the\noptimization pass. Making the optimizations safe would be non-trivial\nand ultimately wasted work because we intended to rewrite all those\noptimization passes to work on SSA code.\n\nWhen I have seen a few too many of those unsafe optimizations, [I ripped\nout all of the unsafe optimization passes][unsafe_passes].\n\nThat meant that we would have to re-implement all of the optimizations\nbefore the generated code would be as good as the code from the old\ncompiler. I had also noticed that the new BEAM code generator in a\nfew ways generated better code than the old one, but in other ways the\ncode was worse. For example, the generated code used more stack space and\ndid a lot of register shuffling. Eventually, that had to be addressed in\nsome way.\n\nMeanwhile, I had worse problems to worry about.\n\n## March 2018\n\nOn March 14 I presented my progress on the new compiler passes for\nthe OTP team. One of my slides had the following text:\n\n> * Can compile all modules in OTP (and run many of them correctly)\n\nYes, I had finished the initial implementation of `beam_ssa_codegen`\nso that I could compile all code in OTP.\n\nThe problem that I only at hinted in the slide was that Erlang could\ncrash and dump core when running test suites. Not every time, and\nnever in the same test case twice. It only happened when I have\ncompiled OTP with the new compiler.\n\nThe crash didn't seem related to the test cases themselves, but to the\nwriting of log files. I soon narrowed it down to that the crash could\nhappen if [`file_io_server`][file_io_server] had been compiled with\nthe new compiler passes. However, that was not much help. The module\ncontains complicated code that uses the binary syntax, `try`/`catch`,\nand `receive`, all of which are complicated instructions that might\nnot be correctly translated by the new compiler passes.\n\n`beam_validator` was supposed to catch those kinds of bugs before\nthey can cause a crash. Either there was some kind of bug that\n`beam_validator` didn't look for, or there was a bug in the\nimplementation of some of the instructions in the BEAM interpreter.\n\nI ended up spending the rest of March trying to hunt down that bug.\n\n[file_io_server]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/kernel/src/file_io_server.erl\n\n## April 2018\n\nAt the beginning of April, the bug still eluded me. I had narrowed\nit down somewhat. I was pretty sure it had something to do with\n`receive`.\n\nThen [Rickard] gave me some information that I could connect to another\npiece of information that I had absorbed during my hunt for the bug.\n\n### The bug\n\nThis section is somewhat advanced, and if you wish you can\nskip to [the fix](#the-fix).\n\nReading about the [Erlang Garbage Collector][lukas_gc] can give some\nbackground to better understand this section.\n\nRickard reminded me about the `message_queue_data` option that\nhad been added to [`process_flag/2`][process_flag] in OTP 19. After\ncalling `process_flag(message_queue_data, off_heap)` all messages\nthat have not yet been received would be stored outside the process\nheap. Storing the messages outside the heap means that the garbage\ncollector doesn't have to spend time copying the unreceived messages\nduring garbage collection, which can be a huge win for processes that\nhave many messages in its message queue.\n\nThe implementations details of messages outside the heap are\ncrucial. Consider this selective `receive`:\n\n```erlang\nreceive\n    {tagged_message,Message} -> Message\nend.\n```\n\nWhen the BEAM interpreter executes this code, it will retrieve a\nreference message from the external message queue and match it against\nthe tuple pattern. If the message does not match, the next message\nwill be processed in the same way, and so on.\n\nIf a message does not match, there **must not** be any remaining\nreferences to it stored on the stack. The reason is that if there is a\ngarbage collection, the garbage collector will copy the message (or\npart of the message) to the heap, and, even worse, it will destroy the\noriginal message during the copy operation. The message is still in\nthe external message queue, but it has now been corrupted by the\ngarbage collector. If the message is later matched out in a `receive`,\nit will likely cause a crash.\n\nWhen Rickard first implemented off-heap messages, he asked me whether\nthe compiler could ever store references to unreceived messages\non the stack. I assured him that it could not happen.\n\nYes, that was true, it could not happen because of the way\n`v3_codegen` generated the code for `receive`.\n\nWith the new compiler passes, [it **could** happen][bad_receive]. When\nI first discussed the bug with Richard in March, he did mention that\nit is forbidden to store references to off-heap messages on the\nstack. At that time, I was not aware that the compiler could store\nreferences to off-heap messages on the stack.\n\nWhen Rickard reminded me about that for the second time in April, I remember\nseeing during my bug hunt generated code that stored off-heap message\nreferences on the stack.\n\n[rickard]: https://github.com/rickard-green\n[process_flag]: http://erlang.org/doc/man/erlang.html#process_flag-2\n[lukas_gc]: https://github.com/erlang/otp/blob/OTP-21.0.9/erts/emulator/internal_doc/GarbageCollection.md\n[bad_receive]: https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/test/beam_validator_SUITE_data/receive_stacked.S#L22\n\n### The fix\n\nAfter finding the reason for the bug, I first taught `beam_validator`\nto [complain about \"fragile references\" on the stack][beam_validator_fragile].\nI included that commit in OTP 21.\n\nI then added a sub pass to `beam_ssa_pre_codegen` to [rewrite `receive`][receive_fix].\nIt introduces new variables and `copy` instructions to ensure that\nany references to the message being matched are kept in X registers.\n\nWith no known bugs in the code generator, I could start rewriting the optimization\npasses I had removed.\n\n[receive_fix]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L919\n\n### More optimizations\n\n#### beam_ssa_recv\n\n[`beam_ssa_recv`][beam_ssa_recv] is a replacement for the unsafe\n[`beam_receive`][beam_receive] pass.  The purpose is to optimize a\n`receive` that can only match a newly created reference.  The\noptimization avoids scanning the messages that were placed in the\nmessage queue before the reference was created.\n\nI actually wrote `beam_ssa_recv` at the beginning of March as an\nexperiment to see how easy it would be to write optimizations of SSA code.\nIt turned out to be pretty easy. `beam_ssa_recv` can apply the optimization\nin more places than `beam_receive` could, using slightly less code.\n\nIn the old `beam_receive` pass, a lot of code is needed to handle\nthe many variants of BEAM instructions. For example, in\n[`opt_update_regs/3`][beam_ssa_recv_opt_update_regs] there are three\nclauses just to handle three variants of a `call` instruction (calling\na local function, calling an external function, and calling a fun).\n\nHere is an example of a function that `beam_receive` did not optimize, but\n[`beam_ssa_recv` can optimize][yes_14].\n\n[beam_receive]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_receive.erl\n[beam_ssa_recv]: https://github.com/erlang/otp/blob/367f4a3fabb12cda3f2547e9908acbf28cb34e3a/lib/compiler/src/beam_ssa_recv.erl\n[beam_ssa_recv_opt_update_regs]: https://github.com/erlang/otp/blob/333e4c5a1406cdeb9d1d5cf9bf4a4fadb232fca8/lib/compiler/src/beam_receive.erl#L185\n[yes_14]: https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/test/receive_SUITE_data/ref_opt/yes_14.erl\n\n#### beam_ssa_opt\n\nThe [`beam_ssa_opt`][beam_ssa_opt] pass runs a [number of\noptimizations][beam_ssa_opt_passes]. Many of the optimizations are replacements\nfor the optimizations I removed earlier.\n\n[beam_ssa_opt]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl\n\n[beam_ssa_opt_passes]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_opt.erl#L49\n\n#### beam_ssa_type\n\n[`beam_ssa_type`][beam_ssa_type] replaces the unsafe [`beam_type`][beam_type] pass.\n\nThe `beam_type` pass did a local type analysis (basically for extended basic blocks),\nand tried to simplify the code, for example by removing unnecessary type tests.\n\nThe `beam_ssa_type` pass analyzes the types in an entire function and\nsimplifies the code, for example by removing unnecessary type\ntests. It finds many more opportunities for optimizations than\n`beam_type` did.\n\n[beam_ssa_type]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl\n\n## May 2018\n\nAt the beginning of May, [John][john] started working on what was to become\nthis pull request:\n\n[#1958: Rewrite BSM optimizations in the new SSA-based intermediate format][pr1958]\n\nI continued to write optimizations and fix bugs that John found while\ndeveloping his optimizations.\n\n### Rethinking the binary matching instructions\n\nWhile working on his binary optimizations, John realized that the SSA\ninstructions for binary matching were difficult to optimize. The\nbinary match instructions I had designed were close to the semantics\nof the BEAM instructions. John suggested that the `bs_get` instruction\nshould be broken up into a `bs_match` instruction and a `bs_extract`\ninstruction to simplify optimizations.\n\nThe breaking up of the instructions meant that [`beam_ssa_pre_codegen`\nwould have to work harder to combine\nthem][beam_ssa_pre_codegen_fix_bs], but it vastly simplified John's\noptimizations. It turned out that it also enabled other optimizations:\nthe [liveness optimizations][beam_ssa_opt_live] could remove unused\ninstructions more aggressively.\n\n[beam_ssa_pre_codegen_fix_bs]: https://github.com/erlang/otp/blob/master/lib/compiler/src/beam_ssa_pre_codegen.erl#L209\n[beam_ssa_opt_live]: https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L777\n\nOn the first day of [Code BEAM STO 2018][code_beam_2018] May 31, I didn't\nknow of any bugs in the new compiler passes and my list of optimizations to\nre-implement was shrinking steadily. I met [Michał Muskała][michal]\n(a frequent contributor to Erlang/OTP and a member of the\n[Elixir Core Team][elixir_core_team]) there and told him about my work\non the compiler and that it was stable enough be tested outside OTP,\nfor example to compile Elixir code...\n\n[pr1958]: https://github.com/erlang/otp/pull/1958\n[code_beam_2018]: https://codesync.global/conferences/code-beam-sto-2018/\n[elixir_core_team]: https://elixirforum.com/groups/Elixir-Core-Team\n\n## June 2018\n\n### Michał's feedback\n\nI received an email from Michał in the middle of June. He had tried out\nmy compiler branch. He wrote:\n\n> First impression is that it took a loooong time to compile Elixir's unicode module,\nso long that I had to shut it down after about 10 minutes.\n\nHe sent me an Erlangified version of [Elixir's unicode module][elixir_unicode].\nThe size of the Erlang source for the module was almost 82,000 lines or\nabout 3,700,000 bytes. Based on the size, compilation could be expected to be\na little bit slow, but not that slow. On his computer, OTP 21.0-RC2 finished\nthe compilation in 16 seconds.\n\nI compiled the module using the `time` option. The slowest pass was `beam_ssa_type`.\nAfter some further profiling, I found the bottleneck in the joining of two maps.\nHere is the [corrected code][beam_ssa_type_bottleneck]. The original code didn't compare\nthe size of maps and swap them as needed. I might have done some other improvements,\ntoo. Anyway, that took care of that bottleneck. Now `beam_ssa_pre_codegen` was the\nslowest pass.\n\nI fixed several bottlenecks in the [linear scan sub pass][linear_scan], and after\nthat some other bottleneck in `beam_ssa_pre_codegen`. I think that reduced the\ncompilation time to well under one minute.\n\n[beam_ssa_type_bottleneck]: https://github.com/erlang/otp/blob/81d34181d391709e9d2c404fa730ee9b5c72b5e3/lib/compiler/src/beam_ssa_type.erl#L944\n\n### Optimizing code generation\n\nAfter having finished the re-implementation of the last optimization\npass (I think it was the [optimization of floating point\noperations][beam_ssa_opt_float], as previously done by the unsafe\n[`beam_type`][beam_type] pass), I started to compare the code\ngenerated by OTP 21 with code from the new compiler passes.\n\nI used [scripts/diffable][diffable], which compiles about 1000\nmodules from OTP to BEAM code and massages the BEAM code to make it more friendly\nfor diffing. I then ran `diff -u old new` to compare the new code to\nthe old code.\n\nIn the last part of June and the first week of July, I then improved\n`beam_ssa_pre_codegen` and `beam_ssa_codegen` to address the issues that I\nnoticed when reading the diff.\n\n#### `beam_ssa_pre_codegen` improvements\n\nI did not change the [linear scan][linear_scan] sub pass of `beam_ssa_pre_codegen`\nitself. Instead I added transformations of the SSA code that would help\nlinear scan do a better job of allocating registers.\n\nThe most obvious issue I noticed was unnecessary `move` instructions.\nHere are two of the sub passes I added to address that issue:\n\n* [reserve_xregs] gives hints to the linear scan sub pass that a\ncertain X register should be used for a certain variable, if possible.\n\n* [opt_get_list] tries to eliminate the extra `move` instruction that\nis frequently added when matching out elements from a list.  See the\ncomments in the code for an example and an explanation.\n\nAnother frequent issue was that the code generated from the new code\ngenerator used more stack space because two variables that were not\nstrictly live at the same time were allocated different Y registers\n(slots on the stack) instead of re-using the same Y register. I addressed\nthat issue in [copy_retval]. See the comments in the code for an example.\n\n#### `beam_ssa_codegen` improvements\n\nMichał noticed that when a value was stored in both an X register and\na Y register (on the stack), instructions using the value would\nalways use the Y register. The old code generator would use the X\nregister.  The new code could be slower because the BEAM interpreter\nis generally optimized for operands being in X registers.\n\nI added [prefer_xregs] to address that issue. See the comments in the code\nfor examples.\n\n[reserve_xregs]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1916\n[copy_retval]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1222\n[opt_get_list]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L1422\n\n[prefer_xregs]: https://github.com/erlang/otp/blob/7fbb86c77fa99caddabedfb992f47ddeece80652/lib/compiler/src/beam_ssa_codegen.erl#L359\n\n[beam_type]: https://github.com/erlang/otp/blob/OTP-21.0.9/lib/compiler/src/beam_type.erl\n\n[beam_ssa_opt_float]: https://github.com/erlang/otp/blob/e6c3dd9f701d354c06b9b1b043a3d7e9cc050b1c/lib/compiler/src/beam_ssa_opt.erl#L517\n\n## July 2018\n\nVacation.\n\n## August 2018\n\nBefore I left for vacation, it seemed that the new compiler passes generally\ngenerated code at least as good as the old compiler passes. In some cases,\nthe code would be much better.\n\nBack after my vacation, I did some final polishing.\n\nOn Aug 17 I created a [pull request][pr1935].\n\nBefore merging the pull request, I sneaked in a few final optimizations.\n\nOn Aug 24 I [merged][merged_ssa] the pull request.\n\n[merged_ssa]: https://github.com/erlang/otp/commit/9facb02b91979ef90b47ac0a54d1eb71fdaa1ee1\n\n[beam_ssa_pre_codegen]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl\n[beam_ssa_codegen]: https://github.com/erlang/otp/blob/ec1f35c9f52be894ba295b9a48237020855e3c46/lib/compiler/src/beam_ssa_codegen.erl\n[beam_validator]: https://github.com/erlang/otp/blob/e2a939dc4d23d75a0588722d0a08aef129b4c0be/lib/compiler/src/beam_validator.erl\n\n[v3_kernel_bug]: https://github.com/erlang/otp/commit/c896f08f5c028b1e31290e6a5502597401acd39f\n[beam_validator_fragile]: https://github.com/erlang/otp/commit/90853d8e7b50be13a3b71f4a1ed6b0407e1f7c2f\n[unsafe_passes]: https://github.com/erlang/otp/commit/3fc40fd57fa01b097b4c363860c4d4762e13db8b\n[beam_validator_maps]: https://github.com/erlang/otp/commit/1f221b27f1336e747f7409692f260055dd3ddf79\n\n[john]: https://github.com/jhogberg\n[lukas]: https://github.com/garazdawi\n[michal]: https://github.com/michalmuskala\n\n[elixir_unicode]: https://github.com/elixir-lang/elixir/blob/54cb02c2407856f4063c75a440507dacb6a31dbc/lib/elixir/unicode/unicode.ex\n[diffable]: https://github.com/erlang/otp/blob/master/scripts/diffable\n\n[pr1935]: https://github.com/erlang/otp/pull/1935\n\n[bin_matching]: http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries\n\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form\n\n[kernel]: http://blog.erlang.org/beam-compiler-history#r6b-enter-kernel-erlang\n\n[beam_bsm]: https://github.com/erlang/otp/blob/2e40d8d1c51ad1c3d3750490ecac6b290233f085/lib/compiler/src/beam_bsm.erl\n\n[software_smoke_testing]: https://en.wikipedia.org/wiki/Smoke_testing_(software)\n\n[beam_kernel_to_ssa_finalize]: https://github.com/erlang/otp/blob/6bee2ac7d11668888d93ec4f93730bcae3e5fa79/lib/compiler/src/beam_kernel_to_ssa.erl#L1231\n\n[dialyzer]: http://erlang.org/doc/apps/dialyzer/index.html\n\n[linear_scan_polleto]: http://web.cs.ucla.edu/~palsberg/course/cs132/linearscan.pdf\n[linear_scan_references]: https://github.com/erlang/otp/blob/494cb3be4a98653c212d673008085bc3ea70dc7e/lib/compiler/src/beam_ssa_pre_codegen.erl#L52\n\n## The Future\n\nThe SSA-based intermediate representation provides a solid framework for\nfuture improvements of the compiler. After the merging of the pull request in\nAugust, several pull requests have already added further improvements:\n\n* [Introduce a put_tuple2 instruction][pr1947]\n\n* [Replace beam_dead with beam_ssa_dead][pr1955]\n\n* [Rewrite BSM optimizations in the new SSA-based intermediate format][pr1958]\n\n* [Clean up variable-related cruft in new SSA passes][pr1959]\n\n* [beam_validator: Use set_aliased_type in more operations][pr1960]\n\n* [Minor cleanups and bug fixes of the compiler][pr1965]\n\nHere is a list of possible further improvements that could be implemented either\nby OTP members or external contributors before OTP 22 is released:\n\n* Rewrite `sys_core_dsetel` to be SSA-based.\n\n* Rewrite the guard optimizing sub pass `guard_opt/2` in `v3_kernel`\n  to an SSA-based optimization pass.\n\n* Rewrite `beam_trim`. It would probably have to be a part of `beam_ssa_codegen`.\n\n* Optimize `switch` branches. If two branches jump to blocks\n  that do the same thing, let both branches jump to the same\n  block. `beam_jump` does this kind of optimization, but doing it\n  earlier in the SSA representation could speed up compilation of functions\n  with many clauses.\n\n* Get rid of the `beam_utils` module, especially the `is_killed()` and\n  `is_not_used()` family of functions. The functions in `beam_utils`\n  used by `beam_jump` could be moved into `beam_jump`.\n\n* Rewrite `beam_bs` to be SSA-based. This rewrite might not improve\n  the generated code, but it might speed up compilation of modules\n  with heavy use of the binary syntax.\n\n[pr1947]: https://github.com/erlang/otp/pull/1947\n[pr1955]: https://github.com/erlang/otp/pull/1955\n[pr1959]: https://github.com/erlang/otp/pull/1959\n[pr1960]: https://github.com/erlang/otp/pull/1960\n[pr1965]: https://github.com/erlang/otp/pull/1965\n"}},"__N_SSG":true}