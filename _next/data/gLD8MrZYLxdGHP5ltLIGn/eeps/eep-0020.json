{"pageProps":{"index":{"id":"0020","content":"<pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-4\nCreated: 05-Aug-2008\nPost-History:\n</code></pre>\n\n<hr />\n\n<h2><a href=\"/eeps/eep-0000\" title=\"EEP Index\">EEP</a> 20: <a href=\"eep-0020.md\" title=\"EEP Source\"> Split the atoms!</a></h2>\n\n<h1>Abstract</h1>\n\n<p>An idea from the Logix implementation of Flat Concurrent Prolog\ncan be adapted to Erlang:  invisibly to users there can be two\nimplementations of 'atoms', fixing a major system integrity\nissue and removing the need to warp one's data structure design\nto code around it.</p>\n\n<h1>Specification</h1>\n\n<p>There are no user-visible changes to the Erlang language or\nlibraries.  Interfaces between Erlang and other languages such\nas C may need to be changed.</p>\n\n<p>We split atoms into two classes:  \"global\" atoms are those atoms\nwhich either appear in the post-preprocessing text of some loaded\nmodule or are the registered name of any process; \"local\" atoms\nare all others which a process creates.</p>\n\n<p>A local atom is represented by a data structure SUCH AS</p>\n\n<pre><code>+----------+\n| size+tag |    boxed object header; see below\n+----------+\n| hashcode |    a 32-bit hash code\n+----------+\n| equivrep |    points to Union/Find representative\n+----------+\n| bytes of |\n| name ... |\n+----------+\n</code></pre>\n\n<p>As usual, the size+tag contains a 2 bit tag to say it is an\nIMMED2 object, a 4-bit subtag to say what kind (I propose\n1011), and a 26-bit arity.  However, the arity field is\nsplit into two subfields:</p>\n\n<pre><code>+--------------+------------+----+--+\n|  byte count  | char count |LATM|BX|\n+--------------+------------+----+--+\n             14           12    4   2   size in bits\n</code></pre>\n\n<p>The char count says how many Unicode characters there are in\nthe name.  The byte count says how many bytes those characters\nare stored in.  For compactness and backwards compatibility,\nan atom whose name consists only of Latin-1 characters has\nbyte count = char count and name represented as Latin-1; atoms\nwith names outside that range are held in some other form\n<em>such as</em> UTF-8, SCSU, BOCU, or what have you.  This proposal\nis not specifically about encoding schemes; all I have to say\nhere is that it should be the same for all atoms and it should\nbe at least as good as UTF-8.</p>\n\n<p>The hash code field is a 32-bit hash code.  Again, I have\nnothing to say about atom hashes as such except to say that\nthe method should be the same for all atoms in all processes\non a node and that it should be a good one.  Advice about\ngood hashing functions is hard to find.  <code>hashpjw()</code> can be\nimproved on.  I heartily recommend <a href=\"http://www.lulu.com/content/1455536\" title=\"Hashing in Smalltalk: Theory and Practice, AndrÃ©s Valloud\">Valloud's book</a>.</p>\n\n<p>The equivrep field is a pointer.  It always points to an atom,\nwhich may be a global atom or a local atom.  Initially, it points\nto the local atom itself.  When a local atom is compared with\nanother local atom,</p>\n\n<ul>\n<li>first,   check the header fields to see if they match</li>\n<li>second,  check the hash codes to see if they match</li>\n<li>finally, check the bytes of the names.</li>\n</ul>\n\n<p>But this is also combined with Union/Find, very much like\nbinding variables in Prolog.  So we \"dereference\" (chase the\nequivrep fields) after the second step, and if we end up at\nthe same place, the two local atoms are equal.  And if two\nphysically distinct local atoms do turn out equal, we make\nthe younger one (the one most recently created) point to the\nolder one.</p>\n\n<p>Global atoms should have a similar representation; I suggest that\nthe representation of a local atom should be embedded in the\nrepresentation of a global atom, so that local atoms can be\ncompared with global atoms as if they were both local.</p>\n\n<p>Atoms returned by <code>list_to_existing_atom/1</code> are always global atoms.\nAtoms returned by <code>list_to_atom/1</code> or <code>binary_to_term/1</code> are global\natoms if and only if they are already existing global atoms,\notherwise they are local atoms.</p>\n\n<p>Interfaces provided to other languages, such as C or Java, should\nleave existing atom-creation operations returning global atoms,\nand should add operations for creating local atoms.</p>\n\n<p>When a process is garbage collected, a pointer to a local atom is\nreplaced by that local atom's equivrep, so that processes that\nhave ever noticed they have duplicate local atoms don't keep them\nforever.</p>\n\n<h1>Motivation</h1>\n\n<p>There are a number of problems that limit the usefulness\nof Erlang atoms.</p>\n\n<p>The first is that atom size is limited to 255 bytes,\nwhich makes Erlang atoms of very little use for file names,\nas C's <code>FILENAME_MAX</code> is typically 1024 these days.</p>\n\n<p>The second is that atoms are limited to Latin-1 characters.\nWe really do want full Unicode support for them, not so\nmuch for programmers to write atoms in strange scripts in\ntheir source code as to allow information to flow <em>through</em>\nan Erlang system as atoms.</p>\n\n<p>Those two are minor problems.</p>\n\n<p>The major problem is the atom table.</p>\n\n<p>It is a global resource, which means that on an SMP system\nthere has to be a lot of locking and unlocking.  This proposal\ndoesn't include a new \"always return a local atom\" operation,\nbut it creates the possibilities for new operations like that\nwhich require no locking.</p>\n\n<p>The atom table is limited, in atom.c, to <code>ATOM_LIMIT=1024*1024</code>\nentries.  Even on a 32-bit system, this is smaller than a\nmachine could support; it is an arbitrary limit, and such limits\nare always a problem.</p>\n\n<p>The atom table is not garbage collected.  Once an atom has been\ncreated, it says created.  Historic Prolog systems, like Quintus\nProlog, did the same thing.  Back in 1984 this was recognised as\na problem, especially for programs that wanted to access large\nvolumes of stored data.  Modern Prolog systems, like SWI Prolog,\ndo collect atoms; SWI Prolog would not be nearly so useful for\nmanipulating large collections of RDF data if it were otherwise.\nThis proposal does not add garbage collection for the atom table;\nwhat it does is to stop most of the atoms that would have been\ncollected ever entering that table in the first place.</p>\n\n<p>Filling up the atom table crashes or hangs the entire node.</p>\n\n<p>This means that it is far too easy to crash or hash Erlang\nsoftware by feeding it too many atoms.</p>\n\n<p>And <em>that</em> means that Erlang programmers who would like to use\natoms in data structures (as keys in dictionaries, say) use\nbinaries instead: binaries are not limited in size or number,\ncan hold UTF-8 if you want them to, are garbage collected, and\nare generally safer to use.</p>\n\n<p>While this proposal makes atoms more <em>convenient</em> to use (they\nmay be longer, more numerous, and may contain Unicode), the\nreal point is to make atoms <em>safer</em> to use.  If you can\nstream data from source through an Erlang process, mapping\nexternal \"strings\" to binaries, you will be able to do the\nsame thing just as safely mapping them to atoms.</p>\n\n<h1>Rationale</h1>\n\n<p>Erlang is not the first language to face these problems.\nIt isn't even the first concurrent language to face them.\nFlat Concurrent Prolog was there first, and while I have\nnot seen the Logix source code, the idea was explained in\nLogix documentation many years ago.  I know this <em>can</em>\nwork because it <em>did</em> work.</p>\n\n<p>Logix used this approach for all atoms; eventually, I\nbelieve Erlang will need to as well in order to handle\nthousands of processors without lots of locks.  Right now,\nit makes sense to keep on using the old representation for\nfairly \"static\" atoms.  In particular, we would like module\nand function names (and frame keys when we have them) to be\njust the way they are now.  If an application is loaded after a\nlocal atom has been created, we may find that it is a module\nname or function name after all; this is one of the reasons\nfor the equivrep field.  Once it's noticed, the duplication\nwon't survive another garbage collection.</p>\n\n<p>The current 'global atom' representation has a hack to make\nterm comparison faster.  For simplicity I have not described\nit above, because that's orthogonal to the issues this EEP is\nconcerned with.  I note (a) that for the ord0 field to\ncontinue in its present form, the encoding would best be\nUTF-8 or BOCU, and (b) to keep the compactness of the Latin-1\natoms, the ord0 field should be the first 31 bits that <em>would</em>\nhave been stored had the atom been stored in whichever of\nUTF-8 or BOCU is chosen.  I also note (c) that if you don't\nallow \"native\" byte ordering to dictate the order in which the\nbytes of an atom's name are stored, you don't <em>need</em> a special\nord0 field.</p>\n\n<p>I should confess that this proposal doesn't <em>entirely</em> avoid the\ncrashes and hangs problem.  If an Erlang system can be persuaded\nto load modules from an untrustworthy source, it can still be\nmade to try to create enough atoms to get into trouble.  This is\none of the reasons that I think Erlang will eventually have to\nabandon the global atom table.  However, anyone who loads modules</p>\n\n<p>from untrustworthy sources should KNOW they are doing that; it is\nan obviously dangerous thing to do.  <code>list_to_atom/1</code> is NOT an\nobviously dangerous function, and it should not be any more\ndangerous than <code>list_to_binary/1</code>.</p>\n\n<h1>Backwards Compatibility</h1>\n\n<p>No existing code (outside the Erlang implementation)\nshould be affected in the slightest.</p>\n\n<h1>Reference Implementation</h1>\n\n<p>None.  The change is simple in concept, but affects several\natoms in the core of the system.</p>\n\n<h1>Copyright</h1>\n\n<p>This document has been placed in the public domain.</p>\n"}},"__N_SSG":true}