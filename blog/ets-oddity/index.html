<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" as="script"/><link rel="preload" href="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" as="script"/><link rel="preload" href="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12"><h3 class="sub-headlines"><img src="/img/news.png"/><span style="position:relative;top:5px;left:20px">NEWS</span></h3></div><div class="col-lg-2"><p></p></div><div class="col-lg-8"><div class="inside-cols"><h3><a href="/blog/ets-oddity/">ETS oddity</a></h3><p><em>Monday, 7 January 2019<!-- --> - <!-- -->Lukas Larsson</em></p><p>When working with the implementation of the new <a href="https://github.com/erlang/otp/pull/1952">scalable ordered_set</a>
we came across a strangeness with the guarantees when iterating over a table
while inserting elements in parallel.</p><h3>Scenario:</h3><pre><code>&gt; Tab = ets:new(test_table,
                [set, public, {write_concurrency, true}]).
#Ref&lt;0.1705802953.985792516.98626&gt;
&gt; P1 = spawn(fun() -&gt;
               ets:insert(Tab, {fir, 1}),
               ets:insert(Tab, {sec, 2})
             end).
&gt; K1 = ets:first(Tab), K2 = ets:next(Tab, K1).</code></pre><p>What are the theoretical possible values of <code>K1</code> and <code>K2</code>? Let us first list the obvious:</p><ul><li><code>K1 = fir</code>, <code>K2 = sec</code> - both values inserted and found in term order</li><li><code>K1 = sec</code>, <code>K2 = fir</code> - since this is a <code>set</code>, the hash algorithm may put <code>sec</code> before <code>fir</code></li><li><code>K1 = fir</code>, <code>K2 = &#x27;$end_of_table&#x27;</code> - only <code>fir</code> had time to be inserted</li><li><code>K1 = &#x27;$end_of_table&#x27;</code>, <code>K2 = badarg</code> - no elements were inserted</li></ul><p>However it is also possible to get:</p><ul><li><code>K1 = sec</code>, <code>K2 = &#x27;$end_of_table&#x27;</code></li></ul><p>This was, at first, very counter-intuitive to me. How can the <code>ets:first/1</code> find the
second value inserted, but then when iterating not find the value inserted before it?</p><p>The answer can be found in the way that the <code>write_concurrency</code> functionality is
implemented. Imagine we have a <a href="https://en.wikipedia.org/wiki/Hash_table">hash table</a>
where each bucket is protected by a mutex. When inserting a new element the mutex for
the current bucket has to be taken and when iterating over the hash table we take
each mutex in turn for the buckets we iterate through.</p><h3>Initial Table:</h3><p>| Bucket #      | Values        |
| ------------- | ------------- |
| 1             | <code>[]</code>          |
| 2             | <code>[]</code>          |
| 3             | <code>[]</code>          |
| 4             | <code>[]</code>          |</p><h3>Finished Table:</h3><p>| Bucket #      | Values        |
| ------------- | ------------- |
| 1             | <code>[{fir,1}]</code>   |
| 2             | <code>[]</code>          |
| 3             | <code>[]</code>          |
| 4             | <code>[{sec,2}]</code>   |</p><p>So, in the scenario that leads to the strange behaviour the following will happen:</p><ul><li><code>ets:first/1</code> is called when the table is empty and iterates to Bucket #2.</li></ul><p>| Bucket #      | Values        |
| ------------- | ------------- |
| 1             | <code>[]</code>          |
| 2 (first)     | <code>[]</code>          |
| 3             | <code>[]</code>          |
| 4             | <code>[]</code>          |</p><ul><li>The OS does a context switch and P1 is allowed to run.</li><li>P1 inserts both <code>{fir,1}</code> and <code>{sec,2}</code> and then exits.</li></ul><p>| Bucket #      | Values        |
| ------------- | ------------- |
| 1             | <code>[{fir,a}]</code>   |
| 2 (first)     | <code>[]</code>          |
| 3             | <code>[]</code>          |
| 4             | <code>[{sec,b}]</code>   |</p><ul><li>The <code>ets:first/1</code> call resumes and will only see <code>sec</code> and then <code>&#x27;$end_of_table&#x27;</code>.</li></ul><p>When spelled out like this it becomes more logical that it is possible to get only
the element inserted as the second element. This is not normally a problem for
tables of type <code>set</code> which have an arbitrary iteration order that you can&#x27;t depend on anyway.</p><p>However, for <code>ordered_set</code> you may very well depend on the defined iteration order
and expect <code>ets:first/1</code> to return a key that has at least been first in the table
at some point in time. But for the same reasons as with <code>set</code>, that is not guaranteed
if you need that guarantee you have to either not use <code>write_concurrency</code>,
find some other way to synchronize or rely on luck... these races are very rare, but in heavily
used tables they will eventually happen.</p><p>The same oddity applies to all kinds of table iterations; <code>ets:next/1</code>,
<code>ets:select/1-3</code>, <code>ets:match/1-3</code> and friends. They may all miss concurrently
inserted keys and return a key that has never existed in the table ordered
directly after the previously returned key.</p></div></div><div class="col-lg-2"><p><a href="/rss/blog/"><img src="/img/rss-icon.png" width="64"/></a></p></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"item":{"id":"ets-oddity","title":"ETS oddity","author":"Lukas Larsson","excerpt":"\nWhen working with the implementation of the new [scalable ordered_set](https://github.com/erlang/otp/pull/1952)\nwe came across a strangeness with the guarantees when iterating over a table\nwhile inserting elements in parallel.","article_date":1546819200000,"tags":["ets","write_concurrency","first","next"],"frontmatter":{"layout":"post","title":"ETS oddity","tags":"ets write_concurrency first next","author":"Lukas Larsson"},"content":"\nWhen working with the implementation of the new [scalable ordered_set](https://github.com/erlang/otp/pull/1952)\nwe came across a strangeness with the guarantees when iterating over a table\nwhile inserting elements in parallel.\n\n### Scenario:\n\n```\n\u003e Tab = ets:new(test_table,\n                [set, public, {write_concurrency, true}]).\n#Ref\u003c0.1705802953.985792516.98626\u003e\n\u003e P1 = spawn(fun() -\u003e\n               ets:insert(Tab, {fir, 1}),\n               ets:insert(Tab, {sec, 2})\n             end).\n\u003e K1 = ets:first(Tab), K2 = ets:next(Tab, K1).\n```\n\nWhat are the theoretical possible values of `K1` and `K2`? Let us first list the obvious:\n\n* `K1 = fir`, `K2 = sec` - both values inserted and found in term order\n* `K1 = sec`, `K2 = fir` - since this is a `set`, the hash algorithm may put `sec` before `fir`\n* `K1 = fir`, `K2 = '$end_of_table'` - only `fir` had time to be inserted\n* `K1 = '$end_of_table'`, `K2 = badarg` - no elements were inserted\n\nHowever it is also possible to get:\n\n* `K1 = sec`, `K2 = '$end_of_table'`\n\nThis was, at first, very counter-intuitive to me. How can the `ets:first/1` find the\nsecond value inserted, but then when iterating not find the value inserted before it?\n\nThe answer can be found in the way that the `write_concurrency` functionality is\nimplemented. Imagine we have a [hash table](https://en.wikipedia.org/wiki/Hash_table)\nwhere each bucket is protected by a mutex. When inserting a new element the mutex for\nthe current bucket has to be taken and when iterating over the hash table we take\neach mutex in turn for the buckets we iterate through.\n\n### Initial Table:\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[]`          |\n| 2             | `[]`          |\n| 3             | `[]`          |\n| 4             | `[]`          |\n\n### Finished Table:\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[{fir,1}]`   |\n| 2             | `[]`          |\n| 3             | `[]`          |\n| 4             | `[{sec,2}]`   |\n\nSo, in the scenario that leads to the strange behaviour the following will happen:\n\n* `ets:first/1` is called when the table is empty and iterates to Bucket #2.\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[]`          |\n| 2 (first)     | `[]`          |\n| 3             | `[]`          |\n| 4             | `[]`          |\n\n\n* The OS does a context switch and P1 is allowed to run.\n* P1 inserts both `{fir,1}` and `{sec,2}` and then exits.\n\n| Bucket #      | Values        |\n| ------------- | ------------- |\n| 1             | `[{fir,a}]`   |\n| 2 (first)     | `[]`          |\n| 3             | `[]`          |\n| 4             | `[{sec,b}]`   |\n\n* The `ets:first/1` call resumes and will only see `sec` and then `'$end_of_table'`.\n\nWhen spelled out like this it becomes more logical that it is possible to get only\nthe element inserted as the second element. This is not normally a problem for\ntables of type `set` which have an arbitrary iteration order that you can't depend on anyway.\n\nHowever, for `ordered_set` you may very well depend on the defined iteration order\nand expect `ets:first/1` to return a key that has at least been first in the table\nat some point in time. But for the same reasons as with `set`, that is not guaranteed\nif you need that guarantee you have to either not use `write_concurrency`,\nfind some other way to synchronize or rely on luck... these races are very rare, but in heavily\nused tables they will eventually happen.\n\nThe same oddity applies to all kinds of table iterations; `ets:next/1`,\n`ets:select/1-3`, `ets:match/1-3` and friends. They may all miss concurrently\ninserted keys and return a key that has never existed in the table ordered\ndirectly after the previously returned key.\n"}},"__N_SSG":true},"page":"/blog/[blog]","query":{"blog":"ets-oddity"},"buildId":"L68tPJnB-kPxrFxsY9AoN","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/9f96d65d.6d2fb2f6923d41a412a8.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/2968c2e854f156f56dcf4f3a0f05db49ee39d399.938502fc97c89e1a18f7.js" async=""></script><script src="/_next/static/chunks/a9595808cf5ee3285d96b2a14ee913304b9362ca.20c663042d024f8cc93c.js" async=""></script><script src="/_next/static/chunks/202314b546da1167b19f69946a64c65ef91ce335.8b78b06e27cf5f3f1fd9.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bblog%5D-68965b4ff10aaca11026.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_buildManifest.js" async=""></script><script src="/_next/static/L68tPJnB-kPxrFxsY9AoN/_ssgManifest.js" async=""></script></body></html>