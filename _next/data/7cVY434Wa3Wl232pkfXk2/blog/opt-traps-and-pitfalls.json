{"pageProps":{"item":{"id":"opt-traps-and-pitfalls","title":"Optimization Traps and Pitfalls","author":"Björn Gustavsson","excerpt":"\nBack after the summer holidays, this blog will now change tracks and\nstart a series of blog posts about Static Single Assignment (SSA).\nThis first installment will set the scene for the posts that follow by\nlooking at the traps and pitfalls one can fall into when trying to\noptimize BEAM assembly code.","article_date":1535068800000,"tags":["compiler BEAM"],"frontmatter":{"layout":"post","title":"Optimization Traps and Pitfalls","tags":"compiler BEAM","author":"Björn Gustavsson"},"content":"\nBack after the summer holidays, this blog will now change tracks and\nstart a series of blog posts about Static Single Assignment (SSA).\nThis first installment will set the scene for the posts that follow by\nlooking at the traps and pitfalls one can fall into when trying to\noptimize BEAM assembly code.\n\n## A brief introduction to BEAM assembly language\n\nWe will look at the BEAM code for the following function:\n\n```erlang\nfoo({tag,A,_,_}) ->\n    {ok,A}.\n```\n\nThe (unoptimized) BEAM code looks like this:\n\n```\n{function, foo, 1, 2}.\n  {label,1}.\n    {line,[{location,\"ex1.erl\",4}]}.\n    {func_info,{atom,ex1},{atom,foo},1}.\n  {label,2}.\n    {test,is_tuple,{f,3},[{x,0}]}.\n    {test,test_arity,{f,3},[{x,0},4]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n  {label,3}.\n    {test_heap,2,1}.\n    {put_list,{x,0},nil,{x,1}}.\n    {move,{atom,function_clause},{x,0}}.\n    {line,[{location,\"ex1.erl\",4}]}.\n    {call_ext_only,2,{extfunc,erlang,error,2}}.\n```\n\nWe will concentrate on the part of the code that does\nthe actual work:\n\n```\n    {test,is_tuple,{f,3},[{x,0}]}.\n    {test,test_arity,{f,3},[{x,0},4]}.\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n  {label,3}.\n    %% Cause a function_clause exception.\n```\n\nWe will now explain what each instruction does.\n\n```\n    {test,is_tuple,{f,3},[{x,0}]}.\n```\n\n`test` instructions test whether a condition is true. If it\nis, the next instruction will be executed. Otherwise,\nthere will be a branch to the failure label.\n\nThe condition tested by this instruction is `is_tuple`, that is\nwhether its operand is a tuple.  The operand is `{x,0}`, which is the\nregister for the first argument for the function. If `{x,0}` does not\ncontain a tuple, execution will continue at the failure label. `{f,3}`\nmeans that that the failure label is `3`. The code at label `3` will\ncause a `function_clause` exception.\n\n```\n    {test,test_arity,{f,3},[{x,0},4]}.\n```\n\nThe `test_arity` instruction tests whether the first operand (which\nmust be a tuple) has the size given by the second operand. The first\noperand is `{x,0}` and the second operand is `4`. The failure label is\nthe same as for the previous instruction.\n\n```\n    {get_tuple_element,{x,0},0,{x,1}}.\n    {get_tuple_element,{x,0},1,{x,2}}.\n```\n\nWhen those two instructions are executed, the previous instructions have\nestablished that `{x,0}` contains a tuple of arity 4.\n`get_tuple_element` takes three operands. The first is the source\ntuple, `{x,0}`, the second is the **zero-based** index into the tuple,\nand the third operand is the register into which the element from the\ntuple should be stored. Note that there is no failure label because it\ncannot fail.\n\nSo the first `get_tuple_element` instruction fetches the first element\nof the tuple and stores it in the `{x,1}` register, and the second\n`get_tuple_element` instruction fetches the second element and stores\nit into the `{x,2}` register.\n\n```\n    {test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.\n```\n\n`is_eq_exact` is again a `test` instruction. It tests\nwhether the contents of `{x,1}` is exactly equal (that is,\n`=:=`) to the atom `tag`. If not, execution will continue\nat the failure label `3`.\n\nThat concludes the function header. The next instruction is in the\nbody of the function that will build the `{ok,A}` tuple:\n\n```\n    {test_heap,3,3}.\n```\n\nThe `test_heap` instruction ensures that there is sufficient free\nspace on the heap to construct a term. The first operand (the first\n`3`) says that the following instructions will need 3 words on the\nheap. A tuple has a header word, followed by the elements, so a tuple\nwith 2 elements needs 3 heap words in total.\n\nIf there is not sufficient room on the heap, the `test_heap`\ninstruction will do a garbage collection to find some fresh heap\nspace. The second operand (the second `3`) is the number of `x`\nregisters that have values that must be preserved during garbage\ncollection. The `3` means that `{x,0}`, `{x,1}`, and `{x,2}` have live\nvalues.\n\n```\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n```\n\nThose three instructions build the tuple, putting a tagged\npointer to the tuple in `{x,0}`.\n\n```\n    return.\n```\n\n`return` returns from the function. The return value is the\nvalue in `{x,0}`.\n\n## Optimizing this code\n\nTesting that a term is a tuple of a certain size with a specific atom\nas the first element is a common operation (think records). Therefore\nthe BEAM machine has an `is_tagged_tuple` instruction that does the\nwork of 4 other instructions.\n\nUsing that instruction, this code:\n\n<pre class=\"highlight\">\n    <b>{test,is_tuple,{f,3},[{x,0}]}.</b>\n    <b>{test,test_arity,{f,3},[{x,0},4]}.</b>\n    <b>{get_tuple_element,{x,0},0,{x,1}}.</b>\n    {get_tuple_element,{x,0},1,{x,2}}.\n    <b>{test,is_eq_exact,{f,3},[{x,1},{atom,tag}]}.</b>\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n</pre>\n\ncan be rewritten like this:\n\n<pre class=\"highlight\">\n    <b>{test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.</b>\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n</pre>\n\nThis is a nice reduction in code size and execution\ntime. However, this optimization is not safe.\n\nWhy?\n\nConsider the `{test_heap,3,3}` instruction. The second `3` says\nthat 3 `x` registers are live, namely `{x,0}`, `{x,1}`, and `{x,2}`.\nClearly, `{x,0}` and `{x,2}` are live, but what about `{x,1}`?\nWe removed the `get_tuple_element` instruction that assigned `{x,1}`\na value, so the value of `{x,1}` is undefined.\n\nPassing undefined register values to the garbage collector is the kind\nof bug that could take weeks to track down. In fact, there will\nprobably be a future blog post about that kind of bug and how two\ntools were born as result of that bug.\n\nReluctantly, in order to make the optimization safe, we must keep\nthe `get_tuple_element` instruction that assigns to `{x,1}`:\n\n<pre class=\"highlight\">\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    <b>{get_tuple_element,{x,0},0,{x,1}}.</b>\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n</pre>\n\nAnother possibility in this case would be to assign an empty list\n(called `nil` in the BEAM assembly language) to `{x,1}`:\n\n<pre class=\"highlight\">\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    <b>{move,nil,{x,1}}.</b>\n    {get_tuple_element,{x,0},1,{x,2}}.\n    {test_heap,3,3}.\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n</pre>\n\nHowever, in this very simple example, another optimization will\nactually allow the compiler to remove the assignment to `{x,1}`:\n\n<pre class=\"highlight\">\n    {test,is_tagged_tuple,{f,1},[{x,0},4,{atom,tag}]}.\n    <b>{test_heap,3,1}.</b>\n    <b>{get_tuple_element,{x,0},1,{x,2}}.</b>\n    {put_tuple,2,{x,0}}.\n    {put,{atom,ok}}.\n    {put,{x,2}}.\n    return.\n</pre>\n\nThe `test_heap` and `get_tuple_element` instructions have been swapped.\nNote that the number of live register have been adjusted in the `test_heap`\ninstruction. It is now `1` instead of `3`.\n\nIn general, though, the compiler might have to abandon an optimization\nor keep an instruction that assigns a register to avoiding feeding the\ngarbage collector undefined values.\n\n## The final straw\n\nDuring the development of OTP 21, we realized that we have reached the\nlimit for improving the optimizations that operates on the BEAM\nassembly language. In particular, we wanted to make the optimization\ncalled the [delayed sub binary creation][bin_matching] applicable in\nmore circumstances. It turned out that would it be hard or impossible\nto substantially improve the optimization by working on BEAM assembly\nlanguage.\n\n[bin_matching]: http://erlang.org/doc/efficiency_guide/binaryhandling.html#matching-binaries\n\nApart from the problem of leaving undefined registers, as illustrated\nin the previous optimization example, there is also the complexity of\ntraversing and analyzing BEAM instructions. The BEAM instruction set\nwas not designed to be optimizer-friendly.\n\n## Conclusion\n\nAs I have tried to show with the example above, one of the hardest\nparts of working with BEAM code is that register allocation has\nalready been done and that instructions that may do a garbage\ncollection (such as `test_heap`) have already been added.\n\nEarly this year (2018), we decided that we should introduce a new\nintermediate format to alleviate the problems with optimizing BEAM\ncode. It should be close enough to BEAM code to allow\nlow-level optimizations such as the `is_tagged_tuple` optimization\ndescribed in this blog post, but register allocation should not have\nbeen done, and `test_heap` and similar instructions should not have\nbeen added. It should also be more regular to make it easier to\ntraverse while doing optimizations.\n\nWe decided to make the new intermediate format [SSA-based][ssa].\nIn the next blog post, we will re-visit the example from this blog\npost and see what it looks like in the [new SSA-based intermediate\nformat][pr1935].\n\n[ssa]: https://en.wikipedia.org/wiki/Static_single_assignment_form\n[pr1935]: https://github.com/erlang/otp/pull/1935\n"}},"__N_SSG":true}