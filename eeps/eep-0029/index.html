<!DOCTYPE html><html><head><meta charSet="utf-8"/><title>Erlang Programming Language</title><meta http-equiv="Content-Type" content="text/html;charset=utf-8"/><meta name="description" content="Erlang Programming Language"/><meta name="keywords" content="erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="alternate" type="application/rss+xml" title="Overall RSS 2.0 Feed" href="/rss"/><link rel="alternate" type="application/rss+xml" title="News RSS 2.0 Feed" href="/rss/news"/><link rel="alternate" type="application/rss+xml" title="Article RSS 2.0 Feed" href="/rss/articles"/><link rel="alternate" type="application/rss+xml" title="Events RSS 2.0 Feed" href="/rss/event"/><link rel="alternate" type="application/rss+xml" title="Downloads RSS 2.0 Feed" href="/rss/download"/><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><link rel="preload" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/4ee9685e1cc0da7f69f0.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" as="script"/><link rel="preload" href="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" as="script"/></head><body><div id="__next"><div class="navbar" style="background-color:#FFF;margin-bottom:0px"><div class="container"><button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse" style="position:absolute;right:5px;margin-bottom:0px"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="/img/erlang.png" width="60"/></a><div class="nav-collapse collapse navbar-responsive-collapse" style="padding:20px"><ul class="nav navbar-nav"><li><a class="menu-headlines" href="/downloads/"> DOWNLOADS </a></li><li><a class="menu-headlines" href="/docs/"> DOCUMENTATION </a></li><li><a class="menu-headlines" href="/community/"> COMMUNITY </a></li><li><a class="menu-headlines" href="/news/"> NEWS </a></li><li><a class="menu-headlines" href="/eeps/"> EEPS </a></li><li><a class="menu-headlines" href="/blog/"> BLOG </a></li><li><a class="menu-headlines" href="/about/"> ABOUT </a></li></ul></div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="static_div"><pre><code>Author: Richard A. O'Keefe &lt;ok(at)cs(dot)otago(dot)ac(dot)nz&gt;
Status: Draft
Type: Standards Track
Erlang-Version: R12B-5
Created: 25-Feb-2009
Post-History:
</code></pre>

<hr />

<h2><a href="/eeps/eep-0000" title="EEP Index">EEP</a> 29: <a href="eep-0029.md" title="EEP Source"> Abstract Patterns, Stage 1</a></h2>

<h1>Abstract</h1>

<p>Abstract Patterns are named pattern/guard combinations
which can be used</p>

<ul>
<li>in patterns, to support abstract data types</li>
<li>as user-defined guards, guaranteed safe-for-guards</li>
<li>as ordinary functions</li>
<li>to replace many but not all uses of macros.</li>
</ul>

<p>The full proposal has six stages, of which this is stage 1.
This stage allows only simple abstract patterns which can be
handled by in-line substitution, so requiring no change to the
Erlang Virtual Machine.</p>

<h1>Specification</h1>

<p>We introduce abstract pattern declarations and calls.
The syntax is given as an adaptation of that in parse.yrl.</p>

<pre><code>form -&gt; abstract_pattern dot.

abstract_pattern -&gt; '#' atom clause_args clause_guard
                    '-&gt;' expr.
</code></pre>

<p>For future reference, we'll use the schematic rule</p>

<pre><code>#A(H1, ..., Hn) when G -&gt; B.
</code></pre>

<p>where an empty clause_guard is taken to mean that <code>G</code> is 'true'.
<code>H1, ..., Hn</code> and <code>B</code> must all be patterns.</p>

<p>Abstract patterns may not be directly or indirectly recursive.</p>

<pre><code>expr_700 -&gt; pattern_call.

pattern_call -&gt; '#' atom argument_list
</code></pre>

<p>The expressions in the argument<em>list of a pattern</em>call must be</p>

<ul>
<li>patterns in a pattern</li>
<li>guard expressions elsewhere in a guard</li>
<li>any expression elsewhere in an ordinary expression.</li>
</ul>

<p>There are two ways to understand the semantics of abstract
patterns: as function calls and as inline substitution.</p>

<p>Considered as functions, stage 1 abstract patterns correspond
to two functions.  Given our schematic rule, we get</p>

<pre><code>'#A-&gt;'(H1, ..., Hn) when G -&gt; B.
</code></pre>

<p>That is, part of the meaning of an abstract pattern is a
function that works just the way it looks as if it works.
(The name '#A->' is for expository purposes and should not
be taken literally.  In particular, it is NOT part of this
specification that such a function should be directly
accessible at all, still less that it should be accessible
by a name of that form.)  So</p>

<pre><code>#permute([R,A,T]) when is_atom(A) -&gt; [T,A,R].
</code></pre>

<p>acts in one direction just like</p>

<pre><code>'#permute-&gt;'([R,A,T]) when is_atom(A) -&gt; [T,A,R].
</code></pre>

<p>would.  Because abstract patterns are not allowed to be
recursive and cannot have any side effects, it is safe
to call them in guards.  As a guard test, <code>#A(E1,...,En)</code>
is equivalent to <code>(true = '#A-&gt;'(E1,...,En))</code>.  </p>

<p>In the other direction, we get</p>

<pre><code>'#A='(B) when G -&gt; {H1, ..., Hn}.
</code></pre>

<p>A pattern match</p>

<pre><code>#A(P1, ..., Pn) = E
</code></pre>

<p>is equivalent to</p>

<pre><code>{P1, ..., Pn} = '#A='(E)
</code></pre>

<p>When some of the patterns Hi, B use '=', the definition is
a little trickier.  Suppose, for example, we have</p>

<pre><code>#foo([H|T] = X) -&gt; {H,T}.
</code></pre>

<p>A naive translation would be</p>

<pre><code>'#foo='({H,T}) -&gt; [H|T] = X.
</code></pre>

<p>which would not work, because X would be undefined.  The
basic problem here is that '=' in patterns is symmetric,
while '=' in expressions is not.  The real translation
has to be that</p>

<pre><code>#A(H11=H12=.., ..., Hn1=Hn2=..) when G -&gt; B
</code></pre>

<p>is equivalent to</p>

<pre><code>'#A='(B)
when G, X1=H11, X1=H12, ..., Xn=Hn1, Xn=Hn2, ...
-&gt; {X1, ..., Xn}
</code></pre>

<p>where the bindings <code>Xi=Hij</code> are both sorted and re-ordered
(that is, switched from <code>Xi=Hij</code> to <code>Hij=Xi</code>) according to
data flow.  In the case of the <code>#foo/1</code> example, we'd get</p>

<pre><code>'#foo='({H,T}) when X1 = [H|T], X = X1 -&gt; {X1}.
</code></pre>

<p>The sorting and reordering process is easier than it sounds.
While there is an equation <code>Xi=Hij</code> such that either every
variable in <code>Hij</code> is known or <code>Xi</code> is known, add <code>Xi=Hij</code> if
<code>Hij</code> is all known, or <code>Hij = Xi</code> if <code>Xi</code> is known.</p>

<p>This sorting-and-reordering-by-dataflow is also recommended
in the forward direction when B contains '='.</p>

<p>Sometimes one or the other direction of an abstract pattern
cannot be constructed, even with sorting and reordering by
dataflow.  This is typically because one side contains a
variable that doesn't occur on the other.  For example,</p>

<pre><code>#first(X) -&gt; {X,_}.
#second(Y) -&gt; {_,Y}.
</code></pre>

<p>are usable as patterns, but not as functions.  The compiler
should issue a warning for such abstract patterns but allow
them.  It should be a run-time error to call such a pattern
as a function as well.  It should be possible to suppress
the warning, perhaps by</p>

<pre><code>-compile({pattern_only,[{first,1,second,1}]}).
</code></pre>

<p>(That's within the current syntax.  Ideally that should be
<code>#first/1</code> and <code>#second/1</code>.)</p>

<p>For another example,</p>

<pre><code>#is_date(#date(_,_,_)) -&gt; true.
</code></pre>

<p>is usable as a function, even/especially in a guard, but is <br />
not usable as a pattern.  The compiler should issue a
warning for such abstract patterns but allow them.  It
should be a run-time error to call such a pattern as well.
It should be possible to suppress the warning, perhaps by</p>

<pre><code>-compile({function_only,[{is_date,1}]}).
</code></pre>

<p>Definition via in-line substituion is straightforward.
All of the following rewrites assume a standard renaming
of variables.</p>

<pre><code>f(... #A(P1,...,Pn) ...) when Gf -&gt; Bf
</code></pre>

<p>rewrites to</p>

<pre><code>f(... B ...)
when G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gf -&gt; Bf

case ... of ... #(P1,...,Pn) ... when Gc -&gt; Bc
</code></pre>

<p>rewrites to</p>

<pre><code>case ... of ... B ...
when G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gc -&gt; Bc

P = E
</code></pre>

<p>rewrites to</p>

<pre><code>case E of P -&gt; ok end
</code></pre>

<p>In a guard expression,</p>

<pre><code>(... #A(E1, ..., En) ...)
</code></pre>

<p>rewrites to</p>

<pre><code>{H1,...,Hn} = {E1,...,En}, G, (... B ...)
</code></pre>

<p>As a guard test,</p>

<pre><code>#A(E1, ..., En)
</code></pre>

<p>rewrites to</p>

<pre><code>{H1,...,Hn} = {E1,...,En}, G, true = B
</code></pre>

<p>As an ordinary expression,</p>

<pre><code>#A(E1, ..., En)
</code></pre>

<p>rewrites to</p>

<pre><code>case {E1,...,En} of {H1,...,Hn} when G -&gt; B end
</code></pre>

<h1>Motivation</h1>

<p>Even in this restricted form, abstract patterns solve a lot
of problems that keep coming up on the Erlang mailing list.
They were invented to serve two main purposes:  to greatly
reduce the need for the preprocessor, and to support the
use of abstract data types.  It turns out that they can also
reduce the amount of keyboard work a programmer has to do,
and increase the amount of type information available to the
compiler.</p>

<p>Macros are often used to provide named constants.
For example,</p>

<pre><code>-define(unknown, "UNKNOWN").
f(?unknown, Actors) -&gt; Actors;
f(N, Actors) -&gt; lists:keydelete(N, #actor.name, Actors).
</code></pre>

<p>A function is not used here because function calls may not
appear in patterns.  Abstract patterns are functions that
are sufficiently restricted that they <em>may</em> appear in patterns:</p>

<pre><code>#unknown() -&gt; "UNKNOWN".
f(#unknown(), Actors) -&gt; Actors;
f(N, Actors) -&gt; lists:keydelete(n, #actor.name, Actors).
</code></pre>

<p>Sometimes these constants must be computed.
For example,</p>

<pre><code>-define(START_TIMEOUT, 1000 * 30).
</code></pre>

<p>Thanks to variable binding in guards, we can do that too:</p>

<pre><code>#start_timeout() when N = 1000*30 -&gt; N.
</code></pre>

<p>There are things that macros cannot do, because there needs
to be a guard test as well as a pattern.  Macros can't bilocate.</p>

<pre><code>#date(D, M, Y)
when is_integer(Y), Y &gt;= 1600, Y =&lt; 2500,
     is_integer(M), M &gt;= 1,    M =&lt; 12,
     is_integer(D), D &gt;= 1,    D =&lt; 31
-&gt; {Y, M, D}.

#vector3(X, Y, Z)
when is_float(X), is_float(Y), is_float(Z)
-&gt; {X, Y, Z}.

#mod_func(M, F) when is_atom(M), is_atom(F) -&gt; {M, F}.

#mod_func_arity(M, F, A)
when is_atom(M), is_atom(F), is_integer(A), A &gt;= 0
-&gt; {M, F, A}.
</code></pre>

<p>Some macros cannot be replaced by abstract patterns.</p>

<pre><code>-define(DBG(DbgLvl, Format, Data),
    dbg(DbgLvl, Format, Data)).
</code></pre>

<p>cannot be an abstract pattern because the right hand side
involves a call to an ordinary function.</p>

<p>Some macros define guard tests.  For example,</p>

<pre><code>-define(tab, 9).
-define(space, 32).
-define(is_tab(X), X == ?tab).
-define(is_space(X), X == ?space).
-define(is_underline(X), X == $_).
-define(is_number(X), X &gt;= $0, X =&lt; $9).
-define(is_upper(X), X &gt;= $A, X =&lt; $Z).
-define(is_lower(X), X &gt;= $a, X =&lt; $z).

token([X|File], L, Result, Gen, BsNl)
  when ?is_upper(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when ?is_lower(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when ?is_underline(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>These can be converted to abstract patterns that are usable
as guard tests,</p>

<pre><code>#tab() -&gt; 9.
#space() -&gt; 32.
#is_tab(#tab()) -&gt; true.
#is_space(#space()) -&gt; true.
#is_underline($_)) -&gt; true.
#is_number(X) when X &gt;= $0, X =&lt; $9 -&gt; true.
#is_upper(X)  when X &gt;= $A, X =&lt; $Z -&gt; true.
#is_lower(X)  when X &gt;= $a, X =&lt; $z -&gt; true.

token([X|File], L, Result, Gen, BsNl)
  when #is_upper(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when #is_lower(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([X|File], L, Result, Gen, BsNl)
  when #is_underline(X) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>or to abstract patterns that can be used as patterns,</p>

<pre><code>#tab() -&gt; 9.
#space() -&gt; 32.
#underline(X) when X == $_ -&gt; X.
#number(X) when X &gt;= $0, X =&lt; $9 -&gt; X.
#upper(X)  when X &gt;= $A, X =&lt; $Z -&gt; X.
#lower(X)  when X &gt;= $a, X =&lt; $z -&gt; X.

token([#upper(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([#lower(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
token([#underline(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>Of course we can use disjunction in the guard of an
abstract pattern.</p>

<pre><code>#id_start(X) when X &gt;= $A, X =&lt; $Z
        ; X &gt;= $a, X =&lt; $z
        ; X == $_           -&gt; X.

token([#is_start(X)|File], L, Result, Gen, BsNl) -&gt;
    GenNew = case Gen of not_set -&gt; var; _ -&gt; Gen end,
    {Rem, Var} = tok_var(File, [X]),
    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);
</code></pre>

<p>Yes, the original macro-based version could have done the same.
It's from the OTP sources; don't blame me.</p>

<p>Aside from replacing a pattern AND a guard, which macros cannot
do, the great advantages over patterns over macros are that</p>

<ul>
<li>they can be syntax-checked at the point of definition,
while macros can only be syntax-checked at the point of use;</li>
<li>there is no problem, indeed no possibility, of variable name
capture;</li>
<li>abstract patterns are value based, not token-list based, so
there are no problems with operators.</li>
</ul>

<p>Consider the following OTP macro:</p>

<pre><code>-define(IC_FLAG_TEST(_F1, _I1), ((_F1 band _I1) == _I1)).
</code></pre>

<p>First, the author was evidently scared of accidental collisions
with other variable names.  Second, the parentheses look as
though they are there in case of operator precedence bugs.</p>

<p>There's at least one other like it,</p>

<pre><code>-define(is_set(F, Bits), ((F) band (Bits)) == (F)).
</code></pre>

<p>which (correctly) suggests that the first macro doesn't have enough
parentheses.    The abstract pattern equivalent,</p>

<pre><code>#ic_flag_test(Flags, Mask) when Flags band Mask == Mask -&gt; true.
</code></pre>

<p>has neither problem.</p>

<p>Once again, there are things that abstract patterns cannot do.
For example,</p>

<pre><code>-define(get_max(_X, _Y), if _X &gt; _Y -&gt; _X; true -&gt; _Y end).
-define(get_min(_X, _Y), if _X &gt; _Y -&gt; _Y; true -&gt; _X end).
</code></pre>

<p>These cannot be abstract patterns because an abstract pattern
cannot contain an 'if' or a 'case' or any other control structure.
But they can, and should, be ordinary inline functions:</p>

<pre><code>-compile({inline,[{max,2},{min,2}]}).
max(X, Y) -&gt; if X &gt; Y -&gt; X; true -&gt; Y end.
min(X, Y) -&gt; if X &gt; Y -&gt; Y; true -&gt; X end.
</code></pre>

<p>Abstract patterns don't need to do what ordinary functions can.
Here's another example from the OTP sources.</p>

<pre><code>-define(LOWER(Char),
    if
        Char &gt;= $A, Char =&lt; $Z -&gt;
        Char - ($A - $a);
        true -&gt;
        Char
    end).
tolower(Chars) -&gt;
    [?LOWER(Char) || Char &lt;- Chars].
</code></pre>

<p>This could, and should, have been an ordinary inlined function.
Abstract patterns don't need to do what ordinary functions can.
Let's examine it a little closer.  Suppose we had a pattern</p>

<pre><code>Cl = #lower(Cx)
</code></pre>

<p>which when used as an ordinary function converted both <code>$x</code> and <code>$X</code>
to <code>$x</code>.  Then when used as a pattern <code>#lower(Cx) = $x</code>, there would
be two correct answers for <code>Cx</code>.  There are no other cases where
a pattern may match more than one way.  The fact that abstract
patterns cannot do conditionals is one of the things that makes
them usable as patterns.</p>

<p>Macros are sometimes used for module names.</p>

<pre><code>-define(SERVER,{rmod_random_impl,
        list_to_atom("babbis@" ++
    hd(tl(string:tokens(atom_to_list(node()),"@"))))}).

-define(CLIENTMOD,'rmod_random').

produce() -&gt; ?CLIENTMOD:produce(?SERVER).
</code></pre>

<p>Abstract patterns can be used for this too, but there is an
error waiting to happen.</p>

<pre><code>server() -&gt; {rmod_random_impl,
        list_to_atom("babbis@" ++
    hd(tl(string:tokens(atom_to_list(node()),"@"))))}.

#client_mod() -&gt; 'rmod_random'.

produce -&gt; #client_mod():produce(server()).
</code></pre>

<p>The risk is that of writing <code>#client_mod:produce(server())</code>,
which is the syntax we'll want in stage 2 for calling an
abstract pattern defined in another module.
There is one thing that macros are used for that abstract
patterns can be used for, but you'd probably rather not.</p>

<p>Abstract patterns were also invented with the aim of
replacing at least some uses of records.  Frames (or Joe
Armstrong's structs, which are essentially the same thing)
are a superior way to do that.   Let's see a simple case.</p>

<pre><code>-record(mark_params, {cell_id,
              virtual_col,
              virtual_row
             }).
...
MarkP = mark_params(),
...
NewMarkP = MarkP#mark_params{cell_id     = undefined,
                 virtual_col = undefined,
                 virtual_row = VirtualRow
                },
</code></pre>

<p>This becomes</p>

<pre><code>% General
#mark_params(Cell, Row, Col) -&gt; {mark_params, Cell, Row, Col}.
% Initial value
#mark_params() -&gt; #mark_params(undefined, undefined, undefined).
% Recogniser
#is_mark_params({mark_params,_,_,_}) -&gt; true.
% Cell extractor
#mark_params__cell(#mark_params(Cell,_,_)) -&gt; Cell.
% Cell updater
#mark_params__cell(Cell, #mark_params(_,R,C)) -&gt;
    #mark_params(Cell, R, C).
% Row extractor
#mark_params__row(#mark_params(_,Row,_)) -&gt; Row.
% Row updater
#mark_params__row(Row, #mark_params(K,_,C)) -&gt;
    #mark_params(K, Row, C).
% Col extractor
#mark_params__col(#mark_params(_,_,Col)) -&gt; Col.
% Col updater
#mark_params__col(Col, #mark_params(K,R,_)) -&gt;
    #mark_params(K, R, Col).
...
MarkP = #mark_params(),
...
NewMarkP = #mark_params__row(VirtualRow,
           #mark_params__col(undefined,
           #mark_params__cell(undefined, MarkP)))
</code></pre>

<p>The extractor and updater patterns can be derived automatically,
which comes in stage 4.  With frames/structs, we may never bother.</p>

<p>There is a feature of Haskell that I have long loved.
That is so-called "n+k patterns", where a pattern may be N+K
for N a variable and K a positive integer.  This matches V
if V is an integer greater than or equal to K, and binds N
to V - K.  For example,</p>

<pre><code>fib 0 = 1
fib 1 = 1
fib (n+2) = fib n + fib (n+1)
</code></pre>

<p>Not that that's a good way to implement the Fibonacci function,
of course.  (It takes O(phi^N) when O(log N) is attainable.)
There's no such thing in Erlang.  But with abstract patterns,
we could program it:</p>

<pre><code>#succ(M) when is_integer(N), N &gt;= 1, M = N - 1 -&gt; N.

fib(0) -&gt; 1;
fib(1) -&gt; 1;
fib(#succ(#succ(N)) -&gt; fib(N) + fib(N+1).
</code></pre>

<p>Sometimes we want a three-way split:</p>

<pre><code>N = 1
N = 2k+0 (k &gt;= 1)
N = 2k+1 (k &gt;= 1)
</code></pre>

<p>We can program that too:</p>

<pre><code>#one() -&gt; 1.
#even(K)
when is_integer(N), (N band 1) == 0, N &gt;= 2, K = N div 2
-&gt; N.
#odd(K)
when is_integer(N), (N band 1) == 1, N &gt;= 3, K = N div 2
-&gt; N.

ruler(#one())   -&gt; 0 ;
ruler(#even(K)) -&gt; 1 + ruler(K);
ruler(#odd(K))  -&gt; 1.
</code></pre>

<p>Let's turn to abstract data types.
There are three obvious ways to implement association lists
as single data structures:</p>

<pre><code>[{K1,V1}, ..., {Kn,Vn}]     % pairs
[K1,V1, ..., Kn,Vn]     % alternating
{K1,V1, ..., {Kn,Vn,[]}}    % triples
</code></pre>

<p>Suppose you cannot make up your mind which is better.</p>

<pre><code>#empty_alist() -&gt; [].
-ifdef(PAIRS).
#non_empty_alist(K,V,R) -&gt; [{K,V}|R].
-else.
-ifdef(TRIPLES).
#non_empty_alist(K,V,R) -&gt; {K,V,R}.
-else.
#non_empty_alist(K,V,R) -&gt; [K,V|R].
-endif.
-endif.

zip([K|Ks], [V|Vs]) -&gt;
    #non_empty_alist(K, V, zip(Ks, Vs));
zip([], []) -&gt;
    #empty_alist().

lookup(K, #non_empty_alist(K,V,_), _) -&gt;
    V;
lookup(K, #non_empty_alist(_,_,R), D) -&gt;
    lookup(K, R, D);
lookup(K, #empty_alist(), D) -&gt;
    D.
</code></pre>

<p>Now you can switch between the three implementations, for <br />
testing and benchmarking, by flicking a single preprocessor
switch.  </p>

<p>Sometimes there is something that would have been an algebraic
data type in Haskell or Clean or SML or CAML, but in Erlang we
just have to use a variety of tuples.  The parsed form of
Erlang source code is a good example.</p>

<pre><code>lform({attribute,Line,Name,Arg}, Hook) -&gt;
    lattribute({attribute,Line,Name,Arg}, Hook);
lform({function,Line,Name,Arity,Clauses}, Hook) -&gt;
    lfunction({function,Line,Name,Arity,Clauses}, Hook);
lform({rule,Line,Name,Arity,Clauses}, Hook) -&gt;
    lrule({rule,Line,Name,Arity,Clauses}, Hook);
%% These are specials to make it easier for the compiler.
lform({error,E}, _Hook) -&gt;
    leaf(format("~p\n", [{error,E}]));
lform({warning,W}, _Hook) -&gt;
    leaf(format("~p\n", [{warning,W}]));
lform({eof,_Line}, _Hook) -&gt;
    $\n.
</code></pre>

<p>We can define abstract patterns for these.</p>

<pre><code>#attribute(L, N, A)    -&gt; {attribute, L, N, A}.
#function( L, N, A, C) -&gt; {function,  L, N, A, C}.
#rule(     L, N, A, C) -&gt; {rule,      L, N, A, C}.
#eof(      L)          -&gt; {eof,       L}.
#error(    E_          -&gt; {error,     E}.
#warning(  W)          -&gt; {warning,   W}.

#attribute()        -&gt; #attribute(_,_,_).
#function()     -&gt; #function(_,_,_,_).
#rule()         -&gt; #rule(_,_,_,_).

lform(Form, Hook) -&gt;
    case Form
      of #attribute() -&gt; lattribute(Form, Hook)
       ; #function()  -&gt; lfunction( Form, Hook)
       ; #rule()      -&gt; lrule(     Form, Hook)
       ; #error(E)    -&gt; leaf(format("~p\n", [{error,E}]))
       ; #warning(W)  -&gt; leaf(format("~p\n", [{warning,W}]))
       ; #eof(_)      -&gt; $\n
    end.
</code></pre>

<p>It would almost be worth defining these patterns even if these
were their only occurrences, simply for the clarity they permit.
But these patterns would be used over and over again.  Using
the patterns not only makes the code shorter and clearer, it
gives us two kinds of protection against changes to the data
representation.  For example, suppose we decided to hold
Name/Arity information in 'function' and 'rule' tuples as
pairs, not as separate fields.  Then we could do</p>

<pre><code>-ifdef(OLD_DATA).
#function( L, N, A,  C) -&gt; {function,  L, N, A, C}.
#rule(     L, N, A,  C) -&gt; {rule,      L, N, A, C}.
#function( L, {N,A}, C) -&gt; {function,  L, N, A, C}.
#rule(     L, {N,A}, C) -&gt; {rule,      L, N, A, C}.
-else.
#function( L, N, A, C)  -&gt; {function,  L, {N,A}, C}.
#rule(     L, N, A, C)  -&gt; {rule,      L, {N,A}, C}.
#function( L, NA,   C)  -&gt; {function,  L, NA,    C}.
#rule(     L, NA,   C)  -&gt; {rule,      L, NA,    C}.
-endif.
</code></pre>

<p>The rest of the code would remain unchanged.  That's one kind of
protection.  It doesn't help us when we need to add new cases.
That's when the second kind of protection comes up.  Looking
for <code>#function</code> is a much safer guide to finding relevant places
than looking for <code>function</code>.</p>

<h1>Rationale</h1>

<p>There is more to the idea of abstract patterns than this
specification describes.  Here's a "road map".</p>

<ul>
<li><p>Stage 0:
Allow pattern matching in guards.
This is the subject of another EEP, as it is
desirable in itself.  This MUST be implemented
first before implementing Stage 1, because that's
what we want inlinable pattern calls to expand to.</p></li>
<li><p>Stage 1:
Simple abstract patterns restricted so that they
can be implemented exclusively by inline expansion.
This requires no change to the VM other than the
changes required for Stage 0.</p>

<p>Import/export of patterns can be faked using the
preprocessor to -include definitions; this is not
ideal, but it's an acceptable stopgap.</p></li>
<li><p>Stage 2:
Abstract functions are (pairs of) real functions,
they may be -exported and -imported, may be called
with module prefixes, can be replaced by hot loading,
should be traceable, debuggable, profilable, and so
on, just like other functions.  In Stage 2, exported
abstract patterns would need inline declarations if
they are to be inlined; other patterns would continue
to be inlined except when compiled in debugging mode.</p>

<p>This requires fairly substantial changes to the
run time system.  The big payoff here is that
imported abstract patterns can be replaced by hot
loading, unlike macros.</p></li>
<li><p>Stage 3:</p>

<pre><code>#fun [Module:]Name/Arity and
#fun (P1, ..., Pn) when G -&gt; B end
</code></pre>

<p>forms are introduced, and a metacall</p>

<pre><code>#Var(E1,...,En) is added.
</code></pre>

<p>This requires extensions to the Erlang term
representation and the VM.  The gain here is that
the FAQ "how do I pass a pattern as a parameter"
finally gets a safe answer.  For example,</p>

<pre><code>collect_messages(P) -&gt;
    lists:reverse(collect_messages_loop(P, [])).


collect_messages_loop(P, Ms) -&gt;
    receive M = #P() -&gt; collect_messages_loop([M|Ms])
      after 0        -&gt; Ms
    end.
</code></pre>

<p>gathers all the messages currently in the mailbox
that match a pattern passed as a parameter.</p></li>
<li><p>Stage 4:
<code>&lt;expression&gt;#&lt;pattern call&gt;</code> field update,
as described in the original proposal.</p></li>
<li><p>Stage 5:
Multi-clause abstract patterns,
as described in the original proposal.
Multi-clause abstract patterns CAN handle
examples like <code>?get_max</code> and <code>?LOWER</code>, which makes
them even more useful in guards, but more than
a little dubious as patterns.</p></li>
<li><p>Stage 6:
"Hybrid" abstract patterns, where in <code>#A/M+N</code> the
first <code>M</code> arguments are always inputs, and only
the last <code>N</code> are outputs.  This one isn't actually
my idea.  The example</p>

<pre><code>#range(L, U, N)
when is_integer(N), L =&lt; N, N =&lt; U
-&gt; N.
</code></pre>

<p>comes from the mailing list.  I don't like this very
much, and note that for some purposes,</p>

<p>range(L, U) ->
       #fun(N) when is_integer(N), L =&lt; N, N =&lt; U
               -> N end.</p>

<p>can do the same job.</p></li>
</ul>

<p>What I've done for this proposal is to strip away everything
that isn't essential.  We get data abstraction, user defined
guard tests and functions, and a replacement for many uses
of macros, without run time overheads and without changes to
anything except the compiler front end, assuming that Stage 0
is done first.</p>

<h1>Backwards Compatibility</h1>

<p>Erlang currently uses the sharp sign for record syntax.
Since record syntax uses curly braces, and abstract patterns
use round parentheses, no existing code should be affected.</p>

<h1>Reference Implementation</h1>

<p>Sketched above.  Given stage 0, this stage 1 is within my
knowledge and abilities, but I don't understand the Erlang
VM well enough to do stage 0.</p>

<h1>Copyright</h1>

<p>This document has been placed in the public domain.</p>
</div></div></div><div class="container"><div class="row"><div class="col-lg-12"><div class="divider"><p></p></div></div><div class="col-lg-12 text-center"><div class="col-lg-4"><a title="DOWNLOAD" href="/download.html"><img src="/img/download.png"/></a></div><div class="col-lg-4"><a href="http://www.github.com/erlang/otp/"><img src="/img/GitHub-Mark-32px.png"/></a></div><div class="col-lg-4"><a href="http://www.twitter.com/erlang_org/"><img src="/img/twitter.png" width="32"/></a></div></div><div class="col-lg-12"><div class="divider"><p></p></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"index":{"id":"0029","content":"\u003cpre\u003e\u003ccode\u003eAuthor: Richard A. O'Keefe \u0026lt;ok(at)cs(dot)otago(dot)ac(dot)nz\u0026gt;\nStatus: Draft\nType: Standards Track\nErlang-Version: R12B-5\nCreated: 25-Feb-2009\nPost-History:\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003chr /\u003e\n\n\u003ch2\u003e\u003ca href=\"/eeps/eep-0000\" title=\"EEP Index\"\u003eEEP\u003c/a\u003e 29: \u003ca href=\"eep-0029.md\" title=\"EEP Source\"\u003e Abstract Patterns, Stage 1\u003c/a\u003e\u003c/h2\u003e\n\n\u003ch1\u003eAbstract\u003c/h1\u003e\n\n\u003cp\u003eAbstract Patterns are named pattern/guard combinations\nwhich can be used\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ein patterns, to support abstract data types\u003c/li\u003e\n\u003cli\u003eas user-defined guards, guaranteed safe-for-guards\u003c/li\u003e\n\u003cli\u003eas ordinary functions\u003c/li\u003e\n\u003cli\u003eto replace many but not all uses of macros.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe full proposal has six stages, of which this is stage 1.\nThis stage allows only simple abstract patterns which can be\nhandled by in-line substitution, so requiring no change to the\nErlang Virtual Machine.\u003c/p\u003e\n\n\u003ch1\u003eSpecification\u003c/h1\u003e\n\n\u003cp\u003eWe introduce abstract pattern declarations and calls.\nThe syntax is given as an adaptation of that in parse.yrl.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eform -\u0026gt; abstract_pattern dot.\n\nabstract_pattern -\u0026gt; '#' atom clause_args clause_guard\n                    '-\u0026gt;' expr.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFor future reference, we'll use the schematic rule\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#A(H1, ..., Hn) when G -\u0026gt; B.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere an empty clause_guard is taken to mean that \u003ccode\u003eG\u003c/code\u003e is 'true'.\n\u003ccode\u003eH1, ..., Hn\u003c/code\u003e and \u003ccode\u003eB\u003c/code\u003e must all be patterns.\u003c/p\u003e\n\n\u003cp\u003eAbstract patterns may not be directly or indirectly recursive.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eexpr_700 -\u0026gt; pattern_call.\n\npattern_call -\u0026gt; '#' atom argument_list\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe expressions in the argument\u003cem\u003elist of a pattern\u003c/em\u003ecall must be\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003epatterns in a pattern\u003c/li\u003e\n\u003cli\u003eguard expressions elsewhere in a guard\u003c/li\u003e\n\u003cli\u003eany expression elsewhere in an ordinary expression.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThere are two ways to understand the semantics of abstract\npatterns: as function calls and as inline substitution.\u003c/p\u003e\n\n\u003cp\u003eConsidered as functions, stage 1 abstract patterns correspond\nto two functions.  Given our schematic rule, we get\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'#A-\u0026gt;'(H1, ..., Hn) when G -\u0026gt; B.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThat is, part of the meaning of an abstract pattern is a\nfunction that works just the way it looks as if it works.\n(The name '#A-\u003e' is for expository purposes and should not\nbe taken literally.  In particular, it is NOT part of this\nspecification that such a function should be directly\naccessible at all, still less that it should be accessible\nby a name of that form.)  So\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#permute([R,A,T]) when is_atom(A) -\u0026gt; [T,A,R].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eacts in one direction just like\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'#permute-\u0026gt;'([R,A,T]) when is_atom(A) -\u0026gt; [T,A,R].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewould.  Because abstract patterns are not allowed to be\nrecursive and cannot have any side effects, it is safe\nto call them in guards.  As a guard test, \u003ccode\u003e#A(E1,...,En)\u003c/code\u003e\nis equivalent to \u003ccode\u003e(true = '#A-\u0026gt;'(E1,...,En))\u003c/code\u003e.  \u003c/p\u003e\n\n\u003cp\u003eIn the other direction, we get\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'#A='(B) when G -\u0026gt; {H1, ..., Hn}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA pattern match\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#A(P1, ..., Pn) = E\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis equivalent to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{P1, ..., Pn} = '#A='(E)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWhen some of the patterns Hi, B use '=', the definition is\na little trickier.  Suppose, for example, we have\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#foo([H|T] = X) -\u0026gt; {H,T}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA naive translation would be\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'#foo='({H,T}) -\u0026gt; [H|T] = X.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhich would not work, because X would be undefined.  The\nbasic problem here is that '=' in patterns is symmetric,\nwhile '=' in expressions is not.  The real translation\nhas to be that\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#A(H11=H12=.., ..., Hn1=Hn2=..) when G -\u0026gt; B\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis equivalent to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'#A='(B)\nwhen G, X1=H11, X1=H12, ..., Xn=Hn1, Xn=Hn2, ...\n-\u0026gt; {X1, ..., Xn}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhere the bindings \u003ccode\u003eXi=Hij\u003c/code\u003e are both sorted and re-ordered\n(that is, switched from \u003ccode\u003eXi=Hij\u003c/code\u003e to \u003ccode\u003eHij=Xi\u003c/code\u003e) according to\ndata flow.  In the case of the \u003ccode\u003e#foo/1\u003c/code\u003e example, we'd get\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e'#foo='({H,T}) when X1 = [H|T], X = X1 -\u0026gt; {X1}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe sorting and reordering process is easier than it sounds.\nWhile there is an equation \u003ccode\u003eXi=Hij\u003c/code\u003e such that either every\nvariable in \u003ccode\u003eHij\u003c/code\u003e is known or \u003ccode\u003eXi\u003c/code\u003e is known, add \u003ccode\u003eXi=Hij\u003c/code\u003e if\n\u003ccode\u003eHij\u003c/code\u003e is all known, or \u003ccode\u003eHij = Xi\u003c/code\u003e if \u003ccode\u003eXi\u003c/code\u003e is known.\u003c/p\u003e\n\n\u003cp\u003eThis sorting-and-reordering-by-dataflow is also recommended\nin the forward direction when B contains '='.\u003c/p\u003e\n\n\u003cp\u003eSometimes one or the other direction of an abstract pattern\ncannot be constructed, even with sorting and reordering by\ndataflow.  This is typically because one side contains a\nvariable that doesn't occur on the other.  For example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#first(X) -\u0026gt; {X,_}.\n#second(Y) -\u0026gt; {_,Y}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eare usable as patterns, but not as functions.  The compiler\nshould issue a warning for such abstract patterns but allow\nthem.  It should be a run-time error to call such a pattern\nas a function as well.  It should be possible to suppress\nthe warning, perhaps by\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-compile({pattern_only,[{first,1,second,1}]}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e(That's within the current syntax.  Ideally that should be\n\u003ccode\u003e#first/1\u003c/code\u003e and \u003ccode\u003e#second/1\u003c/code\u003e.)\u003c/p\u003e\n\n\u003cp\u003eFor another example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#is_date(#date(_,_,_)) -\u0026gt; true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eis usable as a function, even/especially in a guard, but is \u003cbr /\u003e\nnot usable as a pattern.  The compiler should issue a\nwarning for such abstract patterns but allow them.  It\nshould be a run-time error to call such a pattern as well.\nIt should be possible to suppress the warning, perhaps by\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-compile({function_only,[{is_date,1}]}).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eDefinition via in-line substituion is straightforward.\nAll of the following rewrites assume a standard renaming\nof variables.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(... #A(P1,...,Pn) ...) when Gf -\u0026gt; Bf\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erewrites to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ef(... B ...)\nwhen G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gf -\u0026gt; Bf\n\ncase ... of ... #(P1,...,Pn) ... when Gc -\u0026gt; Bc\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erewrites to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase ... of ... B ...\nwhen G, Xi=Hij..., {P1,...,Pn} = {X1,...,Xn}, Gc -\u0026gt; Bc\n\nP = E\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erewrites to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase E of P -\u0026gt; ok end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIn a guard expression,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e(... #A(E1, ..., En) ...)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erewrites to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{H1,...,Hn} = {E1,...,En}, G, (... B ...)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs a guard test,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#A(E1, ..., En)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erewrites to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e{H1,...,Hn} = {E1,...,En}, G, true = B\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAs an ordinary expression,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#A(E1, ..., En)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003erewrites to\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecase {E1,...,En} of {H1,...,Hn} when G -\u0026gt; B end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch1\u003eMotivation\u003c/h1\u003e\n\n\u003cp\u003eEven in this restricted form, abstract patterns solve a lot\nof problems that keep coming up on the Erlang mailing list.\nThey were invented to serve two main purposes:  to greatly\nreduce the need for the preprocessor, and to support the\nuse of abstract data types.  It turns out that they can also\nreduce the amount of keyboard work a programmer has to do,\nand increase the amount of type information available to the\ncompiler.\u003c/p\u003e\n\n\u003cp\u003eMacros are often used to provide named constants.\nFor example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(unknown, \"UNKNOWN\").\nf(?unknown, Actors) -\u0026gt; Actors;\nf(N, Actors) -\u0026gt; lists:keydelete(N, #actor.name, Actors).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eA function is not used here because function calls may not\nappear in patterns.  Abstract patterns are functions that\nare sufficiently restricted that they \u003cem\u003emay\u003c/em\u003e appear in patterns:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#unknown() -\u0026gt; \"UNKNOWN\".\nf(#unknown(), Actors) -\u0026gt; Actors;\nf(N, Actors) -\u0026gt; lists:keydelete(n, #actor.name, Actors).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSometimes these constants must be computed.\nFor example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(START_TIMEOUT, 1000 * 30).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThanks to variable binding in guards, we can do that too:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#start_timeout() when N = 1000*30 -\u0026gt; N.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere are things that macros cannot do, because there needs\nto be a guard test as well as a pattern.  Macros can't bilocate.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#date(D, M, Y)\nwhen is_integer(Y), Y \u0026gt;= 1600, Y =\u0026lt; 2500,\n     is_integer(M), M \u0026gt;= 1,    M =\u0026lt; 12,\n     is_integer(D), D \u0026gt;= 1,    D =\u0026lt; 31\n-\u0026gt; {Y, M, D}.\n\n#vector3(X, Y, Z)\nwhen is_float(X), is_float(Y), is_float(Z)\n-\u0026gt; {X, Y, Z}.\n\n#mod_func(M, F) when is_atom(M), is_atom(F) -\u0026gt; {M, F}.\n\n#mod_func_arity(M, F, A)\nwhen is_atom(M), is_atom(F), is_integer(A), A \u0026gt;= 0\n-\u0026gt; {M, F, A}.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSome macros cannot be replaced by abstract patterns.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(DBG(DbgLvl, Format, Data),\n    dbg(DbgLvl, Format, Data)).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecannot be an abstract pattern because the right hand side\ninvolves a call to an ordinary function.\u003c/p\u003e\n\n\u003cp\u003eSome macros define guard tests.  For example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(tab, 9).\n-define(space, 32).\n-define(is_tab(X), X == ?tab).\n-define(is_space(X), X == ?space).\n-define(is_underline(X), X == $_).\n-define(is_number(X), X \u0026gt;= $0, X =\u0026lt; $9).\n-define(is_upper(X), X \u0026gt;= $A, X =\u0026lt; $Z).\n-define(is_lower(X), X \u0026gt;= $a, X =\u0026lt; $z).\n\ntoken([X|File], L, Result, Gen, BsNl)\n  when ?is_upper(X) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when ?is_lower(X) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when ?is_underline(X) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThese can be converted to abstract patterns that are usable\nas guard tests,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#tab() -\u0026gt; 9.\n#space() -\u0026gt; 32.\n#is_tab(#tab()) -\u0026gt; true.\n#is_space(#space()) -\u0026gt; true.\n#is_underline($_)) -\u0026gt; true.\n#is_number(X) when X \u0026gt;= $0, X =\u0026lt; $9 -\u0026gt; true.\n#is_upper(X)  when X \u0026gt;= $A, X =\u0026lt; $Z -\u0026gt; true.\n#is_lower(X)  when X \u0026gt;= $a, X =\u0026lt; $z -\u0026gt; true.\n\ntoken([X|File], L, Result, Gen, BsNl)\n  when #is_upper(X) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when #is_lower(X) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([X|File], L, Result, Gen, BsNl)\n  when #is_underline(X) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eor to abstract patterns that can be used as patterns,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#tab() -\u0026gt; 9.\n#space() -\u0026gt; 32.\n#underline(X) when X == $_ -\u0026gt; X.\n#number(X) when X \u0026gt;= $0, X =\u0026lt; $9 -\u0026gt; X.\n#upper(X)  when X \u0026gt;= $A, X =\u0026lt; $Z -\u0026gt; X.\n#lower(X)  when X \u0026gt;= $a, X =\u0026lt; $z -\u0026gt; X.\n\ntoken([#upper(X)|File], L, Result, Gen, BsNl) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([#lower(X)|File], L, Result, Gen, BsNl) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\ntoken([#underline(X)|File], L, Result, Gen, BsNl) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eOf course we can use disjunction in the guard of an\nabstract pattern.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#id_start(X) when X \u0026gt;= $A, X =\u0026lt; $Z\n        ; X \u0026gt;= $a, X =\u0026lt; $z\n        ; X == $_           -\u0026gt; X.\n\ntoken([#is_start(X)|File], L, Result, Gen, BsNl) -\u0026gt;\n    GenNew = case Gen of not_set -\u0026gt; var; _ -\u0026gt; Gen end,\n    {Rem, Var} = tok_var(File, [X]),\n    token(Rem, L, [{var,Var}|Result], GenNew, BsNl);\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eYes, the original macro-based version could have done the same.\nIt's from the OTP sources; don't blame me.\u003c/p\u003e\n\n\u003cp\u003eAside from replacing a pattern AND a guard, which macros cannot\ndo, the great advantages over patterns over macros are that\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003ethey can be syntax-checked at the point of definition,\nwhile macros can only be syntax-checked at the point of use;\u003c/li\u003e\n\u003cli\u003ethere is no problem, indeed no possibility, of variable name\ncapture;\u003c/li\u003e\n\u003cli\u003eabstract patterns are value based, not token-list based, so\nthere are no problems with operators.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eConsider the following OTP macro:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(IC_FLAG_TEST(_F1, _I1), ((_F1 band _I1) == _I1)).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eFirst, the author was evidently scared of accidental collisions\nwith other variable names.  Second, the parentheses look as\nthough they are there in case of operator precedence bugs.\u003c/p\u003e\n\n\u003cp\u003eThere's at least one other like it,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(is_set(F, Bits), ((F) band (Bits)) == (F)).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhich (correctly) suggests that the first macro doesn't have enough\nparentheses.    The abstract pattern equivalent,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#ic_flag_test(Flags, Mask) when Flags band Mask == Mask -\u0026gt; true.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ehas neither problem.\u003c/p\u003e\n\n\u003cp\u003eOnce again, there are things that abstract patterns cannot do.\nFor example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(get_max(_X, _Y), if _X \u0026gt; _Y -\u0026gt; _X; true -\u0026gt; _Y end).\n-define(get_min(_X, _Y), if _X \u0026gt; _Y -\u0026gt; _Y; true -\u0026gt; _X end).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThese cannot be abstract patterns because an abstract pattern\ncannot contain an 'if' or a 'case' or any other control structure.\nBut they can, and should, be ordinary inline functions:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-compile({inline,[{max,2},{min,2}]}).\nmax(X, Y) -\u0026gt; if X \u0026gt; Y -\u0026gt; X; true -\u0026gt; Y end.\nmin(X, Y) -\u0026gt; if X \u0026gt; Y -\u0026gt; Y; true -\u0026gt; X end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAbstract patterns don't need to do what ordinary functions can.\nHere's another example from the OTP sources.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(LOWER(Char),\n    if\n        Char \u0026gt;= $A, Char =\u0026lt; $Z -\u0026gt;\n        Char - ($A - $a);\n        true -\u0026gt;\n        Char\n    end).\ntolower(Chars) -\u0026gt;\n    [?LOWER(Char) || Char \u0026lt;- Chars].\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis could, and should, have been an ordinary inlined function.\nAbstract patterns don't need to do what ordinary functions can.\nLet's examine it a little closer.  Suppose we had a pattern\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eCl = #lower(Cx)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ewhich when used as an ordinary function converted both \u003ccode\u003e$x\u003c/code\u003e and \u003ccode\u003e$X\u003c/code\u003e\nto \u003ccode\u003e$x\u003c/code\u003e.  Then when used as a pattern \u003ccode\u003e#lower(Cx) = $x\u003c/code\u003e, there would\nbe two correct answers for \u003ccode\u003eCx\u003c/code\u003e.  There are no other cases where\na pattern may match more than one way.  The fact that abstract\npatterns cannot do conditionals is one of the things that makes\nthem usable as patterns.\u003c/p\u003e\n\n\u003cp\u003eMacros are sometimes used for module names.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-define(SERVER,{rmod_random_impl,\n        list_to_atom(\"babbis@\" ++\n    hd(tl(string:tokens(atom_to_list(node()),\"@\"))))}).\n\n-define(CLIENTMOD,'rmod_random').\n\nproduce() -\u0026gt; ?CLIENTMOD:produce(?SERVER).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eAbstract patterns can be used for this too, but there is an\nerror waiting to happen.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eserver() -\u0026gt; {rmod_random_impl,\n        list_to_atom(\"babbis@\" ++\n    hd(tl(string:tokens(atom_to_list(node()),\"@\"))))}.\n\n#client_mod() -\u0026gt; 'rmod_random'.\n\nproduce -\u0026gt; #client_mod():produce(server()).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe risk is that of writing \u003ccode\u003e#client_mod:produce(server())\u003c/code\u003e,\nwhich is the syntax we'll want in stage 2 for calling an\nabstract pattern defined in another module.\nThere is one thing that macros are used for that abstract\npatterns can be used for, but you'd probably rather not.\u003c/p\u003e\n\n\u003cp\u003eAbstract patterns were also invented with the aim of\nreplacing at least some uses of records.  Frames (or Joe\nArmstrong's structs, which are essentially the same thing)\nare a superior way to do that.   Let's see a simple case.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-record(mark_params, {cell_id,\n              virtual_col,\n              virtual_row\n             }).\n...\nMarkP = mark_params(),\n...\nNewMarkP = MarkP#mark_params{cell_id     = undefined,\n                 virtual_col = undefined,\n                 virtual_row = VirtualRow\n                },\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis becomes\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e% General\n#mark_params(Cell, Row, Col) -\u0026gt; {mark_params, Cell, Row, Col}.\n% Initial value\n#mark_params() -\u0026gt; #mark_params(undefined, undefined, undefined).\n% Recogniser\n#is_mark_params({mark_params,_,_,_}) -\u0026gt; true.\n% Cell extractor\n#mark_params__cell(#mark_params(Cell,_,_)) -\u0026gt; Cell.\n% Cell updater\n#mark_params__cell(Cell, #mark_params(_,R,C)) -\u0026gt;\n    #mark_params(Cell, R, C).\n% Row extractor\n#mark_params__row(#mark_params(_,Row,_)) -\u0026gt; Row.\n% Row updater\n#mark_params__row(Row, #mark_params(K,_,C)) -\u0026gt;\n    #mark_params(K, Row, C).\n% Col extractor\n#mark_params__col(#mark_params(_,_,Col)) -\u0026gt; Col.\n% Col updater\n#mark_params__col(Col, #mark_params(K,R,_)) -\u0026gt;\n    #mark_params(K, R, Col).\n...\nMarkP = #mark_params(),\n...\nNewMarkP = #mark_params__row(VirtualRow,\n           #mark_params__col(undefined,\n           #mark_params__cell(undefined, MarkP)))\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe extractor and updater patterns can be derived automatically,\nwhich comes in stage 4.  With frames/structs, we may never bother.\u003c/p\u003e\n\n\u003cp\u003eThere is a feature of Haskell that I have long loved.\nThat is so-called \"n+k patterns\", where a pattern may be N+K\nfor N a variable and K a positive integer.  This matches V\nif V is an integer greater than or equal to K, and binds N\nto V - K.  For example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003efib 0 = 1\nfib 1 = 1\nfib (n+2) = fib n + fib (n+1)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNot that that's a good way to implement the Fibonacci function,\nof course.  (It takes O(phi^N) when O(log N) is attainable.)\nThere's no such thing in Erlang.  But with abstract patterns,\nwe could program it:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#succ(M) when is_integer(N), N \u0026gt;= 1, M = N - 1 -\u0026gt; N.\n\nfib(0) -\u0026gt; 1;\nfib(1) -\u0026gt; 1;\nfib(#succ(#succ(N)) -\u0026gt; fib(N) + fib(N+1).\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSometimes we want a three-way split:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003eN = 1\nN = 2k+0 (k \u0026gt;= 1)\nN = 2k+1 (k \u0026gt;= 1)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can program that too:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#one() -\u0026gt; 1.\n#even(K)\nwhen is_integer(N), (N band 1) == 0, N \u0026gt;= 2, K = N div 2\n-\u0026gt; N.\n#odd(K)\nwhen is_integer(N), (N band 1) == 1, N \u0026gt;= 3, K = N div 2\n-\u0026gt; N.\n\nruler(#one())   -\u0026gt; 0 ;\nruler(#even(K)) -\u0026gt; 1 + ruler(K);\nruler(#odd(K))  -\u0026gt; 1.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eLet's turn to abstract data types.\nThere are three obvious ways to implement association lists\nas single data structures:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e[{K1,V1}, ..., {Kn,Vn}]     % pairs\n[K1,V1, ..., Kn,Vn]     % alternating\n{K1,V1, ..., {Kn,Vn,[]}}    % triples\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eSuppose you cannot make up your mind which is better.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#empty_alist() -\u0026gt; [].\n-ifdef(PAIRS).\n#non_empty_alist(K,V,R) -\u0026gt; [{K,V}|R].\n-else.\n-ifdef(TRIPLES).\n#non_empty_alist(K,V,R) -\u0026gt; {K,V,R}.\n-else.\n#non_empty_alist(K,V,R) -\u0026gt; [K,V|R].\n-endif.\n-endif.\n\nzip([K|Ks], [V|Vs]) -\u0026gt;\n    #non_empty_alist(K, V, zip(Ks, Vs));\nzip([], []) -\u0026gt;\n    #empty_alist().\n\nlookup(K, #non_empty_alist(K,V,_), _) -\u0026gt;\n    V;\nlookup(K, #non_empty_alist(_,_,R), D) -\u0026gt;\n    lookup(K, R, D);\nlookup(K, #empty_alist(), D) -\u0026gt;\n    D.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eNow you can switch between the three implementations, for \u003cbr /\u003e\ntesting and benchmarking, by flicking a single preprocessor\nswitch.  \u003c/p\u003e\n\n\u003cp\u003eSometimes there is something that would have been an algebraic\ndata type in Haskell or Clean or SML or CAML, but in Erlang we\njust have to use a variety of tuples.  The parsed form of\nErlang source code is a good example.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003elform({attribute,Line,Name,Arg}, Hook) -\u0026gt;\n    lattribute({attribute,Line,Name,Arg}, Hook);\nlform({function,Line,Name,Arity,Clauses}, Hook) -\u0026gt;\n    lfunction({function,Line,Name,Arity,Clauses}, Hook);\nlform({rule,Line,Name,Arity,Clauses}, Hook) -\u0026gt;\n    lrule({rule,Line,Name,Arity,Clauses}, Hook);\n%% These are specials to make it easier for the compiler.\nlform({error,E}, _Hook) -\u0026gt;\n    leaf(format(\"~p\\n\", [{error,E}]));\nlform({warning,W}, _Hook) -\u0026gt;\n    leaf(format(\"~p\\n\", [{warning,W}]));\nlform({eof,_Line}, _Hook) -\u0026gt;\n    $\\n.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eWe can define abstract patterns for these.\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#attribute(L, N, A)    -\u0026gt; {attribute, L, N, A}.\n#function( L, N, A, C) -\u0026gt; {function,  L, N, A, C}.\n#rule(     L, N, A, C) -\u0026gt; {rule,      L, N, A, C}.\n#eof(      L)          -\u0026gt; {eof,       L}.\n#error(    E_          -\u0026gt; {error,     E}.\n#warning(  W)          -\u0026gt; {warning,   W}.\n\n#attribute()        -\u0026gt; #attribute(_,_,_).\n#function()     -\u0026gt; #function(_,_,_,_).\n#rule()         -\u0026gt; #rule(_,_,_,_).\n\nlform(Form, Hook) -\u0026gt;\n    case Form\n      of #attribute() -\u0026gt; lattribute(Form, Hook)\n       ; #function()  -\u0026gt; lfunction( Form, Hook)\n       ; #rule()      -\u0026gt; lrule(     Form, Hook)\n       ; #error(E)    -\u0026gt; leaf(format(\"~p\\n\", [{error,E}]))\n       ; #warning(W)  -\u0026gt; leaf(format(\"~p\\n\", [{warning,W}]))\n       ; #eof(_)      -\u0026gt; $\\n\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIt would almost be worth defining these patterns even if these\nwere their only occurrences, simply for the clarity they permit.\nBut these patterns would be used over and over again.  Using\nthe patterns not only makes the code shorter and clearer, it\ngives us two kinds of protection against changes to the data\nrepresentation.  For example, suppose we decided to hold\nName/Arity information in 'function' and 'rule' tuples as\npairs, not as separate fields.  Then we could do\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e-ifdef(OLD_DATA).\n#function( L, N, A,  C) -\u0026gt; {function,  L, N, A, C}.\n#rule(     L, N, A,  C) -\u0026gt; {rule,      L, N, A, C}.\n#function( L, {N,A}, C) -\u0026gt; {function,  L, N, A, C}.\n#rule(     L, {N,A}, C) -\u0026gt; {rule,      L, N, A, C}.\n-else.\n#function( L, N, A, C)  -\u0026gt; {function,  L, {N,A}, C}.\n#rule(     L, N, A, C)  -\u0026gt; {rule,      L, {N,A}, C}.\n#function( L, NA,   C)  -\u0026gt; {function,  L, NA,    C}.\n#rule(     L, NA,   C)  -\u0026gt; {rule,      L, NA,    C}.\n-endif.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThe rest of the code would remain unchanged.  That's one kind of\nprotection.  It doesn't help us when we need to add new cases.\nThat's when the second kind of protection comes up.  Looking\nfor \u003ccode\u003e#function\u003c/code\u003e is a much safer guide to finding relevant places\nthan looking for \u003ccode\u003efunction\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1\u003eRationale\u003c/h1\u003e\n\n\u003cp\u003eThere is more to the idea of abstract patterns than this\nspecification describes.  Here's a \"road map\".\u003c/p\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eStage 0:\nAllow pattern matching in guards.\nThis is the subject of another EEP, as it is\ndesirable in itself.  This MUST be implemented\nfirst before implementing Stage 1, because that's\nwhat we want inlinable pattern calls to expand to.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStage 1:\nSimple abstract patterns restricted so that they\ncan be implemented exclusively by inline expansion.\nThis requires no change to the VM other than the\nchanges required for Stage 0.\u003c/p\u003e\n\n\u003cp\u003eImport/export of patterns can be faked using the\npreprocessor to -include definitions; this is not\nideal, but it's an acceptable stopgap.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStage 2:\nAbstract functions are (pairs of) real functions,\nthey may be -exported and -imported, may be called\nwith module prefixes, can be replaced by hot loading,\nshould be traceable, debuggable, profilable, and so\non, just like other functions.  In Stage 2, exported\nabstract patterns would need inline declarations if\nthey are to be inlined; other patterns would continue\nto be inlined except when compiled in debugging mode.\u003c/p\u003e\n\n\u003cp\u003eThis requires fairly substantial changes to the\nrun time system.  The big payoff here is that\nimported abstract patterns can be replaced by hot\nloading, unlike macros.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStage 3:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#fun [Module:]Name/Arity and\n#fun (P1, ..., Pn) when G -\u0026gt; B end\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eforms are introduced, and a metacall\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#Var(E1,...,En) is added.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThis requires extensions to the Erlang term\nrepresentation and the VM.  The gain here is that\nthe FAQ \"how do I pass a pattern as a parameter\"\nfinally gets a safe answer.  For example,\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003ecollect_messages(P) -\u0026gt;\n    lists:reverse(collect_messages_loop(P, [])).\n\n\ncollect_messages_loop(P, Ms) -\u0026gt;\n    receive M = #P() -\u0026gt; collect_messages_loop([M|Ms])\n      after 0        -\u0026gt; Ms\n    end.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003egathers all the messages currently in the mailbox\nthat match a pattern passed as a parameter.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStage 4:\n\u003ccode\u003e\u0026lt;expression\u0026gt;#\u0026lt;pattern call\u0026gt;\u003c/code\u003e field update,\nas described in the original proposal.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStage 5:\nMulti-clause abstract patterns,\nas described in the original proposal.\nMulti-clause abstract patterns CAN handle\nexamples like \u003ccode\u003e?get_max\u003c/code\u003e and \u003ccode\u003e?LOWER\u003c/code\u003e, which makes\nthem even more useful in guards, but more than\na little dubious as patterns.\u003c/p\u003e\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eStage 6:\n\"Hybrid\" abstract patterns, where in \u003ccode\u003e#A/M+N\u003c/code\u003e the\nfirst \u003ccode\u003eM\u003c/code\u003e arguments are always inputs, and only\nthe last \u003ccode\u003eN\u003c/code\u003e are outputs.  This one isn't actually\nmy idea.  The example\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode\u003e#range(L, U, N)\nwhen is_integer(N), L =\u0026lt; N, N =\u0026lt; U\n-\u0026gt; N.\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecomes from the mailing list.  I don't like this very\nmuch, and note that for some purposes,\u003c/p\u003e\n\n\u003cp\u003erange(L, U) -\u003e\n       #fun(N) when is_integer(N), L =\u0026lt; N, N =\u0026lt; U\n               -\u003e N end.\u003c/p\u003e\n\n\u003cp\u003ecan do the same job.\u003c/p\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eWhat I've done for this proposal is to strip away everything\nthat isn't essential.  We get data abstraction, user defined\nguard tests and functions, and a replacement for many uses\nof macros, without run time overheads and without changes to\nanything except the compiler front end, assuming that Stage 0\nis done first.\u003c/p\u003e\n\n\u003ch1\u003eBackwards Compatibility\u003c/h1\u003e\n\n\u003cp\u003eErlang currently uses the sharp sign for record syntax.\nSince record syntax uses curly braces, and abstract patterns\nuse round parentheses, no existing code should be affected.\u003c/p\u003e\n\n\u003ch1\u003eReference Implementation\u003c/h1\u003e\n\n\u003cp\u003eSketched above.  Given stage 0, this stage 1 is within my\nknowledge and abilities, but I don't understand the Erlang\nVM well enough to do stage 0.\u003c/p\u003e\n\n\u003ch1\u003eCopyright\u003c/h1\u003e\n\n\u003cp\u003eThis document has been placed in the public domain.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/eeps/[eep]","query":{"eep":"eep-0029"},"buildId":"92Ploa_JRk4A9mAiRpquq","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["title",{"children":"Erlang Programming Language"}],["meta",{"httpEquiv":"Content-Type","content":"text/html;charset=utf-8"}],["meta",{"name":"description","content":"Erlang Programming Language"}],["meta",{"name":"keywords","content":"erlang, functional, programming, fault-tolerant, distributed, multi-platform, portable, software, multi-core, smp, concurrency"}],["meta",{"name":"viewport","content":"width=device-width, initial-scale=1.0"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Overall RSS 2.0 Feed","href":"/rss"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"News RSS 2.0 Feed","href":"/rss/news"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Article RSS 2.0 Feed","href":"/rss/articles"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Events RSS 2.0 Feed","href":"/rss/event"}],["link",{"rel":"alternate","type":"application/rss+xml","title":"Downloads RSS 2.0 Feed","href":"/rss/download"}],["script",{"src":"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"}],["script",{"src":"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js","integrity":"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa","crossOrigin":"anonymous"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-8bebc7aacc0076174a73.js"></script><script src="/_next/static/chunks/main-a9a86200c2afaf3f233a.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.9707fddd9ae5927c17c3.js" async=""></script><script src="/_next/static/chunks/commons.8b4ad2366e12f882e3d5.js" async=""></script><script src="/_next/static/chunks/pages/_app-290342a5f5c41b7caf9d.js" async=""></script><script src="/_next/static/chunks/87b308f4a72b1b263da2fe072492c20d1199252a.8368050723e578161621.js" async=""></script><script src="/_next/static/chunks/pages/eeps/%5Beep%5D-bde5f12f7c4b26eeb23e.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_buildManifest.js" async=""></script><script src="/_next/static/92Ploa_JRk4A9mAiRpquq/_ssgManifest.js" async=""></script></body></html>